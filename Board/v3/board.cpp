/*
* @brief Contains board specific variables and initialization functions
*/

#include <board.h>

#include <odrive_main.h>
#include <low_level.h>

#include <Drivers/STM32/stm32_timer.hpp>

#include <adc.h>
#include <dma.h>
#include <tim.h>
#include <usart.h>
#include <freertos_vars.h>

// this should technically be in task_timer.cpp but let's not make a one-line file
bool TaskTimer::enabled = false;

extern "C" void SystemClock_Config(void); // defined in main.c generated by CubeMX

#define ControlLoop_IRQHandler OTG_HS_IRQHandler
#define ControlLoop_IRQn OTG_HS_IRQn

// This array is placed at the very start of the ram (0x20000000) and will be
// used during manufacturing to test the struct that will go to the OTP before
// _actually_ putting anything into OTP. This avoids bulk-destroying STM32's if
// we introduce unintended breakage in our manufacturing scripts.
//! 将数组 fake_otp 放置到名为 .testdata 的内存段中
//! FLASH_OTP_END + 1 - FLASH_OTP_BASE = 0x20F + 1 = 0x210(16) = 528(10) 
//! Flash 中存储的是初始值备份，RAM 中是实际运行值。
//! 编译器根据这行代码生成 fake_otp 的初始值，并将其存储在二进制文件（如 .elf 或 .hex 文件）的 .testdata 段中,并且会在加载和烧录阶段存放在flash中
//! 3 , 6 , 56
uint8_t __attribute__((section(".testdata"))) fake_otp[FLASH_OTP_END + 1 - FLASH_OTP_BASE] = {0, 0, 0, HW_VERSION_MAJOR, HW_VERSION_MINOR, HW_VERSION_VOLTAGE};

Stm32SpiArbiter spi3_arbiter{&hspi3};
Stm32SpiArbiter& ext_spi_arbiter = spi3_arbiter;

UART_HandleTypeDef* uart_a = &huart4;
UART_HandleTypeDef* uart_b = &huart2; // TODO: this could be supported in ODrive v3.6 (or similar) using STM32's USART2
UART_HandleTypeDef* uart_c = nullptr;

Drv8301 m0_gate_driver{
    &spi3_arbiter,
    {M0_nCS_GPIO_Port, M0_nCS_Pin}, // nCS
    {}, // EN pin (shared between both motors, therefore we actuate it outside of the drv8301 driver)
    {nFAULT_GPIO_Port, nFAULT_Pin} // nFAULT pin (shared between both motors)
};

Drv8301 m1_gate_driver{
    &spi3_arbiter,
    {M1_nCS_GPIO_Port, M1_nCS_Pin}, // nCS
    {}, // EN pin (shared between both motors, therefore we actuate it outside of the drv8301 driver)
    {nFAULT_GPIO_Port, nFAULT_Pin} // nFAULT pin (shared between both motors)
};

const float fet_thermistor_poly_coeffs[] =
    {363.93910201f, -462.15369634f, 307.55129571f, -27.72569531f};
const size_t fet_thermistor_num_coeffs = sizeof(fet_thermistor_poly_coeffs)/sizeof(fet_thermistor_poly_coeffs[1]);

OnboardThermistorCurrentLimiter fet_thermistors[AXIS_COUNT] = {
    {
        15, // adc_channel
        &fet_thermistor_poly_coeffs[0], // coefficients
        fet_thermistor_num_coeffs // num_coeffs
    }, {
#if HW_VERSION_MAJOR == 3 && HW_VERSION_MINOR >= 3
        4, // adc_channel
#else
        1, // adc_channel
#endif
        &fet_thermistor_poly_coeffs[0], // coefficients
        fet_thermistor_num_coeffs // num_coeffs
    }
};

OffboardThermistorCurrentLimiter motor_thermistors[AXIS_COUNT];

Motor motors[AXIS_COUNT] = {
    {
        &htim1, // timer
        0b110, // current_sensor_mask
        1.0f / SHUNT_RESISTANCE, // shunt_conductance [S]
        m0_gate_driver, // gate_driver
        m0_gate_driver, // opamp
        fet_thermistors[0],
        motor_thermistors[0]
    },
    {
        &htim8, // timer
        0b110, // current_sensor_mask
        1.0f / SHUNT_RESISTANCE, // shunt_conductance [S]
        m1_gate_driver, // gate_driver
        m1_gate_driver, // opamp
        fet_thermistors[1],
        motor_thermistors[1]
    }
};

Encoder encoders[AXIS_COUNT] = {
    {
        &htim3, // timer  在这里指定了编码器使用的定时器
        {M0_ENC_Z_GPIO_Port, M0_ENC_Z_Pin}, // index_gpio
        {M0_ENC_A_GPIO_Port, M0_ENC_A_Pin}, // hallA_gpio
        {M0_ENC_B_GPIO_Port, M0_ENC_B_Pin}, // hallB_gpio
        {M0_ENC_Z_GPIO_Port, M0_ENC_Z_Pin}, // hallC_gpio
        &spi3_arbiter // spi_arbiter
    },
    {
        &htim4, // timer
        {M1_ENC_Z_GPIO_Port, M1_ENC_Z_Pin}, // index_gpio
        {M1_ENC_A_GPIO_Port, M1_ENC_A_Pin}, // hallA_gpio
        {M1_ENC_B_GPIO_Port, M1_ENC_B_Pin}, // hallB_gpio
        {M1_ENC_Z_GPIO_Port, M1_ENC_Z_Pin}, // hallC_gpio
        &spi3_arbiter // spi_arbiter
    }
};

// TODO: this has no hardware dependency and should be allocated depending on config
Endstop endstops[2 * AXIS_COUNT];
MechanicalBrake mechanical_brakes[AXIS_COUNT];

SensorlessEstimator sensorless_estimators[AXIS_COUNT];
Controller controllers[AXIS_COUNT];
TrapezoidalTrajectory trap[AXIS_COUNT];

std::array<Axis, AXIS_COUNT> axes{{
    {
        0, // axis_num
        1, // step_gpio_pin
        2, // dir_gpio_pin
        (osPriority)(osPriorityHigh + (osPriority)1), // thread_priority
        encoders[0], // encoder
        sensorless_estimators[0], // sensorless_estimator
        controllers[0], // controller
        motors[0], // motor
        trap[0], // trap
        endstops[0], endstops[1], // min_endstop, max_endstop
        mechanical_brakes[0], // mechanical brake
    },
    {
        1, // axis_num
#if HW_VERSION_MAJOR == 3 && HW_VERSION_MINOR >= 5
        7, // step_gpio_pin
        8, // dir_gpio_pin
#else
        3, // step_gpio_pin
        4, // dir_gpio_pin
#endif
        osPriorityHigh, // thread_priority
        encoders[1], // encoder
        sensorless_estimators[1], // sensorless_estimator
        controllers[1], // controller
        motors[1], // motor
        trap[1], // trap
        endstops[2], endstops[3], // min_endstop, max_endstop
        mechanical_brakes[1], // mechanical brake
    },
}};



#if (HW_VERSION_MINOR == 1) || (HW_VERSION_MINOR == 2)
Stm32Gpio gpios[] = {
    {nullptr, 0}, // dummy GPIO0 so that PCB labels and software numbers match

    {GPIOB, GPIO_PIN_2}, // GPIO1
    {GPIOA, GPIO_PIN_5}, // GPIO2
    {GPIOA, GPIO_PIN_4}, // GPIO3
    {GPIOA, GPIO_PIN_3}, // GPIO4
    {nullptr, 0}, // GPIO5 (doesn't exist on this board)
    {nullptr, 0}, // GPIO6 (doesn't exist on this board)
    {nullptr, 0}, // GPIO7 (doesn't exist on this board)
    {nullptr, 0}, // GPIO8 (doesn't exist on this board)

    {GPIOB, GPIO_PIN_4}, // ENC0_A
    {GPIOB, GPIO_PIN_5}, // ENC0_B
    {GPIOA, GPIO_PIN_15}, // ENC0_Z
    {GPIOB, GPIO_PIN_6}, // ENC1_A
    {GPIOB, GPIO_PIN_7}, // ENC1_B
    {GPIOB, GPIO_PIN_3}, // ENC1_Z
    {GPIOB, GPIO_PIN_8}, // CAN_R
    {GPIOB, GPIO_PIN_9}, // CAN_D
};
#elif (HW_VERSION_MINOR == 3) || (HW_VERSION_MINOR == 4)
Stm32Gpio gpios[] = {
    {nullptr, 0}, // dummy GPIO0 so that PCB labels and software numbers match

    {GPIOA, GPIO_PIN_0}, // GPIO1
    {GPIOA, GPIO_PIN_1}, // GPIO2
    {GPIOA, GPIO_PIN_2}, // GPIO3
    {GPIOA, GPIO_PIN_3}, // GPIO4
    {GPIOB, GPIO_PIN_2}, // GPIO5
    {nullptr, 0}, // GPIO6 (doesn't exist on this board)
    {nullptr, 0}, // GPIO7 (doesn't exist on this board)
    {nullptr, 0}, // GPIO8 (doesn't exist on this board)

    {GPIOB, GPIO_PIN_4}, // ENC0_A
    {GPIOB, GPIO_PIN_5}, // ENC0_B
    {GPIOA, GPIO_PIN_15}, // ENC0_Z
    {GPIOB, GPIO_PIN_6}, // ENC1_A
    {GPIOB, GPIO_PIN_7}, // ENC1_B
    {GPIOB, GPIO_PIN_3}, // ENC1_Z
    {GPIOB, GPIO_PIN_8}, // CAN_R
    {GPIOB, GPIO_PIN_9}, // CAN_D
};
#elif (HW_VERSION_MINOR == 5) || (HW_VERSION_MINOR == 6)
Stm32Gpio gpios[GPIO_COUNT] = {
    {nullptr, 0}, // dummy GPIO0 so that PCB labels and software numbers match

    {GPIOA, GPIO_PIN_0}, // GPIO1
    {GPIOA, GPIO_PIN_1}, // GPIO2
    {GPIOA, GPIO_PIN_2}, // GPIO3
    {GPIOA, GPIO_PIN_3}, // GPIO4
    {GPIOC, GPIO_PIN_4}, // GPIO5
    {GPIOB, GPIO_PIN_2}, // GPIO6
    {GPIOA, GPIO_PIN_15}, // GPIO7
    {GPIOB, GPIO_PIN_3}, // GPIO8
    
    {GPIOB, GPIO_PIN_4}, // ENC0_A
    {GPIOB, GPIO_PIN_5}, // ENC0_B
    {GPIOC, GPIO_PIN_9}, // ENC0_Z
    {GPIOB, GPIO_PIN_6}, // ENC1_A
    {GPIOB, GPIO_PIN_7}, // ENC1_B
    {GPIOC, GPIO_PIN_15}, // ENC1_Z
    {GPIOB, GPIO_PIN_8}, // CAN_R
    {GPIOB, GPIO_PIN_9}, // CAN_D
};
#else
#error "unknown GPIOs"
#endif
//!这是一种固定大小的数组，类型为 std::array，每个数组元素是 GpioFunction 类型。std::array 的大小固定为 3，也就是说每个 GPIO 最多支持 3 种复用功能
std::array<GpioFunction, 3> alternate_functions[GPIO_COUNT] = {
    /* GPIO0 (inexistent): */ {{}},

#if HW_VERSION_MINOR >= 3
    /* GPIO1: */ {{{ODrive::GPIO_MODE_UART_A, GPIO_AF8_UART4}, {ODrive::GPIO_MODE_PWM, GPIO_AF2_TIM5}}},
    /* GPIO2: */ {{{ODrive::GPIO_MODE_UART_A, GPIO_AF8_UART4}, {ODrive::GPIO_MODE_PWM, GPIO_AF2_TIM5}}},
    /* GPIO3: */ {{{ODrive::GPIO_MODE_UART_B, GPIO_AF7_USART2}, {ODrive::GPIO_MODE_PWM, GPIO_AF2_TIM5}}},
#else
    /* GPIO1: */ {{}},
    /* GPIO2: */ {{}},
    /* GPIO3: */ {{}},
#endif

    /* GPIO4: */ {{{ODrive::GPIO_MODE_UART_B, GPIO_AF7_USART2}, {ODrive::GPIO_MODE_PWM, GPIO_AF2_TIM5}}},
    /* GPIO5: */ {{}},
    /* GPIO6: */ {{}},
    /* GPIO7: */ {{}},
    /* GPIO8: */ {{}},
    /* ENC0_A: */ {{{ODrive::GPIO_MODE_ENC0, GPIO_AF2_TIM3}}},
    /* ENC0_B: */ {{{ODrive::GPIO_MODE_ENC0, GPIO_AF2_TIM3}}},
    /* ENC0_Z: */ {{}},
    /* ENC1_A: */ {{{ODrive::GPIO_MODE_I2C_A, GPIO_AF4_I2C1}, {ODrive::GPIO_MODE_ENC1, GPIO_AF2_TIM4}}},
    /* ENC1_B: */ {{{ODrive::GPIO_MODE_I2C_A, GPIO_AF4_I2C1}, {ODrive::GPIO_MODE_ENC1, GPIO_AF2_TIM4}}},
    /* ENC1_Z: */ {{}},
    /* CAN_R: */ {{{ODrive::GPIO_MODE_CAN_A, GPIO_AF9_CAN1}, {ODrive::GPIO_MODE_I2C_A, GPIO_AF4_I2C1}}},
    /* CAN_D: */ {{{ODrive::GPIO_MODE_CAN_A, GPIO_AF9_CAN1}, {ODrive::GPIO_MODE_I2C_A, GPIO_AF4_I2C1}}},
};

#if HW_VERSION_MINOR <= 2
PwmInput pwm0_input{&htim5, {0, 0, 0, 4}}; // 0 means not in use
#else
PwmInput pwm0_input{&htim5, {1, 2, 3, 4}};
#endif

extern USBD_HandleTypeDef hUsbDeviceFS;
USBD_HandleTypeDef& usb_dev_handle = hUsbDeviceFS;

bool check_board_version(const uint8_t* otp_ptr) {
    return (otp_ptr[3] == HW_VERSION_MAJOR) &&
           (otp_ptr[4] == HW_VERSION_MINOR) &&
           (otp_ptr[5] == HW_VERSION_VOLTAGE);
}

void system_init() {
    // Reset of all peripherals, Initializes the Flash interface and the Systick.
    HAL_Init();

    // Configure the system clock
    SystemClock_Config();

    // If the OTP is pristine, use the fake-otp in RAM instead
    //! OTP 区域是 Flash 中的一部分，它是非易失性的，但数据在擦除后只能写一次。 如果没有写FLASH_OTP_BASE，那么每次FLASH_OTP_BASE都是0xff
    const uint8_t* otp_ptr = (const uint8_t*)FLASH_OTP_BASE;
    //! 当otp_ptr指向的OPT区域没有有效数据时，写入一个假数据，只能写一次
    //! 程序运行时，fake_otp 的初值会从 Flash 自动加载到 RAM 中，所以这里otp_ptr指向的是ram中的fake_otp
    if (*otp_ptr == 0xff) {
        otp_ptr = fake_otp;
    }

    // Ensure that the board version for which this firmware is compiled matches
    // the board we're running on.
    //! 检测版本 3， 6， 56
    if (!check_board_version(otp_ptr)) {
        for (;;);
    }
}
bool board_init() {
    // Initialize all configured peripherals
    //!使能GPIOA,B,C,D,H时钟，设置M0_nCS_Pin和M1_nCS_Pin电平状态为高电平，设置EN_GATE_Pin电平状态为低电平，设置M0_nCS_Pin，M1_nCS_Pin，M1_ENC_Z_Pin，M0_ENC_Z_Pin，GPIO_5_Pin，EN_GATE_Pin和nFAULT_Pin的引脚状态
    MX_GPIO_Init();
    //!使能DMA1,DMA2时钟，并设置其各个通道的优先级
    MX_DMA_Init();
    //!ADC1 channel6 规则组采用软件触发，注入组采用tim1上升沿触发（Vbus）
    MX_ADC1_Init();
    //!ADC2 channel13 规则组采用tim8上升沿触发（M1 Ib），channel10 注入组采用tim1上升沿触发（M0 Ib）
    MX_ADC2_Init();
    //!TIM1的更新事件会触发ADC1~ADC3的注入组自动采集，会采集出Vbus，M0电机的B相和C相的电流 168MHz
    //!168MHz/(3500*2) = 24KHz    因为是中间对齐，所以式子中要*2 
    //!电机(M0)的UVW驱动
    MX_TIM1_Init();
    //!TIM8的更新事件会触发ADC2和ADC3的规则组的自动采集，会采集出M1电机的B相和C相的电流 168MHz
    //!168MHz/(3500*2) = 24KHz    因为是中间对齐，所以式子中要*2
    //!电机(M1)的UVW驱动
    MX_TIM8_Init();
    //!84MHz 电机之旋编检测，计满到0xfffff
    MX_TIM3_Init();
    //!84MHz 电机之旋编检测，计满到0xfffff
    MX_TIM4_Init();
    MX_SPI3_Init();
    //!ADC3 channel12 规则组采用tim8上升沿触发（M1 Ic），channel11 注入组采用tim1上升沿触发（M0 Ic）
    MX_ADC3_Init();
    //!84MHz 84M/(4096*2)=10.25KHz CH3(PB.10)和CH4(PB.11)作为pwm输出，duty相反
    MX_TIM2_Init();
    //!84MHz 定时器的CH3(PA.2)和CH4(PA.3)作为捕获输入口  测量输入信号的频率、周期、占空比等
    MX_TIM5_Init();
    //!84MHz 8KHz 启动时和TIM1及TIM8同步；任务耗时测量 
    MX_TIM13_Init();

    // External interrupt lines are individually enabled in stm32_gpio.cpp
    //!设置外部中断优先级
    HAL_NVIC_SetPriority(EXTI0_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI0_IRQn);
    HAL_NVIC_SetPriority(EXTI1_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI1_IRQn);
    HAL_NVIC_SetPriority(EXTI2_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI2_IRQn);
    HAL_NVIC_SetPriority(EXTI3_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI3_IRQn);
    HAL_NVIC_SetPriority(EXTI4_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI4_IRQn);
    HAL_NVIC_SetPriority(EXTI9_5_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
    HAL_NVIC_SetPriority(EXTI15_10_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
    //!设置adc中断优先级
    HAL_NVIC_SetPriority(ControlLoop_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(ControlLoop_IRQn);
    //!设置tim8（M1）的优先级 > adc中断优先级
    HAL_NVIC_SetPriority(TIM8_UP_TIM13_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);
    //!串口4初始化，并设置波特率为115200
    if (odrv.config_.enable_uart_a) {
        uart_a->Init.BaudRate = odrv.config_.uart_a_baudrate;
        MX_UART4_Init();
    }
    //!odrv.config_.enable_uart_b = false
    if (odrv.config_.enable_uart_b) {
        uart_b->Init.BaudRate = odrv.config_.uart_b_baudrate;
        MX_USART2_UART_Init();
    }
    //!odrv.config_.enable_i2c_a = false
    if (odrv.config_.enable_i2c_a) {
        // Set up the direction GPIO as input
        get_gpio(3).config(GPIO_MODE_INPUT, GPIO_PULLUP);
        get_gpio(4).config(GPIO_MODE_INPUT, GPIO_PULLUP);
        get_gpio(5).config(GPIO_MODE_INPUT, GPIO_PULLUP);

        osDelay(1); // This has no effect but was here before.
        i2c_stats_.addr = (0xD << 3);
        i2c_stats_.addr |= get_gpio(3).read() ? 0x1 : 0;
        i2c_stats_.addr |= get_gpio(4).read() ? 0x2 : 0;
        i2c_stats_.addr |= get_gpio(5).read() ? 0x4 : 0;
        MX_I2C1_Init(i2c_stats_.addr);
    }
    //!odrv.config_.enable_can_a = true
    if (odrv.config_.enable_can_a) {
        // The CAN initialization will (and must) init its own GPIOs before the
        // GPIO modes are initialized. Therefore we ensure that the later GPIO
        // mode initialization won't override the CAN mode.
        //!确保 ODrive 控制器的两个 GPIO 引脚正确配置为 CAN A 通道模式，如果其中一个或两个引脚没有正确配置，则会将 misconfigured_ 标志设置为 true，表明配置错误
        if (odrv.config_.gpio_modes[15] != ODriveIntf::GPIO_MODE_CAN_A || odrv.config_.gpio_modes[16] != ODriveIntf::GPIO_MODE_CAN_A) {
            odrv.misconfigured_ = true;
        }
    }

    // Ensure that debug halting of the core doesn't leave the motor PWM running
    //!冻结指定的定时器（TIM1、TIM8、TIM13），从而在调试过程中停止它们的计数。
    __HAL_DBGMCU_FREEZE_TIM1();
    __HAL_DBGMCU_FREEZE_TIM8();
    __HAL_DBGMCU_FREEZE_TIM13();

    Stm32Gpio drv_enable_gpio = {EN_GATE_GPIO_Port, EN_GATE_Pin};

    // Reset both DRV chips. The enable pin also controls the SPI interface, not
    // only the driver stages.
    drv_enable_gpio.write(false);//!将EN_GATE_Pin置低电平
    delay_us(40); // mimumum pull-down time for full reset: 20us
    drv_enable_gpio.write(true);//!将EN_GATE_Pin置高电平
    delay_us(20000); // mimumum pull-down time for full reset: 20us

    return true;
}

void start_timers() {
    CRITICAL_SECTION() {
        // Temporarily disable ADC triggers so they don't trigger as a side
        // effect of starting the timers.
        hadc1.Instance->CR2 &= ~(ADC_CR2_JEXTEN);
        hadc2.Instance->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_JEXTEN);
        hadc3.Instance->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_JEXTEN);

        /*
        * Synchronize TIM1, TIM8 and TIM13 such that:
        *  1. The triangle waveform of TIM1 leads the triangle waveform of TIM8 by a
        *     90° phase shift.
        *  2. Each TIM13 reload coincides with a TIM1 lower update event.
        */
        Stm32Timer::start_synchronously<3>(
            {&htim1, &htim8, &htim13},
            {TIM1_INIT_COUNT, 0, TIM1_INIT_COUNT / 2 /* TIM13 is on a clock that's only have as fast as TIM1 */}
        );

        hadc1.Instance->CR2 |= (ADC_EXTERNALTRIGINJECCONVEDGE_RISING);
        hadc2.Instance->CR2 |= (ADC_EXTERNALTRIGCONVEDGE_RISING | ADC_EXTERNALTRIGINJECCONVEDGE_RISING);
        hadc3.Instance->CR2 |= (ADC_EXTERNALTRIGCONVEDGE_RISING | ADC_EXTERNALTRIGINJECCONVEDGE_RISING);

        __HAL_ADC_CLEAR_FLAG(&hadc1, ADC_FLAG_JEOC);
        __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_JEOC);
        __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_JEOC);
        __HAL_ADC_CLEAR_FLAG(&hadc1, ADC_FLAG_EOC);
        __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_EOC);
        __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_EOC);
        __HAL_ADC_CLEAR_FLAG(&hadc1, ADC_FLAG_OVR);
        __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_OVR);
        __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_OVR);
        
        __HAL_TIM_CLEAR_IT(&htim8, TIM_IT_UPDATE);
        __HAL_TIM_ENABLE_IT(&htim8, TIM_IT_UPDATE);
    }
}

static bool fetch_and_reset_adcs(
        std::optional<Iph_ABC_t>* current0,
        std::optional<Iph_ABC_t>* current1) {
    //!ADC_SR_JEOC表示 注入通道转换完成（Injected End of Conversion）。注入通道是一种特殊的转换序列，优先级高于规则通道。
    //!ADC_SR_EOC表示 规则通道转换完成（End of Conversion）。即，规则序列中最后一个 ADC 通道的数据转换已经完成。
    bool all_adcs_done = (ADC1->SR & ADC_SR_JEOC) == ADC_SR_JEOC
        && (ADC2->SR & (ADC_SR_EOC | ADC_SR_JEOC)) == (ADC_SR_EOC | ADC_SR_JEOC)//!等待adc1和adc2注入组和规则组都完成
        && (ADC3->SR & (ADC_SR_EOC | ADC_SR_JEOC)) == (ADC_SR_EOC | ADC_SR_JEOC);
    if (!all_adcs_done) {//!只有等所有adc转换成功后才行
        return false;
    }
    //!表示ADC1的注入组数据，得到vbus_voltage，获取ADC采集的总线电压
    vbus_sense_adc_cb(ADC1->JDR1);
    //!state_ == kStateReady;
    //!ADC2->JDR1 ---> M0 Ib ，ADC3->JDR1 ---> M0 Ic
    if (m0_gate_driver.is_ready()) {
        std::optional<float> phB = motors[0].phase_current_from_adcval(ADC2->JDR1);//!B相电流
        std::optional<float> phC = motors[0].phase_current_from_adcval(ADC3->JDR1);//!C相电流
        if (phB.has_value() && phC.has_value()) {
            *current0 = {-*phB - *phC, *phB, *phC};//!A相电流，B相电流，C相电流
        }
    }
    //!ADC2->DR表示规则组数据
    if (m1_gate_driver.is_ready()) {
        std::optional<float> phB = motors[1].phase_current_from_adcval(ADC2->DR);
        std::optional<float> phC = motors[1].phase_current_from_adcval(ADC3->DR);
        if (phB.has_value() && phC.has_value()) {
            *current1 = {-*phB - *phC, *phB, *phC};
        }
    }
    //!清空一些标志位
    ADC1->SR = ~(ADC_SR_JEOC);
    ADC2->SR = ~(ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_OVR);
    ADC3->SR = ~(ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_OVR);

    return true;
}

extern "C" {

void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi) {
    HAL_SPI_TxRxCpltCallback(hspi);
}

void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi) {
    HAL_SPI_TxRxCpltCallback(hspi);
}

void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi) {
    if (hspi == &hspi3) {
        spi3_arbiter.on_complete();
    }
}

void TIM5_IRQHandler(void) {
    COUNT_IRQ(TIM5_IRQn);
    pwm0_input.on_capture();
}

volatile uint32_t timestamp_ = 0;
volatile bool counting_down_ = false;

void TIM8_UP_TIM13_IRQHandler(void) {
    //!计数当前触发的中断，用于统计中断触发的次数
    COUNT_IRQ(TIM8_UP_TIM13_IRQn);
    //!清除 TIM8 的更新中断标志 (TIM_IT_UPDATE)
    // Entry into this function happens at 21-23 clock cycles after the timer
    // update event.
    __HAL_TIM_CLEAR_IT(&htim8, TIM_IT_UPDATE);

    // If the corresponding timer is counting up, we just sampled in SVM vector 0, i.e. real current
    // If we are counting down, we just sampled in SVM vector 7, with zero current
    //!判断 TIM8 是向上计数还是向下计数  0 (false)表示向上计数  1 (true)表示向下计数
    bool counting_down = TIM8->CR1 & TIM_CR1_DIR;
    //!中断肯定是一次上溢，一次下溢
    //!counting_down_是上一次中断时的计数方向,counting_down是这一次中断时的计数方向，当相等时，代表定时器没有正常切换方向，意味着丢失了更新事件。
    bool timer_update_missed = (counting_down_ == counting_down);
    //!如果发生了更新事件丢失，两个电机（motors[0] 和 motors[1]）被立即停止（解除使能）
    if (timer_update_missed) {
        motors[0].disarm_with_error(Motor::ERROR_TIMER_UPDATE_MISSED);//!这里还没看
        motors[1].disarm_with_error(Motor::ERROR_TIMER_UPDATE_MISSED);
        return;
    }
    //!将这一次计数方向赋值给上一次计数方向
    counting_down_ = counting_down;
    //!修改时间戳“timestamp_”为下一次中断时间点
    timestamp_ += TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1);
    //!向上计数
    if (!counting_down) {
        TaskTimer::enabled = odrv.task_timers_armed_;//!可能为false，也可能为true，但是好像只能是false
        // Run sampling handlers and kick off control tasks when TIM8 is
        // counting up.
        odrv.sampling_cb();
        NVIC->STIR = ControlLoop_IRQn;//!通过软件触发中断
    } else {
        // Tentatively reset all PWM outputs to 50% duty cycles. If the control
        // loop handler finishes in time then these values will be overridden
        // before they go into effect.
        TIM1->CCR1 =
        TIM1->CCR2 =
        TIM1->CCR3 =
        TIM8->CCR1 =
        TIM8->CCR2 =
        TIM8->CCR3 =
            TIM_1_8_PERIOD_CLOCKS / 2;
    }
}
//!相电流测量
void ControlLoop_IRQHandler(void) {
    //!记录进入该中断的次数
    COUNT_IRQ(ControlLoop_IRQn);
    //!下一次进入TIM8_UP_TIM13_IRQHandler的时间
    uint32_t timestamp = timestamp_;

    // Ensure that all the ADCs are done
    //!struct Iph_ABC_t { float phA; float phB; float phC; };
    std::optional<Iph_ABC_t> current0;
    std::optional<Iph_ABC_t> current1;
    //!得到相电流A,B,C  M0触发比M1的触发要早一点，而我们正在分析的代码执行的是在M1的中断处，所以此时M0的相电压值已经采集结束了（TIM1的update事件会自动触发采样启动）
    if (!fetch_and_reset_adcs(&current0, &current1)) {
        motors[0].disarm_with_error(Motor::ERROR_BAD_TIMING);
        motors[1].disarm_with_error(Motor::ERROR_BAD_TIMING);
    }

    // If the motor FETs are not switching then we can't measure the current
    // because for this we need the low side FET to conduct.
    // So for now we guess the current to be 0 (this is not correct shortly after
    // disarming and when the motor spins fast in idle). Passing an invalid
    // current reading would create problems with starting FOC.
    //!如果 PWM 输出被禁用（MOE 位为 0），将 current0 和 current1 清零，表示当前没有有效的电流测量数据
    if (!(TIM1->BDTR & TIM_BDTR_MOE_Msk)) {
        current0 = {0.0f, 0.0f};
    }
    if (!(TIM8->BDTR & TIM_BDTR_MOE_Msk)) {
        current1 = {0.0f, 0.0f};
    }
    //!timestamp - TIM1_INIT_COUNT：代表M0的ADC相电压采集时间，timestamp：代表M1的ADC相电压采集时间
    //!timestamp - TIM1_INIT_COUNT  ===》 timestamp - TIM_1_8_PERIOD_CLOCKS / 2 + 1 * 128) 这里为啥是这个偏移
    //!TIM1_INIT_COUNT 用于对齐电流采样时间 
    //!这个偏移是进一步微调时间点，用于补偿硬件上的延迟或系统特性。延迟可能来自：
        //!MOSFET 或 IGBT 的开关延迟。
        //!电路中的滤波器引入的信号延迟。
        //!ADC 开始采样到完成采样的时间
    //!做了一些判断
    motors[0].current_meas_cb(timestamp - TIM1_INIT_COUNT, current0);
    motors[1].current_meas_cb(timestamp, current1);

    //!执行一系列数据的update，比如“电角度”、“电速度”、“温度”等 
    odrv.control_loop_cb(timestamp);

    // By this time the ADCs for both M0 and M1 should have fired again. But
    // let's wait for them just to be sure.
    //!ADC 采样可能已经开始了一次新周期，但代码中仍然决定等待 ADC 确保转换完成，原因可能是因为control_loop_cb执行时间比较长？
    MEASURE_TIME(odrv.task_times_.dc_calib_wait) {
        while (!(ADC2->SR & ADC_SR_EOC));
    }
    //!再获取一次电流值
    //!得到相电流A,B,C  M0触发比M1的触发要早一点，而我们正在分析的代码执行的是在M1的中断处，所以此时M0的相电压值已经采集结束了（TIM1的update事件会自动触发采样启动）
    if (!fetch_and_reset_adcs(&current0, &current1)) {
        motors[0].disarm_with_error(Motor::ERROR_BAD_TIMING);
        motors[1].disarm_with_error(Motor::ERROR_BAD_TIMING);
    }
    //!再计算下下一次的ADC采样的时间戳
    //!timestamp + TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1) - TIM1_INIT_COUNT 好像没有用到？
    motors[0].dc_calib_cb(timestamp + TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1) - TIM1_INIT_COUNT, current0);
    motors[1].dc_calib_cb(timestamp + TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1), current1);

    motors[0].pwm_update_cb(timestamp + 3 * TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1) - TIM1_INIT_COUNT);
    motors[1].pwm_update_cb(timestamp + 3 * TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1));

    // If we did everything right, the TIM8 update handler should have been
    // called exactly once between the start of this function and now.

    if (timestamp_ != timestamp + TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1)) {
        motors[0].disarm_with_error(Motor::ERROR_CONTROL_DEADLINE_MISSED);
        motors[1].disarm_with_error(Motor::ERROR_CONTROL_DEADLINE_MISSED);
    }

    odrv.task_timers_armed_ = odrv.task_timers_armed_ && !TaskTimer::enabled;
    TaskTimer::enabled = false;
}

void I2C1_EV_IRQHandler(void) {
    COUNT_IRQ(I2C1_EV_IRQn);
    HAL_I2C_EV_IRQHandler(&hi2c1);
}

void I2C1_ER_IRQHandler(void) {
    COUNT_IRQ(I2C1_ER_IRQn);
    HAL_I2C_ER_IRQHandler(&hi2c1);
}

extern PCD_HandleTypeDef hpcd_USB_OTG_FS; // defined in usbd_conf.c
void OTG_FS_IRQHandler(void) {
    COUNT_IRQ(OTG_FS_IRQn);
    HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
}

}
