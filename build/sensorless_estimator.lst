ARM GAS  /tmp/cced9Z1Y.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"sensorless_estimator.cpp"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text._ZoRRN10ODriveIntf8AxisIntf5ErrorES1_,"axG",%progbits,_ZoRRN10ODriveIntf8AxisIntf5E
  20              		.align	1
  21              		.weak	_ZoRRN10ODriveIntf8AxisIntf5ErrorES1_
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	_ZoRRN10ODriveIntf8AxisIntf5ErrorES1_:
  27              		.fnstart
  28              	.LVL0:
  29              	.LFB4170:
  30              		.file 1 "./autogen/interfaces.hpp"
   1:./autogen/interfaces.hpp **** /*
   2:./autogen/interfaces.hpp ****  * ============================ WARNING ============================
   3:./autogen/interfaces.hpp ****  * ==== This is an autogenerated file.                          ====
   4:./autogen/interfaces.hpp ****  * ==== Any changes to this file will be lost when recompiling. ====
   5:./autogen/interfaces.hpp ****  * =================================================================
   6:./autogen/interfaces.hpp ****  *
   7:./autogen/interfaces.hpp ****  * This file contains base classes that correspond to the interfaces defined in
   8:./autogen/interfaces.hpp ****  * your interface file. The objects you publish should inherit from these
   9:./autogen/interfaces.hpp ****  * interfaces.
  10:./autogen/interfaces.hpp ****  *
  11:./autogen/interfaces.hpp ****  */
  12:./autogen/interfaces.hpp **** #ifndef __FIBRE_INTERFACES_HPP
  13:./autogen/interfaces.hpp **** #define __FIBRE_INTERFACES_HPP
  14:./autogen/interfaces.hpp **** 
  15:./autogen/interfaces.hpp **** #include <tuple>
  16:./autogen/interfaces.hpp **** using float2D = std::pair<float, float>;
  17:./autogen/interfaces.hpp **** struct Iph_ABC_t { float phA; float phB; float phC; };
  18:./autogen/interfaces.hpp **** 
  19:./autogen/interfaces.hpp **** 
  20:./autogen/interfaces.hpp **** #include <fibre/../../protocol.hpp>
  21:./autogen/interfaces.hpp **** 
  22:./autogen/interfaces.hpp **** #pragma GCC push_options
  23:./autogen/interfaces.hpp **** #pragma GCC optimize ("s")
  24:./autogen/interfaces.hpp **** 
  25:./autogen/interfaces.hpp **** 
  26:./autogen/interfaces.hpp **** 
  27:./autogen/interfaces.hpp **** class ODriveIntf {
  28:./autogen/interfaces.hpp **** public:
ARM GAS  /tmp/cced9Z1Y.s 			page 2


  29:./autogen/interfaces.hpp ****     class ConfigIntf {
  30:./autogen/interfaces.hpp ****     public:
  31:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_a(T* obj) { return Property<bool>{&
  32:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_a(T* obj, void* ptr) { new (ptr) Pr
  33:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_b(T* obj) { return Property<bool>{&
  34:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_b(T* obj, void* ptr) { new (ptr) Pr
  35:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_c(T* obj) { return Property<bool>{&
  36:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_c(T* obj, void* ptr) { new (ptr) Pr
  37:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_a_baudrate(T* obj) { return Property<uint3
  38:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_a_baudrate(T* obj, void* ptr) { new (ptr) 
  39:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_b_baudrate(T* obj) { return Property<uint3
  40:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_b_baudrate(T* obj, void* ptr) { new (ptr) 
  41:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_c_baudrate(T* obj) { return Property<uint3
  42:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_c_baudrate(T* obj, void* ptr) { new (ptr) 
  43:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_can_a(T* obj) { return Property<bool>{&o
  44:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_can_a(T* obj, void* ptr) { new (ptr) Pro
  45:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_i2c_a(T* obj) { return Property<bool>{&o
  46:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_i2c_a(T* obj, void* ptr) { new (ptr) Pro
  47:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_usb_cdc_protocol(T* obj) { return Property<ODri
  48:./autogen/interfaces.hpp ****         template<typename T> static inline void get_usb_cdc_protocol(T* obj, void* ptr) { new (ptr)
  49:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart0_protocol(T* obj) { return Property<ODrive
  50:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart0_protocol(T* obj, void* ptr) { new (ptr) P
  51:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart1_protocol(T* obj) { return Property<ODrive
  52:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart1_protocol(T* obj, void* ptr) { new (ptr) P
  53:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart2_protocol(T* obj) { return Property<ODrive
  54:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart2_protocol(T* obj, void* ptr) { new (ptr) P
  55:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_regen_current(T* obj) { return Property<flo
  56:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_regen_current(T* obj, void* ptr) { new (ptr
  57:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_brake_resistance(T* obj) { return Property<floa
  58:./autogen/interfaces.hpp ****         template<typename T> static inline void get_brake_resistance(T* obj, void* ptr) { new (ptr)
  59:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_brake_resistor(T* obj) { return Property
  60:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_brake_resistor(T* obj, void* ptr) { new 
  61:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_undervoltage_trip_level(T* obj) { return
  62:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_undervoltage_trip_level(T* obj, void* pt
  63:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_trip_level(T* obj) { return 
  64:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_trip_level(T* obj, void* ptr
  65:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_dc_bus_overvoltage_ramp(T* obj) { return
  66:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_dc_bus_overvoltage_ramp(T* obj, void* pt
  67:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_ramp_start(T* obj) { return 
  68:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_ramp_start(T* obj, void* ptr
  69:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_ramp_end(T* obj) { return Pr
  70:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_ramp_end(T* obj, void* ptr) 
  71:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_max_positive_current(T* obj) { return Proper
  72:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_max_positive_current(T* obj, void* ptr) { ne
  73:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_max_negative_current(T* obj) { return Proper
  74:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_max_negative_current(T* obj, void* ptr) { ne
  75:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error_gpio_pin(T* obj) { return Property<uint32
  76:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error_gpio_pin(T* obj, void* ptr) { new (ptr) P
  77:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio3_analog_mapping(T* obj) { return &obj->ana
  78:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio4_analog_mapping(T* obj) { return &obj->ana
  79:./autogen/interfaces.hpp ****     };
  80:./autogen/interfaces.hpp ****     class CanIntf {
  81:./autogen/interfaces.hpp ****     public:
  82:./autogen/interfaces.hpp ****         class ConfigIntf {
  83:./autogen/interfaces.hpp ****         public:
  84:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_baud_rate(T* obj) { return Property<uint32_
  85:./autogen/interfaces.hpp ****             template<typename T> static inline void get_baud_rate(T* obj, void* ptr) { new (ptr) Pr
ARM GAS  /tmp/cced9Z1Y.s 			page 3


  86:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_protocol(T* obj) { return Property<ODriveIn
  87:./autogen/interfaces.hpp ****             template<typename T> static inline void get_protocol(T* obj, void* ptr) { new (ptr) Pro
  88:./autogen/interfaces.hpp ****         };
  89:./autogen/interfaces.hpp ****         enum Error {
  90:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
  91:./autogen/interfaces.hpp ****             ERROR_DUPLICATE_CAN_IDS          = 0x00000001,
  92:./autogen/interfaces.hpp ****         };
  93:./autogen/interfaces.hpp ****         enum Protocol {
  94:./autogen/interfaces.hpp ****             PROTOCOL_SIMPLE                  = 0x00000001,
  95:./autogen/interfaces.hpp ****         };
  96:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Can
  97:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
  98:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
  99:./autogen/interfaces.hpp ****     };
 100:./autogen/interfaces.hpp ****     class EndpointIntf {
 101:./autogen/interfaces.hpp ****     public:
 102:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_endpoint(T* obj) { return Property<endpoint_ref
 103:./autogen/interfaces.hpp ****         template<typename T> static inline void get_endpoint(T* obj, void* ptr) { new (ptr) Propert
 104:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_min(T* obj) { return Property<float>{&obj->min}
 105:./autogen/interfaces.hpp ****         template<typename T> static inline void get_min(T* obj, void* ptr) { new (ptr) Property<flo
 106:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max(T* obj) { return Property<float>{&obj->max}
 107:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max(T* obj, void* ptr) { new (ptr) Property<flo
 108:./autogen/interfaces.hpp ****     };
 109:./autogen/interfaces.hpp ****     class AxisIntf {
 110:./autogen/interfaces.hpp ****     public:
 111:./autogen/interfaces.hpp ****         class LockinConfigIntf {
 112:./autogen/interfaces.hpp ****         public:
 113:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current(T* obj) { return Property<float>{&o
 114:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current(T* obj, void* ptr) { new (ptr) Prop
 115:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ramp_time(T* obj) { return Property<float>{
 116:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ramp_time(T* obj, void* ptr) { new (ptr) Pr
 117:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ramp_distance(T* obj) { return Property<flo
 118:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ramp_distance(T* obj, void* ptr) { new (ptr
 119:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_accel(T* obj) { return Property<float>{&obj
 120:./autogen/interfaces.hpp ****             template<typename T> static inline void get_accel(T* obj, void* ptr) { new (ptr) Proper
 121:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel(T* obj) { return Property<float>{&obj->
 122:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel(T* obj, void* ptr) { new (ptr) Property
 123:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_distance(T* obj) { return Property<f
 124:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_distance(T* obj, void* ptr) { new (p
 125:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_vel(T* obj) { return Property<boo
 126:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_vel(T* obj, void* ptr) { new (ptr
 127:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_distance(T* obj) { return Propert
 128:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_distance(T* obj, void* ptr) { new
 129:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_enc_idx(T* obj) { return Property
 130:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_enc_idx(T* obj, void* ptr) { new 
 131:./autogen/interfaces.hpp ****         };
 132:./autogen/interfaces.hpp ****         class CanConfigIntf {
 133:./autogen/interfaces.hpp ****         public:
 134:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_node_id(T* obj) { return Property<uint32_t>
 135:./autogen/interfaces.hpp ****             template<typename T> static inline void get_node_id(T* obj, void* ptr) { new (ptr) Prop
 136:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_is_extended(T* obj) { return Property<bool>
 137:./autogen/interfaces.hpp ****             template<typename T> static inline void get_is_extended(T* obj, void* ptr) { new (ptr) 
 138:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_heartbeat_rate_ms(T* obj) { return Property
 139:./autogen/interfaces.hpp ****             template<typename T> static inline void get_heartbeat_rate_ms(T* obj, void* ptr) { new 
 140:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_rate_ms(T* obj) { return Property<u
 141:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_rate_ms(T* obj, void* ptr) { new (p
 142:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_error_rate_ms(T* obj) { return Proper
ARM GAS  /tmp/cced9Z1Y.s 			page 4


 143:./autogen/interfaces.hpp ****             template<typename T> static inline void get_motor_error_rate_ms(T* obj, void* ptr) { ne
 144:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_error_rate_ms(T* obj) { return Prop
 145:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_error_rate_ms(T* obj, void* ptr) { 
 146:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_controller_error_rate_ms(T* obj) { return P
 147:./autogen/interfaces.hpp ****             template<typename T> static inline void get_controller_error_rate_ms(T* obj, void* ptr)
 148:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_error_rate_ms(T* obj) { return P
 149:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sensorless_error_rate_ms(T* obj, void* ptr)
 150:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_count_rate_ms(T* obj) { return Prop
 151:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_count_rate_ms(T* obj, void* ptr) { 
 152:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_iq_rate_ms(T* obj) { return Property<uint32
 153:./autogen/interfaces.hpp ****             template<typename T> static inline void get_iq_rate_ms(T* obj, void* ptr) { new (ptr) P
 154:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_rate_ms(T* obj) { return Propert
 155:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sensorless_rate_ms(T* obj, void* ptr) { new
 156:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bus_vi_rate_ms(T* obj) { return Property<ui
 157:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bus_vi_rate_ms(T* obj, void* ptr) { new (pt
 158:./autogen/interfaces.hpp ****         };
 159:./autogen/interfaces.hpp ****         class ConfigIntf {
 160:./autogen/interfaces.hpp ****         public:
 161:./autogen/interfaces.hpp ****             class CalibrationLockinIntf {
 162:./autogen/interfaces.hpp ****             public:
 163:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_current(T* obj) { return Property<float
 164:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_current(T* obj, void* ptr) { new (ptr) 
 165:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_ramp_time(T* obj) { return Property<flo
 166:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_ramp_time(T* obj, void* ptr) { new (ptr
 167:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_ramp_distance(T* obj) { return Property
 168:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_ramp_distance(T* obj, void* ptr) { new 
 169:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_accel(T* obj) { return Property<float>{
 170:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_accel(T* obj, void* ptr) { new (ptr) Pr
 171:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_vel(T* obj) { return Property<float>{&o
 172:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_vel(T* obj, void* ptr) { new (ptr) Prop
 173:./autogen/interfaces.hpp ****             };
 174:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_motor_calibration(T* obj) { return 
 175:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_motor_calibration(T* obj, void* ptr
 176:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_encoder_index_search(T* obj) { retu
 177:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_encoder_index_search(T* obj, void* 
 178:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_encoder_offset_calibration(T* obj) 
 179:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_encoder_offset_calibration(T* obj, 
 180:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_closed_loop_control(T* obj) { retur
 181:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_closed_loop_control(T* obj, void* p
 182:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_homing(T* obj) { return Property<bo
 183:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_homing(T* obj, void* ptr) { new (pt
 184:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_step_dir(T* obj) { return Property<b
 185:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_step_dir(T* obj, void* ptr) { new (p
 186:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_step_dir_always_on(T* obj) { return Propert
 187:./autogen/interfaces.hpp ****             template<typename T> static inline void get_step_dir_always_on(T* obj, void* ptr) { new
 188:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_sensorless_mode(T* obj) { return Pro
 189:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_sensorless_mode(T* obj, void* ptr) {
 190:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_watchdog_timeout(T* obj) { return Property<
 191:./autogen/interfaces.hpp ****             template<typename T> static inline void get_watchdog_timeout(T* obj, void* ptr) { new (
 192:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_watchdog(T* obj) { return Property<b
 193:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_watchdog(T* obj, void* ptr) { new (p
 194:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_step_gpio_pin(T* obj) { return Property<uin
 195:./autogen/interfaces.hpp ****             template<typename T> static inline void get_step_gpio_pin(T* obj, void* ptr) { new (ptr
 196:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dir_gpio_pin(T* obj) { return Property<uint
 197:./autogen/interfaces.hpp ****             template<typename T> static inline void get_dir_gpio_pin(T* obj, void* ptr) { new (ptr)
 198:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calibration_lockin(T* obj) { return &obj->c
 199:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_ramp(T* obj) { return &obj->sens
ARM GAS  /tmp/cced9Z1Y.s 			page 5


 200:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_general_lockin(T* obj) { return &obj->gener
 201:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_can(T* obj) { return &obj->can; }
 202:./autogen/interfaces.hpp ****         };
 203:./autogen/interfaces.hpp ****         class TaskTimesIntf {
 204:./autogen/interfaces.hpp ****         public:
 205:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_thermistor_update(T* obj) { return &obj->th
 206:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_update(T* obj) { return &obj->encod
 207:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_estimator_update(T* obj) { retur
 208:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_endstop_update(T* obj) { return &obj->endst
 209:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_can_heartbeat(T* obj) { return &obj->can_he
 210:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_controller_update(T* obj) { return &obj->co
 211:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_open_loop_controller_update(T* obj) { retur
 212:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_estimator_update(T* obj) { return &obj
 213:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_update(T* obj) { return &obj->motor_u
 214:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_controller_update(T* obj) { return 
 215:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dc_calib(T* obj) { return &obj->dc_calib; }
 216:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_sense(T* obj) { return &obj->curren
 217:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pwm_update(T* obj) { return &obj->pwm_updat
 218:./autogen/interfaces.hpp ****         };
 219:./autogen/interfaces.hpp ****         enum Error {
 220:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 221:./autogen/interfaces.hpp ****             ERROR_INVALID_STATE              = 0x00000001,
 222:./autogen/interfaces.hpp ****             ERROR_MOTOR_FAILED               = 0x00000040,
 223:./autogen/interfaces.hpp ****             ERROR_SENSORLESS_ESTIMATOR_FAILED = 0x00000080,
 224:./autogen/interfaces.hpp ****             ERROR_ENCODER_FAILED             = 0x00000100,
 225:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_FAILED          = 0x00000200,
 226:./autogen/interfaces.hpp ****             ERROR_WATCHDOG_TIMER_EXPIRED     = 0x00000800,
 227:./autogen/interfaces.hpp ****             ERROR_MIN_ENDSTOP_PRESSED        = 0x00001000,
 228:./autogen/interfaces.hpp ****             ERROR_MAX_ENDSTOP_PRESSED        = 0x00002000,
 229:./autogen/interfaces.hpp ****             ERROR_ESTOP_REQUESTED            = 0x00004000,
 230:./autogen/interfaces.hpp ****             ERROR_HOMING_WITHOUT_ENDSTOP     = 0x00020000,
 231:./autogen/interfaces.hpp ****             ERROR_OVER_TEMP                  = 0x00040000,
 232:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_POSITION           = 0x00080000,
 233:./autogen/interfaces.hpp ****         };
 234:./autogen/interfaces.hpp ****         enum AxisState {
 235:./autogen/interfaces.hpp ****             AXIS_STATE_UNDEFINED             = 0,
 236:./autogen/interfaces.hpp ****             AXIS_STATE_IDLE                  = 1,
 237:./autogen/interfaces.hpp ****             AXIS_STATE_STARTUP_SEQUENCE      = 2,
 238:./autogen/interfaces.hpp ****             AXIS_STATE_FULL_CALIBRATION_SEQUENCE = 3,
 239:./autogen/interfaces.hpp ****             AXIS_STATE_MOTOR_CALIBRATION     = 4,
 240:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_INDEX_SEARCH  = 6,
 241:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_OFFSET_CALIBRATION = 7,
 242:./autogen/interfaces.hpp ****             AXIS_STATE_CLOSED_LOOP_CONTROL   = 8,
 243:./autogen/interfaces.hpp ****             AXIS_STATE_LOCKIN_SPIN           = 9,
 244:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_DIR_FIND      = 10,
 245:./autogen/interfaces.hpp ****             AXIS_STATE_HOMING                = 11,
 246:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_HALL_POLARITY_CALIBRATION = 12,
 247:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_HALL_PHASE_CALIBRATION = 13,
 248:./autogen/interfaces.hpp ****         };
 249:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Axi
 250:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 251:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_step_dir_active(T* obj) { return Property<const
 252:./autogen/interfaces.hpp ****         template<typename T> static inline void get_step_dir_active(T* obj, void* ptr) { new (ptr) 
 253:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_drv_fault(T* obj) { return Property<const 
 254:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_drv_fault(T* obj, void* ptr) { new (ptr) P
 255:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_steps(T* obj) { return Property<const int64_t>{
 256:./autogen/interfaces.hpp ****         template<typename T> static inline void get_steps(T* obj, void* ptr) { new (ptr) Property<c
ARM GAS  /tmp/cced9Z1Y.s 			page 6


 257:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_state(T* obj) { return Property<const O
 258:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_state(T* obj, void* ptr) { new (ptr) Pr
 259:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_requested_state(T* obj) { return Property<ODriv
 260:./autogen/interfaces.hpp ****         template<typename T> static inline void get_requested_state(T* obj, void* ptr) { new (ptr) 
 261:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_homed(T* obj) { return Property<bool>{&obj->
 262:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_homed(T* obj, void* ptr) { new (ptr) Propert
 263:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 264:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_motor(T* obj) { return &obj->motor_; }
 265:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_controller(T* obj) { return &obj->controller_; 
 266:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_encoder(T* obj) { return &obj->encoder_; }
 267:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_acim_estimator(T* obj) { return &obj->acim_esti
 268:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_sensorless_estimator(T* obj) { return &obj->sen
 269:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_trap_traj(T* obj) { return &obj->trap_traj_; }
 270:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_min_endstop(T* obj) { return &obj->min_endstop_
 271:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_endstop(T* obj) { return &obj->max_endstop_
 272:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_mechanical_brake(T* obj) { return &obj->mechani
 273:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_task_times(T* obj) { return &obj->task_times_; 
 274:./autogen/interfaces.hpp ****         virtual void watchdog_feed() = 0;
 275:./autogen/interfaces.hpp ****     };
 276:./autogen/interfaces.hpp ****     class ThermistorCurrentLimiterIntf {
 277:./autogen/interfaces.hpp ****     public:
 278:./autogen/interfaces.hpp ****     };
 279:./autogen/interfaces.hpp ****     class OnboardThermistorCurrentLimiterIntf {
 280:./autogen/interfaces.hpp ****     public:
 281:./autogen/interfaces.hpp ****         class ConfigIntf {
 282:./autogen/interfaces.hpp ****         public:
 283:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_lower(T* obj) { return Property<
 284:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_lower(T* obj, void* ptr) { new (
 285:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_upper(T* obj) { return Property<
 286:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_upper(T* obj, void* ptr) { new (
 287:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{&ob
 288:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
 289:./autogen/interfaces.hpp ****         };
 290:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_temperature(T* obj) { return Property<const flo
 291:./autogen/interfaces.hpp ****         template<typename T> static inline void get_temperature(T* obj, void* ptr) { new (ptr) Prop
 292:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 293:./autogen/interfaces.hpp ****     };
 294:./autogen/interfaces.hpp ****     class OffboardThermistorCurrentLimiterIntf {
 295:./autogen/interfaces.hpp ****     public:
 296:./autogen/interfaces.hpp ****         class ConfigIntf {
 297:./autogen/interfaces.hpp ****         public:
 298:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gpio_pin(T* obj) { return Property<uint16_t
 299:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gpio_pin(T* obj, void* ptr) { new (ptr) Pro
 300:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_0(T* obj) { return Propert
 301:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_0(T* obj, void* ptr) { new
 302:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_1(T* obj) { return Propert
 303:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_1(T* obj, void* ptr) { new
 304:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_2(T* obj) { return Propert
 305:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_2(T* obj, void* ptr) { new
 306:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_3(T* obj) { return Propert
 307:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_3(T* obj, void* ptr) { new
 308:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_lower(T* obj) { return Property<
 309:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_lower(T* obj, void* ptr) { new (
 310:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_upper(T* obj) { return Property<
 311:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_upper(T* obj, void* ptr) { new (
 312:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{&ob
 313:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
ARM GAS  /tmp/cced9Z1Y.s 			page 7


 314:./autogen/interfaces.hpp ****         };
 315:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_temperature(T* obj) { return Property<const flo
 316:./autogen/interfaces.hpp ****         template<typename T> static inline void get_temperature(T* obj, void* ptr) { new (ptr) Prop
 317:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 318:./autogen/interfaces.hpp ****     };
 319:./autogen/interfaces.hpp ****     class MotorIntf {
 320:./autogen/interfaces.hpp ****     public:
 321:./autogen/interfaces.hpp ****         class CurrentControlIntf {
 322:./autogen/interfaces.hpp ****         public:
 323:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_p_gain(T* obj) { return Property<const floa
 324:./autogen/interfaces.hpp ****             template<typename T> static inline void get_p_gain(T* obj, void* ptr) { new (ptr) Prope
 325:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_i_gain(T* obj) { return Property<const floa
 326:./autogen/interfaces.hpp ****             template<typename T> static inline void get_i_gain(T* obj, void* ptr) { new (ptr) Prope
 327:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_measured_report_filter_k(T* obj) { return
 328:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_measured_report_filter_k(T* obj, void* pt
 329:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Id_setpoint(T* obj) { return Property<const
 330:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Id_setpoint(T* obj, void* ptr) { new (ptr) 
 331:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Iq_setpoint(T* obj) { return Property<const
 332:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Iq_setpoint(T* obj, void* ptr) { new (ptr) 
 333:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Vd_setpoint(T* obj) { return Property<const
 334:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Vd_setpoint(T* obj, void* ptr) { new (ptr) 
 335:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Vq_setpoint(T* obj) { return Property<const
 336:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Vq_setpoint(T* obj, void* ptr) { new (ptr) 
 337:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase(T* obj) { return Property<const float
 338:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Proper
 339:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_vel(T* obj) { return Property<const f
 340:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_vel(T* obj, void* ptr) { new (ptr) Pr
 341:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Ialpha_measured(T* obj) { return Property<c
 342:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Ialpha_measured(T* obj, void* ptr) { new (p
 343:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Ibeta_measured(T* obj) { return Property<co
 344:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Ibeta_measured(T* obj, void* ptr) { new (pt
 345:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Id_measured(T* obj) { return Property<const
 346:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Id_measured(T* obj, void* ptr) { new (ptr) 
 347:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Iq_measured(T* obj) { return Property<const
 348:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Iq_measured(T* obj, void* ptr) { new (ptr) 
 349:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_power(T* obj) { return Property<const float
 350:./autogen/interfaces.hpp ****             template<typename T> static inline void get_power(T* obj, void* ptr) { new (ptr) Proper
 351:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_v_current_control_integral_d(T* obj) { retu
 352:./autogen/interfaces.hpp ****             template<typename T> static inline void get_v_current_control_integral_d(T* obj, void* 
 353:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_v_current_control_integral_q(T* obj) { retu
 354:./autogen/interfaces.hpp ****             template<typename T> static inline void get_v_current_control_integral_q(T* obj, void* 
 355:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_final_v_alpha(T* obj) { return Property<con
 356:./autogen/interfaces.hpp ****             template<typename T> static inline void get_final_v_alpha(T* obj, void* ptr) { new (ptr
 357:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_final_v_beta(T* obj) { return Property<cons
 358:./autogen/interfaces.hpp ****             template<typename T> static inline void get_final_v_beta(T* obj, void* ptr) { new (ptr)
 359:./autogen/interfaces.hpp ****         };
 360:./autogen/interfaces.hpp ****         class ConfigIntf {
 361:./autogen/interfaces.hpp ****         public:
 362:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bo
 363:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (pt
 364:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pole_pairs(T* obj) { return Property<int32_
 365:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pole_pairs(T* obj, void* ptr) { new (ptr) P
 366:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calibration_current(T* obj) { return Proper
 367:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calibration_current(T* obj, void* ptr) { ne
 368:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_resistance_calib_max_voltage(T* obj) { retu
 369:./autogen/interfaces.hpp ****             template<typename T> static inline void get_resistance_calib_max_voltage(T* obj, void* 
 370:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_inductance(T* obj) { return Property<
ARM GAS  /tmp/cced9Z1Y.s 			page 8


 371:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_inductance(T* obj, void* ptr) { new (
 372:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_resistance(T* obj) { return Property<
 373:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_resistance(T* obj, void* ptr) { new (
 374:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_constant(T* obj) { return Property<f
 375:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_constant(T* obj, void* ptr) { new (p
 376:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_type(T* obj) { return Property<ODrive
 377:./autogen/interfaces.hpp ****             template<typename T> static inline void get_motor_type(T* obj, void* ptr) { new (ptr) P
 378:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_lim(T* obj) { return Property<float
 379:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_lim(T* obj, void* ptr) { new (ptr) 
 380:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_lim_margin(T* obj) { return Propert
 381:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_lim_margin(T* obj, void* ptr) { new
 382:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_lim(T* obj) { return Property<float>
 383:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_lim(T* obj, void* ptr) { new (ptr) P
 384:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inverter_temp_limit_lower(T* obj) { return 
 385:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inverter_temp_limit_lower(T* obj, void* ptr
 386:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inverter_temp_limit_upper(T* obj) { return 
 387:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inverter_temp_limit_upper(T* obj, void* ptr
 388:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_requested_current_range(T* obj) { return Pr
 389:./autogen/interfaces.hpp ****             template<typename T> static inline void get_requested_current_range(T* obj, void* ptr) 
 390:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_control_bandwidth(T* obj) { return 
 391:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_control_bandwidth(T* obj, void* ptr
 392:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_gain_min_flux(T* obj) { return Propert
 393:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_gain_min_flux(T* obj, void* ptr) { new
 394:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_min_Id(T* obj) { return Prope
 395:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_min_Id(T* obj, void* ptr) { n
 396:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_enable(T* obj) { return Prope
 397:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_enable(T* obj, void* ptr) { n
 398:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_attack_gain(T* obj) { return 
 399:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_attack_gain(T* obj, void* ptr
 400:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_decay_gain(T* obj) { return P
 401:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_decay_gain(T* obj, void* ptr)
 402:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_R_wL_FF_enable(T* obj) { return Property<bo
 403:./autogen/interfaces.hpp ****             template<typename T> static inline void get_R_wL_FF_enable(T* obj, void* ptr) { new (pt
 404:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bEMF_FF_enable(T* obj) { return Property<bo
 405:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bEMF_FF_enable(T* obj, void* ptr) { new (pt
 406:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_bus_hard_min(T* obj) { return Property<fl
 407:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_bus_hard_min(T* obj, void* ptr) { new (pt
 408:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_bus_hard_max(T* obj) { return Property<fl
 409:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_bus_hard_max(T* obj, void* ptr) { new (pt
 410:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_leak_max(T* obj) { return Property<float>
 411:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_leak_max(T* obj, void* ptr) { new (ptr) P
 412:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dc_calib_tau(T* obj) { return Property<floa
 413:./autogen/interfaces.hpp ****             template<typename T> static inline void get_dc_calib_tau(T* obj, void* ptr) { new (ptr)
 414:./autogen/interfaces.hpp ****         };
 415:./autogen/interfaces.hpp ****         enum Error {
 416:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 417:./autogen/interfaces.hpp ****             ERROR_PHASE_RESISTANCE_OUT_OF_RANGE = 0x00000001,
 418:./autogen/interfaces.hpp ****             ERROR_PHASE_INDUCTANCE_OUT_OF_RANGE = 0x00000002,
 419:./autogen/interfaces.hpp ****             ERROR_DRV_FAULT                  = 0x00000008,
 420:./autogen/interfaces.hpp ****             ERROR_CONTROL_DEADLINE_MISSED    = 0x00000010,
 421:./autogen/interfaces.hpp ****             ERROR_MODULATION_MAGNITUDE       = 0x00000080,
 422:./autogen/interfaces.hpp ****             ERROR_CURRENT_SENSE_SATURATION   = 0x00000400,
 423:./autogen/interfaces.hpp ****             ERROR_CURRENT_LIMIT_VIOLATION    = 0x00001000,
 424:./autogen/interfaces.hpp ****             ERROR_MODULATION_IS_NAN          = 0x00010000,
 425:./autogen/interfaces.hpp ****             ERROR_MOTOR_THERMISTOR_OVER_TEMP = 0x00020000,
 426:./autogen/interfaces.hpp ****             ERROR_FET_THERMISTOR_OVER_TEMP   = 0x00040000,
 427:./autogen/interfaces.hpp ****             ERROR_TIMER_UPDATE_MISSED        = 0x00080000,
ARM GAS  /tmp/cced9Z1Y.s 			page 9


 428:./autogen/interfaces.hpp ****             ERROR_CURRENT_MEASUREMENT_UNAVAILABLE = 0x00100000,
 429:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_FAILED          = 0x00200000,
 430:./autogen/interfaces.hpp ****             ERROR_I_BUS_OUT_OF_RANGE         = 0x00400000,
 431:./autogen/interfaces.hpp ****             ERROR_BRAKE_RESISTOR_DISARMED    = 0x00800000,
 432:./autogen/interfaces.hpp ****             ERROR_SYSTEM_LEVEL               = 0x01000000,
 433:./autogen/interfaces.hpp ****             ERROR_BAD_TIMING                 = 0x02000000,
 434:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_PHASE_ESTIMATE     = 0x04000000,
 435:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_PHASE_VEL          = 0x08000000,
 436:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_TORQUE             = 0x10000000,
 437:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_COMMAND    = 0x20000000,
 438:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x40000000,
 439:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_VBUS_VOLTAGE       = 0x80000000,
 440:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_VOLTAGE_COMMAND    = 0x100000000,
 441:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_GAINS              = 0x200000000,
 442:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_INITIALIZING    = 0x400000000,
 443:./autogen/interfaces.hpp ****             ERROR_UNBALANCED_PHASES          = 0x800000000,
 444:./autogen/interfaces.hpp ****         };
 445:./autogen/interfaces.hpp ****         enum MotorType {
 446:./autogen/interfaces.hpp ****             MOTOR_TYPE_HIGH_CURRENT          = 0,
 447:./autogen/interfaces.hpp ****             MOTOR_TYPE_GIMBAL                = 2,
 448:./autogen/interfaces.hpp ****             MOTOR_TYPE_ACIM                  = 3,
 449:./autogen/interfaces.hpp ****         };
 450:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_error_time(T* obj) { return Property<float
 451:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_error_time(T* obj, void* ptr) { new (ptr) 
 452:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Mot
 453:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 454:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_armed(T* obj) { return Property<const bool>{
 455:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_armed(T* obj, void* ptr) { new (ptr) Propert
 456:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_calibrated(T* obj) { return Property<const b
 457:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_calibrated(T* obj, void* ptr) { new (ptr) Pr
 458:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phA(T* obj) { return Property<cons
 459:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phA(T* obj, void* ptr) { new (ptr)
 460:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phB(T* obj) { return Property<cons
 461:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phB(T* obj, void* ptr) { new (ptr)
 462:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phC(T* obj) { return Property<cons
 463:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phC(T* obj, void* ptr) { new (ptr)
 464:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phA(T* obj) { return Property<float>{&
 465:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phA(T* obj, void* ptr) { new (ptr) Pro
 466:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phB(T* obj) { return Property<float>{&
 467:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phB(T* obj, void* ptr) { new (ptr) Pro
 468:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phC(T* obj) { return Property<float>{&
 469:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phC(T* obj, void* ptr) { new (ptr) Pro
 470:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_I_bus(T* obj) { return Property<const float>{&o
 471:./autogen/interfaces.hpp ****         template<typename T> static inline void get_I_bus(T* obj, void* ptr) { new (ptr) Property<c
 472:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_current_rev_gain(T* obj) { return Propert
 473:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_current_rev_gain(T* obj, void* ptr) { new
 474:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_effective_current_lim(T* obj) { return Property
 475:./autogen/interfaces.hpp ****         template<typename T> static inline void get_effective_current_lim(T* obj, void* ptr) { new 
 476:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_allowed_current(T* obj) { return Property<c
 477:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_allowed_current(T* obj, void* ptr) { new (p
 478:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_dc_calib(T* obj) { return Property<const fl
 479:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_dc_calib(T* obj, void* ptr) { new (ptr) Pro
 480:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_fet_thermistor(T* obj) { return &obj->fet_therm
 481:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_motor_thermistor(T* obj) { return &obj->motor_t
 482:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_control(T* obj) { return &obj->current_
 483:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_n_evt_current_measurement(T* obj) { return Prop
 484:./autogen/interfaces.hpp ****         template<typename T> static inline void get_n_evt_current_measurement(T* obj, void* ptr) { 
ARM GAS  /tmp/cced9Z1Y.s 			page 10


 485:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_n_evt_pwm_update(T* obj) { return Property<cons
 486:./autogen/interfaces.hpp ****         template<typename T> static inline void get_n_evt_pwm_update(T* obj, void* ptr) { new (ptr)
 487:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 488:./autogen/interfaces.hpp ****     };
 489:./autogen/interfaces.hpp ****     class OscilloscopeIntf {
 490:./autogen/interfaces.hpp ****     public:
 491:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_size(T* obj) { return Property<const uint32_t>{
 492:./autogen/interfaces.hpp ****         template<typename T> static inline void get_size(T* obj, void* ptr) { new (ptr) Property<co
 493:./autogen/interfaces.hpp ****         virtual float get_val(uint32_t index) = 0;
 494:./autogen/interfaces.hpp ****         uint32_t get_val_in_index_; // for internal use by Fibre
 495:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_val_in_index_(T* obj) { return Property<uint32_t>{
 496:./autogen/interfaces.hpp ****         template<typename T> static void get_get_val_in_index_(T* obj, void* ptr) { new (ptr) Prope
 497:./autogen/interfaces.hpp ****         float get_val_out_val_; // for internal use by Fibre
 498:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_val_out_val_(T* obj) { return Property<const float
 499:./autogen/interfaces.hpp ****         template<typename T> static void get_get_val_out_val_(T* obj, void* ptr) { new (ptr) Proper
 500:./autogen/interfaces.hpp ****     };
 501:./autogen/interfaces.hpp ****     class AcimEstimatorIntf {
 502:./autogen/interfaces.hpp ****     public:
 503:./autogen/interfaces.hpp ****         class ConfigIntf {
 504:./autogen/interfaces.hpp ****         public:
 505:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_slip_velocity(T* obj) { return Property<flo
 506:./autogen/interfaces.hpp ****             template<typename T> static inline void get_slip_velocity(T* obj, void* ptr) { new (ptr
 507:./autogen/interfaces.hpp ****         };
 508:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_rotor_flux(T* obj) { return Property<const floa
 509:./autogen/interfaces.hpp ****         template<typename T> static inline void get_rotor_flux(T* obj, void* ptr) { new (ptr) Prope
 510:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_slip_vel(T* obj) { return Property<const float>
 511:./autogen/interfaces.hpp ****         template<typename T> static inline void get_slip_vel(T* obj, void* ptr) { new (ptr) Propert
 512:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_offset(T* obj) { return Property<const fl
 513:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_offset(T* obj, void* ptr) { new (ptr) Pro
 514:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stator_phase_vel(T* obj) { return Property<cons
 515:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stator_phase_vel(T* obj, void* ptr) { new (ptr)
 516:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stator_phase(T* obj) { return Property<const fl
 517:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stator_phase(T* obj, void* ptr) { new (ptr) Pro
 518:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 519:./autogen/interfaces.hpp ****     };
 520:./autogen/interfaces.hpp ****     class ControllerIntf {
 521:./autogen/interfaces.hpp ****     public:
 522:./autogen/interfaces.hpp ****         class ConfigIntf {
 523:./autogen/interfaces.hpp ****         public:
 524:./autogen/interfaces.hpp ****             class AnticoggingIntf {
 525:./autogen/interfaces.hpp ****             public:
 526:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_index(T* obj) { return Property<const u
 527:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_index(T* obj, void* ptr) { new (ptr) Pr
 528:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_pre_calibrated(T* obj) { return Propert
 529:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new
 530:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_anticogging(T* obj) { return Prop
 531:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_anticogging(T* obj, void* ptr) { 
 532:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_pos_threshold(T* obj) { return Pr
 533:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_pos_threshold(T* obj, void* ptr) 
 534:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_vel_threshold(T* obj) { return Pr
 535:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_vel_threshold(T* obj, void* ptr) 
 536:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_cogging_ratio(T* obj) { return Property
 537:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_cogging_ratio(T* obj, void* ptr) { new 
 538:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_anticogging_enabled(T* obj) { return Pr
 539:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_anticogging_enabled(T* obj, void* ptr) 
 540:./autogen/interfaces.hpp ****             };
 541:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gain_scheduling_width(T* obj) { return Prop
ARM GAS  /tmp/cced9Z1Y.s 			page 11


 542:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gain_scheduling_width(T* obj, void* ptr) { 
 543:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_vel_limit(T* obj) { return Property<
 544:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_vel_limit(T* obj, void* ptr) { new (
 545:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_torque_mode_vel_limit(T* obj) { retu
 546:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_torque_mode_vel_limit(T* obj, void* 
 547:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_gain_scheduling(T* obj) { return Pro
 548:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_gain_scheduling(T* obj, void* ptr) {
 549:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_overspeed_error(T* obj) { return Pro
 550:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_overspeed_error(T* obj, void* ptr) {
 551:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_control_mode(T* obj) { return Property<ODri
 552:./autogen/interfaces.hpp ****             template<typename T> static inline void get_control_mode(T* obj, void* ptr) { new (ptr)
 553:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_input_mode(T* obj) { return Property<ODrive
 554:./autogen/interfaces.hpp ****             template<typename T> static inline void get_input_mode(T* obj, void* ptr) { new (ptr) P
 555:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pos_gain(T* obj) { return Property<float>{&
 556:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pos_gain(T* obj, void* ptr) { new (ptr) Pro
 557:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_gain(T* obj) { return Property<float>{&
 558:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_gain(T* obj, void* ptr) { new (ptr) Pro
 559:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_integrator_gain(T* obj) { return Proper
 560:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_integrator_gain(T* obj, void* ptr) { ne
 561:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_integrator_limit(T* obj) { return Prope
 562:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_integrator_limit(T* obj, void* ptr) { n
 563:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit(T* obj) { return Property<float>{
 564:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit(T* obj, void* ptr) { new (ptr) Pr
 565:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit_tolerance(T* obj) { return Proper
 566:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit_tolerance(T* obj, void* ptr) { ne
 567:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_ramp_rate(T* obj) { return Property<flo
 568:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_ramp_rate(T* obj, void* ptr) { new (ptr
 569:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_ramp_rate(T* obj) { return Property<
 570:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_ramp_rate(T* obj, void* ptr) { new (
 571:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_circular_setpoints(T* obj) { return Propert
 572:./autogen/interfaces.hpp ****             template<typename T> static inline void get_circular_setpoints(T* obj, void* ptr) { new
 573:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_circular_setpoint_range(T* obj) { return Pr
 574:./autogen/interfaces.hpp ****             template<typename T> static inline void get_circular_setpoint_range(T* obj, void* ptr) 
 575:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_steps_per_circular_range(T* obj) { return P
 576:./autogen/interfaces.hpp ****             template<typename T> static inline void get_steps_per_circular_range(T* obj, void* ptr)
 577:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_homing_speed(T* obj) { return Property<floa
 578:./autogen/interfaces.hpp ****             template<typename T> static inline void get_homing_speed(T* obj, void* ptr) { new (ptr)
 579:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inertia(T* obj) { return Property<float>{&o
 580:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inertia(T* obj, void* ptr) { new (ptr) Prop
 581:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_axis_to_mirror(T* obj) { return Property<ui
 582:./autogen/interfaces.hpp ****             template<typename T> static inline void get_axis_to_mirror(T* obj, void* ptr) { new (pt
 583:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mirror_ratio(T* obj) { return Property<floa
 584:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mirror_ratio(T* obj, void* ptr) { new (ptr)
 585:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_mirror_ratio(T* obj) { return Proper
 586:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_mirror_ratio(T* obj, void* ptr) { ne
 587:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_load_encoder_axis(T* obj) { return Property
 588:./autogen/interfaces.hpp ****             template<typename T> static inline void get_load_encoder_axis(T* obj, void* ptr) { new 
 589:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_input_filter_bandwidth(T* obj) { return Pro
 590:./autogen/interfaces.hpp ****             template<typename T> static inline void get_input_filter_bandwidth(T* obj, void* ptr) {
 591:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_anticogging(T* obj) { return &obj->anticogg
 592:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mechanical_power_bandwidth(T* obj) { return
 593:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mechanical_power_bandwidth(T* obj, void* pt
 594:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_electrical_power_bandwidth(T* obj) { return
 595:./autogen/interfaces.hpp ****             template<typename T> static inline void get_electrical_power_bandwidth(T* obj, void* pt
 596:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_spinout_mechanical_power_threshold(T* obj) 
 597:./autogen/interfaces.hpp ****             template<typename T> static inline void get_spinout_mechanical_power_threshold(T* obj, 
 598:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_spinout_electrical_power_threshold(T* obj) 
ARM GAS  /tmp/cced9Z1Y.s 			page 12


 599:./autogen/interfaces.hpp ****             template<typename T> static inline void get_spinout_electrical_power_threshold(T* obj, 
 600:./autogen/interfaces.hpp ****         };
 601:./autogen/interfaces.hpp ****         class AutotuningIntf {
 602:./autogen/interfaces.hpp ****         public:
 603:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_frequency(T* obj) { return Property<float>{
 604:./autogen/interfaces.hpp ****             template<typename T> static inline void get_frequency(T* obj, void* ptr) { new (ptr) Pr
 605:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pos_amplitude(T* obj) { return Property<flo
 606:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pos_amplitude(T* obj, void* ptr) { new (ptr
 607:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_amplitude(T* obj) { return Property<flo
 608:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_amplitude(T* obj, void* ptr) { new (ptr
 609:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_amplitude(T* obj) { return Property<
 610:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_amplitude(T* obj, void* ptr) { new (
 611:./autogen/interfaces.hpp ****         };
 612:./autogen/interfaces.hpp ****         enum Error {
 613:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 614:./autogen/interfaces.hpp ****             ERROR_OVERSPEED                  = 0x00000001,
 615:./autogen/interfaces.hpp ****             ERROR_INVALID_INPUT_MODE         = 0x00000002,
 616:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000004,
 617:./autogen/interfaces.hpp ****             ERROR_INVALID_MIRROR_AXIS        = 0x00000008,
 618:./autogen/interfaces.hpp ****             ERROR_INVALID_LOAD_ENCODER       = 0x00000010,
 619:./autogen/interfaces.hpp ****             ERROR_INVALID_ESTIMATE           = 0x00000020,
 620:./autogen/interfaces.hpp ****             ERROR_INVALID_CIRCULAR_RANGE     = 0x00000040,
 621:./autogen/interfaces.hpp ****             ERROR_SPINOUT_DETECTED           = 0x00000080,
 622:./autogen/interfaces.hpp ****         };
 623:./autogen/interfaces.hpp ****         enum ControlMode {
 624:./autogen/interfaces.hpp ****             CONTROL_MODE_VOLTAGE_CONTROL     = 0,
 625:./autogen/interfaces.hpp ****             CONTROL_MODE_TORQUE_CONTROL      = 1,
 626:./autogen/interfaces.hpp ****             CONTROL_MODE_VELOCITY_CONTROL    = 2,
 627:./autogen/interfaces.hpp ****             CONTROL_MODE_POSITION_CONTROL    = 3,
 628:./autogen/interfaces.hpp ****         };
 629:./autogen/interfaces.hpp ****         enum InputMode {
 630:./autogen/interfaces.hpp ****             INPUT_MODE_INACTIVE              = 0,
 631:./autogen/interfaces.hpp ****             INPUT_MODE_PASSTHROUGH           = 1,
 632:./autogen/interfaces.hpp ****             INPUT_MODE_VEL_RAMP              = 2,
 633:./autogen/interfaces.hpp ****             INPUT_MODE_POS_FILTER            = 3,
 634:./autogen/interfaces.hpp ****             INPUT_MODE_MIX_CHANNELS          = 4,
 635:./autogen/interfaces.hpp ****             INPUT_MODE_TRAP_TRAJ             = 5,
 636:./autogen/interfaces.hpp ****             INPUT_MODE_TORQUE_RAMP           = 6,
 637:./autogen/interfaces.hpp ****             INPUT_MODE_MIRROR                = 7,
 638:./autogen/interfaces.hpp ****             INPUT_MODE_TUNING                = 8,
 639:./autogen/interfaces.hpp ****         };
 640:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Con
 641:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 642:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_error_time(T* obj) { return Property<float
 643:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_error_time(T* obj, void* ptr) { new (ptr) 
 644:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_pos(T* obj) { return Property<float>{obj,
 645:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_pos(T* obj, void* ptr) { new (ptr) Proper
 646:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_vel(T* obj) { return Property<float>{&obj
 647:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_vel(T* obj, void* ptr) { new (ptr) Proper
 648:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_torque(T* obj) { return Property<float>{&
 649:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_torque(T* obj, void* ptr) { new (ptr) Pro
 650:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_setpoint(T* obj) { return Property<const fl
 651:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_setpoint(T* obj, void* ptr) { new (ptr) Pro
 652:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_setpoint(T* obj) { return Property<const fl
 653:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_setpoint(T* obj, void* ptr) { new (ptr) Pro
 654:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_torque_setpoint(T* obj) { return Property<const
 655:./autogen/interfaces.hpp ****         template<typename T> static inline void get_torque_setpoint(T* obj, void* ptr) { new (ptr) 
ARM GAS  /tmp/cced9Z1Y.s 			page 13


 656:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_trajectory_done(T* obj) { return Property<const
 657:./autogen/interfaces.hpp ****         template<typename T> static inline void get_trajectory_done(T* obj, void* ptr) { new (ptr) 
 658:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_integrator_torque(T* obj) { return Property
 659:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_integrator_torque(T* obj, void* ptr) { new 
 660:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_anticogging_valid(T* obj) { return Property<boo
 661:./autogen/interfaces.hpp ****         template<typename T> static inline void get_anticogging_valid(T* obj, void* ptr) { new (ptr
 662:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_autotuning_phase(T* obj) { return Property<floa
 663:./autogen/interfaces.hpp ****         template<typename T> static inline void get_autotuning_phase(T* obj, void* ptr) { new (ptr)
 664:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 665:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_autotuning(T* obj) { return &obj->autotuning_; 
 666:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_mechanical_power(T* obj) { return Property<cons
 667:./autogen/interfaces.hpp ****         template<typename T> static inline void get_mechanical_power(T* obj, void* ptr) { new (ptr)
 668:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_electrical_power(T* obj) { return Property<cons
 669:./autogen/interfaces.hpp ****         template<typename T> static inline void get_electrical_power(T* obj, void* ptr) { new (ptr)
 670:./autogen/interfaces.hpp ****         virtual void move_incremental(float displacement, bool from_input_pos) = 0;
 671:./autogen/interfaces.hpp ****         virtual void start_anticogging_calibration() = 0;
 672:./autogen/interfaces.hpp ****         virtual float remove_anticogging_bias() = 0;
 673:./autogen/interfaces.hpp ****         virtual float get_anticogging_value(uint32_t index) = 0;
 674:./autogen/interfaces.hpp ****         float move_incremental_in_displacement_; // for internal use by Fibre
 675:./autogen/interfaces.hpp ****         template<typename T> static auto get_move_incremental_in_displacement_(T* obj) { return Pro
 676:./autogen/interfaces.hpp ****         template<typename T> static void get_move_incremental_in_displacement_(T* obj, void* ptr) {
 677:./autogen/interfaces.hpp ****         bool move_incremental_in_from_input_pos_; // for internal use by Fibre
 678:./autogen/interfaces.hpp ****         template<typename T> static auto get_move_incremental_in_from_input_pos_(T* obj) { return P
 679:./autogen/interfaces.hpp ****         template<typename T> static void get_move_incremental_in_from_input_pos_(T* obj, void* ptr)
 680:./autogen/interfaces.hpp ****         float remove_anticogging_bias_out_val_; // for internal use by Fibre
 681:./autogen/interfaces.hpp ****         template<typename T> static auto get_remove_anticogging_bias_out_val_(T* obj) { return Prop
 682:./autogen/interfaces.hpp ****         template<typename T> static void get_remove_anticogging_bias_out_val_(T* obj, void* ptr) { 
 683:./autogen/interfaces.hpp ****         uint32_t get_anticogging_value_in_index_; // for internal use by Fibre
 684:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_anticogging_value_in_index_(T* obj) { return Prope
 685:./autogen/interfaces.hpp ****         template<typename T> static void get_get_anticogging_value_in_index_(T* obj, void* ptr) { n
 686:./autogen/interfaces.hpp ****         float get_anticogging_value_out_val_; // for internal use by Fibre
 687:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_anticogging_value_out_val_(T* obj) { return Proper
 688:./autogen/interfaces.hpp ****         template<typename T> static void get_get_anticogging_value_out_val_(T* obj, void* ptr) { ne
 689:./autogen/interfaces.hpp ****     };
 690:./autogen/interfaces.hpp ****     class EncoderIntf {
 691:./autogen/interfaces.hpp ****     public:
 692:./autogen/interfaces.hpp ****         class ConfigIntf {
 693:./autogen/interfaces.hpp ****         public:
 694:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mode(T* obj) { return Property<ODriveIntf::
 695:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mode(T* obj, void* ptr) { new (ptr) Propert
 696:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_use_index(T* obj) { return Property<bool>{o
 697:./autogen/interfaces.hpp ****             template<typename T> static inline void get_use_index(T* obj, void* ptr) { new (ptr) Pr
 698:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_index_offset(T* obj) { return Property<floa
 699:./autogen/interfaces.hpp ****             template<typename T> static inline void get_index_offset(T* obj, void* ptr) { new (ptr)
 700:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_use_index_offset(T* obj) { return Property<
 701:./autogen/interfaces.hpp ****             template<typename T> static inline void get_use_index_offset(T* obj, void* ptr) { new (
 702:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_find_idx_on_lockin_only(T* obj) { return Pr
 703:./autogen/interfaces.hpp ****             template<typename T> static inline void get_find_idx_on_lockin_only(T* obj, void* ptr) 
 704:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_abs_spi_cs_gpio_pin(T* obj) { return Proper
 705:./autogen/interfaces.hpp ****             template<typename T> static inline void get_abs_spi_cs_gpio_pin(T* obj, void* ptr) { ne
 706:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_cpr(T* obj) { return Property<int32_t>{&obj
 707:./autogen/interfaces.hpp ****             template<typename T> static inline void get_cpr(T* obj, void* ptr) { new (ptr) Property
 708:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_offset(T* obj) { return Property<int3
 709:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_offset(T* obj, void* ptr) { new (ptr)
 710:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_offset_float(T* obj) { return Propert
 711:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_offset_float(T* obj, void* ptr) { new
 712:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_direction(T* obj) { return Property<int32_t
ARM GAS  /tmp/cced9Z1Y.s 			page 14


 713:./autogen/interfaces.hpp ****             template<typename T> static inline void get_direction(T* obj, void* ptr) { new (ptr) Pr
 714:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bo
 715:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (pt
 716:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_phase_interpolation(T* obj) { return
 717:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_phase_interpolation(T* obj, void* pt
 718:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bandwidth(T* obj) { return Property<float>{
 719:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bandwidth(T* obj, void* ptr) { new (ptr) Pr
 720:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_range(T* obj) { return Property<float
 721:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_range(T* obj, void* ptr) { new (ptr) 
 722:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_scan_distance(T* obj) { return Proper
 723:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_scan_distance(T* obj, void* ptr) { ne
 724:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_scan_omega(T* obj) { return Property<
 725:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_scan_omega(T* obj, void* ptr) { new (
 726:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ignore_illegal_hall_state(T* obj) { return 
 727:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ignore_illegal_hall_state(T* obj, void* ptr
 728:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_hall_polarity(T* obj) { return Property<uin
 729:./autogen/interfaces.hpp ****             template<typename T> static inline void get_hall_polarity(T* obj, void* ptr) { new (ptr
 730:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_hall_polarity_calibrated(T* obj) { return P
 731:./autogen/interfaces.hpp ****             template<typename T> static inline void get_hall_polarity_calibrated(T* obj, void* ptr)
 732:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sincos_gpio_pin_sin(T* obj) { return Proper
 733:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sincos_gpio_pin_sin(T* obj, void* ptr) { ne
 734:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sincos_gpio_pin_cos(T* obj) { return Proper
 735:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sincos_gpio_pin_cos(T* obj, void* ptr) { ne
 736:./autogen/interfaces.hpp ****         };
 737:./autogen/interfaces.hpp ****         enum Error {
 738:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 739:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000001,
 740:./autogen/interfaces.hpp ****             ERROR_CPR_POLEPAIRS_MISMATCH     = 0x00000002,
 741:./autogen/interfaces.hpp ****             ERROR_NO_RESPONSE                = 0x00000004,
 742:./autogen/interfaces.hpp ****             ERROR_UNSUPPORTED_ENCODER_MODE   = 0x00000008,
 743:./autogen/interfaces.hpp ****             ERROR_ILLEGAL_HALL_STATE         = 0x00000010,
 744:./autogen/interfaces.hpp ****             ERROR_INDEX_NOT_FOUND_YET        = 0x00000020,
 745:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_TIMEOUT            = 0x00000040,
 746:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_COM_FAIL           = 0x00000080,
 747:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_NOT_READY          = 0x00000100,
 748:./autogen/interfaces.hpp ****             ERROR_HALL_NOT_CALIBRATED_YET    = 0x00000200,
 749:./autogen/interfaces.hpp ****         };
 750:./autogen/interfaces.hpp ****         enum Mode {
 751:./autogen/interfaces.hpp ****             MODE_INCREMENTAL                 = 0,
 752:./autogen/interfaces.hpp ****             MODE_HALL                        = 1,
 753:./autogen/interfaces.hpp ****             MODE_SINCOS                      = 2,
 754:./autogen/interfaces.hpp ****             MODE_SPI_ABS_CUI                 = 256,
 755:./autogen/interfaces.hpp ****             MODE_SPI_ABS_AMS                 = 257,
 756:./autogen/interfaces.hpp ****             MODE_SPI_ABS_AEAT                = 258,
 757:./autogen/interfaces.hpp ****             MODE_SPI_ABS_RLS                 = 259,
 758:./autogen/interfaces.hpp ****             MODE_SPI_ABS_MA732               = 260,
 759:./autogen/interfaces.hpp ****         };
 760:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Enc
 761:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 762:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_ready(T* obj) { return Property<const bool>{
 763:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_ready(T* obj, void* ptr) { new (ptr) Propert
 764:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_index_found(T* obj) { return Property<const boo
 765:./autogen/interfaces.hpp ****         template<typename T> static inline void get_index_found(T* obj, void* ptr) { new (ptr) Prop
 766:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_shadow_count(T* obj) { return Property<const in
 767:./autogen/interfaces.hpp ****         template<typename T> static inline void get_shadow_count(T* obj, void* ptr) { new (ptr) Pro
 768:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_count_in_cpr(T* obj) { return Property<const in
 769:./autogen/interfaces.hpp ****         template<typename T> static inline void get_count_in_cpr(T* obj, void* ptr) { new (ptr) Pro
ARM GAS  /tmp/cced9Z1Y.s 			page 15


 770:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_interpolation(T* obj) { return Property<const f
 771:./autogen/interfaces.hpp ****         template<typename T> static inline void get_interpolation(T* obj, void* ptr) { new (ptr) Pr
 772:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase(T* obj) { return Property<const float>{ob
 773:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<c
 774:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_estimate(T* obj) { return Property<const fl
 775:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_estimate(T* obj, void* ptr) { new (ptr) Pro
 776:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_estimate_counts(T* obj) { return Property<c
 777:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_estimate_counts(T* obj, void* ptr) { new (p
 778:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_circular(T* obj) { return Property<const fl
 779:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_circular(T* obj, void* ptr) { new (ptr) Pro
 780:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_cpr_counts(T* obj) { return Property<const 
 781:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_cpr_counts(T* obj, void* ptr) { new (ptr) P
 782:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_delta_pos_cpr_counts(T* obj) { return Property<
 783:./autogen/interfaces.hpp ****         template<typename T> static inline void get_delta_pos_cpr_counts(T* obj, void* ptr) { new (
 784:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_hall_state(T* obj) { return Property<const uint
 785:./autogen/interfaces.hpp ****         template<typename T> static inline void get_hall_state(T* obj, void* ptr) { new (ptr) Prope
 786:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate(T* obj) { return Property<const fl
 787:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate(T* obj, void* ptr) { new (ptr) Pro
 788:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate_counts(T* obj) { return Property<c
 789:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate_counts(T* obj, void* ptr) { new (p
 790:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_calib_scan_response(T* obj) { return Property<c
 791:./autogen/interfaces.hpp ****         template<typename T> static inline void get_calib_scan_response(T* obj, void* ptr) { new (p
 792:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_abs(T* obj) { return Property<int32_t>{&obj
 793:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_abs(T* obj, void* ptr) { new (ptr) Property
 794:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_spi_error_rate(T* obj) { return Property<const 
 795:./autogen/interfaces.hpp ****         template<typename T> static inline void get_spi_error_rate(T* obj, void* ptr) { new (ptr) P
 796:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 797:./autogen/interfaces.hpp ****         virtual void set_linear_count(int32_t count) = 0;
 798:./autogen/interfaces.hpp ****         int32_t set_linear_count_in_count_; // for internal use by Fibre
 799:./autogen/interfaces.hpp ****         template<typename T> static auto get_set_linear_count_in_count_(T* obj) { return Property<i
 800:./autogen/interfaces.hpp ****         template<typename T> static void get_set_linear_count_in_count_(T* obj, void* ptr) { new (p
 801:./autogen/interfaces.hpp ****     };
 802:./autogen/interfaces.hpp ****     class SensorlessEstimatorIntf {
 803:./autogen/interfaces.hpp ****     public:
 804:./autogen/interfaces.hpp ****         class ConfigIntf {
 805:./autogen/interfaces.hpp ****         public:
 806:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_observer_gain(T* obj) { return Property<flo
 807:./autogen/interfaces.hpp ****             template<typename T> static inline void get_observer_gain(T* obj, void* ptr) { new (ptr
 808:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pll_bandwidth(T* obj) { return Property<flo
 809:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pll_bandwidth(T* obj, void* ptr) { new (ptr
 810:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pm_flux_linkage(T* obj) { return Property<f
 811:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pm_flux_linkage(T* obj, void* ptr) { new (p
 812:./autogen/interfaces.hpp ****         };
 813:./autogen/interfaces.hpp ****         enum Error {
 814:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 815:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000001,
 816:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x00000002,
 817:./autogen/interfaces.hpp ****         };
 818:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Sen
 819:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 820:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase(T* obj) { return Property<const float>{ob
 821:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<c
 822:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pll_pos(T* obj) { return Property<const float>{
 823:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pll_pos(T* obj, void* ptr) { new (ptr) Property
 824:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_vel(T* obj) { return Property<const float
 825:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_vel(T* obj, void* ptr) { new (ptr) Proper
 826:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate(T* obj) { return Property<const fl
ARM GAS  /tmp/cced9Z1Y.s 			page 16


 827:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate(T* obj, void* ptr) { new (ptr) Pro
 828:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 829:./autogen/interfaces.hpp ****     };
 830:./autogen/interfaces.hpp ****     class TrapezoidalTrajectoryIntf {
 831:./autogen/interfaces.hpp ****     public:
 832:./autogen/interfaces.hpp ****         class ConfigIntf {
 833:./autogen/interfaces.hpp ****         public:
 834:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit(T* obj) { return Property<float>{
 835:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit(T* obj, void* ptr) { new (ptr) Pr
 836:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_accel_limit(T* obj) { return Property<float
 837:./autogen/interfaces.hpp ****             template<typename T> static inline void get_accel_limit(T* obj, void* ptr) { new (ptr) 
 838:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_decel_limit(T* obj) { return Property<float
 839:./autogen/interfaces.hpp ****             template<typename T> static inline void get_decel_limit(T* obj, void* ptr) { new (ptr) 
 840:./autogen/interfaces.hpp ****         };
 841:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 842:./autogen/interfaces.hpp ****     };
 843:./autogen/interfaces.hpp ****     class EndstopIntf {
 844:./autogen/interfaces.hpp ****     public:
 845:./autogen/interfaces.hpp ****         class ConfigIntf {
 846:./autogen/interfaces.hpp ****         public:
 847:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gpio_num(T* obj) { return Property<uint16_t
 848:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gpio_num(T* obj, void* ptr) { new (ptr) Pro
 849:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{obj
 850:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
 851:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_offset(T* obj) { return Property<float>{&ob
 852:./autogen/interfaces.hpp ****             template<typename T> static inline void get_offset(T* obj, void* ptr) { new (ptr) Prope
 853:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_is_active_high(T* obj) { return Property<bo
 854:./autogen/interfaces.hpp ****             template<typename T> static inline void get_is_active_high(T* obj, void* ptr) { new (pt
 855:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_debounce_ms(T* obj) { return Property<uint3
 856:./autogen/interfaces.hpp ****             template<typename T> static inline void get_debounce_ms(T* obj, void* ptr) { new (ptr) 
 857:./autogen/interfaces.hpp ****         };
 858:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_endstop_state(T* obj) { return Property<const b
 859:./autogen/interfaces.hpp ****         template<typename T> static inline void get_endstop_state(T* obj, void* ptr) { new (ptr) Pr
 860:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 861:./autogen/interfaces.hpp ****     };
 862:./autogen/interfaces.hpp ****     class MechanicalBrakeIntf {
 863:./autogen/interfaces.hpp ****     public:
 864:./autogen/interfaces.hpp ****         class ConfigIntf {
 865:./autogen/interfaces.hpp ****         public:
 866:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gpio_num(T* obj) { return Property<uint16_t
 867:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gpio_num(T* obj, void* ptr) { new (ptr) Pro
 868:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_is_active_low(T* obj) { return Property<boo
 869:./autogen/interfaces.hpp ****             template<typename T> static inline void get_is_active_low(T* obj, void* ptr) { new (ptr
 870:./autogen/interfaces.hpp ****         };
 871:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 872:./autogen/interfaces.hpp ****         virtual void engage() = 0;
 873:./autogen/interfaces.hpp ****         virtual void release() = 0;
 874:./autogen/interfaces.hpp ****     };
 875:./autogen/interfaces.hpp ****     class TaskTimerIntf {
 876:./autogen/interfaces.hpp ****     public:
 877:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_start_time(T* obj) { return Property<const uint
 878:./autogen/interfaces.hpp ****         template<typename T> static inline void get_start_time(T* obj, void* ptr) { new (ptr) Prope
 879:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_end_time(T* obj) { return Property<const uint32
 880:./autogen/interfaces.hpp ****         template<typename T> static inline void get_end_time(T* obj, void* ptr) { new (ptr) Propert
 881:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_length(T* obj) { return Property<const uint32_t
 882:./autogen/interfaces.hpp ****         template<typename T> static inline void get_length(T* obj, void* ptr) { new (ptr) Property<
 883:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_length(T* obj) { return Property<uint32_t>{
ARM GAS  /tmp/cced9Z1Y.s 			page 17


 884:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_length(T* obj, void* ptr) { new (ptr) Prope
 885:./autogen/interfaces.hpp ****     };
 886:./autogen/interfaces.hpp ****     class TaskTimesIntf {
 887:./autogen/interfaces.hpp ****     public:
 888:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_sampling(T* obj) { return &obj->sampling; }
 889:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_control_loop_misc(T* obj) { return &obj->contro
 890:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_control_loop_checks(T* obj) { return &obj->cont
 891:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_calib_wait(T* obj) { return &obj->dc_calib_w
 892:./autogen/interfaces.hpp ****     };
 893:./autogen/interfaces.hpp ****     class SystemStatsIntf {
 894:./autogen/interfaces.hpp ****     public:
 895:./autogen/interfaces.hpp ****         class UsbIntf {
 896:./autogen/interfaces.hpp ****         public:
 897:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_rx_cnt(T* obj) { return Property<const uint
 898:./autogen/interfaces.hpp ****             template<typename T> static inline void get_rx_cnt(T* obj, void* ptr) { new (ptr) Prope
 899:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_tx_cnt(T* obj) { return Property<const uint
 900:./autogen/interfaces.hpp ****             template<typename T> static inline void get_tx_cnt(T* obj, void* ptr) { new (ptr) Prope
 901:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_tx_overrun_cnt(T* obj) { return Property<co
 902:./autogen/interfaces.hpp ****             template<typename T> static inline void get_tx_overrun_cnt(T* obj, void* ptr) { new (pt
 903:./autogen/interfaces.hpp ****         };
 904:./autogen/interfaces.hpp ****         class I2CIntf {
 905:./autogen/interfaces.hpp ****         public:
 906:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_addr(T* obj) { return Property<const uint8_
 907:./autogen/interfaces.hpp ****             template<typename T> static inline void get_addr(T* obj, void* ptr) { new (ptr) Propert
 908:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_addr_match_cnt(T* obj) { return Property<co
 909:./autogen/interfaces.hpp ****             template<typename T> static inline void get_addr_match_cnt(T* obj, void* ptr) { new (pt
 910:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_rx_cnt(T* obj) { return Property<const uint
 911:./autogen/interfaces.hpp ****             template<typename T> static inline void get_rx_cnt(T* obj, void* ptr) { new (ptr) Prope
 912:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_error_cnt(T* obj) { return Property<const u
 913:./autogen/interfaces.hpp ****             template<typename T> static inline void get_error_cnt(T* obj, void* ptr) { new (ptr) Pr
 914:./autogen/interfaces.hpp ****         };
 915:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uptime(T* obj) { return Property<const uint32_t
 916:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uptime(T* obj, void* ptr) { new (ptr) Property<
 917:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_min_heap_space(T* obj) { return Property<const 
 918:./autogen/interfaces.hpp ****         template<typename T> static inline void get_min_heap_space(T* obj, void* ptr) { new (ptr) P
 919:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_axis(T* obj) { return Property<
 920:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_axis(T* obj, void* ptr) { new (
 921:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_usb(T* obj) { return Property<c
 922:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_usb(T* obj, void* ptr) { new (p
 923:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_uart(T* obj) { return Property<
 924:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_uart(T* obj, void* ptr) { new (
 925:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_can(T* obj) { return Property<c
 926:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_can(T* obj, void* ptr) { new (p
 927:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_startup(T* obj) { return Proper
 928:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_startup(T* obj, void* ptr) { ne
 929:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_analog(T* obj) { return Propert
 930:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_analog(T* obj, void* ptr) { new
 931:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_axis(T* obj) { return Property<const
 932:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_axis(T* obj, void* ptr) { new (ptr) 
 933:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_usb(T* obj) { return Property<const 
 934:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_usb(T* obj, void* ptr) { new (ptr) P
 935:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_uart(T* obj) { return Property<const
 936:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_uart(T* obj, void* ptr) { new (ptr) 
 937:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_startup(T* obj) { return Property<co
 938:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_startup(T* obj, void* ptr) { new (pt
 939:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_can(T* obj) { return Property<const 
 940:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_can(T* obj, void* ptr) { new (ptr) P
ARM GAS  /tmp/cced9Z1Y.s 			page 18


 941:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_analog(T* obj) { return Property<con
 942:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_analog(T* obj, void* ptr) { new (ptr
 943:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_axis(T* obj) { return Property<const int32
 944:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_axis(T* obj, void* ptr) { new (ptr) Proper
 945:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_usb(T* obj) { return Property<const int32_
 946:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_usb(T* obj, void* ptr) { new (ptr) Propert
 947:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_uart(T* obj) { return Property<const int32
 948:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_uart(T* obj, void* ptr) { new (ptr) Proper
 949:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_startup(T* obj) { return Property<const in
 950:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_startup(T* obj, void* ptr) { new (ptr) Pro
 951:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_can(T* obj) { return Property<const int32_
 952:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_can(T* obj, void* ptr) { new (ptr) Propert
 953:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_analog(T* obj) { return Property<const int
 954:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_analog(T* obj, void* ptr) { new (ptr) Prop
 955:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_usb(T* obj) { return &obj->usb; }
 956:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_i2c(T* obj) { return &obj->i2c; }
 957:./autogen/interfaces.hpp ****     };
 958:./autogen/interfaces.hpp ****     enum Error {
 959:./autogen/interfaces.hpp ****         ERROR_NONE                       = 0x00000000,
 960:./autogen/interfaces.hpp ****         ERROR_CONTROL_ITERATION_MISSED   = 0x00000001,
 961:./autogen/interfaces.hpp ****         ERROR_DC_BUS_UNDER_VOLTAGE       = 0x00000002,
 962:./autogen/interfaces.hpp ****         ERROR_DC_BUS_OVER_VOLTAGE        = 0x00000004,
 963:./autogen/interfaces.hpp ****         ERROR_DC_BUS_OVER_REGEN_CURRENT  = 0x00000008,
 964:./autogen/interfaces.hpp ****         ERROR_DC_BUS_OVER_CURRENT        = 0x00000010,
 965:./autogen/interfaces.hpp ****         ERROR_BRAKE_DEADTIME_VIOLATION   = 0x00000020,
 966:./autogen/interfaces.hpp ****         ERROR_BRAKE_DUTY_CYCLE_NAN       = 0x00000040,
 967:./autogen/interfaces.hpp ****         ERROR_INVALID_BRAKE_RESISTANCE   = 0x00000080,
 968:./autogen/interfaces.hpp ****     };
 969:./autogen/interfaces.hpp ****     enum GpioMode {
 970:./autogen/interfaces.hpp ****         GPIO_MODE_DIGITAL                = 0,
 971:./autogen/interfaces.hpp ****         GPIO_MODE_DIGITAL_PULL_UP        = 1,
 972:./autogen/interfaces.hpp ****         GPIO_MODE_DIGITAL_PULL_DOWN      = 2,
 973:./autogen/interfaces.hpp ****         GPIO_MODE_ANALOG_IN              = 3,
 974:./autogen/interfaces.hpp ****         GPIO_MODE_UART_A                 = 4,
 975:./autogen/interfaces.hpp ****         GPIO_MODE_UART_B                 = 5,
 976:./autogen/interfaces.hpp ****         GPIO_MODE_UART_C                 = 6,
 977:./autogen/interfaces.hpp ****         GPIO_MODE_CAN_A                  = 7,
 978:./autogen/interfaces.hpp ****         GPIO_MODE_I2C_A                  = 8,
 979:./autogen/interfaces.hpp ****         GPIO_MODE_SPI_A                  = 9,
 980:./autogen/interfaces.hpp ****         GPIO_MODE_PWM                    = 10,
 981:./autogen/interfaces.hpp ****         GPIO_MODE_ENC0                   = 11,
 982:./autogen/interfaces.hpp ****         GPIO_MODE_ENC1                   = 12,
 983:./autogen/interfaces.hpp ****         GPIO_MODE_ENC2                   = 13,
 984:./autogen/interfaces.hpp ****         GPIO_MODE_MECH_BRAKE             = 14,
 985:./autogen/interfaces.hpp ****         GPIO_MODE_STATUS                 = 15,
 986:./autogen/interfaces.hpp ****     };
 987:./autogen/interfaces.hpp ****     enum StreamProtocolType {
 988:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_FIBRE       = 0,
 989:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_ASCII       = 1,
 990:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_STDOUT      = 2,
 991:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_ASCII_AND_STDOUT = 3,
 992:./autogen/interfaces.hpp ****     };
 993:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Error>{
 994:./autogen/interfaces.hpp ****     template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriv
 995:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_vbus_voltage(T* obj) { return Property<const float>
 996:./autogen/interfaces.hpp ****     template<typename T> static inline void get_vbus_voltage(T* obj, void* ptr) { new (ptr) Propert
 997:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_ibus(T* obj) { return Property<const float>{&obj->i
ARM GAS  /tmp/cced9Z1Y.s 			page 19


 998:./autogen/interfaces.hpp ****     template<typename T> static inline void get_ibus(T* obj, void* ptr) { new (ptr) Property<const 
 999:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_ibus_report_filter_k(T* obj) { return Property<floa
1000:./autogen/interfaces.hpp ****     template<typename T> static inline void get_ibus_report_filter_k(T* obj, void* ptr) { new (ptr)
1001:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_serial_number(T* obj) { return Property<const uint6
1002:./autogen/interfaces.hpp ****     template<typename T> static inline void get_serial_number(T* obj, void* ptr) { new (ptr) Proper
1003:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_hw_version_major(T* obj) { return Property<const ui
1004:./autogen/interfaces.hpp ****     template<typename T> static inline void get_hw_version_major(T* obj, void* ptr) { new (ptr) Pro
1005:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_hw_version_minor(T* obj) { return Property<const ui
1006:./autogen/interfaces.hpp ****     template<typename T> static inline void get_hw_version_minor(T* obj, void* ptr) { new (ptr) Pro
1007:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_hw_version_variant(T* obj) { return Property<const 
1008:./autogen/interfaces.hpp ****     template<typename T> static inline void get_hw_version_variant(T* obj, void* ptr) { new (ptr) P
1009:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_major(T* obj) { return Property<const ui
1010:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_major(T* obj, void* ptr) { new (ptr) Pro
1011:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_minor(T* obj) { return Property<const ui
1012:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_minor(T* obj, void* ptr) { new (ptr) Pro
1013:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_revision(T* obj) { return Property<const
1014:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_revision(T* obj, void* ptr) { new (ptr) 
1015:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_unreleased(T* obj) { return Property<con
1016:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_unreleased(T* obj, void* ptr) { new (ptr
1017:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_brake_resistor_armed(T* obj) { return Property<cons
1018:./autogen/interfaces.hpp ****     template<typename T> static inline void get_brake_resistor_armed(T* obj, void* ptr) { new (ptr)
1019:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_brake_resistor_saturated(T* obj) { return Property<
1020:./autogen/interfaces.hpp ****     template<typename T> static inline void get_brake_resistor_saturated(T* obj, void* ptr) { new (
1021:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_brake_resistor_current(T* obj) { return Property<co
1022:./autogen/interfaces.hpp ****     template<typename T> static inline void get_brake_resistor_current(T* obj, void* ptr) { new (pt
1023:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_n_evt_sampling(T* obj) { return Property<const uint
1024:./autogen/interfaces.hpp ****     template<typename T> static inline void get_n_evt_sampling(T* obj, void* ptr) { new (ptr) Prope
1025:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_n_evt_control_loop(T* obj) { return Property<const 
1026:./autogen/interfaces.hpp ****     template<typename T> static inline void get_n_evt_control_loop(T* obj, void* ptr) { new (ptr) P
1027:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_task_timers_armed(T* obj) { return Property<bool>{&
1028:./autogen/interfaces.hpp ****     template<typename T> static inline void get_task_timers_armed(T* obj, void* ptr) { new (ptr) Pr
1029:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_task_times(T* obj) { return &obj->task_times_; }
1030:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_system_stats(T* obj) { return &obj->system_stats_; 
1031:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_user_config_loaded(T* obj) { return Property<const 
1032:./autogen/interfaces.hpp ****     template<typename T> static inline void get_user_config_loaded(T* obj, void* ptr) { new (ptr) P
1033:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_misconfigured(T* obj) { return Property<const bool>
1034:./autogen/interfaces.hpp ****     template<typename T> static inline void get_misconfigured(T* obj, void* ptr) { new (ptr) Proper
1035:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_oscilloscope(T* obj) { return &obj->oscilloscope_; 
1036:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_can(T* obj) { return &obj->can_; }
1037:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_test_property(T* obj) { return Property<uint32_t>{&
1038:./autogen/interfaces.hpp ****     template<typename T> static inline void get_test_property(T* obj, void* ptr) { new (ptr) Proper
1039:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_otp_valid(T* obj) { return Property<const bool>{&ob
1040:./autogen/interfaces.hpp ****     template<typename T> static inline void get_otp_valid(T* obj, void* ptr) { new (ptr) Property<c
1041:./autogen/interfaces.hpp ****     virtual int32_t test_function(int32_t delta) = 0;
1042:./autogen/interfaces.hpp ****     virtual float get_adc_voltage(uint32_t gpio) = 0;
1043:./autogen/interfaces.hpp ****     virtual bool save_configuration() = 0;
1044:./autogen/interfaces.hpp ****     virtual void erase_configuration() = 0;
1045:./autogen/interfaces.hpp ****     virtual void reboot() = 0;
1046:./autogen/interfaces.hpp ****     virtual void enter_dfu_mode() = 0;
1047:./autogen/interfaces.hpp ****     virtual uint32_t get_interrupt_status(int32_t irqn) = 0;
1048:./autogen/interfaces.hpp ****     virtual uint32_t get_dma_status(uint8_t stream_num) = 0;
1049:./autogen/interfaces.hpp ****     virtual uint32_t get_gpio_states() = 0;
1050:./autogen/interfaces.hpp ****     virtual uint64_t get_drv_fault() = 0;
1051:./autogen/interfaces.hpp ****     virtual void clear_errors() = 0;
1052:./autogen/interfaces.hpp ****     int32_t test_function_in_delta_; // for internal use by Fibre
1053:./autogen/interfaces.hpp ****     template<typename T> static auto get_test_function_in_delta_(T* obj) { return Property<int32_t>
1054:./autogen/interfaces.hpp ****     template<typename T> static void get_test_function_in_delta_(T* obj, void* ptr) { new (ptr) Pro
ARM GAS  /tmp/cced9Z1Y.s 			page 20


1055:./autogen/interfaces.hpp ****     int32_t test_function_out_cnt_; // for internal use by Fibre
1056:./autogen/interfaces.hpp ****     template<typename T> static auto get_test_function_out_cnt_(T* obj) { return Property<const int
1057:./autogen/interfaces.hpp ****     template<typename T> static void get_test_function_out_cnt_(T* obj, void* ptr) { new (ptr) Prop
1058:./autogen/interfaces.hpp ****     uint32_t get_adc_voltage_in_gpio_; // for internal use by Fibre
1059:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_adc_voltage_in_gpio_(T* obj) { return Property<uint32_
1060:./autogen/interfaces.hpp ****     template<typename T> static void get_get_adc_voltage_in_gpio_(T* obj, void* ptr) { new (ptr) Pr
1061:./autogen/interfaces.hpp ****     float get_adc_voltage_out_voltage_; // for internal use by Fibre
1062:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_adc_voltage_out_voltage_(T* obj) { return Property<con
1063:./autogen/interfaces.hpp ****     template<typename T> static void get_get_adc_voltage_out_voltage_(T* obj, void* ptr) { new (ptr
1064:./autogen/interfaces.hpp ****     bool save_configuration_out_success_; // for internal use by Fibre
1065:./autogen/interfaces.hpp ****     template<typename T> static auto get_save_configuration_out_success_(T* obj) { return Property<
1066:./autogen/interfaces.hpp ****     template<typename T> static void get_save_configuration_out_success_(T* obj, void* ptr) { new (
1067:./autogen/interfaces.hpp ****     int32_t get_interrupt_status_in_irqn_; // for internal use by Fibre
1068:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_interrupt_status_in_irqn_(T* obj) { return Property<in
1069:./autogen/interfaces.hpp ****     template<typename T> static void get_get_interrupt_status_in_irqn_(T* obj, void* ptr) { new (pt
1070:./autogen/interfaces.hpp ****     uint32_t get_interrupt_status_out_status_; // for internal use by Fibre
1071:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_interrupt_status_out_status_(T* obj) { return Property
1072:./autogen/interfaces.hpp ****     template<typename T> static void get_get_interrupt_status_out_status_(T* obj, void* ptr) { new 
1073:./autogen/interfaces.hpp ****     uint8_t get_dma_status_in_stream_num_; // for internal use by Fibre
1074:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_dma_status_in_stream_num_(T* obj) { return Property<ui
1075:./autogen/interfaces.hpp ****     template<typename T> static void get_get_dma_status_in_stream_num_(T* obj, void* ptr) { new (pt
1076:./autogen/interfaces.hpp ****     uint32_t get_dma_status_out_status_; // for internal use by Fibre
1077:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_dma_status_out_status_(T* obj) { return Property<const
1078:./autogen/interfaces.hpp ****     template<typename T> static void get_get_dma_status_out_status_(T* obj, void* ptr) { new (ptr) 
1079:./autogen/interfaces.hpp ****     uint32_t get_gpio_states_out_status_; // for internal use by Fibre
1080:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_gpio_states_out_status_(T* obj) { return Property<cons
1081:./autogen/interfaces.hpp ****     template<typename T> static void get_get_gpio_states_out_status_(T* obj, void* ptr) { new (ptr)
1082:./autogen/interfaces.hpp ****     uint64_t get_drv_fault_out_drv_fault_; // for internal use by Fibre
1083:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_drv_fault_out_drv_fault_(T* obj) { return Property<con
1084:./autogen/interfaces.hpp ****     template<typename T> static void get_get_drv_fault_out_drv_fault_(T* obj, void* ptr) { new (ptr
1085:./autogen/interfaces.hpp **** };
1086:./autogen/interfaces.hpp **** 
1087:./autogen/interfaces.hpp **** 
1088:./autogen/interfaces.hpp **** class ODrive3Intf : public ODriveIntf {
1089:./autogen/interfaces.hpp **** public:
1090:./autogen/interfaces.hpp ****     class ConfigIntf : public ODriveIntf::ConfigIntf {
1091:./autogen/interfaces.hpp ****     public:
1092:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio1_mode(T* obj) { return Property<ODriveIntf
1093:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio1_mode(T* obj, void* ptr) { new (ptr) Prope
1094:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio2_mode(T* obj) { return Property<ODriveIntf
1095:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio2_mode(T* obj, void* ptr) { new (ptr) Prope
1096:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio3_mode(T* obj) { return Property<ODriveIntf
1097:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio3_mode(T* obj, void* ptr) { new (ptr) Prope
1098:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio4_mode(T* obj) { return Property<ODriveIntf
1099:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio4_mode(T* obj, void* ptr) { new (ptr) Prope
1100:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio5_mode(T* obj) { return Property<ODriveIntf
1101:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio5_mode(T* obj, void* ptr) { new (ptr) Prope
1102:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio6_mode(T* obj) { return Property<ODriveIntf
1103:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio6_mode(T* obj, void* ptr) { new (ptr) Prope
1104:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio7_mode(T* obj) { return Property<ODriveIntf
1105:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio7_mode(T* obj, void* ptr) { new (ptr) Prope
1106:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio8_mode(T* obj) { return Property<ODriveIntf
1107:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio8_mode(T* obj, void* ptr) { new (ptr) Prope
1108:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio9_mode(T* obj) { return Property<ODriveIntf
1109:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio9_mode(T* obj, void* ptr) { new (ptr) Prope
1110:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio10_mode(T* obj) { return Property<ODriveInt
1111:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio10_mode(T* obj, void* ptr) { new (ptr) Prop
ARM GAS  /tmp/cced9Z1Y.s 			page 21


1112:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio11_mode(T* obj) { return Property<ODriveInt
1113:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio11_mode(T* obj, void* ptr) { new (ptr) Prop
1114:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio12_mode(T* obj) { return Property<ODriveInt
1115:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio12_mode(T* obj, void* ptr) { new (ptr) Prop
1116:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio13_mode(T* obj) { return Property<ODriveInt
1117:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio13_mode(T* obj, void* ptr) { new (ptr) Prop
1118:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio14_mode(T* obj) { return Property<ODriveInt
1119:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio14_mode(T* obj, void* ptr) { new (ptr) Prop
1120:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio15_mode(T* obj) { return Property<ODriveInt
1121:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio15_mode(T* obj, void* ptr) { new (ptr) Prop
1122:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio16_mode(T* obj) { return Property<ODriveInt
1123:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio16_mode(T* obj, void* ptr) { new (ptr) Prop
1124:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio1_pwm_mapping(T* obj) { return &obj->pwm_ma
1125:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio2_pwm_mapping(T* obj) { return &obj->pwm_ma
1126:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio3_pwm_mapping(T* obj) { return &obj->pwm_ma
1127:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio4_pwm_mapping(T* obj) { return &obj->pwm_ma
1128:./autogen/interfaces.hpp ****     };
1129:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
1130:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_axis0(T* obj) { return &obj->get_axis(0); }
1131:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_axis1(T* obj) { return &obj->get_axis(1); }
1132:./autogen/interfaces.hpp **** };
1133:./autogen/interfaces.hpp **** 
1134:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1135:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator | (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIn
1136:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator & (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIn
1137:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator ^ (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIn
1138:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol& operator |= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::Ca
1139:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol& operator &= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::Ca
1140:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol& operator ^= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::Ca
1141:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator ~ (ODriveIntf::CanIntf::Protocol a) { return static_c
1142:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1143:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator | (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast
1144:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator & (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast
1145:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator ^ (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast
1146:./autogen/interfaces.hpp **** inline ODriveIntf::Error& operator |= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterp
1147:./autogen/interfaces.hpp **** inline ODriveIntf::Error& operator &= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterp
1148:./autogen/interfaces.hpp **** inline ODriveIntf::Error& operator ^= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterp
1149:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator ~ (ODriveIntf::Error a) { return static_cast<ODriveIntf::Error>(~
1150:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1151:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator | (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Er
1152:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator & (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Er
1153:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator ^ (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Er
1154:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error& operator |= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf:
1155:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error& operator &= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf:
1156:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error& operator ^= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf:
1157:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator ~ (ODriveIntf::CanIntf::Error a) { return static_cast<OD
1158:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1159:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator | (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf:
1160:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator & (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf:
1161:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator ^ (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf:
1162:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error& operator |= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIn
  31              		.loc 1 1162 113 view -0
  32              		.cfi_startproc
  33              		@ args = 0, pretend = 0, frame = 0
  34              		@ frame_needed = 0, uses_anonymous_args = 0
  35              		@ link register save eliminated.
  36              		.loc 1 1162 115 view .LVU1
ARM GAS  /tmp/cced9Z1Y.s 			page 22


  37              		.loc 1 1162 243 is_stmt 0 view .LVU2
  38 0000 0268     		ldr	r2, [r0]
  39 0002 1143     		orrs	r1, r1, r2
  40              	.LVL1:
  41              		.loc 1 1162 243 view .LVU3
  42 0004 0160     		str	r1, [r0]
  43              		.loc 1 1162 316 view .LVU4
  44 0006 7047     		bx	lr
  45              		.cfi_endproc
  46              	.LFE4170:
  47              		.cantunwind
  48              		.fnend
  50              		.section	.text._ZoRRN10ODriveIntf23SensorlessEstimatorIntf5ErrorES1_,"axG",%progbits,_ZoRRN10ODriv
  51              		.align	1
  52              		.weak	_ZoRRN10ODriveIntf23SensorlessEstimatorIntf5ErrorES1_
  53              		.syntax unified
  54              		.thumb
  55              		.thumb_func
  57              	_ZoRRN10ODriveIntf23SensorlessEstimatorIntf5ErrorES1_:
  58              		.fnstart
  59              	.LVL2:
  60              	.LFB4198:
1163:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error& operator &= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIn
1164:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error& operator ^= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIn
1165:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator ~ (ODriveIntf::AxisIntf::Error a) { return static_cast<
1166:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1167:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error operator | (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIn
1168:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error operator & (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIn
1169:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error operator ^ (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIn
1170:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error& operator |= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::Moto
1171:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error& operator &= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::Moto
1172:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error& operator ^= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::Moto
1173:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error operator ~ (ODriveIntf::MotorIntf::Error a) { return static_cas
1174:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1175:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error operator | (ODriveIntf::ControllerIntf::Error a, ODriveInt
1176:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error operator & (ODriveIntf::ControllerIntf::Error a, ODriveInt
1177:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error operator ^ (ODriveIntf::ControllerIntf::Error a, ODriveInt
1178:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error& operator |= (ODriveIntf::ControllerIntf::Error &a, ODrive
1179:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error& operator &= (ODriveIntf::ControllerIntf::Error &a, ODrive
1180:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error& operator ^= (ODriveIntf::ControllerIntf::Error &a, ODrive
1181:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error operator ~ (ODriveIntf::ControllerIntf::Error a) { return 
1182:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1183:./autogen/interfaces.hpp **** inline ODriveIntf::EncoderIntf::Error operator | (ODriveIntf::EncoderIntf::Error a, ODriveIntf::Enc
1184:./autogen/interfaces.hpp **** inline ODriveIntf::EncoderIntf::Error operator & (ODriveIntf::EncoderIntf::Error a, ODriveIntf::Enc
1185:./autogen/interfaces.hpp **** inline ODriveIntf::EncoderIntf::Error operator ^ (ODriveIntf::EncoderIntf::Error a, ODriveIntf::Enc
1186:./autogen/interfaces.hpp **** inline ODriveIntf::EncoderIntf::Error& operator |= (ODriveIntf::EncoderIntf::Error &a, ODriveIntf::
1187:./autogen/interfaces.hpp **** inline ODriveIntf::EncoderIntf::Error& operator &= (ODriveIntf::EncoderIntf::Error &a, ODriveIntf::
1188:./autogen/interfaces.hpp **** inline ODriveIntf::EncoderIntf::Error& operator ^= (ODriveIntf::EncoderIntf::Error &a, ODriveIntf::
1189:./autogen/interfaces.hpp **** inline ODriveIntf::EncoderIntf::Error operator ~ (ODriveIntf::EncoderIntf::Error a) { return static
1190:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1191:./autogen/interfaces.hpp **** inline ODriveIntf::SensorlessEstimatorIntf::Error operator | (ODriveIntf::SensorlessEstimatorIntf::
1192:./autogen/interfaces.hpp **** inline ODriveIntf::SensorlessEstimatorIntf::Error operator & (ODriveIntf::SensorlessEstimatorIntf::
1193:./autogen/interfaces.hpp **** inline ODriveIntf::SensorlessEstimatorIntf::Error operator ^ (ODriveIntf::SensorlessEstimatorIntf::
1194:./autogen/interfaces.hpp **** inline ODriveIntf::SensorlessEstimatorIntf::Error& operator |= (ODriveIntf::SensorlessEstimatorIntf
  61              		.loc 1 1194 158 is_stmt 1 view -0
  62              		.cfi_startproc
  63              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/cced9Z1Y.s 			page 23


  64              		@ frame_needed = 0, uses_anonymous_args = 0
  65              		@ link register save eliminated.
  66              		.loc 1 1194 160 view .LVU6
  67              		.loc 1 1194 318 is_stmt 0 view .LVU7
  68 0000 0278     		ldrb	r2, [r0]	@ zero_extendqisi2
  69 0002 1143     		orrs	r1, r1, r2
  70              	.LVL3:
  71              		.loc 1 1194 318 view .LVU8
  72 0004 0170     		strb	r1, [r0]
  73              		.loc 1 1194 406 view .LVU9
  74 0006 7047     		bx	lr
  75              		.cfi_endproc
  76              	.LFE4198:
  77              		.cantunwind
  78              		.fnend
  80              		.section	.text._ZN19SensorlessEstimator5resetEv,"ax",%progbits
  81              		.align	1
  82              		.global	_ZN19SensorlessEstimator5resetEv
  83              		.syntax unified
  84              		.thumb
  85              		.thumb_func
  87              	_ZN19SensorlessEstimator5resetEv:
  88              		.fnstart
  89              	.LVL4:
  90              	.LFB5158:
  91              		.file 2 "MotorControl/sensorless_estimator.cpp"
   1:MotorControl/sensorless_estimator.cpp **** 
   2:MotorControl/sensorless_estimator.cpp **** #include "odrive_main.h"
   3:MotorControl/sensorless_estimator.cpp **** 
   4:MotorControl/sensorless_estimator.cpp **** void SensorlessEstimator::reset() {
  92              		.loc 2 4 35 is_stmt 1 view -0
  93              		.cfi_startproc
  94              		@ args = 0, pretend = 0, frame = 0
  95              		@ frame_needed = 0, uses_anonymous_args = 0
  96              		@ link register save eliminated.
   5:MotorControl/sensorless_estimator.cpp ****     pll_pos_ = 0.0f;
  97              		.loc 2 5 5 view .LVU11
  98              		.loc 2 5 14 is_stmt 0 view .LVU12
  99 0000 0023     		movs	r3, #0
 100 0002 4361     		str	r3, [r0, #20]	@ float
   6:MotorControl/sensorless_estimator.cpp ****     vel_estimate_ = 0.0f;
 101              		.loc 2 6 5 is_stmt 1 view .LVU13
 102              	.LVL5:
 103              	.LBB186:
 104              	.LBI186:
 105              		.file 3 "./MotorControl/component.hpp"
   1:./MotorControl/component.hpp **** #ifndef __COMPONENT_HPP
   2:./MotorControl/component.hpp **** #define __COMPONENT_HPP
   3:./MotorControl/component.hpp **** 
   4:./MotorControl/component.hpp **** #include <stdint.h>
   5:./MotorControl/component.hpp **** #include <optional>
   6:./MotorControl/component.hpp **** #include <variant>
   7:./MotorControl/component.hpp **** 
   8:./MotorControl/component.hpp **** class ComponentBase {
   9:./MotorControl/component.hpp **** public:
  10:./MotorControl/component.hpp ****     /**
  11:./MotorControl/component.hpp ****      * @brief Shall run the update action of this component.
ARM GAS  /tmp/cced9Z1Y.s 			page 24


  12:./MotorControl/component.hpp ****      * 
  13:./MotorControl/component.hpp ****      * This function gets called in a low priority interrupt context and is
  14:./MotorControl/component.hpp ****      * allowed to call CMSIS functions.
  15:./MotorControl/component.hpp ****      * 
  16:./MotorControl/component.hpp ****      * @param timestamp: The timestamp (in HCLK ticks) for which this update
  17:./MotorControl/component.hpp ****      * is run.
  18:./MotorControl/component.hpp ****      */
  19:./MotorControl/component.hpp ****     virtual void update(uint32_t timestamp) = 0;
  20:./MotorControl/component.hpp **** };
  21:./MotorControl/component.hpp **** 
  22:./MotorControl/component.hpp **** 
  23:./MotorControl/component.hpp **** template<typename T>
  24:./MotorControl/component.hpp **** class InputPort;
  25:./MotorControl/component.hpp **** 
  26:./MotorControl/component.hpp **** /**
  27:./MotorControl/component.hpp ****  * @brief An output port stores a value for consumption by a connecting input
  28:./MotorControl/component.hpp ****  * port.
  29:./MotorControl/component.hpp ****  * 
  30:./MotorControl/component.hpp ****  * Output ports are supposed to be reset at the beginning of a control loop
  31:./MotorControl/component.hpp ****  * iteration. This ensures that connecting input ports don't use an outdated
  32:./MotorControl/component.hpp ****  * value and, more importantly, ensures proper handling if the producer of the
  33:./MotorControl/component.hpp ****  * value is incapable of producing the value for any reason.
  34:./MotorControl/component.hpp ****  * 
  35:./MotorControl/component.hpp ****  * Member functions of this class are not thread-safe unless noted otherwise.
  36:./MotorControl/component.hpp ****  */
  37:./MotorControl/component.hpp **** template<typename T>
  38:./MotorControl/component.hpp **** class OutputPort {
  39:./MotorControl/component.hpp **** public:
  40:./MotorControl/component.hpp ****     /**
  41:./MotorControl/component.hpp ****      * @brief Initializes the output port with the specified value.
  42:./MotorControl/component.hpp ****      * 
  43:./MotorControl/component.hpp ****      * An initialization value is required for any() to work properly.
  44:./MotorControl/component.hpp ****      * present() and previous() cannot be used to fetch the
  45:./MotorControl/component.hpp ****      * initialization value.
  46:./MotorControl/component.hpp ****      */
  47:./MotorControl/component.hpp ****     OutputPort(T val) : content_(val) {}
  48:./MotorControl/component.hpp ****     
  49:./MotorControl/component.hpp ****     /**
  50:./MotorControl/component.hpp ****      * @brief Updates the underlying value of this output port.
  51:./MotorControl/component.hpp ****      */
  52:./MotorControl/component.hpp ****     void operator=(T value) {
 106              		.loc 3 52 10 view .LVU14
 107              	.LBB187:
  53:./MotorControl/component.hpp ****         content_ = value;
 108              		.loc 3 53 18 is_stmt 0 view .LVU15
 109 0004 C363     		str	r3, [r0, #60]	@ float
  54:./MotorControl/component.hpp ****         age_ = 0;
 110              		.loc 3 54 14 view .LVU16
 111 0006 0022     		movs	r2, #0
 112 0008 8263     		str	r2, [r0, #56]
 113              	.LVL6:
 114              		.loc 3 54 14 view .LVU17
 115              	.LBE187:
 116              	.LBE186:
   7:MotorControl/sensorless_estimator.cpp ****     V_alpha_beta_memory_[0] = 0.0f;
 117              		.loc 2 7 5 is_stmt 1 view .LVU18
 118              		.loc 2 7 29 is_stmt 0 view .LVU19
ARM GAS  /tmp/cced9Z1Y.s 			page 25


 119 000a 0362     		str	r3, [r0, #32]	@ float
   8:MotorControl/sensorless_estimator.cpp ****     V_alpha_beta_memory_[1] = 0.0f;
 120              		.loc 2 8 5 is_stmt 1 view .LVU20
 121              		.loc 2 8 29 is_stmt 0 view .LVU21
 122 000c 4362     		str	r3, [r0, #36]	@ float
   9:MotorControl/sensorless_estimator.cpp ****     flux_state_[0] = 0.0f;
 123              		.loc 2 9 5 is_stmt 1 view .LVU22
 124              		.loc 2 9 20 is_stmt 0 view .LVU23
 125 000e 8361     		str	r3, [r0, #24]	@ float
  10:MotorControl/sensorless_estimator.cpp ****     flux_state_[1] = 0.0f;
 126              		.loc 2 10 5 is_stmt 1 view .LVU24
 127              		.loc 2 10 20 is_stmt 0 view .LVU25
 128 0010 C361     		str	r3, [r0, #28]	@ float
  11:MotorControl/sensorless_estimator.cpp **** }
 129              		.loc 2 11 1 view .LVU26
 130 0012 7047     		bx	lr
 131              		.cfi_endproc
 132              	.LFE5158:
 133              		.cantunwind
 134              		.fnend
 136              		.section	.text._ZN19SensorlessEstimator6updateEv,"ax",%progbits
 137              		.align	1
 138              		.global	_ZN19SensorlessEstimator6updateEv
 139              		.syntax unified
 140              		.thumb
 141              		.thumb_func
 143              	_ZN19SensorlessEstimator6updateEv:
 144              		.fnstart
 145              	.LVL7:
 146              	.LFB5159:
  12:MotorControl/sensorless_estimator.cpp **** 
  13:MotorControl/sensorless_estimator.cpp **** bool SensorlessEstimator::update() {
 147              		.loc 2 13 36 is_stmt 1 view -0
 148              		.cfi_startproc
 149              		@ args = 0, pretend = 0, frame = 64
 150              		@ frame_needed = 0, uses_anonymous_args = 0
 151              		.loc 2 13 36 is_stmt 0 view .LVU28
 152 0000 70B5     		push	{r4, r5, r6, lr}
 153              		.save {r4, r5, r6, lr}
 154              	.LCFI0:
 155              		.cfi_def_cfa_offset 16
 156              		.cfi_offset 4, -16
 157              		.cfi_offset 5, -12
 158              		.cfi_offset 6, -8
 159              		.cfi_offset 14, -4
 160 0002 2DED068B 		vpush.64	{d8, d9, d10}
 161              		.vsave {d8, d9, d10}
 162              	.LCFI1:
 163              		.cfi_def_cfa_offset 40
 164              		.cfi_offset 80, -40
 165              		.cfi_offset 81, -36
 166              		.cfi_offset 82, -32
 167              		.cfi_offset 83, -28
 168              		.cfi_offset 84, -24
 169              		.cfi_offset 85, -20
 170              		.pad #64
 171 0006 90B0     		sub	sp, sp, #64
ARM GAS  /tmp/cced9Z1Y.s 			page 26


 172              	.LCFI2:
 173              		.cfi_def_cfa_offset 104
 174 0008 0446     		mov	r4, r0
  14:MotorControl/sensorless_estimator.cpp ****     // Algorithm based on paper: Sensorless Control of Surface-Mount Permanent-Magnet Synchronous M
  15:MotorControl/sensorless_estimator.cpp ****     // http://cas.ensmp.fr/~praly/Telechargement/Journaux/2010-IEEE_TPEL-Lee-Hong-Nam-Ortega-Praly-
  16:MotorControl/sensorless_estimator.cpp ****     // In particular, equation 8 (and by extension eqn 4 and 6).
  17:MotorControl/sensorless_estimator.cpp **** 
  18:MotorControl/sensorless_estimator.cpp ****     // The V_alpha_beta applied immedietly prior to the current measurement associated with this cy
  19:MotorControl/sensorless_estimator.cpp ****     // is the one computed two cycles ago. To get the correct measurement, it was stored twice:
  20:MotorControl/sensorless_estimator.cpp ****     // once by final_v_alpha/final_v_beta in the current control reporting, and once by V_alpha_bet
  21:MotorControl/sensorless_estimator.cpp **** 
  22:MotorControl/sensorless_estimator.cpp ****     // PLL
  23:MotorControl/sensorless_estimator.cpp ****     // TODO: the PLL part has some code duplication with the encoder PLL
  24:MotorControl/sensorless_estimator.cpp ****     // Pll gains as a function of bandwidth
  25:MotorControl/sensorless_estimator.cpp ****     float pll_kp = 2.0f * config_.pll_bandwidth;
 175              		.loc 2 25 5 is_stmt 1 view .LVU29
 176              		.loc 2 25 35 is_stmt 0 view .LVU30
 177 000a D0ED027A 		vldr.32	s15, [r0, #8]
 178              		.loc 2 25 11 view .LVU31
 179 000e 77EEA77A 		vadd.f32	s15, s15, s15
 180              	.LVL8:
  26:MotorControl/sensorless_estimator.cpp ****     // Critically damped
  27:MotorControl/sensorless_estimator.cpp ****     float pll_ki = 0.25f * (pll_kp * pll_kp);
 181              		.loc 2 27 5 is_stmt 1 view .LVU32
 182              		.loc 2 27 36 is_stmt 0 view .LVU33
 183 0012 67EEA78A 		vmul.f32	s17, s15, s15
 184              		.loc 2 27 11 view .LVU34
 185 0016 B5EE007A 		vmov.f32	s14, #2.5e-1
 186 001a 68EE878A 		vmul.f32	s17, s17, s14
 187              	.LVL9:
  28:MotorControl/sensorless_estimator.cpp **** 
  29:MotorControl/sensorless_estimator.cpp ****     // Check that we don't get problems with discrete time approximation
  30:MotorControl/sensorless_estimator.cpp ****     if (!(current_meas_period * pll_kp < 1.0f)) {
 188              		.loc 2 30 5 is_stmt 1 view .LVU35
 189              		.loc 2 30 31 is_stmt 0 view .LVU36
 190 001e 9FEDAE8A 		vldr.32	s16, .L27
 191 0022 27EE888A 		vmul.f32	s16, s15, s16
 192              		.loc 2 30 5 view .LVU37
 193 0026 F7EE007A 		vmov.f32	s15, #1.0e+0
 194              	.LVL10:
 195              		.loc 2 30 5 view .LVU38
 196 002a B4EEE78A 		vcmpe.f32	s16, s15
 197 002e F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 198 0032 1ED5     		bpl	.L22
  31:MotorControl/sensorless_estimator.cpp ****         error_ |= ERROR_UNSTABLE_GAIN;
  32:MotorControl/sensorless_estimator.cpp ****         axis_->error_ |= Axis::ERROR_SENSORLESS_ESTIMATOR_FAILED;
  33:MotorControl/sensorless_estimator.cpp ****         reset(); // Reset state for when the next valid current measurement comes in.
  34:MotorControl/sensorless_estimator.cpp ****         return false;
  35:MotorControl/sensorless_estimator.cpp ****     }
  36:MotorControl/sensorless_estimator.cpp **** 
  37:MotorControl/sensorless_estimator.cpp ****     // TODO: we read values here which are modified by a higher priority interrupt.
  38:MotorControl/sensorless_estimator.cpp ****     // This is not thread-safe.    
  39:MotorControl/sensorless_estimator.cpp ****     auto current_meas = axis_->motor_.current_meas_;
 199              		.loc 2 39 5 is_stmt 1 view .LVU39
 200              		.loc 2 39 25 is_stmt 0 view .LVU40
 201 0034 0368     		ldr	r3, [r0]
 202              		.loc 2 39 32 view .LVU41
ARM GAS  /tmp/cced9Z1Y.s 			page 27


 203 0036 D3F85861 		ldr	r6, [r3, #344]
 204              		.loc 2 39 10 view .LVU42
 205 003a 05AD     		add	r5, sp, #20
 206 003c 06F1A003 		add	r3, r6, #160
 207 0040 0FCB     		ldm	r3, {r0, r1, r2, r3}
 208              	.LVL11:
 209              		.loc 2 39 10 view .LVU43
 210 0042 85E80F00 		stm	r5, {r0, r1, r2, r3}
  40:MotorControl/sensorless_estimator.cpp ****     if (!axis_->motor_.is_armed_) {
 211              		.loc 2 40 5 is_stmt 1 view .LVU44
 212              		.loc 2 40 24 is_stmt 0 view .LVU45
 213 0046 96F89C30 		ldrb	r3, [r6, #156]	@ zero_extendqisi2
 214              		.loc 2 40 5 view .LVU46
 215 004a 0BB3     		cbz	r3, .L23
 216              	.L7:
  41:MotorControl/sensorless_estimator.cpp ****         // While the motor is disarmed the current is not measurable so we
  42:MotorControl/sensorless_estimator.cpp ****         // assume that it's zero.
  43:MotorControl/sensorless_estimator.cpp ****         current_meas = {0.0f, 0.0f};
  44:MotorControl/sensorless_estimator.cpp ****     }
  45:MotorControl/sensorless_estimator.cpp ****     if (!current_meas.has_value()) {
 217              		.loc 2 45 5 is_stmt 1 view .LVU47
 218              	.LVL12:
 219              	.LBB257:
 220              	.LBI257:
 221              		.file 4 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // <optional> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Copyright (C) 2013-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** /** @file include/optional
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****  *  This is a Standard C++ Library header.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****  */
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #ifndef _GLIBCXX_OPTIONAL
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #define _GLIBCXX_OPTIONAL 1
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #pragma GCC system_header
ARM GAS  /tmp/cced9Z1Y.s 			page 28


  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #if __cplusplus >= 201703L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <utility>
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <type_traits>
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <exception>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <new>
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <initializer_list>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/exception_defines.h>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/functional_hash.h>
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/enable_special_members.h>
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #if __cplusplus > 201703L
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** # include <compare>
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #endif
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** namespace std _GLIBCXX_VISIBILITY(default)
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** {
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @addtogroup utilities
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @{
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    */
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #define __cpp_lib_optional 201606L
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class optional;
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /// Tag type to disengage optional objects.
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   struct nullopt_t
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   {
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Do not user-declare default constructor at all for
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // optional_value = {} syntax to work.
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // nullopt_t() = delete;
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Used for constructing nullopt.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     enum class _Construct { _Token };
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Must be constexpr for nullopt_t to be literal.
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     explicit constexpr nullopt_t(_Construct) { }
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   };
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /// Tag to disengage optional objects.
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   inline constexpr nullopt_t nullopt { nullopt_t::_Construct::_Token };
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @brief Exception class thrown when a disengaged optional object is
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  dereferenced.
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @ingroup exceptions
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    */
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   class bad_optional_access : public exception
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   {
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   public:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     bad_optional_access() = default;
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     virtual ~bad_optional_access() = default;
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/cced9Z1Y.s 			page 29


  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     const char* what() const noexcept override
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return "bad optional access"; }
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   };
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   void
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __throw_bad_optional_access()
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __attribute__((__noreturn__));
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // XXX Does not belong here.
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   inline void
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __throw_bad_optional_access()
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   { _GLIBCXX_THROW_OR_ABORT(bad_optional_access()); }
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // This class template manages construction/destruction of
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // the contained value for a std::optional.
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload_base
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Stored_type = remove_const_t<_Tp>;
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base() = default;
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_Optional_payload_base(in_place_t __tag, _Args&&... __args)
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_engaged(true)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args>
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_Optional_payload_base(std::initializer_list<_Up> __il,
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			       _Args&&... __args)
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__il, std::forward<_Args>(__args)...),
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_engaged(true)
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructor used by _Optional_base copy constructor when the
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // contained value is not trivially copy constructible.
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(bool __engaged,
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			     const _Optional_payload_base& __other)
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (__other._M_engaged)
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(__other._M_get());
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructor used by _Optional_base move constructor when the
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // contained value is not trivially move constructible.
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(bool __engaged,
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			     _Optional_payload_base&& __other)
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (__other._M_engaged)
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(std::move(__other._M_get()));
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
ARM GAS  /tmp/cced9Z1Y.s 			page 30


 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy constructor is only used to when the contained value is
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // trivially copy constructible.
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(const _Optional_payload_base&) = default;
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Move constructor is only used to when the contained value is
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // trivially copy constructible.
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(_Optional_payload_base&&) = default;
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base&
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload_base&) = default;
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base&
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload_base&&) = default;
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // used to perform non-trivial copy assignment.
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_copy_assign(const _Optional_payload_base& __other)
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         if (this->_M_engaged && __other._M_engaged)
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           this->_M_get() = __other._M_get();
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         else
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    if (__other._M_engaged)
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_construct(__other._M_get());
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    else
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // used to perform non-trivial move assignment.
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_move_assign(_Optional_payload_base&& __other)
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_engaged && __other._M_engaged)
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_get() = std::move(__other._M_get());
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    if (__other._M_engaged)
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_construct(std::move(__other._M_get()));
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    else
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       struct _Empty_byte { };
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, bool = is_trivially_destructible_v<_Up>>
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	union _Storage
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  constexpr _Storage() noexcept : _M_empty() { }
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename... _Args>
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(in_place_t, _Args&&... __args)
ARM GAS  /tmp/cced9Z1Y.s 			page 31


 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename _Vp, typename... _Args>
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(__il, std::forward<_Args>(__args)...)
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _Empty_byte _M_empty;
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           _Up _M_value;
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	};
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	union _Storage<_Up, false>
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  constexpr _Storage() noexcept : _M_empty() { }
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename... _Args>
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(in_place_t, _Args&&... __args)
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename _Vp, typename... _Args>
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(__il, std::forward<_Args>(__args)...)
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  // User-provided destructor is needed when _Up has non-trivial dtor.
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ~_Storage() { }
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _Empty_byte _M_empty;
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           _Up _M_value;
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	};
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Storage<_Stored_type> _M_payload;
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       bool _M_engaged = false;
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         void
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         _M_construct(_Args&&... __args)
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         {
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           ::new ((void *) std::__addressof(this->_M_payload))
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****             _Stored_type(std::forward<_Args>(__args)...);
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           this->_M_engaged = true;
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         }
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_destroy() noexcept
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_engaged = false;
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_payload._M_value.~_Stored_type();
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
ARM GAS  /tmp/cced9Z1Y.s 			page 32


 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_get() operations have _M_engaged as a precondition.
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // They exist to access the contained value with the appropriate
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // const-qualification, because _M_payload has had the const removed.
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() noexcept
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_payload._M_value; }
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() const noexcept
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_payload._M_value; }
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // _M_reset is a 'safe' operation with no precondition.
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_reset() noexcept
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_engaged)
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_destroy();
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Class template that manages the payload for optionals.
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp,
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialDestructor*/ =
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_destructible_v<_Tp>,
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialCopy */ =
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_copy_assignable_v<_Tp>
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      && is_trivially_copy_constructible_v<_Tp>,
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialMove */ =
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_move_assignable_v<_Tp>
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      && is_trivially_move_constructible_v<_Tp>>
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload;
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for potentially-constexpr optionals (trivial copy/move/destroy).
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, true, true>
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial copy construction/assignment.
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, false, true>
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(_Optional_payload&&) = default;
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/cced9Z1Y.s 			page 33


 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial copy assignment.
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload& __other)
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_copy_assign(__other);
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial move construction/assignment.
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, true, false>
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(const _Optional_payload&) = default;
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial move assignment.
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload&& __other)
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_move_assign(std::move(__other));
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial copy and move assignment.
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, false, false>
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial copy assignment.
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload& __other)
 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_copy_assign(__other);
 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial move assignment.
ARM GAS  /tmp/cced9Z1Y.s 			page 34


 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload&& __other)
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_move_assign(std::move(__other));
 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial destructors.
 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp, bool _Copy, bool _Move>
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, false, _Copy, _Move>
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload<_Tp, true, false, false>
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Base class implements all the constructors and assignment operators:
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload<_Tp, true, false, false>::_Optional_payload;
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(const _Optional_payload&) = default;
 397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(_Optional_payload&&) = default;
 398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Destructor needs to destroy the contained value:
 400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() { this->_M_reset(); }
 401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Common base class for _Optional_base<T> to avoid repeating these
 404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // member functions in each specialization.
 405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Dp>
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class _Optional_base_impl
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     protected:
 409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Stored_type = remove_const_t<_Tp>;
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_construct operation has !_M_engaged as a precondition
 412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // while _M_destruct has _M_engaged as a precondition.
 413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	void
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_construct(_Args&&... __args)
 416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ::new
 419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    (std::__addressof(static_cast<_Dp*>(this)->_M_payload._M_payload))
 420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Stored_type(std::forward<_Args>(__args)...);
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_cast<_Dp*>(this)->_M_payload._M_engaged = true;
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       void
 425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_destruct() noexcept
 426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { static_cast<_Dp*>(this)->_M_payload._M_destroy(); }
 427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // _M_reset is a 'safe' operation with no precondition.
 429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_reset() noexcept
 431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { static_cast<_Dp*>(this)->_M_payload._M_reset(); }
ARM GAS  /tmp/cced9Z1Y.s 			page 35


 432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr bool _M_is_engaged() const noexcept
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_get operations have _M_engaged as a precondition.
 437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() noexcept
 439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__glibcxx_assert(this->_M_is_engaged());
 441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return static_cast<_Dp*>(this)->_M_payload._M_get();
 442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() const noexcept
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__glibcxx_assert(this->_M_is_engaged());
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return static_cast<const _Dp*>(this)->_M_payload._M_get();
 449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
 453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @brief Class template that provides copy/move constructors of optional.
 454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * Such a separate base class template is necessary in order to
 456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * conditionally make copy/move constructors trivial.
 457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * When the contained value is trivially copy/move constructible,
 459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * the copy/move constructors of _Optional_base will invoke the
 460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * trivial copy/move constructor of _Optional_payload. Otherwise,
 461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * they will invoke _Optional_payload(bool, const _Optional_payload&)
 462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * or _Optional_payload(bool, _Optional_payload&&) to initialize
 463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * the contained value, if copying/moving an engaged optional.
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * Whether the other special members are trivial is determined by the
 466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * _Optional_payload<_Tp> specialization used for the _M_payload member.
 467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @see optional, _Enable_special_members
 469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     */
 470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp,
 471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	   bool = is_trivially_copy_constructible_v<_Tp>,
 472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	   bool = is_trivially_move_constructible_v<_Tp>>
 473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base
 474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
ARM GAS  /tmp/cced9Z1Y.s 			page 36


 489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other)
 499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __other._M_payload)
 501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other)
 504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>)
 505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::move(__other._M_payload))
 507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, false, true>
 518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other)
 543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __other._M_payload)
 545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
ARM GAS  /tmp/cced9Z1Y.s 			page 37


 546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other) = default;
 548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, true, false>
 558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other) = default;
 583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other)
 585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>)
 586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::move(__other._M_payload))
 588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, true, true>
 599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
ARM GAS  /tmp/cced9Z1Y.s 			page 38


 603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other) = default;
 624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other) = default;
 625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   class optional;
 635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __converts_from_optional =
 638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       __or_<is_constructible<_Tp, const optional<_Up>&>,
 639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, optional<_Up>&>,
 640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, const optional<_Up>&&>,
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, optional<_Up>&&>,
 642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<const optional<_Up>&, _Tp>,
 643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<optional<_Up>&, _Tp>,
 644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<const optional<_Up>&&, _Tp>,
 645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<optional<_Up>&&, _Tp>>;
 646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __assigns_from_optional =
 649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       __or_<is_assignable<_Tp&, const optional<_Up>&>,
 650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, optional<_Up>&>,
 651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, const optional<_Up>&&>,
 652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, optional<_Up>&&>>;
 653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
 655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @brief Class template for optional values.
 656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     */
 657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class optional
 659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : private _Optional_base<_Tp>,
ARM GAS  /tmp/cced9Z1Y.s 			page 39


 660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       private _Enable_copy_move<
 661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Copy constructor.
 662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	is_copy_constructible_v<_Tp>,
 663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Copy assignment.
 664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__and_v<is_copy_constructible<_Tp>, is_copy_assignable<_Tp>>,
 665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Move constructor.
 666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	is_move_constructible_v<_Tp>,
 667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Move assignment.
 668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__and_v<is_move_constructible<_Tp>, is_move_assignable<_Tp>>,
 669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Unique tag type.
 670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional<_Tp>>
 671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_same_v<remove_cv_t<_Tp>, nullopt_t>);
 673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_same_v<remove_cv_t<_Tp>, in_place_t>);
 674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_reference_v<_Tp>);
 675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     private:
 677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Base = _Optional_base<_Tp>;
 678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // SFINAE helpers
 680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using __not_self = __not_<is_same<optional, __remove_cvref_t<_Up>>>;
 682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using __not_tag = __not_<is_same<in_place_t, __remove_cvref_t<_Up>>>;
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Cond>
 685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using _Requires = enable_if_t<__and_v<_Cond...>, bool>;
 686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     public:
 688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using value_type = _Tp;
 689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr optional() = default;
 691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr optional(nullopt_t) noexcept { }
 693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Converting constructors for engaged optionals.
 695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp,
 696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_self<_Up>, __not_tag<_Up>,
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, _Up&&>,
 698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_convertible<_Up&&, _Tp>> = true>
 699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(_Up&& __t)
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp,
 704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_self<_Up>, __not_tag<_Up>,
 705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, _Up&&>,
 706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<is_convertible<_Up&&, _Tp>>> = false>
 707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(_Up&& __t)
 709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _Base(std::in_place, std::forward<_Up>(__t)) { }
 710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up,
 712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_<is_same<_Tp, _Up>>,
 713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, const _Up&>,
 714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_convertible<const _Up&, _Tp>,
 715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<__converts_from_optional<_Tp, _Up>>> = true>
 716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
ARM GAS  /tmp/cced9Z1Y.s 			page 40


 717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(const optional<_Up>& __t)
 718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(*__t);
 721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up,
 724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_<is_same<_Tp, _Up>>,
 725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, const _Up&>,
 726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<is_convertible<const _Up&, _Tp>>,
 727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<__converts_from_optional<_Tp, _Up>>> = false>
 728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(const optional<_Up>& __t)
 730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(*__t);
 733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template <typename _Up,
 736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		_Requires<__not_<is_same<_Tp, _Up>>,
 737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_constructible<_Tp, _Up&&>,
 738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_convertible<_Up&&, _Tp>,
 739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<__converts_from_optional<_Tp, _Up>>> = true>
 740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(optional<_Up>&& __t)
 742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(std::move(*__t));
 745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template <typename _Up,
 748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		_Requires<__not_<is_same<_Tp, _Up>>,
 749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_constructible<_Tp, _Up&&>,
 750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<is_convertible<_Up&&, _Tp>>,
 751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<__converts_from_optional<_Tp, _Up>>> = false>
 752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(optional<_Up>&& __t)
 754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(std::move(*__t));
 757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<is_constructible<_Tp, _Args&&...>> = false>
 761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(in_place_t, _Args&&... __args)
 763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Args>(__args)...) { }
 764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<is_constructible<_Tp,
 767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  initializer_list<_Up>&,
 768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  _Args&&...>> = false>
 769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(in_place_t, initializer_list<_Up> __il, _Args&&... __args)
 771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, __il, std::forward<_Args>(__args)...) { }
 772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
ARM GAS  /tmp/cced9Z1Y.s 			page 41


 774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       optional&
 775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(nullopt_t) noexcept
 776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_reset();
 778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp>
 782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<__and_v<__not_self<_Up>,
 783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__and_<is_scalar<_Tp>,
 784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  is_same<_Tp, decay_t<_Up>>>>,
 785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, _Up>,
 786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, _Up>>,
 787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(_Up&& __u)
 789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (this->_M_is_engaged())
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_get() = std::forward<_Up>(__u);
 792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_construct(std::forward<_Up>(__u));
 794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
 796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
 800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, const _Up&>,
 801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, const _Up&>,
 802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__converts_from_optional<_Tp, _Up>>,
 803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__assigns_from_optional<_Tp, _Up>>>,
 804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(const optional<_Up>& __u)
 806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__u)
 808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      if (this->_M_is_engaged())
 810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_get() = *__u;
 811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      else
 812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_construct(*__u);
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
 819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, _Up>,
 824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, _Up>,
 825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__converts_from_optional<_Tp, _Up>>,
 826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__assigns_from_optional<_Tp, _Up>>>,
 827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(optional<_Up>&& __u)
 829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__u)
ARM GAS  /tmp/cced9Z1Y.s 			page 42


 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      if (this->_M_is_engaged())
 833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_get() = std::move(*__u);
 834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      else
 835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_construct(std::move(*__u));
 836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
 843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<is_constructible_v<_Tp, _Args&&...>, _Tp&>
 847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	emplace(_Args&&... __args)
 848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_reset();
 850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(std::forward<_Args>(__args)...);
 851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_get();
 852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args>
 855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&,
 856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 				       _Args&&...>, _Tp&>
 857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	emplace(initializer_list<_Up> __il, _Args&&... __args)
 858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_reset();
 860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(__il, std::forward<_Args>(__args)...);
 861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_get();
 862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Destructor is implicit, implemented in _Optional_base.
 865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Swap.
 867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       void
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       swap(optional& __other)
 869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>
 870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       && is_nothrow_swappable_v<_Tp>)
 871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using std::swap;
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_is_engaged() && __other._M_is_engaged())
 875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  swap(this->_M_get(), __other._M_get());
 876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else if (this->_M_is_engaged())
 877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    __other._M_construct(std::move(this->_M_get()));
 879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_destruct();
 880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else if (__other._M_is_engaged())
 882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_construct(std::move(__other._M_get()));
 884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    __other._M_destruct();
 885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/cced9Z1Y.s 			page 43


 888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Observers.
 889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp*
 890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator->() const
 891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::__addressof(this->_M_get()); }
 892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp*
 894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator->()
 895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::__addressof(this->_M_get()); }
 896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*() const&
 899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_get(); }
 900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*()&
 903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_get(); }
 904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&&
 906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*()&&
 907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::move(this->_M_get()); }
 908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&&
 910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*() const&&
 911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::move(this->_M_get()); }
 912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr explicit operator bool() const noexcept
 914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr bool has_value() const noexcept
 222              		.loc 4 916 22 view .LVU48
 223              	.LBB258:
 224              	.LBI258:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 225              		.loc 4 433 22 view .LVU49
 226              	.LBB259:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 227              		.loc 4 434 58 is_stmt 0 view .LVU50
 228 004c 9DF82050 		ldrb	r5, [sp, #32]	@ zero_extendqisi2
 229              	.LVL13:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 230              		.loc 4 434 58 view .LVU51
 231              	.LBE259:
 232              	.LBE258:
 233              	.LBE257:
 234              		.loc 2 45 5 view .LVU52
 235 0050 8DB3     		cbz	r5, .L24
  46:MotorControl/sensorless_estimator.cpp ****         error_ |= ERROR_UNKNOWN_CURRENT_MEASUREMENT;
  47:MotorControl/sensorless_estimator.cpp ****         axis_->error_ |= Axis::ERROR_SENSORLESS_ESTIMATOR_FAILED;
  48:MotorControl/sensorless_estimator.cpp ****         reset(); // Reset state for when the next valid current measurement comes in.
  49:MotorControl/sensorless_estimator.cpp ****         return false;
  50:MotorControl/sensorless_estimator.cpp ****     }
  51:MotorControl/sensorless_estimator.cpp **** 
  52:MotorControl/sensorless_estimator.cpp ****     // Clarke transform
  53:MotorControl/sensorless_estimator.cpp ****     float I_alpha_beta[2] = {
 236              		.loc 2 53 5 is_stmt 1 view .LVU53
  54:MotorControl/sensorless_estimator.cpp ****         current_meas->phA,
 237              		.loc 2 54 23 is_stmt 0 view .LVU54
ARM GAS  /tmp/cced9Z1Y.s 			page 44


 238 0052 059B     		ldr	r3, [sp, #20]	@ float
  55:MotorControl/sensorless_estimator.cpp ****         one_by_sqrt3 * (current_meas->phB - current_meas->phC)};
 239              		.loc 2 55 63 view .LVU55
 240 0054 0393     		str	r3, [sp, #12]	@ float
 241              		.loc 2 55 43 view .LVU56
 242 0056 DDED067A 		vldr.32	s15, [sp, #24]
 243 005a 9DED077A 		vldr.32	s14, [sp, #28]
 244 005e 77EEC77A 		vsub.f32	s15, s15, s14
 245              		.loc 2 55 22 view .LVU57
 246 0062 9FED9E7A 		vldr.32	s14, .L27+4
 247 0066 67EE877A 		vmul.f32	s15, s15, s14
 248              		.loc 2 55 63 view .LVU58
 249 006a CDED047A 		vstr.32	s15, [sp, #16]
  56:MotorControl/sensorless_estimator.cpp **** 
  57:MotorControl/sensorless_estimator.cpp ****     // alpha-beta vector operations
  58:MotorControl/sensorless_estimator.cpp ****     float eta[2];
 250              		.loc 2 58 5 is_stmt 1 view .LVU59
  59:MotorControl/sensorless_estimator.cpp ****     for (int i = 0; i <= 1; ++i) {
 251              		.loc 2 59 5 view .LVU60
 252              	.LVL14:
 253              	.LBB260:
 254              		.loc 2 59 14 is_stmt 0 view .LVU61
 255 006e 0023     		movs	r3, #0
 256 0070 5CE0     		b	.L12
 257              	.LVL15:
 258              	.L22:
 259              		.loc 2 59 14 view .LVU62
 260              	.LBE260:
  31:MotorControl/sensorless_estimator.cpp ****         axis_->error_ |= Axis::ERROR_SENSORLESS_ESTIMATOR_FAILED;
 261              		.loc 2 31 9 is_stmt 1 view .LVU63
  31:MotorControl/sensorless_estimator.cpp ****         axis_->error_ |= Axis::ERROR_SENSORLESS_ESTIMATOR_FAILED;
 262              		.loc 2 31 19 is_stmt 0 view .LVU64
 263 0072 0121     		movs	r1, #1
 264 0074 1030     		adds	r0, r0, #16
 265              	.LVL16:
  31:MotorControl/sensorless_estimator.cpp ****         axis_->error_ |= Axis::ERROR_SENSORLESS_ESTIMATOR_FAILED;
 266              		.loc 2 31 19 view .LVU65
 267 0076 FFF7FEFF 		bl	_ZoRRN10ODriveIntf23SensorlessEstimatorIntf5ErrorES1_
 268              	.LVL17:
  32:MotorControl/sensorless_estimator.cpp ****         reset(); // Reset state for when the next valid current measurement comes in.
 269              		.loc 2 32 9 is_stmt 1 view .LVU66
 270 007a 2068     		ldr	r0, [r4]
  32:MotorControl/sensorless_estimator.cpp ****         reset(); // Reset state for when the next valid current measurement comes in.
 271              		.loc 2 32 32 is_stmt 0 view .LVU67
 272 007c 8021     		movs	r1, #128
 273 007e 00F51270 		add	r0, r0, #584
 274 0082 FFF7FEFF 		bl	_ZoRRN10ODriveIntf8AxisIntf5ErrorES1_
 275              	.LVL18:
  33:MotorControl/sensorless_estimator.cpp ****         return false;
 276              		.loc 2 33 9 is_stmt 1 view .LVU68
  33:MotorControl/sensorless_estimator.cpp ****         return false;
 277              		.loc 2 33 14 is_stmt 0 view .LVU69
 278 0086 2046     		mov	r0, r4
 279 0088 FFF7FEFF 		bl	_ZN19SensorlessEstimator5resetEv
 280              	.LVL19:
  34:MotorControl/sensorless_estimator.cpp ****     }
 281              		.loc 2 34 9 is_stmt 1 view .LVU70
ARM GAS  /tmp/cced9Z1Y.s 			page 45


  34:MotorControl/sensorless_estimator.cpp ****     }
 282              		.loc 2 34 16 is_stmt 0 view .LVU71
 283 008c 0025     		movs	r5, #0
 284 008e 12E1     		b	.L6
 285              	.LVL20:
 286              	.L23:
  43:MotorControl/sensorless_estimator.cpp ****     }
 287              		.loc 2 43 9 is_stmt 1 view .LVU72
  43:MotorControl/sensorless_estimator.cpp ****     }
 288              		.loc 2 43 35 is_stmt 0 view .LVU73
 289 0090 0993     		str	r3, [sp, #36]
 290 0092 0A93     		str	r3, [sp, #40]
 291 0094 0B93     		str	r3, [sp, #44]
 292              	.LVL21:
 293              	.LBB262:
 294              	.LBI262:
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 295              		.loc 4 788 2 is_stmt 1 view .LVU74
 296              	.LBB263:
 297              	.LBB264:
 298              	.LBI264:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 299              		.loc 4 433 22 view .LVU75
 300              	.LBB265:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 301              		.loc 4 434 58 is_stmt 0 view .LVU76
 302 0096 9DF82030 		ldrb	r3, [sp, #32]	@ zero_extendqisi2
 303              	.LVL22:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 304              		.loc 4 434 58 view .LVU77
 305              	.LBE265:
 306              	.LBE264:
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_get() = std::forward<_Up>(__u);
 307              		.loc 4 790 4 view .LVU78
 308 009a 23B1     		cbz	r3, .L8
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 309              		.loc 4 791 6 view .LVU79
 310 009c 0023     		movs	r3, #0
 311 009e 0593     		str	r3, [sp, #20]
 312 00a0 0693     		str	r3, [sp, #24]
 313 00a2 0793     		str	r3, [sp, #28]
 314 00a4 D2E7     		b	.L7
 315              	.L8:
 316              	.LVL23:
 317              	.LBB266:
 318              	.LBI266:
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 319              		.loc 4 415 2 is_stmt 1 view .LVU80
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 320              		.loc 4 415 2 is_stmt 0 view .LVU81
 321              	.LBE266:
 322              	.LBE263:
 323              	.LBE262:
 324              		.file 5 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // The -*- C++ -*- dynamic memory management header.
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // Copyright (C) 1994-2020 Free Software Foundation, Inc.
ARM GAS  /tmp/cced9Z1Y.s 			page 46


   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // This file is part of GCC.
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** //
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // GCC is free software; you can redistribute it and/or modify
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // it under the terms of the GNU General Public License as published by
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // the Free Software Foundation; either version 3, or (at your option)
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // any later version.
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // 
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // GCC is distributed in the hope that it will be useful,
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // GNU General Public License for more details.
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // 
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // Under Section 7 of GPL version 3, you are granted additional
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // permissions described in the GCC Runtime Library Exception, version
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // 3.1, as published by the Free Software Foundation.
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // You should have received a copy of the GNU General Public License and
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // a copy of the GCC Runtime Library Exception along with this program;
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // <http://www.gnu.org/licenses/>.
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** /** @file new
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  This is a Standard C++ Library header.
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  The header @c new defines several functions to manage dynamic memory and
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  handling memory allocation errors; see
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/dynamic_memory.html
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  for more.
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  */
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #ifndef _NEW
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #define _NEW
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #pragma GCC system_header
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #include <bits/c++config.h>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #include <exception>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #pragma GCC visibility push(default)
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** extern "C++" {
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** namespace std 
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** {
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /**
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  @brief  Exception possibly thrown by @c new.
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  @ingroup exceptions
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  @c bad_alloc (or classes derived from it) is used to report allocation
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  errors from the throwing forms of @c new.  */
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   class bad_alloc : public exception 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   {
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   public:
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_alloc() throw() { }
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
ARM GAS  /tmp/cced9Z1Y.s 			page 47


  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_alloc(const bad_alloc&) = default;
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_alloc& operator=(const bad_alloc&) = default;
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // This declaration is not useless:
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual ~bad_alloc() throw();
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // See comment in eh_exception.cc.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual const char* what() const throw();
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   };
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   class bad_array_new_length : public bad_alloc
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   {
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   public:
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_array_new_length() throw() { }
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // This declaration is not useless:
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual ~bad_array_new_length() throw();
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // See comment in eh_exception.cc.
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual const char* what() const throw();
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   };
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_aligned_new
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   enum class align_val_t: size_t {};
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   struct nothrow_t
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   {
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     explicit nothrow_t() = default;
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   };
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   extern const nothrow_t nothrow;
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /** If you write your own error handler to be called by @c new, it must
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  be of this type.  */
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   typedef void (*new_handler)();
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /// Takes a replacement handler as the argument, returns the
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /// previous handler.
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   new_handler set_new_handler(new_handler) throw();
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /// Return the current new handler.
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   new_handler get_new_handler() noexcept;
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** } // namespace std
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** //@{
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** /** These are replaceable signatures:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
ARM GAS  /tmp/cced9Z1Y.s 			page 48


 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - normal array new and delete (same)
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - @c nothrow single new and delete (take a @c nothrow argument, return
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *    @c NULL on error)
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - @c nothrow array new and delete (same)
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  Placement new and delete signatures (take a memory address argument,
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  does nothing) may not be replaced by a user's program.
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** */
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t) _GLIBCXX_THROW (std::bad_alloc)
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*) _GLIBCXX_USE_NOEXCEPT
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*) _GLIBCXX_USE_NOEXCEPT
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_sized_deallocation
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__, __malloc__));
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__, __malloc__));
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_aligned_new
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t)
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __malloc__));
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::align_val_t)
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::align_val_t, const std::nothrow_t&)
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t)
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __malloc__));
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::align_val_t)
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_sized_deallocation
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::size_t, std::align_val_t)
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::size_t, std::align_val_t)
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif // __cpp_sized_deallocation
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif // __cpp_aligned_new
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // Default placement versions of operator new.
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
ARM GAS  /tmp/cced9Z1Y.s 			page 49


 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** { return __p; }
 325              		.loc 5 175 3 is_stmt 1 view .LVU82
 326              	.LBB270:
 327              	.LBB269:
 328              	.LBB268:
 329              	.LBB267:
 330              		.loc 5 175 3 is_stmt 0 view .LVU83
 331 00a6 0023     		movs	r3, #0
 332 00a8 0593     		str	r3, [sp, #20]
 333 00aa 0693     		str	r3, [sp, #24]
 334 00ac 0793     		str	r3, [sp, #28]
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 335              		.loc 4 421 51 view .LVU84
 336 00ae 0123     		movs	r3, #1
 337 00b0 8DF82030 		strb	r3, [sp, #32]
 338              	.LVL24:
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 339              		.loc 4 422 2 view .LVU85
 340 00b4 CAE7     		b	.L7
 341              	.L24:
 342              	.LBE267:
 343              	.LBE268:
 344              	.LBE269:
 345              	.LBE270:
  46:MotorControl/sensorless_estimator.cpp ****         axis_->error_ |= Axis::ERROR_SENSORLESS_ESTIMATOR_FAILED;
 346              		.loc 2 46 9 is_stmt 1 view .LVU86
  46:MotorControl/sensorless_estimator.cpp ****         axis_->error_ |= Axis::ERROR_SENSORLESS_ESTIMATOR_FAILED;
 347              		.loc 2 46 19 is_stmt 0 view .LVU87
 348 00b6 0221     		movs	r1, #2
 349 00b8 04F11000 		add	r0, r4, #16
 350 00bc FFF7FEFF 		bl	_ZoRRN10ODriveIntf23SensorlessEstimatorIntf5ErrorES1_
 351              	.LVL25:
  47:MotorControl/sensorless_estimator.cpp ****         reset(); // Reset state for when the next valid current measurement comes in.
 352              		.loc 2 47 9 is_stmt 1 view .LVU88
 353 00c0 2068     		ldr	r0, [r4]
  47:MotorControl/sensorless_estimator.cpp ****         reset(); // Reset state for when the next valid current measurement comes in.
 354              		.loc 2 47 32 is_stmt 0 view .LVU89
 355 00c2 8021     		movs	r1, #128
 356 00c4 00F51270 		add	r0, r0, #584
 357 00c8 FFF7FEFF 		bl	_ZoRRN10ODriveIntf8AxisIntf5ErrorES1_
 358              	.LVL26:
  48:MotorControl/sensorless_estimator.cpp ****         return false;
 359              		.loc 2 48 9 is_stmt 1 view .LVU90
  48:MotorControl/sensorless_estimator.cpp ****         return false;
 360              		.loc 2 48 14 is_stmt 0 view .LVU91
 361 00cc 2046     		mov	r0, r4
 362 00ce FFF7FEFF 		bl	_ZN19SensorlessEstimator5resetEv
 363              	.LVL27:
  49:MotorControl/sensorless_estimator.cpp ****     }
 364              		.loc 2 49 9 is_stmt 1 view .LVU92
  49:MotorControl/sensorless_estimator.cpp ****     }
 365              		.loc 2 49 16 is_stmt 0 view .LVU93
 366 00d2 F0E0     		b	.L6
 367              	.LVL28:
 368              	.L25:
 369              	.LBB271:
 370              	.LBB261:
ARM GAS  /tmp/cced9Z1Y.s 			page 50


  60:MotorControl/sensorless_estimator.cpp ****         // y is the total flux-driving voltage (see paper eqn 4)
  61:MotorControl/sensorless_estimator.cpp ****         float y = -axis_->motor_.config_.phase_resistance * I_alpha_beta[i] + V_alpha_beta_memory_[
 371              		.loc 2 61 9 is_stmt 1 discriminator 2 view .LVU94
 372              		.loc 2 61 20 is_stmt 0 discriminator 2 view .LVU95
 373 00d4 2068     		ldr	r0, [r4]
 374              		.loc 2 61 27 discriminator 2 view .LVU96
 375 00d6 D0F85821 		ldr	r2, [r0, #344]
 376              		.loc 2 61 42 discriminator 2 view .LVU97
 377 00da D2ED0C7A 		vldr.32	s15, [r2, #48]
 378              		.loc 2 61 75 discriminator 2 view .LVU98
 379 00de 10AA     		add	r2, sp, #64
 380 00e0 02EB8301 		add	r1, r2, r3, lsl #2
 381 00e4 11ED0D7A 		vldr.32	s14, [r1, #-52]
 382              		.loc 2 61 59 discriminator 2 view .LVU99
 383 00e8 67EEC77A 		vnmul.f32	s15, s15, s14
 384              		.loc 2 61 101 discriminator 2 view .LVU100
 385 00ec 03F10802 		add	r2, r3, #8
 386 00f0 04EB8202 		add	r2, r4, r2, lsl #2
 387 00f4 D2ED006A 		vldr.32	s13, [r2]
 388              		.loc 2 61 15 discriminator 2 view .LVU101
 389 00f8 77EEA67A 		vadd.f32	s15, s15, s13
 390              	.LVL29:
  62:MotorControl/sensorless_estimator.cpp ****         // flux dynamics (prediction)
  63:MotorControl/sensorless_estimator.cpp ****         float x_dot = y;
 391              		.loc 2 63 9 is_stmt 1 discriminator 2 view .LVU102
  64:MotorControl/sensorless_estimator.cpp ****         // integrate prediction to current timestep
  65:MotorControl/sensorless_estimator.cpp ****         flux_state_[i] += x_dot * current_meas_period;
 392              		.loc 2 65 9 discriminator 2 view .LVU103
 393              		.loc 2 65 33 is_stmt 0 discriminator 2 view .LVU104
 394 00fc DFED766A 		vldr.32	s13, .L27
 395 0100 67EEA67A 		vmul.f32	s15, s15, s13
 396              	.LVL30:
 397              		.loc 2 65 24 discriminator 2 view .LVU105
 398 0104 9A1D     		adds	r2, r3, #6
 399              	.LVL31:
 400              		.loc 2 65 24 discriminator 2 view .LVU106
 401 0106 04EB8202 		add	r2, r4, r2, lsl #2
 402 010a D2ED006A 		vldr.32	s13, [r2]
 403 010e 77EEA67A 		vadd.f32	s15, s15, s13
 404 0112 C2ED007A 		vstr.32	s15, [r2]
 405              	.LVL32:
  66:MotorControl/sensorless_estimator.cpp **** 
  67:MotorControl/sensorless_estimator.cpp ****         // eta is the estimated permanent magnet flux (see paper eqn 6)
  68:MotorControl/sensorless_estimator.cpp ****         eta[i] = flux_state_[i] - axis_->motor_.config_.phase_inductance * I_alpha_beta[i];
 406              		.loc 2 68 9 is_stmt 1 discriminator 2 view .LVU107
 407              		.loc 2 68 42 is_stmt 0 discriminator 2 view .LVU108
 408 0116 D0F85821 		ldr	r2, [r0, #344]
 409              		.loc 2 68 57 discriminator 2 view .LVU109
 410 011a D2ED0B6A 		vldr.32	s13, [r2, #44]
 411              		.loc 2 68 74 discriminator 2 view .LVU110
 412 011e 27EE267A 		vmul.f32	s14, s14, s13
 413              		.loc 2 68 33 discriminator 2 view .LVU111
 414 0122 77EEC77A 		vsub.f32	s15, s15, s14
 415              		.loc 2 68 16 discriminator 2 view .LVU112
 416 0126 41ED0F7A 		vstr.32	s15, [r1, #-60]
 417              	.LBE261:
  59:MotorControl/sensorless_estimator.cpp ****         // y is the total flux-driving voltage (see paper eqn 4)
ARM GAS  /tmp/cced9Z1Y.s 			page 51


 418              		.loc 2 59 5 is_stmt 1 discriminator 2 view .LVU113
 419 012a 0133     		adds	r3, r3, #1
 420              	.LVL33:
 421              	.L12:
  59:MotorControl/sensorless_estimator.cpp ****         // y is the total flux-driving voltage (see paper eqn 4)
 422              		.loc 2 59 23 discriminator 3 view .LVU114
 423 012c 012B     		cmp	r3, #1
 424 012e D1DD     		ble	.L25
 425              	.LBE271:
  69:MotorControl/sensorless_estimator.cpp ****     }
  70:MotorControl/sensorless_estimator.cpp **** 
  71:MotorControl/sensorless_estimator.cpp ****     // Non-linear observer (see paper eqn 8):
  72:MotorControl/sensorless_estimator.cpp ****     float pm_flux_sqr = config_.pm_flux_linkage * config_.pm_flux_linkage;
 426              		.loc 2 72 5 view .LVU115
 427              		.loc 2 72 33 is_stmt 0 view .LVU116
 428 0130 D4ED037A 		vldr.32	s15, [r4, #12]
 429              		.loc 2 72 11 view .LVU117
 430 0134 67EEA77A 		vmul.f32	s15, s15, s15
 431              	.LVL34:
  73:MotorControl/sensorless_estimator.cpp ****     float est_pm_flux_sqr = eta[0] * eta[0] + eta[1] * eta[1];
 432              		.loc 2 73 5 is_stmt 1 view .LVU118
 433              		.loc 2 73 34 is_stmt 0 view .LVU119
 434 0138 9DED017A 		vldr.32	s14, [sp, #4]
 435              		.loc 2 73 36 view .LVU120
 436 013c 27EE077A 		vmul.f32	s14, s14, s14
 437              		.loc 2 73 52 view .LVU121
 438 0140 DDED026A 		vldr.32	s13, [sp, #8]
 439              		.loc 2 73 54 view .LVU122
 440 0144 66EEA66A 		vmul.f32	s13, s13, s13
 441              		.loc 2 73 11 view .LVU123
 442 0148 77EE266A 		vadd.f32	s13, s14, s13
 443              	.LVL35:
  74:MotorControl/sensorless_estimator.cpp ****     float bandwidth_factor = 1.0f / pm_flux_sqr;
 444              		.loc 2 74 5 is_stmt 1 view .LVU124
 445              		.loc 2 74 11 is_stmt 0 view .LVU125
 446 014c B7EE007A 		vmov.f32	s14, #1.0e+0
 447 0150 87EE276A 		vdiv.f32	s12, s14, s15
 448              	.LVL36:
  75:MotorControl/sensorless_estimator.cpp ****     float eta_factor = 0.5f * (config_.observer_gain * bandwidth_factor) * (pm_flux_sqr - est_pm_fl
 449              		.loc 2 75 5 is_stmt 1 view .LVU126
 450              		.loc 2 75 40 is_stmt 0 view .LVU127
 451 0154 94ED017A 		vldr.32	s14, [r4, #4]
 452              		.loc 2 75 54 view .LVU128
 453 0158 27EE067A 		vmul.f32	s14, s14, s12
 454              		.loc 2 75 29 view .LVU129
 455 015c B6EE006A 		vmov.f32	s12, #5.0e-1
 456              	.LVL37:
 457              		.loc 2 75 29 view .LVU130
 458 0160 27EE067A 		vmul.f32	s14, s14, s12
 459              		.loc 2 75 89 view .LVU131
 460 0164 77EEE67A 		vsub.f32	s15, s15, s13
 461              	.LVL38:
 462              		.loc 2 75 11 view .LVU132
 463 0168 27EE277A 		vmul.f32	s14, s14, s15
 464              	.LVL39:
  76:MotorControl/sensorless_estimator.cpp **** 
  77:MotorControl/sensorless_estimator.cpp ****     // alpha-beta vector operations
ARM GAS  /tmp/cced9Z1Y.s 			page 52


  78:MotorControl/sensorless_estimator.cpp ****     for (int i = 0; i <= 1; ++i) {
 465              		.loc 2 78 5 is_stmt 1 view .LVU133
 466              	.LBB272:
 467              		.loc 2 78 14 is_stmt 0 view .LVU134
 468 016c 0023     		movs	r3, #0
 469              	.LVL40:
 470              	.L14:
 471              		.loc 2 78 23 is_stmt 1 discriminator 3 view .LVU135
 472 016e 012B     		cmp	r3, #1
 473 0170 22DC     		bgt	.L13
 474              	.LBB273:
  79:MotorControl/sensorless_estimator.cpp ****         // add observer action to flux estimate dynamics
  80:MotorControl/sensorless_estimator.cpp ****         float x_dot = eta_factor * eta[i];
 475              		.loc 2 80 9 discriminator 2 view .LVU136
 476              		.loc 2 80 41 is_stmt 0 discriminator 2 view .LVU137
 477 0172 10AA     		add	r2, sp, #64
 478 0174 02EB8301 		add	r1, r2, r3, lsl #2
 479 0178 51ED0F7A 		vldr.32	s15, [r1, #-60]
 480              		.loc 2 80 15 discriminator 2 view .LVU138
 481 017c 67EE877A 		vmul.f32	s15, s15, s14
 482              	.LVL41:
  81:MotorControl/sensorless_estimator.cpp ****         // convert action to discrete-time
  82:MotorControl/sensorless_estimator.cpp ****         flux_state_[i] += x_dot * current_meas_period;
 483              		.loc 2 82 9 is_stmt 1 discriminator 2 view .LVU139
 484              		.loc 2 82 33 is_stmt 0 discriminator 2 view .LVU140
 485 0180 DFED556A 		vldr.32	s13, .L27
 486 0184 67EEA67A 		vmul.f32	s15, s15, s13
 487              	.LVL42:
 488              		.loc 2 82 24 discriminator 2 view .LVU141
 489 0188 9A1D     		adds	r2, r3, #6
 490 018a 04EB8202 		add	r2, r4, r2, lsl #2
 491 018e D2ED006A 		vldr.32	s13, [r2]
 492 0192 77EEA67A 		vadd.f32	s15, s15, s13
 493 0196 C2ED007A 		vstr.32	s15, [r2]
  83:MotorControl/sensorless_estimator.cpp ****         // update new eta
  84:MotorControl/sensorless_estimator.cpp ****         eta[i] = flux_state_[i] - axis_->motor_.config_.phase_inductance * I_alpha_beta[i];
 494              		.loc 2 84 9 is_stmt 1 discriminator 2 view .LVU142
 495              		.loc 2 84 35 is_stmt 0 discriminator 2 view .LVU143
 496 019a 2268     		ldr	r2, [r4]
 497              		.loc 2 84 42 discriminator 2 view .LVU144
 498 019c D2F85821 		ldr	r2, [r2, #344]
 499              		.loc 2 84 57 discriminator 2 view .LVU145
 500 01a0 D2ED0B6A 		vldr.32	s13, [r2, #44]
 501              		.loc 2 84 90 discriminator 2 view .LVU146
 502 01a4 11ED0D6A 		vldr.32	s12, [r1, #-52]
 503              		.loc 2 84 74 discriminator 2 view .LVU147
 504 01a8 66EE866A 		vmul.f32	s13, s13, s12
 505              		.loc 2 84 33 discriminator 2 view .LVU148
 506 01ac 77EEE67A 		vsub.f32	s15, s15, s13
 507              		.loc 2 84 16 discriminator 2 view .LVU149
 508 01b0 41ED0F7A 		vstr.32	s15, [r1, #-60]
 509              	.LVL43:
 510              		.loc 2 84 16 discriminator 2 view .LVU150
 511              	.LBE273:
  78:MotorControl/sensorless_estimator.cpp ****         // add observer action to flux estimate dynamics
 512              		.loc 2 78 5 is_stmt 1 discriminator 2 view .LVU151
 513 01b4 0133     		adds	r3, r3, #1
ARM GAS  /tmp/cced9Z1Y.s 			page 53


 514              	.LVL44:
  78:MotorControl/sensorless_estimator.cpp ****         // add observer action to flux estimate dynamics
 515              		.loc 2 78 5 is_stmt 0 discriminator 2 view .LVU152
 516 01b6 DAE7     		b	.L14
 517              	.L13:
  78:MotorControl/sensorless_estimator.cpp ****         // add observer action to flux estimate dynamics
 518              		.loc 2 78 5 discriminator 2 view .LVU153
 519              	.LBE272:
  85:MotorControl/sensorless_estimator.cpp ****     }
  86:MotorControl/sensorless_estimator.cpp **** 
  87:MotorControl/sensorless_estimator.cpp ****     // Flux state estimation done, store V_alpha_beta for next timestep
  88:MotorControl/sensorless_estimator.cpp ****     V_alpha_beta_memory_[0] = axis_->motor_.current_control_.final_v_alpha_;
 520              		.loc 2 88 5 is_stmt 1 view .LVU154
 521              		.loc 2 88 31 is_stmt 0 view .LVU155
 522 01b8 2368     		ldr	r3, [r4]
 523              	.LVL45:
 524              		.loc 2 88 38 view .LVU156
 525 01ba D3F85821 		ldr	r2, [r3, #344]
 526              		.loc 2 88 62 view .LVU157
 527 01be D2F86421 		ldr	r2, [r2, #356]	@ float
 528              		.loc 2 88 29 view .LVU158
 529 01c2 2262     		str	r2, [r4, #32]	@ float
  89:MotorControl/sensorless_estimator.cpp ****     V_alpha_beta_memory_[1] = axis_->motor_.current_control_.final_v_beta_;
 530              		.loc 2 89 5 is_stmt 1 view .LVU159
 531              		.loc 2 89 38 is_stmt 0 view .LVU160
 532 01c4 D3F85831 		ldr	r3, [r3, #344]
 533              		.loc 2 89 62 view .LVU161
 534 01c8 D3F86831 		ldr	r3, [r3, #360]	@ float
 535              		.loc 2 89 29 view .LVU162
 536 01cc 6362     		str	r3, [r4, #36]	@ float
  90:MotorControl/sensorless_estimator.cpp **** 
  91:MotorControl/sensorless_estimator.cpp ****     float phase_vel = phase_vel_.previous().value_or(0.0f);
 537              		.loc 2 91 5 is_stmt 1 view .LVU163
 538              	.LVL46:
 539              	.LBB274:
 540              	.LBI274:
  55:./MotorControl/component.hpp ****     }
  56:./MotorControl/component.hpp **** 
  57:./MotorControl/component.hpp ****     /**
  58:./MotorControl/component.hpp ****      * @brief Marks the contained value as outdated. The value is not actually
  59:./MotorControl/component.hpp ****      * deleted and can still be accessed through some of the member functions
  60:./MotorControl/component.hpp ****      * of this class.
  61:./MotorControl/component.hpp ****      */
  62:./MotorControl/component.hpp ****     void reset() {
  63:./MotorControl/component.hpp ****         // This will eventually overflow to 0 so present() could
  64:./MotorControl/component.hpp ****         // theoretically return a very old value however it is very likely that
  65:./MotorControl/component.hpp ****         // the motor will be long disarmed by then.
  66:./MotorControl/component.hpp ****         age_++;
  67:./MotorControl/component.hpp ****     }
  68:./MotorControl/component.hpp **** 
  69:./MotorControl/component.hpp ****     /**
  70:./MotorControl/component.hpp ****      * @brief Returns the value from this control loop iteration or std::nullopt
  71:./MotorControl/component.hpp ****      * if the value was not yet set during this control loop iteration.
  72:./MotorControl/component.hpp ****      */
  73:./MotorControl/component.hpp ****     std::optional<T> present() {
  74:./MotorControl/component.hpp ****         if (age_ == 0) {
  75:./MotorControl/component.hpp ****             return content_;
ARM GAS  /tmp/cced9Z1Y.s 			page 54


  76:./MotorControl/component.hpp ****         } else {
  77:./MotorControl/component.hpp ****             return std::nullopt;
  78:./MotorControl/component.hpp ****         }
  79:./MotorControl/component.hpp ****     }
  80:./MotorControl/component.hpp **** 
  81:./MotorControl/component.hpp ****     /**
  82:./MotorControl/component.hpp ****      * @brief Returns the value from exactly the previous control loop iteration.
  83:./MotorControl/component.hpp ****      * 
  84:./MotorControl/component.hpp ****      * If during the last iteration no value was set or the value was already
  85:./MotorControl/component.hpp ****      * overwritten during this control loop iteration then this function returns
  86:./MotorControl/component.hpp ****      * std::nullopt.
  87:./MotorControl/component.hpp ****      */
  88:./MotorControl/component.hpp ****     std::optional<T> previous() {
 541              		.loc 3 88 22 view .LVU164
 542              	.LBB275:
  89:./MotorControl/component.hpp ****         if (age_ == 1) {
 543              		.loc 3 89 13 is_stmt 0 view .LVU165
 544 01ce 236B     		ldr	r3, [r4, #48]
 545              		.loc 3 89 9 view .LVU166
 546 01d0 012B     		cmp	r3, #1
 547 01d2 75D0     		beq	.L26
 548              	.LVL47:
 549              	.LBB276:
 550              	.LBI276:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 551              		.loc 4 692 17 is_stmt 1 view .LVU167
 552              	.LBB277:
 553              	.LBB278:
 554              	.LBI278:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 555              		.loc 4 602 17 view .LVU168
 556              	.LBB279:
 557              	.LBI279:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 558              		.loc 4 302 7 view .LVU169
 559              	.LBB280:
 560              	.LBI280:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 561              		.loc 4 110 7 view .LVU170
 562              	.LBB281:
 563              	.LBB282:
 564              	.LBI282:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 565              		.loc 4 199 14 view .LVU171
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 566              		.loc 4 199 14 is_stmt 0 view .LVU172
 567              	.LBE282:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 568              		.loc 4 110 7 view .LVU173
 569 01d4 0023     		movs	r3, #0
 570 01d6 8DF83430 		strb	r3, [sp, #52]
 571              	.LVL48:
 572              	.L16:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 573              		.loc 4 110 7 view .LVU174
 574              	.LBE281:
 575              	.LBE280:
ARM GAS  /tmp/cced9Z1Y.s 			page 55


 576              	.LBE279:
 577              	.LBE278:
 578              	.LBE277:
 579              	.LBE276:
 580              	.LBE275:
 581              	.LBE274:
 582              	.LBB303:
 583              	.LBI303:
 917:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 918:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 919:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 920:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value() const&
 921:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 922:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 923:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? this->_M_get()
 924:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), this->_M_get());
 925:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 926:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 927:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 928:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value()&
 929:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 930:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 931:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? this->_M_get()
 932:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), this->_M_get());
 933:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 934:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 935:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&&
 936:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value()&&
 937:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 938:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 939:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? std::move(this->_M_get())
 940:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), std::move(this->_M_get()));
 941:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 942:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 943:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&&
 944:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value() const&&
 945:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 946:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 947:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? std::move(this->_M_get())
 948:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), std::move(this->_M_get()));
 949:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 950:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 952:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr _Tp
 953:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	value_or(_Up&& __u) const&
 954:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 955:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_copy_constructible_v<_Tp>);
 956:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_convertible_v<_Up&&, _Tp>);
 957:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 958:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_is_engaged()
 959:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    ? this->_M_get() : static_cast<_Tp>(std::forward<_Up>(__u));
 960:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 961:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 962:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 963:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr _Tp
 964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	value_or(_Up&& __u) &&
 584              		.loc 4 964 2 is_stmt 1 view .LVU175
ARM GAS  /tmp/cced9Z1Y.s 			page 56


 585              	.LBB304:
 586              	.LBB305:
 587              	.LBI305:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 588              		.loc 4 433 22 view .LVU176
 589              	.LBB306:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 590              		.loc 4 434 58 is_stmt 0 view .LVU177
 591 01da 9DF83430 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 592              	.LVL49:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 593              		.loc 4 434 58 view .LVU178
 594              	.LBE306:
 595              	.LBE305:
 965:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 966:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_move_constructible_v<_Tp>);
 967:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_convertible_v<_Up&&, _Tp>);
 968:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 969:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_is_engaged()
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    ? std::move(this->_M_get())
 596              		.loc 4 970 6 view .LVU179
 597 01de 002B     		cmp	r3, #0
 598 01e0 74D0     		beq	.L19
 599 01e2 DDED0C9A 		vldr.32	s19, [sp, #48]
 600              	.L17:
 601              	.LVL50:
 602              		.loc 4 970 6 view .LVU180
 603              	.LBE304:
 604              	.LBE303:
  92:MotorControl/sensorless_estimator.cpp **** 
  93:MotorControl/sensorless_estimator.cpp ****     // predict PLL phase with velocity
  94:MotorControl/sensorless_estimator.cpp ****     pll_pos_ = wrap_pm_pi(pll_pos_ + current_meas_period * phase_vel);
 605              		.loc 2 94 5 is_stmt 1 view .LVU181
 606              		.loc 2 94 27 is_stmt 0 view .LVU182
 607 01e6 D4ED057A 		vldr.32	s15, [r4, #20]
 608              		.loc 2 94 58 view .LVU183
 609 01ea 9FED3BAA 		vldr.32	s20, .L27
 610 01ee 29EE8A7A 		vmul.f32	s14, s19, s20
 611              	.LVL51:
 612              		.loc 2 94 26 view .LVU184
 613 01f2 77EE877A 		vadd.f32	s15, s15, s14
 614              	.LVL52:
 615              	.LBB308:
 616              	.LBI308:
 617              		.file 6 "./MotorControl/utils.hpp"
   1:./MotorControl/utils.hpp **** #pragma once
   2:./MotorControl/utils.hpp **** 
   3:./MotorControl/utils.hpp **** #include <stdint.h>
   4:./MotorControl/utils.hpp **** #include <limits>
   5:./MotorControl/utils.hpp **** #include <algorithm>
   6:./MotorControl/utils.hpp **** #include <array>
   7:./MotorControl/utils.hpp **** #include <tuple>
   8:./MotorControl/utils.hpp **** #include <cmath>
   9:./MotorControl/utils.hpp **** 
  10:./MotorControl/utils.hpp **** /**
  11:./MotorControl/utils.hpp ****  * @brief Flash size register address
  12:./MotorControl/utils.hpp ****  */
ARM GAS  /tmp/cced9Z1Y.s 			page 57


  13:./MotorControl/utils.hpp **** #define ID_FLASH_ADDRESS (0x1FFF7A22)
  14:./MotorControl/utils.hpp **** 
  15:./MotorControl/utils.hpp **** /**
  16:./MotorControl/utils.hpp ****  * @brief Device ID register address
  17:./MotorControl/utils.hpp ****  */
  18:./MotorControl/utils.hpp **** #define ID_DBGMCU_IDCODE (0xE0042000)
  19:./MotorControl/utils.hpp **** 
  20:./MotorControl/utils.hpp **** /**
  21:./MotorControl/utils.hpp ****  * "Returns" the device signature
  22:./MotorControl/utils.hpp ****  *
  23:./MotorControl/utils.hpp ****  * Possible returns:
  24:./MotorControl/utils.hpp ****  *    - 0x0413: STM32F405xx/07xx and STM32F415xx/17xx)
  25:./MotorControl/utils.hpp ****  *    - 0x0419: STM32F42xxx and STM32F43xxx
  26:./MotorControl/utils.hpp ****  *    - 0x0423: STM32F401xB/C
  27:./MotorControl/utils.hpp ****  *    - 0x0433: STM32F401xD/E
  28:./MotorControl/utils.hpp ****  *    - 0x0431: STM32F411xC/E
  29:./MotorControl/utils.hpp ****  *
  30:./MotorControl/utils.hpp ****  * Returned data is in 16-bit mode, but only bits 11:0 are valid, bits 15:12 are always 0.
  31:./MotorControl/utils.hpp ****  * Defined as macro
  32:./MotorControl/utils.hpp ****  */
  33:./MotorControl/utils.hpp **** #define STM_ID_GetSignature() ((*(uint16_t *)(ID_DBGMCU_IDCODE)) & 0x0FFF)
  34:./MotorControl/utils.hpp **** 
  35:./MotorControl/utils.hpp **** /**
  36:./MotorControl/utils.hpp ****  * "Returns" the device revision
  37:./MotorControl/utils.hpp ****  *
  38:./MotorControl/utils.hpp ****  * Revisions possible:
  39:./MotorControl/utils.hpp ****  *    - 0x1000: Revision A
  40:./MotorControl/utils.hpp ****  *    - 0x1001: Revision Z
  41:./MotorControl/utils.hpp ****  *    - 0x1003: Revision Y
  42:./MotorControl/utils.hpp ****  *    - 0x1007: Revision 1
  43:./MotorControl/utils.hpp ****  *    - 0x2001: Revision 3
  44:./MotorControl/utils.hpp ****  *
  45:./MotorControl/utils.hpp ****  * Returned data is in 16-bit mode.
  46:./MotorControl/utils.hpp ****  */
  47:./MotorControl/utils.hpp **** #define STM_ID_GetRevision() (*(uint16_t *)(ID_DBGMCU_IDCODE + 2))
  48:./MotorControl/utils.hpp **** 
  49:./MotorControl/utils.hpp **** /**
  50:./MotorControl/utils.hpp **** * "Returns" the Flash size
  51:./MotorControl/utils.hpp **** *
  52:./MotorControl/utils.hpp **** * Returned data is in 16-bit mode, returned value is flash size in kB (kilo bytes).
  53:./MotorControl/utils.hpp **** */
  54:./MotorControl/utils.hpp **** #define STM_ID_GetFlashSize() (*(uint16_t *)(ID_FLASH_ADDRESS))
  55:./MotorControl/utils.hpp **** 
  56:./MotorControl/utils.hpp **** #ifdef M_PI
  57:./MotorControl/utils.hpp **** #undef M_PI
  58:./MotorControl/utils.hpp **** #endif
  59:./MotorControl/utils.hpp **** 
  60:./MotorControl/utils.hpp **** // Math Constants
  61:./MotorControl/utils.hpp **** constexpr float M_PI = 3.14159265358979323846f;
  62:./MotorControl/utils.hpp **** constexpr float one_by_sqrt3 = 0.57735026919f;
  63:./MotorControl/utils.hpp **** constexpr float two_by_sqrt3 = 1.15470053838f;
  64:./MotorControl/utils.hpp **** constexpr float sqrt3_by_2 = 0.86602540378f;
  65:./MotorControl/utils.hpp **** 
  66:./MotorControl/utils.hpp **** // Function prototypes for implementations in utils.cpp
  67:./MotorControl/utils.hpp **** std::tuple<float, float, float, bool> SVM(float alpha, float beta);
  68:./MotorControl/utils.hpp **** float fast_atan2(float y, float x);
  69:./MotorControl/utils.hpp **** uint32_t deadline_to_timeout(uint32_t deadline_ms);
ARM GAS  /tmp/cced9Z1Y.s 			page 58


  70:./MotorControl/utils.hpp **** uint32_t timeout_to_deadline(uint32_t timeout_ms);
  71:./MotorControl/utils.hpp **** int is_in_the_future(uint32_t time_ms);
  72:./MotorControl/utils.hpp **** uint32_t micros(void);
  73:./MotorControl/utils.hpp **** void delay_us(uint32_t us);
  74:./MotorControl/utils.hpp **** 
  75:./MotorControl/utils.hpp **** extern "C" {
  76:./MotorControl/utils.hpp **** float our_arm_sin_f32(float x);
  77:./MotorControl/utils.hpp **** float our_arm_cos_f32(float x);
  78:./MotorControl/utils.hpp **** }
  79:./MotorControl/utils.hpp **** 
  80:./MotorControl/utils.hpp **** // ----------------
  81:./MotorControl/utils.hpp **** // Inline functions
  82:./MotorControl/utils.hpp **** 
  83:./MotorControl/utils.hpp **** template<typename T>
  84:./MotorControl/utils.hpp **** constexpr T SQ(const T& x){
  85:./MotorControl/utils.hpp ****     return x * x;
  86:./MotorControl/utils.hpp **** }
  87:./MotorControl/utils.hpp **** 
  88:./MotorControl/utils.hpp **** /**
  89:./MotorControl/utils.hpp ****  * @brief Small helper to make array with known size
  90:./MotorControl/utils.hpp ****  * in contrast to initializer lists the number of arguments
  91:./MotorControl/utils.hpp ****  * has to match exactly. Whereas initializer lists allow
  92:./MotorControl/utils.hpp ****  * less arguments.
  93:./MotorControl/utils.hpp ****  */
  94:./MotorControl/utils.hpp **** template <class T, class... Tail>
  95:./MotorControl/utils.hpp **** std::array<T, 1 + sizeof...(Tail)> make_array(T head, Tail... tail) {
  96:./MotorControl/utils.hpp ****     return std::array<T, 1 + sizeof...(Tail)>({head, tail...});
  97:./MotorControl/utils.hpp **** }
  98:./MotorControl/utils.hpp **** 
  99:./MotorControl/utils.hpp **** // To allow use of -ffast-math we need to have a special check for nan
 100:./MotorControl/utils.hpp **** // that bypasses the "ignore nan" flag
 101:./MotorControl/utils.hpp **** __attribute__((optimize("-fno-finite-math-only")))
 102:./MotorControl/utils.hpp **** inline bool is_nan(float x) {
 103:./MotorControl/utils.hpp ****     return __builtin_isnan(x);
 104:./MotorControl/utils.hpp **** }
 105:./MotorControl/utils.hpp **** 
 106:./MotorControl/utils.hpp **** // Round to integer
 107:./MotorControl/utils.hpp **** // Default rounding mode: round to nearest
 108:./MotorControl/utils.hpp **** inline int round_int(float x) {
 109:./MotorControl/utils.hpp **** #ifdef __arm__
 110:./MotorControl/utils.hpp ****     int res;
 111:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 112:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 113:./MotorControl/utils.hpp ****         : [x] "w" (x) );
 114:./MotorControl/utils.hpp ****     return res;
 115:./MotorControl/utils.hpp **** #else
 116:./MotorControl/utils.hpp ****     return (int)nearbyint(x);
 117:./MotorControl/utils.hpp **** #endif
 118:./MotorControl/utils.hpp **** }
 119:./MotorControl/utils.hpp **** 
 120:./MotorControl/utils.hpp **** // Wrap value to range.
 121:./MotorControl/utils.hpp **** // With default rounding mode (round to nearest),
 122:./MotorControl/utils.hpp **** // the result will be in range -y/2 to y/2
 123:./MotorControl/utils.hpp **** inline float wrap_pm(float x, float y) {
 124:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 125:./MotorControl/utils.hpp ****     float intval = (float)round_int(x / y);
 126:./MotorControl/utils.hpp **** #else
ARM GAS  /tmp/cced9Z1Y.s 			page 59


 127:./MotorControl/utils.hpp ****     float intval = nearbyintf(x / y);
 128:./MotorControl/utils.hpp **** #endif
 129:./MotorControl/utils.hpp ****     return x - intval * y;
 130:./MotorControl/utils.hpp **** }
 131:./MotorControl/utils.hpp **** 
 132:./MotorControl/utils.hpp **** // Same as fmodf but result is positive and y must be positive
 133:./MotorControl/utils.hpp **** inline float fmodf_pos(float x, float y) {
 134:./MotorControl/utils.hpp ****     float res = wrap_pm(x, y);
 135:./MotorControl/utils.hpp ****     if (res < 0) res += y;
 136:./MotorControl/utils.hpp ****     return res;
 137:./MotorControl/utils.hpp **** }
 138:./MotorControl/utils.hpp **** 
 139:./MotorControl/utils.hpp **** inline float wrap_pm_pi(float x) {
 618              		.loc 6 139 14 is_stmt 1 view .LVU185
 619              	.LBE308:
 140:./MotorControl/utils.hpp ****     return wrap_pm(x, 2 * M_PI);
 620              		.loc 6 140 5 view .LVU186
 621              	.LBB313:
 622              	.LBB309:
 623              	.LBI309:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 624              		.loc 6 123 14 view .LVU187
 625              	.LBB310:
 125:./MotorControl/utils.hpp **** #else
 626              		.loc 6 125 5 view .LVU188
 125:./MotorControl/utils.hpp **** #else
 627              		.loc 6 125 36 is_stmt 0 view .LVU189
 628 01f6 9FED3A9A 		vldr.32	s18, .L27+8
 629 01fa 87EE897A 		vdiv.f32	s14, s15, s18
 630              	.LVL53:
 631              	.LBB311:
 632              	.LBI311:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 633              		.loc 6 108 12 is_stmt 1 view .LVU190
 634              	.LBB312:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 635              		.loc 6 110 5 view .LVU191
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 636              		.loc 6 111 5 view .LVU192
 637              		.syntax unified
 638              	@ 111 "./MotorControl/utils.hpp" 1
 639 01fe BDEE477A 		vcvtr.s32.f32   s14, s14
 640              	@ 0 "" 2
 641              	.LVL54:
 114:./MotorControl/utils.hpp **** #else
 642              		.loc 6 114 5 view .LVU193
 114:./MotorControl/utils.hpp **** #else
 643              		.loc 6 114 5 is_stmt 0 view .LVU194
 644              		.thumb
 645              		.syntax unified
 646              	.LBE312:
 647              	.LBE311:
 125:./MotorControl/utils.hpp **** #else
 648              		.loc 6 125 42 view .LVU195
 649 0202 B8EEC77A 		vcvt.f32.s32	s14, s14
 650              	.LVL55:
 129:./MotorControl/utils.hpp **** }
ARM GAS  /tmp/cced9Z1Y.s 			page 60


 651              		.loc 6 129 5 is_stmt 1 view .LVU196
 129:./MotorControl/utils.hpp **** }
 652              		.loc 6 129 23 is_stmt 0 view .LVU197
 653 0206 27EE097A 		vmul.f32	s14, s14, s18
 654              	.LVL56:
 129:./MotorControl/utils.hpp **** }
 655              		.loc 6 129 25 view .LVU198
 656 020a 77EEC77A 		vsub.f32	s15, s15, s14
 657              	.LVL57:
 129:./MotorControl/utils.hpp **** }
 658              		.loc 6 129 25 view .LVU199
 659              	.LBE310:
 660              	.LBE309:
 661              	.LBE313:
 662              		.loc 2 94 14 view .LVU200
 663 020e C4ED057A 		vstr.32	s15, [r4, #20]
  95:MotorControl/sensorless_estimator.cpp ****     // update PLL phase with observer permanent magnet phase
  96:MotorControl/sensorless_estimator.cpp ****     float phase = fast_atan2(eta[1], eta[0]);
 664              		.loc 2 96 5 is_stmt 1 view .LVU201
 665              		.loc 2 96 29 is_stmt 0 view .LVU202
 666 0212 DDED010A 		vldr.32	s1, [sp, #4]
 667 0216 9DED020A 		vldr.32	s0, [sp, #8]
 668 021a FFF7FEFF 		bl	_Z10fast_atan2ff
 669              	.LVL58:
  97:MotorControl/sensorless_estimator.cpp ****     float delta_phase = wrap_pm_pi(phase - pll_pos_);
 670              		.loc 2 97 5 is_stmt 1 view .LVU203
 671              		.loc 2 97 44 is_stmt 0 view .LVU204
 672 021e 94ED057A 		vldr.32	s14, [r4, #20]
 673              		.loc 2 97 35 view .LVU205
 674 0222 70EE477A 		vsub.f32	s15, s0, s14
 675              	.LVL59:
 676              	.LBB314:
 677              	.LBI314:
 139:./MotorControl/utils.hpp ****     return wrap_pm(x, 2 * M_PI);
 678              		.loc 6 139 14 is_stmt 1 view .LVU206
 679              	.LBE314:
 680              		.loc 6 140 5 view .LVU207
 681              	.LBB319:
 682              	.LBB315:
 683              	.LBI315:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 684              		.loc 6 123 14 view .LVU208
 685              	.LBB316:
 125:./MotorControl/utils.hpp **** #else
 686              		.loc 6 125 5 view .LVU209
 125:./MotorControl/utils.hpp **** #else
 687              		.loc 6 125 36 is_stmt 0 view .LVU210
 688 0226 C7EE896A 		vdiv.f32	s13, s15, s18
 689              	.LVL60:
 690              	.LBB317:
 691              	.LBI317:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 692              		.loc 6 108 12 is_stmt 1 view .LVU211
 693              	.LBB318:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 694              		.loc 6 110 5 view .LVU212
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
ARM GAS  /tmp/cced9Z1Y.s 			page 61


 695              		.loc 6 111 5 view .LVU213
 696              		.syntax unified
 697              	@ 111 "./MotorControl/utils.hpp" 1
 698 022a FDEE666A 		vcvtr.s32.f32   s13, s13
 699              	@ 0 "" 2
 700              	.LVL61:
 114:./MotorControl/utils.hpp **** #else
 701              		.loc 6 114 5 view .LVU214
 114:./MotorControl/utils.hpp **** #else
 702              		.loc 6 114 5 is_stmt 0 view .LVU215
 703              		.thumb
 704              		.syntax unified
 705              	.LBE318:
 706              	.LBE317:
 125:./MotorControl/utils.hpp **** #else
 707              		.loc 6 125 42 view .LVU216
 708 022e F8EEE66A 		vcvt.f32.s32	s13, s13
 709              	.LVL62:
 129:./MotorControl/utils.hpp **** }
 710              		.loc 6 129 5 is_stmt 1 view .LVU217
 129:./MotorControl/utils.hpp **** }
 711              		.loc 6 129 23 is_stmt 0 view .LVU218
 712 0232 66EE896A 		vmul.f32	s13, s13, s18
 713              	.LVL63:
 129:./MotorControl/utils.hpp **** }
 714              		.loc 6 129 25 view .LVU219
 715 0236 77EEE66A 		vsub.f32	s13, s15, s13
 716              	.LVL64:
 129:./MotorControl/utils.hpp **** }
 717              		.loc 6 129 25 view .LVU220
 718              	.LBE316:
 719              	.LBE315:
 720              	.LBE319:
  98:MotorControl/sensorless_estimator.cpp ****     pll_pos_ = wrap_pm_pi(pll_pos_ + current_meas_period * pll_kp * delta_phase);
 721              		.loc 2 98 5 is_stmt 1 view .LVU221
 722              		.loc 2 98 67 is_stmt 0 view .LVU222
 723 023a 28EE268A 		vmul.f32	s16, s16, s13
 724              		.loc 2 98 26 view .LVU223
 725 023e 37EE088A 		vadd.f32	s16, s14, s16
 726              	.LVL65:
 727              	.LBB320:
 728              	.LBI320:
 139:./MotorControl/utils.hpp ****     return wrap_pm(x, 2 * M_PI);
 729              		.loc 6 139 14 is_stmt 1 view .LVU224
 730              	.LBE320:
 731              		.loc 6 140 5 view .LVU225
 732              	.LBB325:
 733              	.LBB321:
 734              	.LBI321:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 735              		.loc 6 123 14 view .LVU226
 736              	.LBB322:
 125:./MotorControl/utils.hpp **** #else
 737              		.loc 6 125 5 view .LVU227
 125:./MotorControl/utils.hpp **** #else
 738              		.loc 6 125 36 is_stmt 0 view .LVU228
 739 0242 C8EE097A 		vdiv.f32	s15, s16, s18
ARM GAS  /tmp/cced9Z1Y.s 			page 62


 740              	.LVL66:
 741              	.LBB323:
 742              	.LBI323:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 743              		.loc 6 108 12 is_stmt 1 view .LVU229
 744              	.LBB324:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 745              		.loc 6 110 5 view .LVU230
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 746              		.loc 6 111 5 view .LVU231
 747              		.syntax unified
 748              	@ 111 "./MotorControl/utils.hpp" 1
 749 0246 FDEE677A 		vcvtr.s32.f32   s15, s15
 750              	@ 0 "" 2
 751              	.LVL67:
 114:./MotorControl/utils.hpp **** #else
 752              		.loc 6 114 5 view .LVU232
 114:./MotorControl/utils.hpp **** #else
 753              		.loc 6 114 5 is_stmt 0 view .LVU233
 754              		.thumb
 755              		.syntax unified
 756              	.LBE324:
 757              	.LBE323:
 125:./MotorControl/utils.hpp **** #else
 758              		.loc 6 125 42 view .LVU234
 759 024a F8EEE77A 		vcvt.f32.s32	s15, s15
 760              	.LVL68:
 129:./MotorControl/utils.hpp **** }
 761              		.loc 6 129 5 is_stmt 1 view .LVU235
 129:./MotorControl/utils.hpp **** }
 762              		.loc 6 129 23 is_stmt 0 view .LVU236
 763 024e 27EE899A 		vmul.f32	s18, s15, s18
 129:./MotorControl/utils.hpp **** }
 764              		.loc 6 129 25 view .LVU237
 765 0252 38EE498A 		vsub.f32	s16, s16, s18
 766              	.LVL69:
 129:./MotorControl/utils.hpp **** }
 767              		.loc 6 129 25 view .LVU238
 768              	.LBE322:
 769              	.LBE321:
 770              	.LBE325:
 771              		.loc 2 98 14 view .LVU239
 772 0256 84ED058A 		vstr.32	s16, [r4, #20]
  99:MotorControl/sensorless_estimator.cpp ****     // update PLL velocity
 100:MotorControl/sensorless_estimator.cpp ****     phase_vel += current_meas_period * pll_ki * delta_phase;
 773              		.loc 2 100 5 is_stmt 1 view .LVU240
 774              		.loc 2 100 38 is_stmt 0 view .LVU241
 775 025a 68EE8A7A 		vmul.f32	s15, s17, s20
 776              		.loc 2 100 47 view .LVU242
 777 025e 67EEA67A 		vmul.f32	s15, s15, s13
 778              		.loc 2 100 15 view .LVU243
 779 0262 77EEA97A 		vadd.f32	s15, s15, s19
 780              	.LVL70:
 101:MotorControl/sensorless_estimator.cpp **** 
 102:MotorControl/sensorless_estimator.cpp ****     // set outputs
 103:MotorControl/sensorless_estimator.cpp ****     phase_ = phase;
 781              		.loc 2 103 5 is_stmt 1 view .LVU244
ARM GAS  /tmp/cced9Z1Y.s 			page 63


 782              	.LBB326:
 783              	.LBI326:
  52:./MotorControl/component.hpp ****         content_ = value;
 784              		.loc 3 52 10 view .LVU245
 785              	.LBB327:
  53:./MotorControl/component.hpp ****         age_ = 0;
 786              		.loc 3 53 18 is_stmt 0 view .LVU246
 787 0266 84ED0B0A 		vstr.32	s0, [r4, #44]
  54:./MotorControl/component.hpp ****     }
 788              		.loc 3 54 14 view .LVU247
 789 026a 0023     		movs	r3, #0
 790 026c A362     		str	r3, [r4, #40]
 791              	.LVL71:
  54:./MotorControl/component.hpp ****     }
 792              		.loc 3 54 14 view .LVU248
 793              	.LBE327:
 794              	.LBE326:
 104:MotorControl/sensorless_estimator.cpp ****     phase_vel_ = phase_vel;
 795              		.loc 2 104 5 is_stmt 1 view .LVU249
 796              	.LBB328:
 797              	.LBI328:
  52:./MotorControl/component.hpp ****         content_ = value;
 798              		.loc 3 52 10 view .LVU250
 799              	.LBB329:
  53:./MotorControl/component.hpp ****         age_ = 0;
 800              		.loc 3 53 18 is_stmt 0 view .LVU251
 801 026e C4ED0D7A 		vstr.32	s15, [r4, #52]
  54:./MotorControl/component.hpp ****     }
 802              		.loc 3 54 14 view .LVU252
 803 0272 2363     		str	r3, [r4, #48]
 804              	.LVL72:
  54:./MotorControl/component.hpp ****     }
 805              		.loc 3 54 14 view .LVU253
 806              	.LBE329:
 807              	.LBE328:
 105:MotorControl/sensorless_estimator.cpp ****     vel_estimate_ = phase_vel / (std::max((float)axis_->motor_.config_.pole_pairs, 1.0f) * 2.0f * M
 808              		.loc 2 105 5 is_stmt 1 view .LVU254
 809              		.loc 2 105 50 is_stmt 0 view .LVU255
 810 0274 2368     		ldr	r3, [r4]
 811              		.loc 2 105 57 view .LVU256
 812 0276 D3F85831 		ldr	r3, [r3, #344]
 813              		.loc 2 105 72 view .LVU257
 814 027a 93ED087A 		vldr.32	s14, [r3, #32]	@ int
 815              		.loc 2 105 43 view .LVU258
 816 027e B8EEC77A 		vcvt.f32.s32	s14, s14
 817 0282 8DED0E7A 		vstr.32	s14, [sp, #56]
 818              		.loc 2 105 84 view .LVU259
 819 0286 F7EE006A 		vmov.f32	s13, #1.0e+0
 820              	.LVL73:
 821              		.loc 2 105 84 view .LVU260
 822 028a CDED0F6A 		vstr.32	s13, [sp, #60]
 823              	.LVL74:
 824              	.LBB330:
 825              	.LBI330:
 826              		.file 7 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Core algorithmic facilities -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
ARM GAS  /tmp/cced9Z1Y.s 			page 64


   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Copyright (C) 2001-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** /*
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Copyright (c) 1994
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Hewlett-Packard Company
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Permission to use, copy, modify, distribute and sell this software
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * and its documentation for any purpose is hereby granted without fee,
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * provided that the above copyright notice appear in all copies and
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * that both that copyright notice and this permission notice appear
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * in supporting documentation.  Hewlett-Packard Company makes no
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * representations about the suitability of this software for any
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Copyright (c) 1996-1998
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Silicon Graphics Computer Systems, Inc.
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Permission to use, copy, modify, distribute and sell this software
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * and its documentation for any purpose is hereby granted without fee,
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * provided that the above copyright notice appear in all copies and
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * that both that copyright notice and this permission notice appear
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * in supporting documentation.  Silicon Graphics makes no
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * representations about the suitability of this software for any
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  */
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** /** @file bits/stl_algobase.h
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *  This is an internal header file, included by other library headers.
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *  Do not attempt to use it directly. @headername{algorithm}
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  */
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #ifndef _STL_ALGOBASE_H
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #define _STL_ALGOBASE_H 1
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/c++config.h>
ARM GAS  /tmp/cced9Z1Y.s 			page 65


  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/functexcept.h>
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/cpp_type_traits.h>
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <ext/type_traits.h>
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <ext/numeric_traits.h>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_pair.h>
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator_base_types.h>
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator_base_funcs.h>
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator.h>
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/concept_check.h>
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <debug/debug.h>
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/move.h> // For std::swap
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/predefined_ops.h>
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** # include <type_traits>
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus > 201703L
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** # include <compare>
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** namespace std _GLIBCXX_VISIBILITY(default)
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** {
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /*
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    * A constexpr wrapper for __builtin_memcmp.
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    * @param __num The number of elements of type _Tp (not bytes).
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    */
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp, typename _Up>
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline int
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #ifdef __cpp_lib_is_constant_evaluated
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (std::is_constant_evaluated())
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  for(; __num > 0; ++__first1, ++__first2, --__num)
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    if (*__first1 != *__first2)
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      return *__first1 < *__first2 ? -1 : 1;
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return 0;
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       else
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus < 201103L
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // nutshell, we are partially implementing the resolution of DR 187,
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // when it's safe, i.e., the value_types are equal.
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _BoolType>
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __iter_swap
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _ForwardIterator1, typename _ForwardIterator2>
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static void
ARM GAS  /tmp/cced9Z1Y.s 			page 66


 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  typedef typename iterator_traits<_ForwardIterator1>::value_type
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    _ValueType1;
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  _ValueType1 __tmp = *__a;
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  *__a = *__b;
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  *__b = __tmp;
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<>
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __iter_swap<true>
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _ForwardIterator1, typename _ForwardIterator2>
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static void
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  swap(*__a, *__b);
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif // C++03
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Swaps the contents of two iterators.
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  An iterator.
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another iterator.
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   Nothing.
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This function swaps the values pointed to by two iterators, not the
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  iterators themselves.
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2>
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline void
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator1>)
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator2>)
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus < 201103L
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator1>::value_type
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ValueType1;
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator2>::value_type
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ValueType2;
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ValueType2>)
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ValueType1>)
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator1>::reference
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ReferenceType1;
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator2>::reference
ARM GAS  /tmp/cced9Z1Y.s 			page 67


 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ReferenceType2;
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	&& __are_same<_ValueType1&, _ReferenceType1>::__value
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	&& __are_same<_ValueType2&, _ReferenceType2>::__value>::
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(__a, __b);
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #else
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // _GLIBCXX_RESOLVE_LIB_DEFECTS
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // 187. iter_swap underspecified
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       swap(*__a, *__b);
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Swap the elements of two sequences.
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first1  A forward iterator.
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __last1   A forward iterator.
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first2  A forward iterator.
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   An iterator equal to @p first2+(last1-first1).
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  Swaps each element in the range @p [first1,last1) with the
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  corresponding element in the range @p [first2,(last1-first1)).
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  The ranges must not overlap.
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2>
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _ForwardIterator2
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		_ForwardIterator2 __first2)
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator1>)
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator2>)
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_requires_valid_range(__first1, __last1);
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       for (; __first1 != __last1; ++__first1, (void)++__first2)
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	std::iter_swap(__first1, __first2);
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __first2;
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief This does what you think it does.
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup sorting_algorithms
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  A thing of arbitrary type.
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another thing of arbitrary type.
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   The lesser of the parameters.
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This is the simple classic generic implementation.  It will work on
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  temporary expressions, since they are only evaluated once, unlike a
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  preprocessor macro.
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp>
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline const _Tp&
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     min(const _Tp& __a, const _Tp& __b)
ARM GAS  /tmp/cced9Z1Y.s 			page 68


 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       //return __b < __a ? __b : __a;
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (__b < __a)
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief This does what you think it does.
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup sorting_algorithms
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  A thing of arbitrary type.
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another thing of arbitrary type.
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   The greater of the parameters.
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This is the simple classic generic implementation.  It will work on
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  temporary expressions, since they are only evaluated once, unlike a
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  preprocessor macro.
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp>
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline const _Tp&
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     max(const _Tp& __a, const _Tp& __b)
 827              		.loc 7 254 5 is_stmt 1 view .LVU261
 828              	.LBB331:
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       //return  __a < __b ? __b : __a;
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (__a < __b)
 829              		.loc 7 259 7 is_stmt 0 view .LVU262
 830 028e B4EEE67A 		vcmpe.f32	s14, s13
 831 0292 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 832 0296 1CD4     		bmi	.L20
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 833              		.loc 7 261 14 view .LVU263
 834 0298 0EAB     		add	r3, sp, #56
 835              	.LVL75:
 836              	.L18:
 837              		.loc 7 261 14 view .LVU264
 838              	.LBE331:
 839              	.LBE330:
 840              		.loc 2 105 42 view .LVU265
 841 029a 93ED007A 		vldr.32	s14, [r3]
 842              		.loc 2 105 90 view .LVU266
 843 029e 37EE077A 		vadd.f32	s14, s14, s14
 844              		.loc 2 105 97 view .LVU267
 845 02a2 DFED106A 		vldr.32	s13, .L27+12
 846              		.loc 2 105 97 view .LVU268
 847 02a6 27EE267A 		vmul.f32	s14, s14, s13
 848              		.loc 2 105 19 view .LVU269
 849 02aa C7EE876A 		vdiv.f32	s13, s15, s14
 850              	.LVL76:
 851              	.LBB333:
 852              	.LBI333:
ARM GAS  /tmp/cced9Z1Y.s 			page 69


  52:./MotorControl/component.hpp ****         content_ = value;
 853              		.loc 3 52 10 is_stmt 1 view .LVU270
 854              	.LBB334:
  53:./MotorControl/component.hpp ****         age_ = 0;
 855              		.loc 3 53 18 is_stmt 0 view .LVU271
 856 02ae C4ED0F6A 		vstr.32	s13, [r4, #60]
  54:./MotorControl/component.hpp ****     }
 857              		.loc 3 54 14 view .LVU272
 858 02b2 0023     		movs	r3, #0
 859 02b4 A363     		str	r3, [r4, #56]
 860              	.LVL77:
  54:./MotorControl/component.hpp ****     }
 861              		.loc 3 54 14 view .LVU273
 862              	.LBE334:
 863              	.LBE333:
 106:MotorControl/sensorless_estimator.cpp **** 
 107:MotorControl/sensorless_estimator.cpp ****     return true;
 864              		.loc 2 107 5 is_stmt 1 view .LVU274
 865              	.L6:
 108:MotorControl/sensorless_estimator.cpp **** };
 866              		.loc 2 108 1 is_stmt 0 view .LVU275
 867 02b6 2846     		mov	r0, r5
 868 02b8 10B0     		add	sp, sp, #64
 869              	.LCFI3:
 870              		.cfi_remember_state
 871              		.cfi_def_cfa_offset 40
 872              		@ sp needed
 873 02ba BDEC068B 		vldm	sp!, {d8-d10}
 874              	.LCFI4:
 875              		.cfi_restore 84
 876              		.cfi_restore 85
 877              		.cfi_restore 82
 878              		.cfi_restore 83
 879              		.cfi_restore 80
 880              		.cfi_restore 81
 881              		.cfi_def_cfa_offset 16
 882 02be 70BD     		pop	{r4, r5, r6, pc}
 883              	.LVL78:
 884              	.L26:
 885              	.LCFI5:
 886              		.cfi_restore_state
 887              	.LBB335:
 888              	.LBB302:
 889              	.LBB283:
 890              	.LBI283:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 891              		.loc 4 700 2 is_stmt 1 view .LVU276
 892              	.LBB284:
 893              	.LBB285:
 894              	.LBB286:
 895              	.LBI286:
 896              		.file 8 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Move, forward and identity for C++11 + swap -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Copyright (C) 2007-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // This file is part of the GNU ISO C++ Library.  This library is free
ARM GAS  /tmp/cced9Z1Y.s 			page 70


   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** /** @file bits/move.h
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****  *  This is an internal header file, included by other library headers.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****  *  Do not attempt to use it directly. @headername{utility}
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****  */
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #ifndef _MOVE_H
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #define _MOVE_H 1
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #include <bits/c++config.h>
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #if __cplusplus < 201103L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** # include <bits/concept_check.h>
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #endif
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** namespace std _GLIBCXX_VISIBILITY(default)
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** {
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   // Used, in C++03 mode too, by allocators, etc.
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief Same as C++11 std::addressof
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @ingroup utilities
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     inline _GLIBCXX_CONSTEXPR _Tp*
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return __builtin_addressof(__r); }
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #if __cplusplus >= 201103L
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** _GLIBCXX_END_NAMESPACE_VERSION
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** } // namespace
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #include <type_traits> // Brings in std::declval too.
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** namespace std _GLIBCXX_VISIBILITY(default)
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** {
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
ARM GAS  /tmp/cced9Z1Y.s 			page 71


  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @addtogroup utilities
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @{
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief  Forward an lvalue.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @return The parameter cast to the specified type.
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  This function is used to implement "perfect forwarding".
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     constexpr _Tp&&
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 897              		.loc 8 76 5 view .LVU277
 898              		.loc 8 76 5 is_stmt 0 view .LVU278
 899              	.LBE286:
 900              	.LBB287:
 901              	.LBI287:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 902              		.loc 4 607 28 is_stmt 1 view .LVU279
 903              	.LBB288:
 904              	.LBB289:
 905              	.LBB290:
 906              	.LBI290:
 907              		.loc 8 76 5 view .LVU280
 908              		.loc 8 76 5 is_stmt 0 view .LVU281
 909              	.LBE290:
 910              	.LBB291:
 911              	.LBI291:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 912              		.loc 4 300 42 is_stmt 1 view .LVU282
 913              	.LBB292:
 914              	.LBB293:
 915              	.LBB294:
 916              	.LBI294:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 917              		.loc 4 115 2 view .LVU283
 918              	.LBB295:
 919              	.LBB296:
 920              	.LBB297:
 921              	.LBI297:
 922              		.loc 8 76 5 view .LVU284
 923              		.loc 8 76 5 is_stmt 0 view .LVU285
 924              	.LBE297:
 925              	.LBB298:
 926              	.LBI298:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 927              		.loc 4 203 6 is_stmt 1 view .LVU286
 928              	.LBB299:
 929              	.LBB300:
 930              	.LBB301:
 931              	.LBI301:
 932              		.loc 8 76 5 view .LVU287
 933              		.loc 8 76 5 is_stmt 0 view .LVU288
 934              	.LBE301:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
ARM GAS  /tmp/cced9Z1Y.s 			page 72


 935              		.loc 4 204 47 view .LVU289
 936 02c0 636B     		ldr	r3, [r4, #52]	@ float
 937 02c2 0C93     		str	r3, [sp, #48]	@ float
 938              	.LVL79:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 939              		.loc 4 204 47 view .LVU290
 940              	.LBE300:
 941              	.LBE299:
 942              	.LBE298:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 943              		.loc 4 117 19 view .LVU291
 944 02c4 0123     		movs	r3, #1
 945 02c6 8DF83430 		strb	r3, [sp, #52]
 946              	.LVL80:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 947              		.loc 4 117 19 view .LVU292
 948              	.LBE296:
 949              	.LBE295:
 950              	.LBE294:
 951              	.LBE293:
 952              	.LBE292:
 953              	.LBE291:
 954              	.LBE289:
 955              	.LBE288:
 956              	.LBE287:
 957              	.LBE285:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 958              		.loc 4 701 51 view .LVU293
 959 02ca 86E7     		b	.L16
 960              	.LVL81:
 961              	.L19:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 962              		.loc 4 701 51 view .LVU294
 963              	.LBE284:
 964              	.LBE283:
 965              	.LBE302:
 966              	.LBE335:
 967              	.LBB336:
 968              	.LBB307:
 969              		.loc 4 970 6 view .LVU295
 970 02cc DFED069A 		vldr.32	s19, .L27+16
 971 02d0 89E7     		b	.L17
 972              	.LVL82:
 973              	.L20:
 974              		.loc 4 970 6 view .LVU296
 975              	.LBE307:
 976              	.LBE336:
 977              	.LBB337:
 978              	.LBB332:
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 979              		.loc 7 260 9 view .LVU297
 980 02d2 0FAB     		add	r3, sp, #60
 981              	.LVL83:
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 982              		.loc 7 260 9 view .LVU298
 983 02d4 E1E7     		b	.L18
 984              	.L28:
ARM GAS  /tmp/cced9Z1Y.s 			page 73


 985 02d6 00BF     		.align	2
 986              	.L27:
 987 02d8 6F120339 		.word	956502639
 988 02dc 3ACD133F 		.word	1058262330
 989 02e0 DB0FC940 		.word	1086918619
 990 02e4 DB0F4940 		.word	1078530011
 991 02e8 00000000 		.word	0
 992              	.LBE332:
 993              	.LBE337:
 994              		.cfi_endproc
 995              	.LFE5159:
 996              		.fnend
 998              		.text
 999              	.Letext0:
 1000              		.file 9 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/machine/_default_types.h"
 1001              		.file 10 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/_stdint.h"
 1002              		.file 11 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdint.h"
 1003              		.file 12 "/opt/gcc-arm-none-eabi/lib/gcc/arm-none-eabi/10.3.1/include/stddef.h"
 1004              		.file 13 "/opt/gcc-arm-none-eabi/lib/gcc/arm-none-eabi/10.3.1/include/stdarg.h"
 1005              		.file 14 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/_types.h"
 1006              		.file 15 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/reent.h"
 1007              		.file 16 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/lock.h"
 1008              		.file 17 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdio.h"
 1009              		.file 18 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdlib"
 1010              		.file 19 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h"
 1011              		.file 20 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath"
 1012              		.file 21 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/type_traits"
 1013              		.file 22 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/arm-none-eabi/thumb/v7e-m+fp/har
 1014              		.file 23 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/debug/debug.h"
 1015              		.file 24 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/utility"
 1016              		.file 25 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception_ptr.h"
 1017              		.file 26 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_iterator.h"
 1018              		.file 27 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h"
 1019              		.file 28 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/algorithmfwd.h"
 1020              		.file 29 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional"
 1021              		.file 30 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstring"
 1022              		.file 31 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/enable_special_members.h"
 1023              		.file 32 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/parse_numbers.h"
 1024              		.file 33 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cwchar"
 1025              		.file 34 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/clocale"
 1026              		.file 35 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdint"
 1027              		.file 36 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/string_view"
 1028              		.file 37 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/basic_string.h"
 1029              		.file 38 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdio"
 1030              		.file 39 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/predefined_ops.h"
 1031              		.file 40 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdlib.h"
 1032              		.file 41 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/stdlib.h"
 1033              		.file 42 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/math.h"
 1034              		.file 43 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/math.h"
 1035              		.file 44 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/string.h"
 1036              		.file 45 "fibre-cpp/include/fibre/cpp_utils.hpp"
 1037              		.file 46 "fibre-cpp/include/fibre/callback.hpp"
 1038              		.file 47 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/pstl/execution_defs.h"
 1039              		.file 48 "Board/v3/Inc/board.h"
 1040              		.file 49 "MotorControl/sensorless_estimator.hpp"
 1041              		.file 50 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/wchar.h"
 1042              		.file 51 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/locale.h"
ARM GAS  /tmp/cced9Z1Y.s 			page 74


 1043              		.file 52 "<built-in>"
ARM GAS  /tmp/cced9Z1Y.s 			page 75


DEFINED SYMBOLS
                            *ABS*:0000000000000000 sensorless_estimator.cpp
     /tmp/cced9Z1Y.s:20     .text._ZoRRN10ODriveIntf8AxisIntf5ErrorES1_:0000000000000000 $t
     /tmp/cced9Z1Y.s:26     .text._ZoRRN10ODriveIntf8AxisIntf5ErrorES1_:0000000000000000 _ZoRRN10ODriveIntf8AxisIntf5ErrorES1_
.ARM.exidx.text._ZoRRN10ODriveIntf8AxisIntf5ErrorES1_:0000000000000000 $d
     /tmp/cced9Z1Y.s:51     .text._ZoRRN10ODriveIntf23SensorlessEstimatorIntf5ErrorES1_:0000000000000000 $t
     /tmp/cced9Z1Y.s:57     .text._ZoRRN10ODriveIntf23SensorlessEstimatorIntf5ErrorES1_:0000000000000000 _ZoRRN10ODriveIntf23SensorlessEstimatorIntf5ErrorES1_
.ARM.exidx.text._ZoRRN10ODriveIntf23SensorlessEstimatorIntf5ErrorES1_:0000000000000000 $d
     /tmp/cced9Z1Y.s:81     .text._ZN19SensorlessEstimator5resetEv:0000000000000000 $t
     /tmp/cced9Z1Y.s:87     .text._ZN19SensorlessEstimator5resetEv:0000000000000000 _ZN19SensorlessEstimator5resetEv
.ARM.exidx.text._ZN19SensorlessEstimator5resetEv:0000000000000000 $d
     /tmp/cced9Z1Y.s:137    .text._ZN19SensorlessEstimator6updateEv:0000000000000000 $t
     /tmp/cced9Z1Y.s:143    .text._ZN19SensorlessEstimator6updateEv:0000000000000000 _ZN19SensorlessEstimator6updateEv
     /tmp/cced9Z1Y.s:987    .text._ZN19SensorlessEstimator6updateEv:00000000000002d8 $d
.ARM.extab.text._ZN19SensorlessEstimator6updateEv:0000000000000000 $d
.ARM.exidx.text._ZN19SensorlessEstimator6updateEv:0000000000000000 $d

UNDEFINED SYMBOLS
_Z10fast_atan2ff
__aeabi_unwind_cpp_pr1
