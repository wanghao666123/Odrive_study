ARM GAS  /tmp/ccoErako.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"can_simple.cpp"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text._ZNKSt18bad_variant_access4whatEv,"axG",%progbits,_ZNKSt18bad_variant_access4whatEv
  20              		.align	1
  21              		.weak	_ZNKSt18bad_variant_access4whatEv
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	_ZNKSt18bad_variant_access4whatEv:
  27              		.fnstart
  28              	.LVL0:
  29              	.LFB3280:
  30              		.file 1 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // <variant> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // Copyright (C) 2016-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** /** @file variant
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****  *  This is the `<variant>` C++ Library header.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****  */
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/ccoErako.s 			page 2


  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #ifndef _GLIBCXX_VARIANT
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define _GLIBCXX_VARIANT 1
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #pragma GCC system_header
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #if __cplusplus >= 201703L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <type_traits>
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <utility>
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/enable_special_members.h>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/functexcept.h>
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/move.h>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/functional_hash.h>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/invoke.h>
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <ext/aligned_buffer.h>
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/parse_numbers.h>
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/stl_iterator_base_types.h>
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/stl_iterator_base_funcs.h>
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/stl_construct.h>
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #if __cplusplus > 201703L
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** # include <compare>
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #endif
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace std _GLIBCXX_VISIBILITY(default)
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __detail
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __variant
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Nth_type;
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _First, typename... _Rest>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Nth_type<_Np, _First, _Rest...>
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _Nth_type<_Np-1, _Rest...> { };
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _First, typename... _Rest>
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Nth_type<0, _First, _Rest...>
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = _First; };
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __variant
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __detail
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define __cpp_lib_variant 201606L
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types> class tuple;
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types> class variant;
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename> struct hash;
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size;
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<const _Variant> : variant_size<_Variant> {};
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/ccoErako.s 			page 3


  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<volatile _Variant> : variant_size<_Variant> {};
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<const volatile _Variant> : variant_size<_Variant> {};
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<variant<_Types...>>
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : std::integral_constant<size_t, sizeof...(_Types)> {};
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr size_t variant_size_v = variant_size<_Variant>::value;
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative;
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _First, typename... _Rest>
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, variant<_First, _Rest...>>
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : variant_alternative<_Np-1, variant<_Rest...>> {};
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _First, typename... _Rest>
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<0, variant<_First, _Rest...>>
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = _First; };
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using variant_alternative_t =
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       typename variant_alternative<_Np, _Variant>::type;
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, const _Variant>
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = add_const_t<variant_alternative_t<_Np, _Variant>>; };
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, volatile _Variant>
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = add_volatile_t<variant_alternative_t<_Np, _Variant>>; };
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, const volatile _Variant>
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = add_cv_t<variant_alternative_t<_Np, _Variant>>; };
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   inline constexpr size_t variant_npos = -1;
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>>&
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(variant<_Types...>&);
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>>&&
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(variant<_Types...>&&);
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>> const&
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(const variant<_Types...>&);
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>> const&&
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(const variant<_Types...>&&);
ARM GAS  /tmp/ccoErako.s 			page 4


 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, typename... _Variants>
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __do_visit(_Visitor&& __visitor, _Variants&&... __variants);
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename... _Types, typename _Tp>
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     decltype(auto)
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __variant_cast(_Tp&& __rhs)
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if constexpr (is_lvalue_reference_v<_Tp>)
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (is_const_v<remove_reference_t<_Tp>>)
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return static_cast<const variant<_Types...>&>(__rhs);
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return static_cast<variant<_Types...>&>(__rhs);
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       else
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         return static_cast<variant<_Types...>&&>(__rhs);
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __detail
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __variant
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns the first appearence of _Tp in _Types.
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns sizeof...(_Types) if _Tp is not in _Types.
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __index_of : std::integral_constant<size_t, 0> {};
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr size_t __index_of_v = __index_of<_Tp, _Types...>::value;
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _First, typename... _Rest>
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __index_of<_Tp, _First, _Rest...> :
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       std::integral_constant<size_t, is_same_v<_Tp, _First>
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	? 0 : __index_of_v<_Tp, _Rest...> + 1> {};
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // used for raw visitation
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   struct __variant_cookie {};
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // used for raw visitation with indices passed in
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   struct __variant_idx_cookie { using type = __variant_idx_cookie; };
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Used to enable deduction (and same-type checking) for std::visit:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename> struct __deduce_visit_result { };
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Visit variants that might be valueless.
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr void
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __raw_visit(_Visitor&& __visitor, _Variants&&... __variants)
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       std::__do_visit<__variant_cookie>(std::forward<_Visitor>(__visitor),
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				        std::forward<_Variants>(__variants)...);
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Visit variants that might be valueless, passing indices to the visitor.
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr void
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __raw_idx_visit(_Visitor&& __visitor, _Variants&&... __variants)
ARM GAS  /tmp/ccoErako.s 			page 5


 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       std::__do_visit<__variant_idx_cookie>(std::forward<_Visitor>(__visitor),
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  std::forward<_Variants>(__variants)...);
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // _Uninitialized<T> is guaranteed to be a trivially destructible type,
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // even if T is not.
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Type, bool = std::is_trivially_destructible_v<_Type>>
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Uninitialized;
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Type>
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Uninitialized<_Type, true>
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Uninitialized(in_place_index_t<0>, _Args&&... __args)
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_storage(std::forward<_Args>(__args)...)
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr const _Type& _M_get() const & noexcept
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr _Type& _M_get() & noexcept
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr const _Type&& _M_get() const && noexcept
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(_M_storage); }
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr _Type&& _M_get() && noexcept
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(_M_storage); }
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Type _M_storage;
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Type>
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Uninitialized<_Type, false>
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Uninitialized(in_place_index_t<0>, _Args&&... __args)
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  ::new ((void*)std::addressof(_M_storage))
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    _Type(std::forward<_Args>(__args)...);
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       const _Type& _M_get() const & noexcept
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return *_M_storage._M_ptr(); }
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Type& _M_get() & noexcept
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return *_M_storage._M_ptr(); }
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       const _Type&& _M_get() const && noexcept
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(*_M_storage._M_ptr()); }
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Type&& _M_get() && noexcept
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(*_M_storage._M_ptr()); }
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/ccoErako.s 			page 6


 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __gnu_cxx::__aligned_membuf<_Type> _M_storage;
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Union>
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __get(in_place_index_t<0>, _Union&& __u) noexcept
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Union>
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __get(in_place_index_t<_Np>, _Union&& __u) noexcept
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __variant::__get(in_place_index<_Np-1>,
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			      std::forward<_Union>(__u)._M_rest);
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns the typed storage for __v.
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __get(_Variant&& __v) noexcept
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __variant::__get(std::in_place_index<_Np>,
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			      std::forward<_Variant>(__v)._M_u);
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Traits
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_default_ctor =
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  is_default_constructible_v<typename _Nth_type<0, _Types...>::type>;
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_copy_ctor =
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_copy_constructible_v<_Types> && ...);
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_move_ctor =
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_move_constructible_v<_Types> && ...);
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_copy_assign =
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_copy_ctor
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_copy_assignable_v<_Types> && ...);
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_move_assign =
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_move_ctor
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_move_assignable_v<_Types> && ...);
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_dtor =
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_trivially_destructible_v<_Types> && ...);
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_copy_ctor =
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_trivially_copy_constructible_v<_Types> && ...);
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_move_ctor =
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_trivially_move_constructible_v<_Types> && ...);
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_copy_assign =
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_trivial_dtor && _S_trivial_copy_ctor
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_trivially_copy_assignable_v<_Types> && ...);
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_move_assign =
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_trivial_dtor && _S_trivial_move_ctor
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_trivially_move_assignable_v<_Types> && ...);
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // The following nothrow traits are for non-trivial SMFs. Trivial SMFs
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // are always nothrow.
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_default_ctor =
ARM GAS  /tmp/ccoErako.s 			page 7


 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  is_nothrow_default_constructible_v<
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      typename _Nth_type<0, _Types...>::type>;
 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_copy_ctor = false;
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_move_ctor =
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_nothrow_move_constructible_v<_Types> && ...);
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_copy_assign = false;
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_move_assign =
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_nothrow_move_ctor
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_nothrow_move_assignable_v<_Types> && ...);
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Defines members and ctors.
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     union _Variadic_union { };
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _First, typename... _Rest>
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     union _Variadic_union<_First, _Rest...>
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr _Variadic_union() : _M_rest() { }
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr _Variadic_union(in_place_index_t<0>, _Args&&... __args)
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_first(in_place_index<0>, std::forward<_Args>(__args)...)
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr _Variadic_union(in_place_index_t<_Np>, _Args&&... __args)
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_rest(in_place_index<_Np-1>, std::forward<_Args>(__args)...)
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Uninitialized<_First> _M_first;
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variadic_union<_Rest...> _M_rest;
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // _Never_valueless_alt is true for variant alternatives that can
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // always be placed in a variant without it becoming valueless.
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // For suitably-small, trivially copyable types we can create temporaries
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // on the stack and then memcpy them into place.
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp>
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Never_valueless_alt
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : __and_<bool_constant<sizeof(_Tp) <= 256>, is_trivially_copyable<_Tp>>
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { };
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Specialize _Never_valueless_alt for other types which have a
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // non-throwing and cheap move construction and move assignment operator,
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // so that emplacing the type will provide the strong exception-safety
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // guarantee, by creating and moving a temporary.
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Whether _Never_valueless_alt<T> is true or not affects the ABI of a
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // variant using that alternative, so we can't change the value later!
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // True if every alternative in _Types... can be emplaced in a variant
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // without it becoming valueless. If this is true, variant<_Types...>
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // can never be valueless, which enables some minor optimizations.
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename... _Types>
 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr bool __never_valueless()
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
ARM GAS  /tmp/ccoErako.s 			page 8


 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return _Traits<_Types...>::_S_move_assign
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	&& (_Never_valueless_alt<_Types>::value && ...);
 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Defines index and the dtor, possibly trivial.
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool __trivially_destructible, typename... _Types>
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_storage;
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename... _Types>
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using __select_index =
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       typename __select_int::_Select_int_base<sizeof...(_Types),
 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					      unsigned char,
 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					      unsigned short>::type::value_type;
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_storage<false, _Types...>
 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_storage()
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       : _M_index(static_cast<__index_type>(variant_npos))
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { }
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
 397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_index{_Np}
 398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void _M_reset()
 401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if (!_M_valid()) [[unlikely]]
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return;
 404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::__do_visit<void>([](auto&& __this_mem) mutable
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::_Destroy(std::__addressof(__this_mem));
 408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __variant_cast<_Types...>(*this));
 409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_index = static_cast<__index_type>(variant_npos);
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       ~_Variant_storage()
 414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_reset(); }
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void*
 417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_storage() const noexcept
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return const_cast<void*>(static_cast<const void*>(
 420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::addressof(_M_u)));
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr bool
 424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_valid() const noexcept
 425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (__variant::__never_valueless<_Types...>())
 427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return true;
ARM GAS  /tmp/ccoErako.s 			page 9


 428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return this->_M_index != __index_type(variant_npos);
 429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variadic_union<_Types...> _M_u;
 432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using __index_type = __select_index<_Types...>;
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __index_type _M_index;
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_storage<true, _Types...>
 438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr
 440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_storage()
 441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       : _M_index(static_cast<__index_type>(variant_npos))
 442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { }
 443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
 447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_index{_Np}
 449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void _M_reset() noexcept
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_index = static_cast<__index_type>(variant_npos); }
 453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void*
 455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_storage() const noexcept
 456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return const_cast<void*>(static_cast<const void*>(
 458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::addressof(_M_u)));
 459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr bool
 462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_valid() const noexcept
 463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (__variant::__never_valueless<_Types...>())
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return true;
 466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return this->_M_index != static_cast<__index_type>(variant_npos);
 467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variadic_union<_Types...> _M_u;
 470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using __index_type = __select_index<_Types...>;
 471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __index_type _M_index;
 472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Variant_storage_alias =
 476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_storage<_Traits<_Types...>::_S_trivial_dtor, _Types...>;
 477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Up>
 479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void __variant_construct_single(_Tp&& __lhs, _Up&& __rhs_mem)
 480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void* __storage = std::addressof(__lhs._M_u);
 482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Type = remove_reference_t<decltype(__rhs_mem)>;
 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if constexpr (!is_same_v<_Type, __variant_cookie>)
 484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         ::new (__storage)
ARM GAS  /tmp/ccoErako.s 			page 10


 485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Type(std::forward<decltype(__rhs_mem)>(__rhs_mem));
 486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types, typename _Tp, typename _Up>
 489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void __variant_construct(_Tp&& __lhs, _Up&& __rhs)
 490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __lhs._M_index = __rhs._M_index;
 492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __variant::__raw_visit([&__lhs](auto&& __rhs_mem) mutable
 493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(std::forward<_Tp>(__lhs),
 495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      std::forward<decltype(__rhs_mem)>(__rhs_mem));
 496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}, __variant_cast<_Types...>(std::forward<_Up>(__rhs)));
 497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The following are (Copy|Move) (ctor|assign) layers for forwarding
 500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // triviality and handling non-trivial SMF behaviors.
 501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_ctor_base : _Variant_storage_alias<_Types...>
 504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Variant_storage_alias<_Types...>;
 506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base(const _Copy_ctor_base& __rhs)
 509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_copy_ctor)
 510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant_construct<_Types...>(*this, __rhs);
 512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base(_Copy_ctor_base&&) = default;
 515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base& operator=(const _Copy_ctor_base&) = default;
 516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base& operator=(_Copy_ctor_base&&) = default;
 517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_ctor_base<true, _Types...> : _Variant_storage_alias<_Types...>
 521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Variant_storage_alias<_Types...>;
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Copy_ctor_alias =
 528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Copy_ctor_base<_Traits<_Types...>::_S_trivial_copy_ctor, _Types...>;
 529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_ctor_base : _Copy_ctor_alias<_Types...>
 532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_ctor_alias<_Types...>;
 534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base(_Move_ctor_base&& __rhs)
 537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_move_ctor)
 538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant_construct<_Types...>(*this, std::move(__rhs));
 540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/ccoErako.s 			page 11


 542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)
 544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, std::forward<_Up>(__rhs));
 547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)
 552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, __rhs);
 555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base(const _Move_ctor_base&) = default;
 559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base& operator=(const _Move_ctor_base&) = default;
 560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base& operator=(_Move_ctor_base&&) = default;
 561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_ctor_base<true, _Types...> : _Copy_ctor_alias<_Types...>
 565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_ctor_alias<_Types...>;
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)
 571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, std::forward<_Up>(__rhs));
 574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)
 579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, __rhs);
 582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Move_ctor_alias =
 588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Move_ctor_base<_Traits<_Types...>::_S_trivial_move_ctor, _Types...>;
 589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_assign_base : _Move_ctor_alias<_Types...>
 592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Move_ctor_alias<_Types...>;
 594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base&
 597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       operator=(const _Copy_assign_base& __rhs)
 598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_copy_assign)
ARM GAS  /tmp/ccoErako.s 			page 12


 599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant::__raw_idx_visit(
 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  [this](auto&& __rhs_mem, auto __rhs_index) mutable
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
 603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    if constexpr (__rhs_index != variant_npos)
 604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      {
 605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		if (this->_M_index == __rhs_index)
 606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant::__get<__rhs_index>(*this) = __rhs_mem;
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		else
 608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  {
 609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    using __rhs_type = __remove_cvref_t<decltype(__rhs_mem)>;
 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    if constexpr (is_nothrow_copy_constructible_v<__rhs_type>
 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			|| !is_nothrow_move_constructible_v<__rhs_type>)
 612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // The standard says this->emplace<__rhs_type>(__rhs_mem)
 613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // should be used here, but _M_destructive_copy is
 614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // equivalent in this case. Either copy construction
 615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // doesn't throw, so _M_destructive_copy gives strong
 616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // exception safety guarantee, or both copy construction
 617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // and move construction can throw, so emplace only gives
 618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // basic exception safety anyway.
 619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      this->_M_destructive_copy(__rhs_index, __rhs_mem);
 620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    else
 621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      __variant_cast<_Types...>(*this)
 622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			= variant<_Types...>(std::in_place_index<__rhs_index>,
 623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					     __rhs_mem);
 624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  }
 625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      }
 626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    else
 627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
 628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __variant_cast<_Types...>(__rhs));
 629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return *this;
 630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base(const _Copy_assign_base&) = default;
 633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base(_Copy_assign_base&&) = default;
 634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base& operator=(_Copy_assign_base&&) = default;
 635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_assign_base<true, _Types...> : _Move_ctor_alias<_Types...>
 639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Move_ctor_alias<_Types...>;
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Copy_assign_alias =
 646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base<_Traits<_Types...>::_S_trivial_copy_assign, _Types...>;
 647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_assign_base : _Copy_assign_alias<_Types...>
 650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_assign_alias<_Types...>;
 652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base&
 655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       operator=(_Move_assign_base&& __rhs)
ARM GAS  /tmp/ccoErako.s 			page 13


 656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_move_assign)
 657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant::__raw_idx_visit(
 659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  [this](auto&& __rhs_mem, auto __rhs_index) mutable
 660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
 661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    if constexpr (__rhs_index != variant_npos)
 662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      {
 663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		if (this->_M_index == __rhs_index)
 664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant::__get<__rhs_index>(*this) = std::move(__rhs_mem);
 665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		else
 666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant_cast<_Types...>(*this)
 667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    .template emplace<__rhs_index>(std::move(__rhs_mem));
 668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      }
 669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    else
 670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
 671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __variant_cast<_Types...>(__rhs));
 672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return *this;
 673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base(const _Move_assign_base&) = default;
 676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base(_Move_assign_base&&) = default;
 677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base& operator=(const _Move_assign_base&) = default;
 678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_assign_base<true, _Types...> : _Copy_assign_alias<_Types...>
 682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_assign_alias<_Types...>;
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Move_assign_alias =
 689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base<_Traits<_Types...>::_S_trivial_move_assign, _Types...>;
 690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_base : _Move_assign_alias<_Types...>
 693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Move_assign_alias<_Types...>;
 695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base()
 698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_default_ctor)
 699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       : _Variant_base(in_place_index<0>) { }
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_base(in_place_index_t<_Np> __i, _Args&&... __args)
 704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _Base(__i, std::forward<_Args>(__args)...)
 705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base(const _Variant_base&) = default;
 708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base(_Variant_base&&) = default;
 709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base& operator=(const _Variant_base&) = default;
 710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base& operator=(_Variant_base&&) = default;
 711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/ccoErako.s 			page 14


 713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // For how many times does _Tp appear in _Tuple?
 714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Tuple>
 715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __tuple_count;
 716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Tuple>
 718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr size_t __tuple_count_v =
 719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __tuple_count<_Tp, _Tuple>::value;
 720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __tuple_count<_Tp, tuple<_Types...>>
 723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : integral_constant<size_t, 0> { };
 724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _First, typename... _Rest>
 726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __tuple_count<_Tp, tuple<_First, _Rest...>>
 727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : integral_constant<
 728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	size_t,
 729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__tuple_count_v<_Tp, tuple<_Rest...>> + is_same_v<_Tp, _First>> { };
 730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // TODO: Reuse this in <tuple> ?
 732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr bool __exactly_once =
 734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __tuple_count_v<_Tp, tuple<_Types...>> == 1;
 735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Helper used to check for valid conversions that don't involve narrowing.
 737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Ti> struct _Arr { _Ti _M_x[1]; };
 738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Build an imaginary function FUN(Ti) for each alternative type Ti
 740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Ind, typename _Tp, typename _Ti,
 741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   bool _Ti_is_cv_bool = is_same_v<remove_cv_t<_Ti>, bool>,
 742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename = void>
 743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUN
 744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // This function means 'using _Build_FUN<I, T, Ti>::_S_fun;' is valid,
 746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // but only static functions will be considered in the call below.
 747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void _S_fun();
 748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // ... for which Ti x[] = {std::forward<T>(t)}; is well-formed,
 751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Ind, typename _Tp, typename _Ti>
 752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUN<_Ind, _Tp, _Ti, false,
 753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      void_t<decltype(_Arr<_Ti>{{std::declval<_Tp>()}})>>
 754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // This is the FUN function for type _Ti, with index _Ind
 756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static integral_constant<size_t, _Ind> _S_fun(_Ti);
 757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // ... and if Ti is cv bool, remove_cvref_t<T> is bool.
 760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Ind, typename _Tp, typename _Ti>
 761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUN<_Ind, _Tp, _Ti, true,
 762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      enable_if_t<is_same_v<__remove_cvref_t<_Tp>, bool>>>
 763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // This is the FUN function for when _Ti is cv bool, with index _Ind
 765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static integral_constant<size_t, _Ind> _S_fun(_Ti);
 766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant,
 769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename = make_index_sequence<variant_size_v<_Variant>>>
ARM GAS  /tmp/ccoErako.s 			page 15


 770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUNs;
 771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Ti, size_t... _Ind>
 773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUNs<_Tp, variant<_Ti...>, index_sequence<_Ind...>>
 774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _Build_FUN<_Ind, _Tp, _Ti>...
 775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Build_FUN<_Ind, _Tp, _Ti>::_S_fun...;
 777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The index j of the overload FUN(Tj) selected by overload resolution
 780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // for FUN(std::forward<_Tp>(t))
 781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant>
 782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _FUN_type
 783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       = decltype(_Build_FUNs<_Tp, _Variant>::_S_fun(std::declval<_Tp>()));
 784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The index selected for FUN(std::forward<T>(t)), or variant_npos if none.
 786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant, typename = void>
 787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __accepted_index
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : integral_constant<size_t, variant_npos>
 789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { };
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant>
 792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __accepted_index<_Tp, _Variant, void_t<_FUN_type<_Tp, _Variant>>>
 793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _FUN_type<_Tp, _Variant>
 794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { };
 795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns the raw storage for __v.
 797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
 798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void* __get_storage(_Variant&& __v) noexcept
 799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return __v._M_storage(); }
 800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename _Maybe_variant_cookie, typename _Variant>
 802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Extra_visit_slot_needed
 803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename> struct _Variant_never_valueless;
 805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Types>
 807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct _Variant_never_valueless<variant<_Types...>>
 808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: bool_constant<__variant::__never_valueless<_Types...>()> {};
 809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool value =
 811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	(is_same_v<_Maybe_variant_cookie, __variant_cookie>
 812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	 || is_same_v<_Maybe_variant_cookie, __variant_idx_cookie>)
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	&& !_Variant_never_valueless<__remove_cvref_t<_Variant>>::value;
 814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Used for storing a multi-dimensional vtable.
 817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, size_t... _Dimensions>
 818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Multi_array;
 819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Partial specialization with rank zero, stores a single _Tp element.
 821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp>
 822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Multi_array<_Tp>
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename>
 825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result
 826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
ARM GAS  /tmp/ccoErako.s 			page 16


 827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = _Tp; };
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Args>
 830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<const void(*)(_Args...)>
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
 832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = void(*)(_Args...); };
 833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Args>
 835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<__variant_cookie(*)(_Args...)>
 836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
 837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = void(*)(_Args...); };
 838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Args>
 840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<__variant_idx_cookie(*)(_Args...)>
 841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
 842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = void(*)(_Args...); };
 843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename _Res, typename... _Args>
 845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<__deduce_visit_result<_Res>(*)(_Args...)>
 846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: true_type
 847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = _Res(*)(_Args...); };
 848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using __result_is_deduced = __untag_result<_Tp>;
 850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr const typename __untag_result<_Tp>::element_type&
 852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_access() const
 853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_data; }
 854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       typename __untag_result<_Tp>::element_type _M_data;
 856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Partial specialization with rank >= 1.
 859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Ret,
 860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename _Visitor,
 861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename... _Variants,
 862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   size_t __first, size_t... __rest>
 863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Multi_array<_Ret(*)(_Visitor, _Variants...), __first, __rest...>
 864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr size_t __index =
 866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	sizeof...(_Variants) - sizeof...(__rest) - 1;
 867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Variant = typename _Nth_type<__index, _Variants...>::type;
 869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr int __do_cookie =
 871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Extra_visit_slot_needed<_Ret, _Variant>::value ? 1 : 0;
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Tp = _Ret(*)(_Visitor, _Variants...);
 874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr decltype(auto)
 877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_access(size_t __first_index, _Args... __rest_indices) const
 878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return _M_arr[__first_index + __do_cookie]
 880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    ._M_access(__rest_indices...);
 881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Multi_array<_Tp, __rest...> _M_arr[__first + __do_cookie];
ARM GAS  /tmp/ccoErako.s 			page 17


 884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Creates a multi-dimensional vtable recursively.
 887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //
 888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // For example,
 889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // visit([](auto, auto){},
 890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //       variant<int, char>(),  // typedef'ed as V1
 891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //       variant<float, double, long double>())  // typedef'ed as V2
 892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // will trigger instantiations of:
 893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 2, 3>,
 894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                   tuple<V1&&, V2&&>, std::index_sequence<>>
 895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //   __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 3>,
 896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                     tuple<V1&&, V2&&>, std::index_sequence<0>>
 897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 0>>
 899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 1>>
 901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 2>>
 903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //   __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 3>,
 904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                     tuple<V1&&, V2&&>, std::index_sequence<1>>
 905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 0>>
 907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 1>>
 909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 2>>
 911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The returned multi-dimensional vtable can be fast accessed by the visitor
 912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // using index calculation.
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Array_type, typename _Index_seq>
 914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable_impl;
 915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Defines the _S_apply() member that returns a _Multi_array populated
 917:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // with function pointers that perform the visitation expressions e(m)
 918:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // for each valid pack of indexes into the variant types _Variants.
 919:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //
 920:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // This partial specialization builds up the index sequences by recursively
 921:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // calling _S_apply() on the next specialization of __gen_vtable_impl.
 922:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The base case of the recursion defines the actual function pointers.
 923:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, size_t... __dimensions,
 924:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename... _Variants, size_t... __indices>
 925:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable_impl<
 926:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Multi_array<_Result_type (*)(_Visitor, _Variants...), __dimensions...>,
 927:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::index_sequence<__indices...>>
 928:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 929:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Next =
 930:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  remove_reference_t<typename _Nth_type<sizeof...(__indices),
 931:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			     _Variants...>::type>;
 932:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Array_type =
 933:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Multi_array<_Result_type (*)(_Visitor, _Variants...),
 934:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		       __dimensions...>;
 935:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 936:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr _Array_type
 937:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _S_apply()
 938:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 939:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Array_type __vtable{};
 940:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_S_apply_all_alts(
ARM GAS  /tmp/ccoErako.s 			page 18


 941:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __vtable, make_index_sequence<variant_size_v<_Next>>());
 942:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return __vtable;
 943:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 944:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 945:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t... __var_indices>
 946:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr void
 947:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_S_apply_all_alts(_Array_type& __vtable,
 948:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			  std::index_sequence<__var_indices...>)
 949:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 950:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (_Extra_visit_slot_needed<_Result_type, _Next>::value)
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    (_S_apply_single_alt<true, __var_indices>(
 952:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __vtable._M_arr[__var_indices + 1],
 953:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      &(__vtable._M_arr[0])), ...);
 954:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 955:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    (_S_apply_single_alt<false, __var_indices>(
 956:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __vtable._M_arr[__var_indices]), ...);
 957:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 958:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 959:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<bool __do_cookie, size_t __index, typename _Tp>
 960:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr void
 961:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_S_apply_single_alt(_Tp& __element, _Tp* __cookie_element = nullptr)
 962:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 963:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__do_cookie)
 964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
 965:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element = __gen_vtable_impl<
 966:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		_Tp,
 967:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::index_sequence<__indices..., __index>>::_S_apply();
 968:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      *__cookie_element = __gen_vtable_impl<
 969:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		_Tp,
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::index_sequence<__indices..., variant_npos>>::_S_apply();
 971:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
 972:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 973:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
 974:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element = __gen_vtable_impl<
 975:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		remove_reference_t<decltype(__element)>,
 976:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::index_sequence<__indices..., __index>>::_S_apply();
 977:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
 978:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 979:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 980:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 981:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // This partial specialization is the base case for the recursion.
 982:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // It populates a _Multi_array element with the address of a function
 983:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // that invokes the visitor with the alternatives specified by __indices.
 984:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, typename... _Variants,
 985:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   size_t... __indices>
 986:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable_impl<
 987:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Multi_array<_Result_type (*)(_Visitor, _Variants...)>,
 988:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		   std::index_sequence<__indices...>>
 989:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 990:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Array_type =
 991:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Multi_array<_Result_type (*)(_Visitor, _Variants...)>;
 992:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 993:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t __index, typename _Variant>
 994:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr decltype(auto)
 995:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__element_by_index_or_cookie(_Variant&& __var) noexcept
 996:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 997:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__index != variant_npos)
ARM GAS  /tmp/ccoErako.s 			page 19


 998:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return __variant::__get<__index>(std::forward<_Variant>(__var));
 999:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
1000:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return __variant_cookie{};
1001:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1002:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1003:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr decltype(auto)
1004:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __visit_invoke(_Visitor&& __visitor, _Variants... __vars)
1005:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
1006:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (is_same_v<_Result_type, __variant_idx_cookie>)
1007:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // For raw visitation using indices, pass the indices to the visitor
1008:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // and discard the return value:
1009:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  std::__invoke(std::forward<_Visitor>(__visitor),
1010:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element_by_index_or_cookie<__indices>(
1011:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::forward<_Variants>(__vars))...,
1012:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      integral_constant<size_t, __indices>()...);
1013:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (is_same_v<_Result_type, __variant_cookie>)
1014:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // For raw visitation without indices, and discard the return value:
1015:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  std::__invoke(std::forward<_Visitor>(__visitor),
1016:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element_by_index_or_cookie<__indices>(
1017:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::forward<_Variants>(__vars))...);
1018:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (_Array_type::__result_is_deduced::value)
1019:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // For the usual std::visit case deduce the return value:
1020:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return std::__invoke(std::forward<_Visitor>(__visitor),
1021:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element_by_index_or_cookie<__indices>(
1022:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::forward<_Variants>(__vars))...);
1023:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else // for std::visit<R> use INVOKE<R>
1024:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return std::__invoke_r<_Result_type>(
1025:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      std::forward<_Visitor>(__visitor),
1026:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __variant::__get<__indices>(std::forward<_Variants>(__vars))...);
1027:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
1028:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1029:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr auto
1030:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _S_apply()
1031:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _Array_type{&__visit_invoke}; }
1032:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
1033:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1034:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, typename... _Variants>
1035:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable
1036:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1037:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Array_type =
1038:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Multi_array<_Result_type (*)(_Visitor, _Variants...),
1039:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		       variant_size_v<remove_reference_t<_Variants>>...>;
1040:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1041:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr _Array_type _S_vtable
1042:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	= __gen_vtable_impl<_Array_type, std::index_sequence<>>::_S_apply();
1043:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
1044:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1045:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Tp>
1046:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Base_dedup : public _Tp { };
1047:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1048:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant, typename __indices>
1049:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_hash_base;
1050:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1051:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types, size_t... __indices>
1052:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_hash_base<variant<_Types...>,
1053:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			      std::index_sequence<__indices...>>
1054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _Base_dedup<__indices, __poison_hash<remove_const_t<_Types>>>... { };
ARM GAS  /tmp/ccoErako.s 			page 20


1055:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1056:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
1057:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using __get_t = decltype(std::get<_Np>(std::declval<_Variant>()));
1058:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1059:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Return type of std::visit.
1060:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
1061:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using __visit_result_t
1062:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       = invoke_result_t<_Visitor, __get_t<0, _Variants>...>;
1063:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1064:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __variant
1065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __detail
1066:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1067:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant, typename... _Args>
1068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void __variant_construct_by_index(_Variant& __v, _Args&&... __args)
1069:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __v._M_index = _Np;
1071:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       auto&& __storage = __detail::__variant::__get<_Np>(__v);
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       ::new ((void*)std::addressof(__storage))
1073:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         remove_reference_t<decltype(__storage)>
1074:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (std::forward<_Args>(__args)...);
1075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1076:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1077:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1078:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr bool
1079:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     holds_alternative(const variant<_Types...>& __v) noexcept
1080:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1081:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1082:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1083:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __v.index() == __detail::__variant::__index_of_v<_Tp, _Types...>;
1084:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1085:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1086:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1087:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr _Tp& get(variant<_Types...>& __v)
1088:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1089:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1090:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1091:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1092:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
1093:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1094:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1095:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1096:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr _Tp&& get(variant<_Types...>&& __v)
1097:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1098:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1099:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::move(__v));
1103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr const _Tp& get(const variant<_Types...>& __v)
1107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
ARM GAS  /tmp/ccoErako.s 			page 21


1112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr const _Tp&& get(const variant<_Types...>&& __v)
1116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::move(__v));
1122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
1125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr add_pointer_t<variant_alternative_t<_Np, variant<_Types...>>>
1126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(variant<_Types...>* __ptr) noexcept
1127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
1129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(_Np < sizeof...(_Types),
1130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "The index must be in [0, number of alternatives)");
1131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Alternative_type>, "_Tp must not be void");
1132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if (__ptr && __ptr->index() == _Np)
1133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return std::addressof(__detail::__variant::__get<_Np>(*__ptr));
1134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return nullptr;
1135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
1138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr
1139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     add_pointer_t<const variant_alternative_t<_Np, variant<_Types...>>>
1140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(const variant<_Types...>* __ptr) noexcept
1141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
1143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(_Np < sizeof...(_Types),
1144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "The index must be in [0, number of alternatives)");
1145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Alternative_type>, "_Tp must not be void");
1146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if (__ptr && __ptr->index() == _Np)
1147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return std::addressof(__detail::__variant::__get<_Np>(*__ptr));
1148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return nullptr;
1149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr add_pointer_t<_Tp>
1153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(variant<_Types...>* __ptr) noexcept
1154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __ptr);
1160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr add_pointer_t<const _Tp>
1164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(const variant<_Types...>* __ptr) noexcept
1165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
ARM GAS  /tmp/ccoErako.s 			page 22


1169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __ptr);
1171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   struct monostate { };
1174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP, __NAME) \
1176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types> \
1177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr bool operator __OP(const variant<_Types...>& __lhs, \
1178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				 const variant<_Types...>& __rhs) \
1179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { \
1180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       bool __ret = true; \
1181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __detail::__variant::__raw_idx_visit( \
1182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         [&__ret, &__lhs] (auto&& __rhs_mem, auto __rhs_index) mutable \
1183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         { \
1184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__rhs_index != variant_npos) \
1185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    { \
1186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      if (__lhs.index() == __rhs_index) \
1187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	        { \
1188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  auto& __this_mem = std::get<__rhs_index>(__lhs);	\
1189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****                   __ret = __this_mem __OP __rhs_mem; \
1190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****                 } \
1191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      else \
1192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		__ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \
1193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****             } \
1194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****           else \
1195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****             __ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \
1196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}, __rhs); \
1197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __ret; \
1198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(<, less)
1201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(<=, less_equal)
1202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(==, equal)
1203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(!=, not_equal)
1204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(>=, greater_equal)
1205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(>, greater)
1206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #undef _VARIANT_RELATION_FUNCTION_TEMPLATE
1208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator==(monostate, monostate) noexcept { return true; }
1210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #ifdef __cpp_lib_three_way_comparison
1212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     requires (three_way_comparable<_Types> && ...)
1214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr
1215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     common_comparison_category_t<compare_three_way_result_t<_Types>...>
1216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     operator<=>(const variant<_Types...>& __v, const variant<_Types...>& __w)
1217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       common_comparison_category_t<compare_three_way_result_t<_Types>...> __ret
1219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	= strong_ordering::equal;
1220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __detail::__variant::__raw_idx_visit(
1222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	[&__ret, &__v] (auto&& __w_mem, auto __w_index) mutable
1223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__w_index != variant_npos)
1225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
ARM GAS  /tmp/ccoErako.s 			page 23


1226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      if (__v.index() == __w_index)
1227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  auto& __this_mem = std::get<__w_index>(__v);
1229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __ret = __this_mem <=> __w_mem;
1230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  return;
1231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __ret = (__v.index() + 1) <=> (__w_index + 1);
1234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}, __w);
1235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __ret;
1236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr strong_ordering
1239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   operator<=>(monostate, monostate) noexcept { return strong_ordering::equal; }
1240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #else
1241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator!=(monostate, monostate) noexcept { return false; }
1242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator<(monostate, monostate) noexcept { return false; }
1243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator>(monostate, monostate) noexcept { return false; }
1244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator<=(monostate, monostate) noexcept { return true; }
1245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator>=(monostate, monostate) noexcept { return true; }
1246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #endif
1247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
1249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
1250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     visit(_Visitor&&, _Variants&&...);
1251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline enable_if_t<(is_move_constructible_v<_Types> && ...)
1254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			&& (is_swappable_v<_Types> && ...)>
1255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     swap(variant<_Types...>& __lhs, variant<_Types...>& __rhs)
1256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     noexcept(noexcept(__lhs.swap(__rhs)))
1257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { __lhs.swap(__rhs); }
1258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     enable_if_t<!((is_move_constructible_v<_Types> && ...)
1261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		   && (is_swappable_v<_Types> && ...))>
1262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     swap(variant<_Types...>&, variant<_Types...>&) = delete;
1263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   class bad_variant_access : public exception
1265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
1266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   public:
1267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     bad_variant_access() noexcept { }
1268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     const char* what() const noexcept override
  31              		.loc 1 1269 17 view -0
  32              		.cfi_startproc
  33              		@ args = 0, pretend = 0, frame = 0
  34              		@ frame_needed = 0, uses_anonymous_args = 0
  35              		@ link register save eliminated.
1270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return _M_reason; }
  36              		.loc 1 1270 7 view .LVU1
  37              		.loc 1 1270 25 is_stmt 0 view .LVU2
  38 0000 4068     		ldr	r0, [r0, #4]
  39              	.LVL1:
  40              		.loc 1 1270 25 view .LVU3
  41 0002 7047     		bx	lr
  42              		.cfi_endproc
ARM GAS  /tmp/ccoErako.s 			page 24


  43              	.LFE3280:
  44              		.cantunwind
  45              		.fnend
  47              		.section	.text._ZL8get_gpioj,"ax",%progbits
  48              		.align	1
  49              		.syntax unified
  50              		.thumb
  51              		.thumb_func
  53              	_ZL8get_gpioj:
  54              		.fnstart
  55              	.LVL2:
  56              	.LFB5151:
  57              		.file 2 "MotorControl/odrive_main.h"
   1:MotorControl/odrive_main.h **** #ifndef __ODRIVE_MAIN_H
   2:MotorControl/odrive_main.h **** #define __ODRIVE_MAIN_H
   3:MotorControl/odrive_main.h **** 
   4:MotorControl/odrive_main.h **** // Hardware configuration
   5:MotorControl/odrive_main.h **** #include <board.h>
   6:MotorControl/odrive_main.h **** 
   7:MotorControl/odrive_main.h **** #ifdef __cplusplus
   8:MotorControl/odrive_main.h **** #include <communication/interface_usb.h>
   9:MotorControl/odrive_main.h **** #include <communication/interface_i2c.h>
  10:MotorControl/odrive_main.h **** #include <communication/interface_uart.h>
  11:MotorControl/odrive_main.h **** #include <task_timer.hpp>
  12:MotorControl/odrive_main.h **** extern "C" {
  13:MotorControl/odrive_main.h **** #endif
  14:MotorControl/odrive_main.h **** 
  15:MotorControl/odrive_main.h **** // OS includes
  16:MotorControl/odrive_main.h **** #include <cmsis_os.h>
  17:MotorControl/odrive_main.h **** 
  18:MotorControl/odrive_main.h **** // extern const float elec_rad_per_enc;
  19:MotorControl/odrive_main.h **** extern uint32_t _reboot_cookie;
  20:MotorControl/odrive_main.h **** 
  21:MotorControl/odrive_main.h **** extern uint64_t serial_number;
  22:MotorControl/odrive_main.h **** extern char serial_number_str[13];
  23:MotorControl/odrive_main.h **** 
  24:MotorControl/odrive_main.h **** #ifdef __cplusplus
  25:MotorControl/odrive_main.h **** }
  26:MotorControl/odrive_main.h **** 
  27:MotorControl/odrive_main.h **** typedef struct {
  28:MotorControl/odrive_main.h ****     bool fully_booted;
  29:MotorControl/odrive_main.h ****     uint32_t uptime; // [ms]
  30:MotorControl/odrive_main.h ****     uint32_t min_heap_space; // FreeRTOS heap [Bytes]
  31:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_axis; // minimum remaining space since startup [Bytes]
  32:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_usb;
  33:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_uart;
  34:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_startup;
  35:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_can;
  36:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_analog;
  37:MotorControl/odrive_main.h **** 
  38:MotorControl/odrive_main.h ****     uint32_t stack_size_axis;
  39:MotorControl/odrive_main.h ****     uint32_t stack_size_usb;
  40:MotorControl/odrive_main.h ****     uint32_t stack_size_uart;
  41:MotorControl/odrive_main.h ****     uint32_t stack_size_startup;
  42:MotorControl/odrive_main.h ****     uint32_t stack_size_can;
  43:MotorControl/odrive_main.h ****     uint32_t stack_size_analog;
  44:MotorControl/odrive_main.h **** 
ARM GAS  /tmp/ccoErako.s 			page 25


  45:MotorControl/odrive_main.h ****     int32_t prio_axis;
  46:MotorControl/odrive_main.h ****     int32_t prio_usb;
  47:MotorControl/odrive_main.h ****     int32_t prio_uart;
  48:MotorControl/odrive_main.h ****     int32_t prio_startup;
  49:MotorControl/odrive_main.h ****     int32_t prio_can;
  50:MotorControl/odrive_main.h ****     int32_t prio_analog;
  51:MotorControl/odrive_main.h **** 
  52:MotorControl/odrive_main.h ****     USBStats_t& usb = usb_stats_;
  53:MotorControl/odrive_main.h ****     I2CStats_t& i2c = i2c_stats_;
  54:MotorControl/odrive_main.h **** } SystemStats_t;
  55:MotorControl/odrive_main.h **** 
  56:MotorControl/odrive_main.h **** struct PWMMapping_t {
  57:MotorControl/odrive_main.h ****     endpoint_ref_t endpoint = {0, 0};
  58:MotorControl/odrive_main.h ****     float min = 0;
  59:MotorControl/odrive_main.h ****     float max = 0;
  60:MotorControl/odrive_main.h **** };
  61:MotorControl/odrive_main.h **** 
  62:MotorControl/odrive_main.h **** // @brief general user configurable board configuration
  63:MotorControl/odrive_main.h **** struct BoardConfig_t {
  64:MotorControl/odrive_main.h ****     ODriveIntf::GpioMode gpio_modes[GPIO_COUNT] = {
  65:MotorControl/odrive_main.h ****         DEFAULT_GPIO_MODES
  66:MotorControl/odrive_main.h ****     };
  67:MotorControl/odrive_main.h **** 
  68:MotorControl/odrive_main.h ****     bool enable_uart_a = true;
  69:MotorControl/odrive_main.h ****     bool enable_uart_b = false;
  70:MotorControl/odrive_main.h ****     bool enable_uart_c = false;
  71:MotorControl/odrive_main.h ****     uint32_t uart_a_baudrate = 115200;
  72:MotorControl/odrive_main.h ****     uint32_t uart_b_baudrate = 115200;
  73:MotorControl/odrive_main.h ****     uint32_t uart_c_baudrate = 115200;
  74:MotorControl/odrive_main.h ****     bool enable_can_a = true;
  75:MotorControl/odrive_main.h ****     bool enable_i2c_a = false;
  76:MotorControl/odrive_main.h ****     ODriveIntf::StreamProtocolType uart0_protocol = ODriveIntf::STREAM_PROTOCOL_TYPE_ASCII_AND_STDO
  77:MotorControl/odrive_main.h ****     ODriveIntf::StreamProtocolType uart1_protocol = ODriveIntf::STREAM_PROTOCOL_TYPE_ASCII_AND_STDO
  78:MotorControl/odrive_main.h ****     ODriveIntf::StreamProtocolType uart2_protocol = ODriveIntf::STREAM_PROTOCOL_TYPE_ASCII_AND_STDO
  79:MotorControl/odrive_main.h ****     ODriveIntf::StreamProtocolType usb_cdc_protocol = ODriveIntf::STREAM_PROTOCOL_TYPE_ASCII_AND_ST
  80:MotorControl/odrive_main.h ****     float max_regen_current = 0.0f;
  81:MotorControl/odrive_main.h ****     float brake_resistance = DEFAULT_BRAKE_RESISTANCE;
  82:MotorControl/odrive_main.h ****     bool enable_brake_resistor = false;
  83:MotorControl/odrive_main.h ****     float dc_bus_undervoltage_trip_level = DEFAULT_MIN_DC_VOLTAGE;      //<! [V] minimum voltage be
  84:MotorControl/odrive_main.h ****     float dc_bus_overvoltage_trip_level = 1.07f * HW_VERSION_VOLTAGE;   //<! [V] maximum voltage ab
  85:MotorControl/odrive_main.h ****                                                                         //<! This protects against 
  86:MotorControl/odrive_main.h ****                                                                         //<! the brake power if the
  87:MotorControl/odrive_main.h ****                                                                         //<! The default is 26V for
  88:MotorControl/odrive_main.h **** 
  89:MotorControl/odrive_main.h ****     /**
  90:MotorControl/odrive_main.h ****      * If enabled, if the measured DC voltage exceeds `dc_bus_overvoltage_ramp_start`,
  91:MotorControl/odrive_main.h ****      * the ODrive will sink more power than usual into the the brake resistor
  92:MotorControl/odrive_main.h ****      * in an attempt to bring the voltage down again.
  93:MotorControl/odrive_main.h ****      * 
  94:MotorControl/odrive_main.h ****      * The brake duty cycle is increased by the following amount:
  95:MotorControl/odrive_main.h ****      *  vbus_voltage == dc_bus_overvoltage_ramp_start  =>  brake_duty_cycle += 0%
  96:MotorControl/odrive_main.h ****      *  vbus_voltage == dc_bus_overvoltage_ramp_end  =>  brake_duty_cycle += 100%
  97:MotorControl/odrive_main.h ****      * 
  98:MotorControl/odrive_main.h ****      * Remarks:
  99:MotorControl/odrive_main.h ****      *  - This feature is active even when all motors are disarmed.
 100:MotorControl/odrive_main.h ****      *  - This feature is disabled if `brake_resistance` is non-positive.
 101:MotorControl/odrive_main.h ****      */
ARM GAS  /tmp/ccoErako.s 			page 26


 102:MotorControl/odrive_main.h ****     bool enable_dc_bus_overvoltage_ramp = false;
 103:MotorControl/odrive_main.h ****     float dc_bus_overvoltage_ramp_start = 1.07f * HW_VERSION_VOLTAGE; //!< See `enable_dc_bus_overv
 104:MotorControl/odrive_main.h ****                                                                       //!< Do not set this lower th
 105:MotorControl/odrive_main.h ****                                                                       //!< unless you like fried br
 106:MotorControl/odrive_main.h ****     float dc_bus_overvoltage_ramp_end = 1.07f * HW_VERSION_VOLTAGE; //!< See `enable_dc_bus_overvol
 107:MotorControl/odrive_main.h ****                                                                     //!< Must be larger than `dc_bu
 108:MotorControl/odrive_main.h ****                                                                     //!< otherwise the ramp feature
 109:MotorControl/odrive_main.h **** 
 110:MotorControl/odrive_main.h ****     float dc_max_positive_current = INFINITY; // Max current [A] the power supply can source
 111:MotorControl/odrive_main.h ****     float dc_max_negative_current = -0.01f; // Max current [A] the power supply can sink. You most 
 112:MotorControl/odrive_main.h ****     uint32_t error_gpio_pin = DEFAULT_ERROR_PIN;
 113:MotorControl/odrive_main.h ****     PWMMapping_t pwm_mappings[4];
 114:MotorControl/odrive_main.h ****     PWMMapping_t analog_mappings[GPIO_COUNT];
 115:MotorControl/odrive_main.h **** };
 116:MotorControl/odrive_main.h **** 
 117:MotorControl/odrive_main.h **** struct TaskTimes {
 118:MotorControl/odrive_main.h ****     TaskTimer sampling;
 119:MotorControl/odrive_main.h ****     TaskTimer control_loop_misc;
 120:MotorControl/odrive_main.h ****     TaskTimer control_loop_checks;
 121:MotorControl/odrive_main.h ****     TaskTimer dc_calib_wait;
 122:MotorControl/odrive_main.h **** };
 123:MotorControl/odrive_main.h **** 
 124:MotorControl/odrive_main.h **** 
 125:MotorControl/odrive_main.h **** // Forward Declarations
 126:MotorControl/odrive_main.h **** class Axis;
 127:MotorControl/odrive_main.h **** class Motor;
 128:MotorControl/odrive_main.h **** 
 129:MotorControl/odrive_main.h **** // TODO: move
 130:MotorControl/odrive_main.h **** // this is technically not thread-safe but practically it might be
 131:MotorControl/odrive_main.h **** #define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE) \
 132:MotorControl/odrive_main.h **** inline ENUMTYPE operator | (ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<std:
 133:MotorControl/odrive_main.h **** inline ENUMTYPE operator & (ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<std:
 134:MotorControl/odrive_main.h **** inline ENUMTYPE operator ^ (ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<std:
 135:MotorControl/odrive_main.h **** inline ENUMTYPE &operator |= (ENUMTYPE &a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinter
 136:MotorControl/odrive_main.h **** inline ENUMTYPE &operator &= (ENUMTYPE &a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinter
 137:MotorControl/odrive_main.h **** inline ENUMTYPE &operator ^= (ENUMTYPE &a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinter
 138:MotorControl/odrive_main.h **** inline ENUMTYPE operator ~ (ENUMTYPE a) { return static_cast<ENUMTYPE>(~static_cast<std::underlying
 139:MotorControl/odrive_main.h **** 
 140:MotorControl/odrive_main.h **** #include "autogen/interfaces.hpp"
 141:MotorControl/odrive_main.h **** 
 142:MotorControl/odrive_main.h **** // ODrive specific includes
 143:MotorControl/odrive_main.h **** #include <utils.hpp>
 144:MotorControl/odrive_main.h **** #include <low_level.h>
 145:MotorControl/odrive_main.h **** #include <encoder.hpp>
 146:MotorControl/odrive_main.h **** #include <sensorless_estimator.hpp>
 147:MotorControl/odrive_main.h **** #include <controller.hpp>
 148:MotorControl/odrive_main.h **** #include <current_limiter.hpp>
 149:MotorControl/odrive_main.h **** #include <thermistor.hpp>
 150:MotorControl/odrive_main.h **** #include <trapTraj.hpp>
 151:MotorControl/odrive_main.h **** #include <endstop.hpp>
 152:MotorControl/odrive_main.h **** #include <mechanical_brake.hpp>
 153:MotorControl/odrive_main.h **** #include <axis.hpp>
 154:MotorControl/odrive_main.h **** #include <oscilloscope.hpp>
 155:MotorControl/odrive_main.h **** #include <communication/communication.h>
 156:MotorControl/odrive_main.h **** #include <communication/can/odrive_can.hpp>
 157:MotorControl/odrive_main.h **** 
 158:MotorControl/odrive_main.h **** // Defined in autogen/version.c based on git-derived version numbers
ARM GAS  /tmp/ccoErako.s 			page 27


 159:MotorControl/odrive_main.h **** extern "C" {
 160:MotorControl/odrive_main.h **** extern const unsigned char fw_version_major_;
 161:MotorControl/odrive_main.h **** extern const unsigned char fw_version_minor_;
 162:MotorControl/odrive_main.h **** extern const unsigned char fw_version_revision_;
 163:MotorControl/odrive_main.h **** extern const unsigned char fw_version_unreleased_;
 164:MotorControl/odrive_main.h **** }
 165:MotorControl/odrive_main.h **** 
 166:MotorControl/odrive_main.h **** static Stm32Gpio get_gpio(size_t gpio_num) {
  58              		.loc 2 166 44 is_stmt 1 view -0
  59              		.cfi_startproc
  60              		@ args = 0, pretend = 0, frame = 0
  61              		@ frame_needed = 0, uses_anonymous_args = 0
  62              		@ link register save eliminated.
  63              		.loc 2 166 44 is_stmt 0 view .LVU5
  64 0000 0346     		mov	r3, r0
 167:MotorControl/odrive_main.h ****     return (gpio_num < GPIO_COUNT) ? gpios[gpio_num] : GPIO_COUNT ? gpios[0] : Stm32Gpio::none;
  65              		.loc 2 167 5 is_stmt 1 view .LVU6
  66              		.loc 2 167 36 is_stmt 0 view .LVU7
  67 0002 1029     		cmp	r1, #16
  68 0004 07D8     		bhi	.L4
  69              		.loc 2 167 36 discriminator 1 view .LVU8
  70 0006 054A     		ldr	r2, .L5
  71 0008 02EBC101 		add	r1, r2, r1, lsl #3
  72              	.LVL3:
  73              	.L3:
  74              		.loc 2 167 91 discriminator 4 view .LVU9
  75 000c 03C9     		ldm	r1, {r0, r1}
  76              	.LVL4:
  77              		.loc 2 167 91 discriminator 4 view .LVU10
  78 000e 83E80300 		stm	r3, {r0, r1}
 168:MotorControl/odrive_main.h **** }
  79              		.loc 2 168 1 discriminator 4 view .LVU11
  80 0012 1846     		mov	r0, r3
  81 0014 7047     		bx	lr
  82              	.LVL5:
  83              	.L4:
 167:MotorControl/odrive_main.h ****     return (gpio_num < GPIO_COUNT) ? gpios[gpio_num] : GPIO_COUNT ? gpios[0] : Stm32Gpio::none;
  84              		.loc 2 167 36 view .LVU12
  85 0016 0149     		ldr	r1, .L5
  86              	.LVL6:
 167:MotorControl/odrive_main.h ****     return (gpio_num < GPIO_COUNT) ? gpios[gpio_num] : GPIO_COUNT ? gpios[0] : Stm32Gpio::none;
  87              		.loc 2 167 36 view .LVU13
  88 0018 F8E7     		b	.L3
  89              	.L6:
  90 001a 00BF     		.align	2
  91              	.L5:
  92 001c 00000000 		.word	gpios
  93              		.cfi_endproc
  94              	.LFE5151:
  95              		.cantunwind
  96              		.fnend
  98              		.section	.text._ZNSt18bad_variant_accessD2Ev,"axG",%progbits,_ZNSt18bad_variant_accessD5Ev,comdat
  99              		.align	1
 100              		.weak	_ZNSt18bad_variant_accessD2Ev
 101              		.syntax unified
 102              		.thumb
 103              		.thumb_func
ARM GAS  /tmp/ccoErako.s 			page 28


 105              	_ZNSt18bad_variant_accessD2Ev:
 106              		.fnstart
 107              	.LVL7:
 108              	.LFB6321:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 109              		.loc 1 1264 9 is_stmt 1 view -0
 110              		.cfi_startproc
 111              		@ args = 0, pretend = 0, frame = 0
 112              		@ frame_needed = 0, uses_anonymous_args = 0
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 113              		.loc 1 1264 9 is_stmt 0 view .LVU15
 114 0000 10B5     		push	{r4, lr}
 115              	.LCFI0:
 116              		.cfi_def_cfa_offset 8
 117              		.cfi_offset 4, -8
 118              		.cfi_offset 14, -4
 119 0002 0446     		mov	r4, r0
 120              	.LBB656:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 121              		.loc 1 1264 9 view .LVU16
 122 0004 024B     		ldr	r3, .L9
 123 0006 0360     		str	r3, [r0]
 124 0008 FFF7FEFF 		bl	_ZNSt9exceptionD2Ev
 125              	.LVL8:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 126              		.loc 1 1264 9 view .LVU17
 127              	.LBE656:
 128 000c 2046     		mov	r0, r4
 129 000e 10BD     		pop	{r4, pc}
 130              	.LVL9:
 131              	.L10:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 132              		.loc 1 1264 9 view .LVU18
 133              		.align	2
 134              	.L9:
 135 0010 08000000 		.word	_ZTVSt18bad_variant_access+8
 136              		.cfi_endproc
 137              	.LFE6321:
 138              		.cantunwind
 139              		.fnend
 141              		.weak	_ZNSt18bad_variant_accessD1Ev
 142              		.thumb_set _ZNSt18bad_variant_accessD1Ev,_ZNSt18bad_variant_accessD2Ev
 143              		.section	.text._ZNSt18bad_variant_accessD0Ev,"axG",%progbits,_ZNSt18bad_variant_accessD5Ev,comdat
 144              		.align	1
 145              		.weak	_ZNSt18bad_variant_accessD0Ev
 146              		.syntax unified
 147              		.thumb
 148              		.thumb_func
 150              	_ZNSt18bad_variant_accessD0Ev:
 151              		.fnstart
 152              	.LVL10:
 153              	.LFB6323:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 154              		.loc 1 1264 9 is_stmt 1 view -0
 155              		.cfi_startproc
 156              		@ args = 0, pretend = 0, frame = 0
 157              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccoErako.s 			page 29


1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 158              		.loc 1 1264 9 is_stmt 0 view .LVU20
 159 0000 10B5     		push	{r4, lr}
 160              	.LCFI1:
 161              		.cfi_def_cfa_offset 8
 162              		.cfi_offset 4, -8
 163              		.cfi_offset 14, -4
 164 0002 0446     		mov	r4, r0
 165              	.LVL11:
 166              	.LBB657:
 167              	.LBI657:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 168              		.loc 1 1264 9 is_stmt 1 view .LVU21
 169              	.LBB658:
 170 0004 044B     		ldr	r3, .L13
 171 0006 0360     		str	r3, [r0]
 172 0008 FFF7FEFF 		bl	_ZNSt9exceptionD2Ev
 173              	.LVL12:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 174              		.loc 1 1264 9 is_stmt 0 view .LVU22
 175              	.LBE658:
 176              	.LBE657:
 177 000c 0821     		movs	r1, #8
 178 000e 2046     		mov	r0, r4
 179 0010 FFF7FEFF 		bl	_ZdlPvj
 180              	.LVL13:
 181 0014 2046     		mov	r0, r4
 182 0016 10BD     		pop	{r4, pc}
 183              	.LVL14:
 184              	.L14:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 185              		.loc 1 1264 9 view .LVU23
 186              		.align	2
 187              	.L13:
 188 0018 08000000 		.word	_ZTVSt18bad_variant_access+8
 189              		.cfi_endproc
 190              	.LFE6323:
 191              		.cantunwind
 192              		.fnend
 194              		.section	.text._ZN9CANSimple26get_encoder_error_callbackERK4Axis,"ax",%progbits
 195              		.align	1
 196              		.global	_ZN9CANSimple26get_encoder_error_callbackERK4Axis
 197              		.syntax unified
 198              		.thumb
 199              		.thumb_func
 201              	_ZN9CANSimple26get_encoder_error_callbackERK4Axis:
 202              		.fnstart
 203              	.LVL15:
 204              	.LFB5207:
 205              		.file 3 "communication/can/can_simple.cpp"
   1:communication/can/can_simple.cpp **** 
   2:communication/can/can_simple.cpp **** #include "can_simple.hpp"
   3:communication/can/can_simple.cpp **** 
   4:communication/can/can_simple.cpp **** #include <odrive_main.h>
   5:communication/can/can_simple.cpp **** #include <functional>
   6:communication/can/can_simple.cpp **** 
   7:communication/can/can_simple.cpp **** bool CANSimple::init() {
ARM GAS  /tmp/ccoErako.s 			page 30


   8:communication/can/can_simple.cpp ****     for (size_t i = 0; i < AXIS_COUNT; ++i) {
   9:communication/can/can_simple.cpp ****         if (!renew_subscription(i)) {
  10:communication/can/can_simple.cpp ****             return false;
  11:communication/can/can_simple.cpp ****         }
  12:communication/can/can_simple.cpp ****     }
  13:communication/can/can_simple.cpp **** 
  14:communication/can/can_simple.cpp ****     return true;
  15:communication/can/can_simple.cpp **** }
  16:communication/can/can_simple.cpp **** 
  17:communication/can/can_simple.cpp **** bool CANSimple::renew_subscription(size_t i) {
  18:communication/can/can_simple.cpp ****     Axis& axis = axes[i];
  19:communication/can/can_simple.cpp **** 
  20:communication/can/can_simple.cpp ****     // TODO: remove these two lines (see comment in header)
  21:communication/can/can_simple.cpp ****     node_ids_[i] = axis.config_.can.node_id;
  22:communication/can/can_simple.cpp ****     extended_node_ids_[i] = axis.config_.can.is_extended;
  23:communication/can/can_simple.cpp **** 
  24:communication/can/can_simple.cpp ****     MsgIdFilterSpecs filter = {
  25:communication/can/can_simple.cpp ****         .id = {},
  26:communication/can/can_simple.cpp ****         .mask = (uint32_t)(0xffffffff << NUM_CMD_ID_BITS)};
  27:communication/can/can_simple.cpp ****     if (axis.config_.can.is_extended) {
  28:communication/can/can_simple.cpp ****         filter.id = (uint32_t)(axis.config_.can.node_id << NUM_CMD_ID_BITS);
  29:communication/can/can_simple.cpp ****     } else {
  30:communication/can/can_simple.cpp ****         filter.id = (uint16_t)(axis.config_.can.node_id << NUM_CMD_ID_BITS);
  31:communication/can/can_simple.cpp ****     }
  32:communication/can/can_simple.cpp **** 
  33:communication/can/can_simple.cpp ****     if (subscription_handles_[i]) {
  34:communication/can/can_simple.cpp ****         canbus_->unsubscribe(subscription_handles_[i]);
  35:communication/can/can_simple.cpp ****     }
  36:communication/can/can_simple.cpp **** 
  37:communication/can/can_simple.cpp ****     return canbus_->subscribe(
  38:communication/can/can_simple.cpp ****         filter, [](void* ctx, const can_Message_t& msg) {
  39:communication/can/can_simple.cpp ****             ((CANSimple*)ctx)->handle_can_message(msg);
  40:communication/can/can_simple.cpp ****         },
  41:communication/can/can_simple.cpp ****         this, &subscription_handles_[i]);
  42:communication/can/can_simple.cpp **** }
  43:communication/can/can_simple.cpp **** 
  44:communication/can/can_simple.cpp **** void CANSimple::handle_can_message(const can_Message_t& msg) {
  45:communication/can/can_simple.cpp ****     //     Frame
  46:communication/can/can_simple.cpp ****     // nodeID | CMD
  47:communication/can/can_simple.cpp ****     // 6 bits | 5 bits
  48:communication/can/can_simple.cpp ****     uint32_t nodeID = get_node_id(msg.id);
  49:communication/can/can_simple.cpp **** 
  50:communication/can/can_simple.cpp ****     for (auto& axis : axes) {
  51:communication/can/can_simple.cpp ****         if ((axis.config_.can.node_id == nodeID) && (axis.config_.can.is_extended == msg.isExt)) {
  52:communication/can/can_simple.cpp ****             do_command(axis, msg);
  53:communication/can/can_simple.cpp ****             return;
  54:communication/can/can_simple.cpp ****         }
  55:communication/can/can_simple.cpp ****     }
  56:communication/can/can_simple.cpp **** }
  57:communication/can/can_simple.cpp **** 
  58:communication/can/can_simple.cpp **** void CANSimple::do_command(Axis& axis, const can_Message_t& msg) {
  59:communication/can/can_simple.cpp ****     const uint32_t cmd = get_cmd_id(msg.id);
  60:communication/can/can_simple.cpp ****     axis.watchdog_feed();
  61:communication/can/can_simple.cpp ****     switch (cmd) {
  62:communication/can/can_simple.cpp ****         case MSG_CO_NMT_CTRL:
  63:communication/can/can_simple.cpp ****             break;
  64:communication/can/can_simple.cpp ****         case MSG_CO_HEARTBEAT_CMD:
ARM GAS  /tmp/ccoErako.s 			page 31


  65:communication/can/can_simple.cpp ****             break;
  66:communication/can/can_simple.cpp ****         case MSG_ODRIVE_HEARTBEAT:
  67:communication/can/can_simple.cpp ****             // We don't currently do anything to respond to ODrive heartbeat messages
  68:communication/can/can_simple.cpp ****             break;
  69:communication/can/can_simple.cpp ****         case MSG_ODRIVE_ESTOP:
  70:communication/can/can_simple.cpp ****             estop_callback(axis, msg);
  71:communication/can/can_simple.cpp ****             break;
  72:communication/can/can_simple.cpp ****         case MSG_GET_MOTOR_ERROR:
  73:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
  74:communication/can/can_simple.cpp ****                 get_motor_error_callback(axis);
  75:communication/can/can_simple.cpp ****             break;
  76:communication/can/can_simple.cpp ****         case MSG_GET_ENCODER_ERROR:
  77:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
  78:communication/can/can_simple.cpp ****                 get_encoder_error_callback(axis);
  79:communication/can/can_simple.cpp ****             break;
  80:communication/can/can_simple.cpp ****         case MSG_GET_SENSORLESS_ERROR:
  81:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
  82:communication/can/can_simple.cpp ****                 get_sensorless_error_callback(axis);
  83:communication/can/can_simple.cpp ****             break;
  84:communication/can/can_simple.cpp ****         case MSG_SET_AXIS_NODE_ID:
  85:communication/can/can_simple.cpp ****             set_axis_nodeid_callback(axis, msg);
  86:communication/can/can_simple.cpp ****             break;
  87:communication/can/can_simple.cpp ****         case MSG_SET_AXIS_REQUESTED_STATE:
  88:communication/can/can_simple.cpp ****             set_axis_requested_state_callback(axis, msg);
  89:communication/can/can_simple.cpp ****             break;
  90:communication/can/can_simple.cpp ****         case MSG_SET_AXIS_STARTUP_CONFIG:
  91:communication/can/can_simple.cpp ****             set_axis_startup_config_callback(axis, msg);
  92:communication/can/can_simple.cpp ****             break;
  93:communication/can/can_simple.cpp ****         case MSG_GET_ENCODER_ESTIMATES:
  94:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
  95:communication/can/can_simple.cpp ****                 get_encoder_estimates_callback(axis);
  96:communication/can/can_simple.cpp ****             break;
  97:communication/can/can_simple.cpp ****         case MSG_GET_ENCODER_COUNT:
  98:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
  99:communication/can/can_simple.cpp ****                 get_encoder_count_callback(axis);
 100:communication/can/can_simple.cpp ****             break;
 101:communication/can/can_simple.cpp ****         case MSG_SET_INPUT_POS:
 102:communication/can/can_simple.cpp ****             set_input_pos_callback(axis, msg);
 103:communication/can/can_simple.cpp ****             break;
 104:communication/can/can_simple.cpp ****         case MSG_SET_INPUT_VEL:
 105:communication/can/can_simple.cpp ****             set_input_vel_callback(axis, msg);
 106:communication/can/can_simple.cpp ****             break;
 107:communication/can/can_simple.cpp ****         case MSG_SET_INPUT_TORQUE:
 108:communication/can/can_simple.cpp ****             set_input_torque_callback(axis, msg);
 109:communication/can/can_simple.cpp ****             break;
 110:communication/can/can_simple.cpp ****         case MSG_SET_CONTROLLER_MODES:
 111:communication/can/can_simple.cpp ****             set_controller_modes_callback(axis, msg);
 112:communication/can/can_simple.cpp ****             break;
 113:communication/can/can_simple.cpp ****         case MSG_SET_LIMITS:
 114:communication/can/can_simple.cpp ****             set_limits_callback(axis, msg);
 115:communication/can/can_simple.cpp ****             break;
 116:communication/can/can_simple.cpp ****         case MSG_START_ANTICOGGING:
 117:communication/can/can_simple.cpp ****             start_anticogging_callback(axis, msg);
 118:communication/can/can_simple.cpp ****             break;
 119:communication/can/can_simple.cpp ****         case MSG_SET_TRAJ_INERTIA:
 120:communication/can/can_simple.cpp ****             set_traj_inertia_callback(axis, msg);
 121:communication/can/can_simple.cpp ****             break;
ARM GAS  /tmp/ccoErako.s 			page 32


 122:communication/can/can_simple.cpp ****         case MSG_SET_TRAJ_ACCEL_LIMITS:
 123:communication/can/can_simple.cpp ****             set_traj_accel_limits_callback(axis, msg);
 124:communication/can/can_simple.cpp ****             break;
 125:communication/can/can_simple.cpp ****         case MSG_SET_TRAJ_VEL_LIMIT:
 126:communication/can/can_simple.cpp ****             set_traj_vel_limit_callback(axis, msg);
 127:communication/can/can_simple.cpp ****             break;
 128:communication/can/can_simple.cpp ****         case MSG_GET_IQ:
 129:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
 130:communication/can/can_simple.cpp ****                 get_iq_callback(axis);
 131:communication/can/can_simple.cpp ****             break;
 132:communication/can/can_simple.cpp ****         case MSG_GET_SENSORLESS_ESTIMATES:
 133:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
 134:communication/can/can_simple.cpp ****                 get_sensorless_estimates_callback(axis);
 135:communication/can/can_simple.cpp ****             break;
 136:communication/can/can_simple.cpp ****         case MSG_RESET_ODRIVE:
 137:communication/can/can_simple.cpp ****             NVIC_SystemReset();
 138:communication/can/can_simple.cpp ****             break;
 139:communication/can/can_simple.cpp ****         case MSG_GET_BUS_VOLTAGE_CURRENT:
 140:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
 141:communication/can/can_simple.cpp ****                 get_bus_voltage_current_callback(axis);
 142:communication/can/can_simple.cpp ****             break;
 143:communication/can/can_simple.cpp ****         case MSG_CLEAR_ERRORS:
 144:communication/can/can_simple.cpp ****             clear_errors_callback(axis, msg);
 145:communication/can/can_simple.cpp ****             break;
 146:communication/can/can_simple.cpp ****         case MSG_SET_LINEAR_COUNT:
 147:communication/can/can_simple.cpp ****             set_linear_count_callback(axis, msg);
 148:communication/can/can_simple.cpp ****             break;
 149:communication/can/can_simple.cpp ****         case MSG_SET_POS_GAIN:
 150:communication/can/can_simple.cpp ****             set_pos_gain_callback(axis, msg);
 151:communication/can/can_simple.cpp ****             break;
 152:communication/can/can_simple.cpp ****         case MSG_SET_VEL_GAINS:
 153:communication/can/can_simple.cpp ****             set_vel_gains_callback(axis, msg);
 154:communication/can/can_simple.cpp ****             break;
 155:communication/can/can_simple.cpp ****         case MSG_GET_ADC_VOLTAGE:
 156:communication/can/can_simple.cpp ****             get_adc_voltage_callback(axis, msg);
 157:communication/can/can_simple.cpp ****             break;
 158:communication/can/can_simple.cpp ****         case MSG_GET_CONTROLLER_ERROR:
 159:communication/can/can_simple.cpp ****             get_controller_error_callback(axis);
 160:communication/can/can_simple.cpp ****             break;
 161:communication/can/can_simple.cpp ****         default:
 162:communication/can/can_simple.cpp ****             break;
 163:communication/can/can_simple.cpp ****     }
 164:communication/can/can_simple.cpp **** }
 165:communication/can/can_simple.cpp **** 
 166:communication/can/can_simple.cpp **** void CANSimple::nmt_callback(const Axis& axis, const can_Message_t& msg) {
 167:communication/can/can_simple.cpp ****     // Not implemented
 168:communication/can/can_simple.cpp **** }
 169:communication/can/can_simple.cpp **** 
 170:communication/can/can_simple.cpp **** void CANSimple::estop_callback(Axis& axis, const can_Message_t& msg) {
 171:communication/can/can_simple.cpp ****     axis.error_ |= Axis::ERROR_ESTOP_REQUESTED;
 172:communication/can/can_simple.cpp **** }
 173:communication/can/can_simple.cpp **** 
 174:communication/can/can_simple.cpp **** bool CANSimple::get_motor_error_callback(const Axis& axis) {
 175:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 176:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 177:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_MOTOR_ERROR;  // heartbeat ID
 178:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
ARM GAS  /tmp/ccoErako.s 			page 33


 179:communication/can/can_simple.cpp ****     txmsg.len = 8;
 180:communication/can/can_simple.cpp **** 
 181:communication/can/can_simple.cpp ****     can_setSignal(txmsg, axis.motor_.error_, 0, 64, true);
 182:communication/can/can_simple.cpp **** 
 183:communication/can/can_simple.cpp ****     return canbus_->send_message(txmsg);
 184:communication/can/can_simple.cpp **** }
 185:communication/can/can_simple.cpp **** 
 186:communication/can/can_simple.cpp **** bool CANSimple::get_encoder_error_callback(const Axis& axis) {
 206              		.loc 3 186 62 is_stmt 1 view -0
 207              		.cfi_startproc
 208              		@ args = 0, pretend = 0, frame = 32
 209              		@ frame_needed = 0, uses_anonymous_args = 0
 210              		.loc 3 186 62 is_stmt 0 view .LVU25
 211 0000 10B5     		push	{r4, lr}
 212              		.save {r4, lr}
 213              	.LCFI2:
 214              		.cfi_def_cfa_offset 8
 215              		.cfi_offset 4, -8
 216              		.cfi_offset 14, -4
 217              		.pad #32
 218 0002 88B0     		sub	sp, sp, #32
 219              	.LCFI3:
 220              		.cfi_def_cfa_offset 40
 221 0004 0446     		mov	r4, r0
 222 0006 8E46     		mov	lr, r1
 187:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 223              		.loc 3 187 5 is_stmt 1 view .LVU26
 224              		.loc 3 187 19 is_stmt 0 view .LVU27
 225 0008 1B4B     		ldr	r3, .L17
 226 000a 0DF1100C 		add	ip, sp, #16
 227 000e 0FCB     		ldm	r3, {r0, r1, r2, r3}
 228              	.LVL16:
 229              		.loc 3 187 19 view .LVU28
 230 0010 8CE80F00 		stm	ip, {r0, r1, r2, r3}
 188:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 231              		.loc 3 188 5 is_stmt 1 view .LVU29
 232              		.loc 3 188 33 is_stmt 0 view .LVU30
 233 0014 DEF87830 		ldr	r3, [lr, #120]
 234              		.loc 3 188 41 view .LVU31
 235 0018 5B01     		lsls	r3, r3, #5
 236              		.loc 3 188 14 view .LVU32
 237 001a 0493     		str	r3, [sp, #16]
 189:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_ENCODER_ERROR;  // heartbeat ID
 238              		.loc 3 189 5 is_stmt 1 view .LVU33
 239              		.loc 3 189 14 is_stmt 0 view .LVU34
 240 001c 0433     		adds	r3, r3, #4
 241 001e 0493     		str	r3, [sp, #16]
 190:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 242              		.loc 3 190 5 is_stmt 1 view .LVU35
 243              		.loc 3 190 36 is_stmt 0 view .LVU36
 244 0020 9EF87C30 		ldrb	r3, [lr, #124]	@ zero_extendqisi2
 245              		.loc 3 190 17 view .LVU37
 246 0024 8DF81430 		strb	r3, [sp, #20]
 191:communication/can/can_simple.cpp ****     txmsg.len = 8;
 247              		.loc 3 191 5 is_stmt 1 view .LVU38
 192:communication/can/can_simple.cpp **** 
 193:communication/can/can_simple.cpp ****     can_setSignal(txmsg, axis.encoder_.error_, 0, 32, true);
ARM GAS  /tmp/ccoErako.s 			page 34


 248              		.loc 3 193 5 view .LVU39
 249              		.loc 3 193 31 is_stmt 0 view .LVU40
 250 0028 DEF8AC10 		ldr	r1, [lr, #172]
 251              	.LVL17:
 252              	.LBB670:
 253              	.LBI670:
 254              		.file 4 "communication/can/can_helpers.hpp"
   1:communication/can/can_helpers.hpp **** #pragma once
   2:communication/can/can_helpers.hpp **** 
   3:communication/can/can_helpers.hpp **** #include <stdint.h>
   4:communication/can/can_helpers.hpp **** #include <algorithm>
   5:communication/can/can_helpers.hpp **** #include <cstring>
   6:communication/can/can_helpers.hpp **** #include <iterator>
   7:communication/can/can_helpers.hpp **** 
   8:communication/can/can_helpers.hpp **** struct can_Message_t {
   9:communication/can/can_helpers.hpp ****     uint32_t id = 0x000;  // 11-bit max is 0x7ff, 29-bit max is 0x1FFFFFFF
  10:communication/can/can_helpers.hpp ****     bool isExt = false;
  11:communication/can/can_helpers.hpp ****     bool rtr = false;
  12:communication/can/can_helpers.hpp ****     uint8_t len = 8;
  13:communication/can/can_helpers.hpp ****     uint8_t buf[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  14:communication/can/can_helpers.hpp **** } ;
  15:communication/can/can_helpers.hpp **** 
  16:communication/can/can_helpers.hpp **** struct can_Signal_t {
  17:communication/can/can_helpers.hpp ****     const uint8_t startBit;
  18:communication/can/can_helpers.hpp ****     const uint8_t length;
  19:communication/can/can_helpers.hpp ****     const bool isIntel;
  20:communication/can/can_helpers.hpp ****     const float factor;
  21:communication/can/can_helpers.hpp ****     const float offset;
  22:communication/can/can_helpers.hpp **** };
  23:communication/can/can_helpers.hpp **** 
  24:communication/can/can_helpers.hpp **** struct can_Cyclic_t {
  25:communication/can/can_helpers.hpp ****     uint32_t cycleTime_ms;
  26:communication/can/can_helpers.hpp ****     uint32_t lastTime_ms;
  27:communication/can/can_helpers.hpp **** };
  28:communication/can/can_helpers.hpp **** 
  29:communication/can/can_helpers.hpp **** #include <iterator>
  30:communication/can/can_helpers.hpp **** template <typename T>
  31:communication/can/can_helpers.hpp **** constexpr T can_getSignal(can_Message_t msg, const uint8_t startBit, const uint8_t length, const bo
  32:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
  33:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
  34:communication/can/can_helpers.hpp **** 
  35:communication/can/can_helpers.hpp ****     if (isIntel) {
  36:communication/can/can_helpers.hpp ****         std::memcpy(&tempVal, msg.buf, sizeof(tempVal));
  37:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
  38:communication/can/can_helpers.hpp ****     } else {
  39:communication/can/can_helpers.hpp ****         std::reverse(std::begin(msg.buf), std::end(msg.buf));
  40:communication/can/can_helpers.hpp ****         std::memcpy(&tempVal, msg.buf, sizeof(tempVal));
  41:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> (64 - startBit - length)) & mask;
  42:communication/can/can_helpers.hpp ****     }
  43:communication/can/can_helpers.hpp **** 
  44:communication/can/can_helpers.hpp ****     T retVal;
  45:communication/can/can_helpers.hpp ****     std::memcpy(&retVal, &tempVal, sizeof(T));
  46:communication/can/can_helpers.hpp ****     return retVal;
  47:communication/can/can_helpers.hpp **** }
  48:communication/can/can_helpers.hpp **** 
  49:communication/can/can_helpers.hpp **** template <typename T>
  50:communication/can/can_helpers.hpp **** constexpr void can_setSignal(can_Message_t& msg, const T& val, const uint8_t startBit, const uint8_
ARM GAS  /tmp/ccoErako.s 			page 35


 255              		.loc 4 50 16 is_stmt 1 view .LVU41
 256              	.LBB671:
  51:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 257              		.loc 4 51 14 is_stmt 0 view .LVU42
 258 002c 0022     		movs	r2, #0
 259 002e 0023     		movs	r3, #0
 260 0030 CDE90023 		strd	r2, [sp]
 261 0034 B1F88C10 		ldrh	r1, [r1, #140]	@ unaligned
 262              	.LVL18:
  52:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 263              		.loc 4 52 16 view .LVU43
 264 0038 ADF80010 		strh	r1, [sp]	@ movhi
 265              	.LVL19:
 266              	.LBB672:
  53:communication/can/can_helpers.hpp **** 
  54:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
  55:communication/can/can_helpers.hpp **** 
  56:communication/can/can_helpers.hpp ****     if (isIntel) {
  57:communication/can/can_helpers.hpp ****         uint64_t data = 0;
 267              		.loc 4 57 18 view .LVU44
 268 003c CDE90223 		strd	r2, [sp, #8]
  58:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 269              		.loc 4 58 20 view .LVU45
 270 0040 02AB     		add	r3, sp, #8
 271 0042 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 272 0046 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 273 004a 03C3     		stmia	r3!, {r0, r1}
  59:communication/can/can_helpers.hpp **** 
  60:communication/can/can_helpers.hpp ****         data &= ~(mask << startBit);
 274              		.loc 4 60 14 view .LVU46
 275 004c 0023     		movs	r3, #0
 276 004e 0293     		str	r3, [sp, #8]
  61:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 277              		.loc 4 61 27 view .LVU47
 278 0050 019A     		ldr	r2, [sp, #4]
 279              		.loc 4 61 14 view .LVU48
 280 0052 0B46     		mov	r3, r1
 281 0054 1343     		orrs	r3, r3, r2
 282 0056 009A     		ldr	r2, [sp]
 283 0058 0292     		str	r2, [sp, #8]
 284 005a 0393     		str	r3, [sp, #12]
  62:communication/can/can_helpers.hpp **** 
  63:communication/can/can_helpers.hpp ****         std::memcpy(msg.buf, &data, sizeof(data));
 285              		.loc 4 63 20 view .LVU49
 286 005c 02AB     		add	r3, sp, #8
 287 005e 03CB     		ldmia	r3!, {r0, r1}
 288 0060 CDF81700 		str	r0, [sp, #23]	@ unaligned
 289 0064 CDF81B10 		str	r1, [sp, #27]	@ unaligned
 290              	.LVL20:
 291              		.loc 4 63 20 view .LVU50
 292              	.LBE672:
 293              	.LBE671:
 294              	.LBE670:
 194:communication/can/can_simple.cpp **** 
 195:communication/can/can_simple.cpp ****     return canbus_->send_message(txmsg);
 295              		.loc 3 195 5 is_stmt 1 view .LVU51
 296              		.loc 3 195 12 is_stmt 0 view .LVU52
ARM GAS  /tmp/ccoErako.s 			page 36


 297 0068 2068     		ldr	r0, [r4]
 298              		.loc 3 195 39 view .LVU53
 299 006a 0368     		ldr	r3, [r0]
 300 006c 1B68     		ldr	r3, [r3]
 301              		.loc 3 195 33 view .LVU54
 302 006e 6146     		mov	r1, ip
 303 0070 9847     		blx	r3
 304              	.LVL21:
 196:communication/can/can_simple.cpp **** }
 305              		.loc 3 196 1 view .LVU55
 306 0072 08B0     		add	sp, sp, #32
 307              	.LCFI4:
 308              		.cfi_def_cfa_offset 8
 309              		@ sp needed
 310 0074 10BD     		pop	{r4, pc}
 311              	.LVL22:
 312              	.L18:
 313              		.loc 3 196 1 view .LVU56
 314 0076 00BF     		.align	2
 315              	.L17:
 316 0078 00000000 		.word	.LANCHOR0
 317              		.cfi_endproc
 318              	.LFE5207:
 319              		.fnend
 321              		.section	.text._ZN9CANSimple29get_sensorless_error_callbackERK4Axis,"ax",%progbits
 322              		.align	1
 323              		.global	_ZN9CANSimple29get_sensorless_error_callbackERK4Axis
 324              		.syntax unified
 325              		.thumb
 326              		.thumb_func
 328              	_ZN9CANSimple29get_sensorless_error_callbackERK4Axis:
 329              		.fnstart
 330              	.LVL23:
 331              	.LFB5208:
 197:communication/can/can_simple.cpp **** 
 198:communication/can/can_simple.cpp **** bool CANSimple::get_sensorless_error_callback(const Axis& axis) {
 332              		.loc 3 198 65 is_stmt 1 view -0
 333              		.cfi_startproc
 334              		@ args = 0, pretend = 0, frame = 32
 335              		@ frame_needed = 0, uses_anonymous_args = 0
 336              		.loc 3 198 65 is_stmt 0 view .LVU58
 337 0000 10B5     		push	{r4, lr}
 338              		.save {r4, lr}
 339              	.LCFI5:
 340              		.cfi_def_cfa_offset 8
 341              		.cfi_offset 4, -8
 342              		.cfi_offset 14, -4
 343              		.pad #32
 344 0002 88B0     		sub	sp, sp, #32
 345              	.LCFI6:
 346              		.cfi_def_cfa_offset 40
 347 0004 0446     		mov	r4, r0
 348 0006 8E46     		mov	lr, r1
 199:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 349              		.loc 3 199 5 is_stmt 1 view .LVU59
 350              		.loc 3 199 19 is_stmt 0 view .LVU60
 351 0008 1A4B     		ldr	r3, .L21
ARM GAS  /tmp/ccoErako.s 			page 37


 352 000a 0DF1100C 		add	ip, sp, #16
 353 000e 0FCB     		ldm	r3, {r0, r1, r2, r3}
 354              	.LVL24:
 355              		.loc 3 199 19 view .LVU61
 356 0010 8CE80F00 		stm	ip, {r0, r1, r2, r3}
 200:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 357              		.loc 3 200 5 is_stmt 1 view .LVU62
 358              		.loc 3 200 33 is_stmt 0 view .LVU63
 359 0014 DEF87830 		ldr	r3, [lr, #120]
 360              		.loc 3 200 41 view .LVU64
 361 0018 5B01     		lsls	r3, r3, #5
 362              		.loc 3 200 14 view .LVU65
 363 001a 0493     		str	r3, [sp, #16]
 201:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_SENSORLESS_ERROR;  // heartbeat ID
 364              		.loc 3 201 5 is_stmt 1 view .LVU66
 365              		.loc 3 201 14 is_stmt 0 view .LVU67
 366 001c 0533     		adds	r3, r3, #5
 367 001e 0493     		str	r3, [sp, #16]
 202:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 368              		.loc 3 202 5 is_stmt 1 view .LVU68
 369              		.loc 3 202 36 is_stmt 0 view .LVU69
 370 0020 9EF87C30 		ldrb	r3, [lr, #124]	@ zero_extendqisi2
 371              		.loc 3 202 17 view .LVU70
 372 0024 8DF81430 		strb	r3, [sp, #20]
 203:communication/can/can_simple.cpp ****     txmsg.len = 8;
 373              		.loc 3 203 5 is_stmt 1 view .LVU71
 204:communication/can/can_simple.cpp **** 
 205:communication/can/can_simple.cpp ****     can_setSignal(txmsg, axis.sensorless_estimator_.error_, 0, 32, true);
 374              		.loc 3 205 5 view .LVU72
 375              		.loc 3 205 31 is_stmt 0 view .LVU73
 376 0028 DEF8FC10 		ldr	r1, [lr, #252]
 377              	.LVL25:
 378              	.LBB684:
 379              	.LBI684:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 380              		.loc 4 50 16 is_stmt 1 view .LVU74
 381              	.LBB685:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 382              		.loc 4 51 14 is_stmt 0 view .LVU75
 383 002c 0022     		movs	r2, #0
 384 002e 0023     		movs	r3, #0
 385 0030 CDE90023 		strd	r2, [sp]
 386 0034 097C     		ldrb	r1, [r1, #16]	@ zero_extendqisi2
 387              	.LVL26:
  52:communication/can/can_helpers.hpp **** 
 388              		.loc 4 52 16 view .LVU76
 389 0036 8DF80010 		strb	r1, [sp]
 390              	.LVL27:
 391              	.LBB686:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 392              		.loc 4 57 18 view .LVU77
 393 003a CDE90223 		strd	r2, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 394              		.loc 4 58 20 view .LVU78
 395 003e 02AB     		add	r3, sp, #8
 396 0040 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 397 0044 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
ARM GAS  /tmp/ccoErako.s 			page 38


 398 0048 03C3     		stmia	r3!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 399              		.loc 4 60 14 view .LVU79
 400 004a 0023     		movs	r3, #0
 401 004c 0293     		str	r3, [sp, #8]
  61:communication/can/can_helpers.hpp **** 
 402              		.loc 4 61 27 view .LVU80
 403 004e 019A     		ldr	r2, [sp, #4]
  61:communication/can/can_helpers.hpp **** 
 404              		.loc 4 61 14 view .LVU81
 405 0050 0B46     		mov	r3, r1
 406 0052 1343     		orrs	r3, r3, r2
 407 0054 009A     		ldr	r2, [sp]
 408 0056 0292     		str	r2, [sp, #8]
 409 0058 0393     		str	r3, [sp, #12]
 410              		.loc 4 63 20 view .LVU82
 411 005a 02AB     		add	r3, sp, #8
 412 005c 03CB     		ldmia	r3!, {r0, r1}
 413 005e CDF81700 		str	r0, [sp, #23]	@ unaligned
 414 0062 CDF81B10 		str	r1, [sp, #27]	@ unaligned
 415              	.LVL28:
 416              		.loc 4 63 20 view .LVU83
 417              	.LBE686:
 418              	.LBE685:
 419              	.LBE684:
 206:communication/can/can_simple.cpp **** 
 207:communication/can/can_simple.cpp ****     return canbus_->send_message(txmsg);
 420              		.loc 3 207 5 is_stmt 1 view .LVU84
 421              		.loc 3 207 12 is_stmt 0 view .LVU85
 422 0066 2068     		ldr	r0, [r4]
 423              		.loc 3 207 39 view .LVU86
 424 0068 0368     		ldr	r3, [r0]
 425 006a 1B68     		ldr	r3, [r3]
 426              		.loc 3 207 33 view .LVU87
 427 006c 6146     		mov	r1, ip
 428 006e 9847     		blx	r3
 429              	.LVL29:
 208:communication/can/can_simple.cpp **** }
 430              		.loc 3 208 1 view .LVU88
 431 0070 08B0     		add	sp, sp, #32
 432              	.LCFI7:
 433              		.cfi_def_cfa_offset 8
 434              		@ sp needed
 435 0072 10BD     		pop	{r4, pc}
 436              	.LVL30:
 437              	.L22:
 438              		.loc 3 208 1 view .LVU89
 439              		.align	2
 440              	.L21:
 441 0074 00000000 		.word	.LANCHOR0
 442              		.cfi_endproc
 443              	.LFE5208:
 444              		.fnend
 446              		.section	.text._ZN9CANSimple29get_controller_error_callbackERK4Axis,"ax",%progbits
 447              		.align	1
 448              		.global	_ZN9CANSimple29get_controller_error_callbackERK4Axis
 449              		.syntax unified
ARM GAS  /tmp/ccoErako.s 			page 39


 450              		.thumb
 451              		.thumb_func
 453              	_ZN9CANSimple29get_controller_error_callbackERK4Axis:
 454              		.fnstart
 455              	.LVL31:
 456              	.LFB5209:
 209:communication/can/can_simple.cpp **** 
 210:communication/can/can_simple.cpp **** bool CANSimple::get_controller_error_callback(const Axis& axis) {
 457              		.loc 3 210 65 is_stmt 1 view -0
 458              		.cfi_startproc
 459              		@ args = 0, pretend = 0, frame = 32
 460              		@ frame_needed = 0, uses_anonymous_args = 0
 461              		.loc 3 210 65 is_stmt 0 view .LVU91
 462 0000 10B5     		push	{r4, lr}
 463              		.save {r4, lr}
 464              	.LCFI8:
 465              		.cfi_def_cfa_offset 8
 466              		.cfi_offset 4, -8
 467              		.cfi_offset 14, -4
 468              		.pad #32
 469 0002 88B0     		sub	sp, sp, #32
 470              	.LCFI9:
 471              		.cfi_def_cfa_offset 40
 472 0004 0446     		mov	r4, r0
 473 0006 8E46     		mov	lr, r1
 211:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 474              		.loc 3 211 5 is_stmt 1 view .LVU92
 475              		.loc 3 211 19 is_stmt 0 view .LVU93
 476 0008 1B4B     		ldr	r3, .L25
 477 000a 0DF1100C 		add	ip, sp, #16
 478 000e 0FCB     		ldm	r3, {r0, r1, r2, r3}
 479              	.LVL32:
 480              		.loc 3 211 19 view .LVU94
 481 0010 8CE80F00 		stm	ip, {r0, r1, r2, r3}
 212:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 482              		.loc 3 212 5 is_stmt 1 view .LVU95
 483              		.loc 3 212 33 is_stmt 0 view .LVU96
 484 0014 DEF87830 		ldr	r3, [lr, #120]
 485              		.loc 3 212 41 view .LVU97
 486 0018 5B01     		lsls	r3, r3, #5
 487              		.loc 3 212 14 view .LVU98
 488 001a 0493     		str	r3, [sp, #16]
 213:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_CONTROLLER_ERROR;  // heartbeat ID
 489              		.loc 3 213 5 is_stmt 1 view .LVU99
 490              		.loc 3 213 14 is_stmt 0 view .LVU100
 491 001c 1D33     		adds	r3, r3, #29
 492 001e 0493     		str	r3, [sp, #16]
 214:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 493              		.loc 3 214 5 is_stmt 1 view .LVU101
 494              		.loc 3 214 36 is_stmt 0 view .LVU102
 495 0020 9EF87C30 		ldrb	r3, [lr, #124]	@ zero_extendqisi2
 496              		.loc 3 214 17 view .LVU103
 497 0024 8DF81430 		strb	r3, [sp, #20]
 215:communication/can/can_simple.cpp ****     txmsg.len = 8;
 498              		.loc 3 215 5 is_stmt 1 view .LVU104
 216:communication/can/can_simple.cpp **** 
 217:communication/can/can_simple.cpp ****     can_setSignal(txmsg, axis.controller_.error_, 0, 32, true);
ARM GAS  /tmp/ccoErako.s 			page 40


 499              		.loc 3 217 5 view .LVU105
 500              		.loc 3 217 31 is_stmt 0 view .LVU106
 501 0028 DEF80001 		ldr	r0, [lr, #256]
 502              	.LVL33:
 503              	.LBB698:
 504              	.LBI698:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 505              		.loc 4 50 16 is_stmt 1 view .LVU107
 506              	.LBB699:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 507              		.loc 4 51 14 is_stmt 0 view .LVU108
 508 002c 0022     		movs	r2, #0
 509 002e 0023     		movs	r3, #0
 510 0030 CDE90023 		strd	r2, [sp]
 511 0034 43F6DC01 		movw	r1, #14556
 512 0038 415C     		ldrb	r1, [r0, r1]	@ zero_extendqisi2
  52:communication/can/can_helpers.hpp **** 
 513              		.loc 4 52 16 view .LVU109
 514 003a 8DF80010 		strb	r1, [sp]
 515              	.LVL34:
 516              	.LBB700:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 517              		.loc 4 57 18 view .LVU110
 518 003e CDE90223 		strd	r2, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 519              		.loc 4 58 20 view .LVU111
 520 0042 02AB     		add	r3, sp, #8
 521 0044 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 522              	.LVL35:
  58:communication/can/can_helpers.hpp **** 
 523              		.loc 4 58 20 view .LVU112
 524 0048 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 525 004c 03C3     		stmia	r3!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 526              		.loc 4 60 14 view .LVU113
 527 004e 0023     		movs	r3, #0
 528 0050 0293     		str	r3, [sp, #8]
  61:communication/can/can_helpers.hpp **** 
 529              		.loc 4 61 27 view .LVU114
 530 0052 019A     		ldr	r2, [sp, #4]
  61:communication/can/can_helpers.hpp **** 
 531              		.loc 4 61 14 view .LVU115
 532 0054 0B46     		mov	r3, r1
 533 0056 1343     		orrs	r3, r3, r2
 534 0058 009A     		ldr	r2, [sp]
 535 005a 0292     		str	r2, [sp, #8]
 536 005c 0393     		str	r3, [sp, #12]
 537              		.loc 4 63 20 view .LVU116
 538 005e 02AB     		add	r3, sp, #8
 539 0060 03CB     		ldmia	r3!, {r0, r1}
 540 0062 CDF81700 		str	r0, [sp, #23]	@ unaligned
 541 0066 CDF81B10 		str	r1, [sp, #27]	@ unaligned
 542              	.LVL36:
 543              		.loc 4 63 20 view .LVU117
 544              	.LBE700:
 545              	.LBE699:
 546              	.LBE698:
ARM GAS  /tmp/ccoErako.s 			page 41


 218:communication/can/can_simple.cpp **** 
 219:communication/can/can_simple.cpp ****     return canbus_->send_message(txmsg);
 547              		.loc 3 219 5 is_stmt 1 view .LVU118
 548              		.loc 3 219 12 is_stmt 0 view .LVU119
 549 006a 2068     		ldr	r0, [r4]
 550              		.loc 3 219 39 view .LVU120
 551 006c 0368     		ldr	r3, [r0]
 552 006e 1B68     		ldr	r3, [r3]
 553              		.loc 3 219 33 view .LVU121
 554 0070 6146     		mov	r1, ip
 555 0072 9847     		blx	r3
 556              	.LVL37:
 220:communication/can/can_simple.cpp **** }
 557              		.loc 3 220 1 view .LVU122
 558 0074 08B0     		add	sp, sp, #32
 559              	.LCFI10:
 560              		.cfi_def_cfa_offset 8
 561              		@ sp needed
 562 0076 10BD     		pop	{r4, pc}
 563              	.LVL38:
 564              	.L26:
 565              		.loc 3 220 1 view .LVU123
 566              		.align	2
 567              	.L25:
 568 0078 00000000 		.word	.LANCHOR0
 569              		.cfi_endproc
 570              	.LFE5209:
 571              		.fnend
 573              		.section	.text._ZN9CANSimple24get_motor_error_callbackERK4Axis,"ax",%progbits
 574              		.align	1
 575              		.global	_ZN9CANSimple24get_motor_error_callbackERK4Axis
 576              		.syntax unified
 577              		.thumb
 578              		.thumb_func
 580              	_ZN9CANSimple24get_motor_error_callbackERK4Axis:
 581              		.fnstart
 582              	.LVL39:
 583              	.LFB5203:
 174:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 584              		.loc 3 174 60 is_stmt 1 view -0
 585              		.cfi_startproc
 586              		@ args = 0, pretend = 0, frame = 32
 587              		@ frame_needed = 0, uses_anonymous_args = 0
 174:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 588              		.loc 3 174 60 is_stmt 0 view .LVU125
 589 0000 10B5     		push	{r4, lr}
 590              		.save {r4, lr}
 591              	.LCFI11:
 592              		.cfi_def_cfa_offset 8
 593              		.cfi_offset 4, -8
 594              		.cfi_offset 14, -4
 595              		.pad #32
 596 0002 88B0     		sub	sp, sp, #32
 597              	.LCFI12:
 598              		.cfi_def_cfa_offset 40
 599 0004 0446     		mov	r4, r0
 600 0006 8E46     		mov	lr, r1
ARM GAS  /tmp/ccoErako.s 			page 42


 175:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 601              		.loc 3 175 5 is_stmt 1 view .LVU126
 175:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 602              		.loc 3 175 19 is_stmt 0 view .LVU127
 603 0008 1D4B     		ldr	r3, .L29+8
 604 000a 0DF1100C 		add	ip, sp, #16
 605 000e 0FCB     		ldm	r3, {r0, r1, r2, r3}
 606              	.LVL40:
 175:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 607              		.loc 3 175 19 view .LVU128
 608 0010 8CE80F00 		stm	ip, {r0, r1, r2, r3}
 176:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_MOTOR_ERROR;  // heartbeat ID
 609              		.loc 3 176 5 is_stmt 1 view .LVU129
 176:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_MOTOR_ERROR;  // heartbeat ID
 610              		.loc 3 176 33 is_stmt 0 view .LVU130
 611 0014 DEF87830 		ldr	r3, [lr, #120]
 176:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_MOTOR_ERROR;  // heartbeat ID
 612              		.loc 3 176 41 view .LVU131
 613 0018 5B01     		lsls	r3, r3, #5
 176:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_MOTOR_ERROR;  // heartbeat ID
 614              		.loc 3 176 14 view .LVU132
 615 001a 0493     		str	r3, [sp, #16]
 177:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 616              		.loc 3 177 5 is_stmt 1 view .LVU133
 177:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 617              		.loc 3 177 14 is_stmt 0 view .LVU134
 618 001c 0333     		adds	r3, r3, #3
 619 001e 0493     		str	r3, [sp, #16]
 178:communication/can/can_simple.cpp ****     txmsg.len = 8;
 620              		.loc 3 178 5 is_stmt 1 view .LVU135
 178:communication/can/can_simple.cpp ****     txmsg.len = 8;
 621              		.loc 3 178 36 is_stmt 0 view .LVU136
 622 0020 9EF87C30 		ldrb	r3, [lr, #124]	@ zero_extendqisi2
 178:communication/can/can_simple.cpp ****     txmsg.len = 8;
 623              		.loc 3 178 17 view .LVU137
 624 0024 8DF81430 		strb	r3, [sp, #20]
 179:communication/can/can_simple.cpp **** 
 625              		.loc 3 179 5 is_stmt 1 view .LVU138
 181:communication/can/can_simple.cpp **** 
 626              		.loc 3 181 5 view .LVU139
 181:communication/can/can_simple.cpp **** 
 627              		.loc 3 181 31 is_stmt 0 view .LVU140
 628 0028 DEF85821 		ldr	r2, [lr, #344]
 629              	.LVL41:
 630              	.LBB712:
 631              	.LBI712:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 632              		.loc 4 50 16 is_stmt 1 view .LVU141
 633              	.LBB713:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 634              		.loc 4 51 14 is_stmt 0 view .LVU142
 635 002c 9FED127B 		vldr.64	d7, .L29	@ int
 636 0030 8DED007B 		vstr.64	d7, [sp]	@ int
  52:communication/can/can_helpers.hpp **** 
 637              		.loc 4 52 16 view .LVU143
 638 0034 6B46     		mov	r3, sp
 639 0036 D2F89000 		ldr	r0, [r2, #144]	@ unaligned
ARM GAS  /tmp/ccoErako.s 			page 43


 640 003a D2F89410 		ldr	r1, [r2, #148]	@ unaligned
 641 003e 03C3     		stmia	r3!, {r0, r1}
 642              	.LVL42:
 643              	.LBB714:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 644              		.loc 4 57 18 view .LVU144
 645 0040 8DED027B 		vstr.64	d7, [sp, #8]	@ int
  58:communication/can/can_helpers.hpp **** 
 646              		.loc 4 58 20 view .LVU145
 647 0044 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 648 0048 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 649 004c 03C3     		stmia	r3!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 650              		.loc 4 60 14 view .LVU146
 651 004e 8DED027B 		vstr.64	d7, [sp, #8]	@ int
  61:communication/can/can_helpers.hpp **** 
 652              		.loc 4 61 27 view .LVU147
 653 0052 DDE90023 		ldrd	r2, [sp]
 654              	.LVL43:
  61:communication/can/can_helpers.hpp **** 
 655              		.loc 4 61 14 view .LVU148
 656 0056 CDE90223 		strd	r2, [sp, #8]
 657              		.loc 4 63 20 view .LVU149
 658 005a 02AB     		add	r3, sp, #8
 659 005c 03CB     		ldmia	r3!, {r0, r1}
 660 005e CDF81700 		str	r0, [sp, #23]	@ unaligned
 661 0062 CDF81B10 		str	r1, [sp, #27]	@ unaligned
 662              	.LVL44:
 663              		.loc 4 63 20 view .LVU150
 664              	.LBE714:
 665              	.LBE713:
 666              	.LBE712:
 183:communication/can/can_simple.cpp **** }
 667              		.loc 3 183 5 is_stmt 1 view .LVU151
 183:communication/can/can_simple.cpp **** }
 668              		.loc 3 183 12 is_stmt 0 view .LVU152
 669 0066 2068     		ldr	r0, [r4]
 183:communication/can/can_simple.cpp **** }
 670              		.loc 3 183 39 view .LVU153
 671 0068 0368     		ldr	r3, [r0]
 672 006a 1B68     		ldr	r3, [r3]
 183:communication/can/can_simple.cpp **** }
 673              		.loc 3 183 33 view .LVU154
 674 006c 6146     		mov	r1, ip
 675 006e 9847     		blx	r3
 676              	.LVL45:
 184:communication/can/can_simple.cpp **** 
 677              		.loc 3 184 1 view .LVU155
 678 0070 08B0     		add	sp, sp, #32
 679              	.LCFI13:
 680              		.cfi_def_cfa_offset 8
 681              		@ sp needed
 682 0072 10BD     		pop	{r4, pc}
 683              	.LVL46:
 684              	.L30:
 184:communication/can/can_simple.cpp **** 
 685              		.loc 3 184 1 view .LVU156
ARM GAS  /tmp/ccoErako.s 			page 44


 686 0074 AFF30080 		.align	3
 687              	.L29:
 688 0078 00000000 		.word	0
 689 007c 00000000 		.word	0
 690 0080 00000000 		.word	.LANCHOR0
 691              		.cfi_endproc
 692              	.LFE5203:
 693              		.fnend
 695              		.section	.text._ZN9CANSimple26get_encoder_count_callbackERK4Axis,"ax",%progbits
 696              		.align	1
 697              		.global	_ZN9CANSimple26get_encoder_count_callbackERK4Axis
 698              		.syntax unified
 699              		.thumb
 700              		.thumb_func
 702              	_ZN9CANSimple26get_encoder_count_callbackERK4Axis:
 703              		.fnstart
 704              	.LVL47:
 705              	.LFB5219:
 221:communication/can/can_simple.cpp **** 
 222:communication/can/can_simple.cpp **** void CANSimple::set_axis_nodeid_callback(Axis& axis, const can_Message_t& msg) {
 223:communication/can/can_simple.cpp ****     axis.config_.can.node_id = can_getSignal<uint32_t>(msg, 0, 32, true);
 224:communication/can/can_simple.cpp **** }
 225:communication/can/can_simple.cpp **** 
 226:communication/can/can_simple.cpp **** void CANSimple::set_axis_requested_state_callback(Axis& axis, const can_Message_t& msg) {
 227:communication/can/can_simple.cpp ****     axis.requested_state_ = static_cast<Axis::AxisState>(can_getSignal<int32_t>(msg, 0, 32, true));
 228:communication/can/can_simple.cpp **** }
 229:communication/can/can_simple.cpp **** 
 230:communication/can/can_simple.cpp **** void CANSimple::set_axis_startup_config_callback(Axis& axis, const can_Message_t& msg) {
 231:communication/can/can_simple.cpp ****     // Not Implemented
 232:communication/can/can_simple.cpp **** }
 233:communication/can/can_simple.cpp **** 
 234:communication/can/can_simple.cpp **** bool CANSimple::get_encoder_estimates_callback(const Axis& axis) {
 235:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 236:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 237:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_ENCODER_ESTIMATES;  // heartbeat ID
 238:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 239:communication/can/can_simple.cpp ****     txmsg.len = 8;
 240:communication/can/can_simple.cpp **** 
 241:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, axis.controller_.pos_estimate_linear_src_.any().value_or(0.0f), 0, 
 242:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, axis.controller_.vel_estimate_src_.any().value_or(0.0f), 32, 32, tr
 243:communication/can/can_simple.cpp **** 
 244:communication/can/can_simple.cpp ****     return canbus_->send_message(txmsg);
 245:communication/can/can_simple.cpp **** }
 246:communication/can/can_simple.cpp **** 
 247:communication/can/can_simple.cpp **** bool CANSimple::get_sensorless_estimates_callback(const Axis& axis) {
 248:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 249:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 250:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_SENSORLESS_ESTIMATES;  // heartbeat ID
 251:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 252:communication/can/can_simple.cpp ****     txmsg.len = 8;
 253:communication/can/can_simple.cpp **** 
 254:communication/can/can_simple.cpp ****     static_assert(sizeof(float) == sizeof(axis.sensorless_estimator_.pll_pos_));
 255:communication/can/can_simple.cpp **** 
 256:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, axis.sensorless_estimator_.pll_pos_, 0, 32, true);
 257:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, axis.sensorless_estimator_.vel_estimate_.any().value_or(0.0f), 32, 
 258:communication/can/can_simple.cpp **** 
 259:communication/can/can_simple.cpp ****     return canbus_->send_message(txmsg);
ARM GAS  /tmp/ccoErako.s 			page 45


 260:communication/can/can_simple.cpp **** }
 261:communication/can/can_simple.cpp **** 
 262:communication/can/can_simple.cpp **** bool CANSimple::get_encoder_count_callback(const Axis& axis) {
 706              		.loc 3 262 62 is_stmt 1 view -0
 707              		.cfi_startproc
 708              		@ args = 0, pretend = 0, frame = 32
 709              		@ frame_needed = 0, uses_anonymous_args = 0
 710              		.loc 3 262 62 is_stmt 0 view .LVU158
 711 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 712              		.save {r4, r5, r6, r7, lr}
 713              	.LCFI14:
 714              		.cfi_def_cfa_offset 20
 715              		.cfi_offset 4, -20
 716              		.cfi_offset 5, -16
 717              		.cfi_offset 6, -12
 718              		.cfi_offset 7, -8
 719              		.cfi_offset 14, -4
 720              		.pad #36
 721 0002 89B0     		sub	sp, sp, #36
 722              	.LCFI15:
 723              		.cfi_def_cfa_offset 56
 724 0004 0446     		mov	r4, r0
 725 0006 8E46     		mov	lr, r1
 263:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 726              		.loc 3 263 5 is_stmt 1 view .LVU159
 727              		.loc 3 263 19 is_stmt 0 view .LVU160
 728 0008 264B     		ldr	r3, .L33
 729 000a 0DF1100C 		add	ip, sp, #16
 730 000e 0FCB     		ldm	r3, {r0, r1, r2, r3}
 731              	.LVL48:
 732              		.loc 3 263 19 view .LVU161
 733 0010 8CE80F00 		stm	ip, {r0, r1, r2, r3}
 264:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 734              		.loc 3 264 5 is_stmt 1 view .LVU162
 735              		.loc 3 264 33 is_stmt 0 view .LVU163
 736 0014 DEF87830 		ldr	r3, [lr, #120]
 737              		.loc 3 264 41 view .LVU164
 738 0018 5B01     		lsls	r3, r3, #5
 739              		.loc 3 264 14 view .LVU165
 740 001a 0493     		str	r3, [sp, #16]
 265:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_ENCODER_COUNT;
 741              		.loc 3 265 5 is_stmt 1 view .LVU166
 742              		.loc 3 265 14 is_stmt 0 view .LVU167
 743 001c 0A33     		adds	r3, r3, #10
 744 001e 0493     		str	r3, [sp, #16]
 266:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 745              		.loc 3 266 5 is_stmt 1 view .LVU168
 746              		.loc 3 266 36 is_stmt 0 view .LVU169
 747 0020 9EF87C30 		ldrb	r3, [lr, #124]	@ zero_extendqisi2
 748              		.loc 3 266 17 view .LVU170
 749 0024 8DF81430 		strb	r3, [sp, #20]
 267:communication/can/can_simple.cpp ****     txmsg.len = 8;
 750              		.loc 3 267 5 is_stmt 1 view .LVU171
 268:communication/can/can_simple.cpp **** 
 269:communication/can/can_simple.cpp ****     can_setSignal<int32_t>(txmsg, axis.encoder_.shadow_count_, 0, 32, true);
 751              		.loc 3 269 5 view .LVU172
 752              		.loc 3 269 40 is_stmt 0 view .LVU173
ARM GAS  /tmp/ccoErako.s 			page 46


 753 0028 DEF8AC50 		ldr	r5, [lr, #172]
 754              	.LVL49:
 755              	.LBB737:
 756              	.LBI737:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 757              		.loc 4 50 16 is_stmt 1 view .LVU174
 758              	.LBB738:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 759              		.loc 4 51 14 is_stmt 0 view .LVU175
 760 002c 0022     		movs	r2, #0
 761 002e 0023     		movs	r3, #0
 762 0030 CDE90023 		strd	r2, [sp]
 763 0034 D5F89070 		ldr	r7, [r5, #144]	@ unaligned
  52:communication/can/can_helpers.hpp **** 
 764              		.loc 4 52 16 view .LVU176
 765 0038 0097     		str	r7, [sp]
 766              	.LVL50:
 767              	.LBB739:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 768              		.loc 4 57 18 view .LVU177
 769 003a CDE90223 		strd	r2, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 770              		.loc 4 58 20 view .LVU178
 771 003e 0DF1080E 		add	lr, sp, #8
 772              	.LVL51:
  58:communication/can/can_helpers.hpp **** 
 773              		.loc 4 58 20 view .LVU179
 774 0042 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 775 0046 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 776 004a AEE80300 		stmia	lr!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 777              		.loc 4 60 14 view .LVU180
 778 004e 0026     		movs	r6, #0
 779 0050 0296     		str	r6, [sp, #8]
  61:communication/can/can_helpers.hpp **** 
 780              		.loc 4 61 27 view .LVU181
 781 0052 0198     		ldr	r0, [sp, #4]
  61:communication/can/can_helpers.hpp **** 
 782              		.loc 4 61 14 view .LVU182
 783 0054 0143     		orrs	r1, r1, r0
 784 0056 0297     		str	r7, [sp, #8]
 785 0058 0391     		str	r1, [sp, #12]
 786              		.loc 4 63 20 view .LVU183
 787 005a 0DF1080E 		add	lr, sp, #8
 788 005e BEE80300 		ldmia	lr!, {r0, r1}
 789 0062 CDF81700 		str	r0, [sp, #23]	@ unaligned
 790 0066 CDF81B10 		str	r1, [sp, #27]	@ unaligned
 791              	.LVL52:
 792              		.loc 4 63 20 view .LVU184
 793              	.LBE739:
 794              	.LBE738:
 795              	.LBE737:
 270:communication/can/can_simple.cpp ****     can_setSignal<int32_t>(txmsg, axis.encoder_.count_in_cpr_, 32, 32, true);
 796              		.loc 3 270 5 is_stmt 1 view .LVU185
 797              	.LBB740:
 798              	.LBI740:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
ARM GAS  /tmp/ccoErako.s 			page 47


 799              		.loc 4 50 16 view .LVU186
 800              	.LBB741:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 801              		.loc 4 51 14 is_stmt 0 view .LVU187
 802 006a CDE90023 		strd	r2, [sp]
 803 006e D5F89450 		ldr	r5, [r5, #148]	@ unaligned
 804              	.LVL53:
  52:communication/can/can_helpers.hpp **** 
 805              		.loc 4 52 16 view .LVU188
 806 0072 0095     		str	r5, [sp]
 807              	.LVL54:
 808              	.LBB742:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 809              		.loc 4 57 18 view .LVU189
 810 0074 CDE90223 		strd	r2, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 811              		.loc 4 58 20 view .LVU190
 812 0078 02AB     		add	r3, sp, #8
 813 007a DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 814 007e DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 815 0082 03C3     		stmia	r3!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 816              		.loc 4 60 14 view .LVU191
 817 0084 0396     		str	r6, [sp, #12]
  61:communication/can/can_helpers.hpp **** 
 818              		.loc 4 61 14 view .LVU192
 819 0086 0395     		str	r5, [sp, #12]
 820              		.loc 4 63 20 view .LVU193
 821 0088 02AB     		add	r3, sp, #8
 822 008a 03CB     		ldmia	r3!, {r0, r1}
 823 008c CDF81700 		str	r0, [sp, #23]	@ unaligned
 824 0090 CDF81B10 		str	r1, [sp, #27]	@ unaligned
 825              	.LVL55:
 826              		.loc 4 63 20 view .LVU194
 827              	.LBE742:
 828              	.LBE741:
 829              	.LBE740:
 271:communication/can/can_simple.cpp ****     return canbus_->send_message(txmsg);
 830              		.loc 3 271 5 is_stmt 1 view .LVU195
 831              		.loc 3 271 12 is_stmt 0 view .LVU196
 832 0094 2068     		ldr	r0, [r4]
 833              		.loc 3 271 39 view .LVU197
 834 0096 0368     		ldr	r3, [r0]
 835 0098 1B68     		ldr	r3, [r3]
 836              		.loc 3 271 33 view .LVU198
 837 009a 6146     		mov	r1, ip
 838 009c 9847     		blx	r3
 839              	.LVL56:
 272:communication/can/can_simple.cpp **** }
 840              		.loc 3 272 1 view .LVU199
 841 009e 09B0     		add	sp, sp, #36
 842              	.LCFI16:
 843              		.cfi_def_cfa_offset 20
 844              		@ sp needed
 845 00a0 F0BD     		pop	{r4, r5, r6, r7, pc}
 846              	.LVL57:
 847              	.L34:
ARM GAS  /tmp/ccoErako.s 			page 48


 848              		.loc 3 272 1 view .LVU200
 849 00a2 00BF     		.align	2
 850              	.L33:
 851 00a4 00000000 		.word	.LANCHOR0
 852              		.cfi_endproc
 853              	.LFE5219:
 854              		.fnend
 856              		.section	.text._ZN9CANSimple14send_heartbeatERK4Axis,"ax",%progbits
 857              		.align	1
 858              		.global	_ZN9CANSimple14send_heartbeatERK4Axis
 859              		.syntax unified
 860              		.thumb
 861              		.thumb_func
 863              	_ZN9CANSimple14send_heartbeatERK4Axis:
 864              		.fnstart
 865              	.LVL58:
 866              	.LFB5250:
 273:communication/can/can_simple.cpp **** 
 274:communication/can/can_simple.cpp **** void CANSimple::set_input_pos_callback(Axis& axis, const can_Message_t& msg) {
 275:communication/can/can_simple.cpp ****     axis.controller_.set_input_pos_and_steps(can_getSignal<float>(msg, 0, 32, true));
 276:communication/can/can_simple.cpp ****     axis.controller_.input_vel_ = can_getSignal<int16_t>(msg, 32, 16, true, 0.001f, 0);
 277:communication/can/can_simple.cpp ****     axis.controller_.input_torque_ = can_getSignal<int16_t>(msg, 48, 16, true, 0.001f, 0);
 278:communication/can/can_simple.cpp ****     axis.controller_.input_pos_updated();
 279:communication/can/can_simple.cpp **** }
 280:communication/can/can_simple.cpp **** 
 281:communication/can/can_simple.cpp **** void CANSimple::set_input_vel_callback(Axis& axis, const can_Message_t& msg) {
 282:communication/can/can_simple.cpp ****     axis.controller_.input_vel_ = can_getSignal<float>(msg, 0, 32, true);
 283:communication/can/can_simple.cpp ****     axis.controller_.input_torque_ = can_getSignal<float>(msg, 32, 32, true);
 284:communication/can/can_simple.cpp **** }
 285:communication/can/can_simple.cpp **** 
 286:communication/can/can_simple.cpp **** void CANSimple::set_input_torque_callback(Axis& axis, const can_Message_t& msg) {
 287:communication/can/can_simple.cpp ****     axis.controller_.input_torque_ = can_getSignal<float>(msg, 0, 32, true);
 288:communication/can/can_simple.cpp **** }
 289:communication/can/can_simple.cpp **** 
 290:communication/can/can_simple.cpp **** void CANSimple::set_controller_modes_callback(Axis& axis, const can_Message_t& msg) {
 291:communication/can/can_simple.cpp ****     Controller::ControlMode const mode = static_cast<Controller::ControlMode>(can_getSignal<int32_t
 292:communication/can/can_simple.cpp ****     axis.controller_.config_.control_mode = static_cast<Controller::ControlMode>(mode);
 293:communication/can/can_simple.cpp ****     axis.controller_.config_.input_mode = static_cast<Controller::InputMode>(can_getSignal<int32_t>
 294:communication/can/can_simple.cpp ****     axis.controller_.control_mode_updated();
 295:communication/can/can_simple.cpp **** }
 296:communication/can/can_simple.cpp **** 
 297:communication/can/can_simple.cpp **** void CANSimple::set_limits_callback(Axis& axis, const can_Message_t& msg) {
 298:communication/can/can_simple.cpp ****     axis.controller_.config_.vel_limit = can_getSignal<float>(msg, 0, 32, true);
 299:communication/can/can_simple.cpp ****     axis.motor_.config_.current_lim = can_getSignal<float>(msg, 32, 32, true);
 300:communication/can/can_simple.cpp **** }
 301:communication/can/can_simple.cpp **** 
 302:communication/can/can_simple.cpp **** void CANSimple::start_anticogging_callback(const Axis& axis, const can_Message_t& msg) {
 303:communication/can/can_simple.cpp ****     axis.controller_.start_anticogging_calibration();
 304:communication/can/can_simple.cpp **** }
 305:communication/can/can_simple.cpp **** 
 306:communication/can/can_simple.cpp **** void CANSimple::set_traj_vel_limit_callback(Axis& axis, const can_Message_t& msg) {
 307:communication/can/can_simple.cpp ****     axis.trap_traj_.config_.vel_limit = can_getSignal<float>(msg, 0, 32, true);
 308:communication/can/can_simple.cpp **** }
 309:communication/can/can_simple.cpp **** 
 310:communication/can/can_simple.cpp **** void CANSimple::set_traj_accel_limits_callback(Axis& axis, const can_Message_t& msg) {
 311:communication/can/can_simple.cpp ****     axis.trap_traj_.config_.accel_limit = can_getSignal<float>(msg, 0, 32, true);
 312:communication/can/can_simple.cpp ****     axis.trap_traj_.config_.decel_limit = can_getSignal<float>(msg, 32, 32, true);
ARM GAS  /tmp/ccoErako.s 			page 49


 313:communication/can/can_simple.cpp **** }
 314:communication/can/can_simple.cpp **** 
 315:communication/can/can_simple.cpp **** void CANSimple::set_traj_inertia_callback(Axis& axis, const can_Message_t& msg) {
 316:communication/can/can_simple.cpp ****     axis.controller_.config_.inertia = can_getSignal<float>(msg, 0, 32, true);
 317:communication/can/can_simple.cpp **** }
 318:communication/can/can_simple.cpp **** 
 319:communication/can/can_simple.cpp **** void CANSimple::set_linear_count_callback(Axis& axis, const can_Message_t& msg) {
 320:communication/can/can_simple.cpp ****     axis.encoder_.set_linear_count(can_getSignal<int32_t>(msg, 0, 32, true));
 321:communication/can/can_simple.cpp **** }
 322:communication/can/can_simple.cpp **** 
 323:communication/can/can_simple.cpp **** void CANSimple::set_pos_gain_callback(Axis& axis, const can_Message_t& msg) {
 324:communication/can/can_simple.cpp ****     axis.controller_.config_.pos_gain = can_getSignal<float>(msg, 0, 32, true);
 325:communication/can/can_simple.cpp **** }
 326:communication/can/can_simple.cpp **** 
 327:communication/can/can_simple.cpp **** void CANSimple::set_vel_gains_callback(Axis& axis, const can_Message_t& msg) {
 328:communication/can/can_simple.cpp ****     axis.controller_.config_.vel_gain = can_getSignal<float>(msg, 0, 32, true);
 329:communication/can/can_simple.cpp ****     axis.controller_.config_.vel_integrator_gain = can_getSignal<float>(msg, 32, 32, true);
 330:communication/can/can_simple.cpp **** }
 331:communication/can/can_simple.cpp **** 
 332:communication/can/can_simple.cpp **** bool CANSimple::get_iq_callback(const Axis& axis) {
 333:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 334:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 335:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_IQ;
 336:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 337:communication/can/can_simple.cpp ****     txmsg.len = 8;
 338:communication/can/can_simple.cpp **** 
 339:communication/can/can_simple.cpp ****     std::optional<float2D> Idq_setpoint = axis.motor_.current_control_.Idq_setpoint_;
 340:communication/can/can_simple.cpp ****     if (!Idq_setpoint.has_value()) {
 341:communication/can/can_simple.cpp ****         Idq_setpoint = {0.0f, 0.0f};
 342:communication/can/can_simple.cpp ****     }
 343:communication/can/can_simple.cpp ****     
 344:communication/can/can_simple.cpp ****     static_assert(sizeof(float) == sizeof(Idq_setpoint->second));
 345:communication/can/can_simple.cpp ****     static_assert(sizeof(float) == sizeof(axis.motor_.current_control_.Iq_measured_));
 346:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, Idq_setpoint->second, 0, 32, true);
 347:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, axis.motor_.current_control_.Iq_measured_, 32, 32, true);
 348:communication/can/can_simple.cpp **** 
 349:communication/can/can_simple.cpp ****     return canbus_->send_message(txmsg);
 350:communication/can/can_simple.cpp **** }
 351:communication/can/can_simple.cpp **** 
 352:communication/can/can_simple.cpp **** bool CANSimple::get_bus_voltage_current_callback(const Axis& axis) {
 353:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 354:communication/can/can_simple.cpp **** 
 355:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 356:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_BUS_VOLTAGE_CURRENT;
 357:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 358:communication/can/can_simple.cpp ****     txmsg.len = 8;
 359:communication/can/can_simple.cpp **** 
 360:communication/can/can_simple.cpp ****     static_assert(sizeof(float) == sizeof(vbus_voltage));
 361:communication/can/can_simple.cpp ****     static_assert(sizeof(float) == sizeof(ibus_));
 362:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, vbus_voltage, 0, 32, true);
 363:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, ibus_, 32, 32, true);
 364:communication/can/can_simple.cpp **** 
 365:communication/can/can_simple.cpp ****     return canbus_->send_message(txmsg);
 366:communication/can/can_simple.cpp **** }
 367:communication/can/can_simple.cpp **** 
 368:communication/can/can_simple.cpp **** bool CANSimple::get_adc_voltage_callback(const Axis& axis, const can_Message_t& msg) {
 369:communication/can/can_simple.cpp ****     can_Message_t txmsg;
ARM GAS  /tmp/ccoErako.s 			page 50


 370:communication/can/can_simple.cpp **** 
 371:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 372:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_ADC_VOLTAGE;
 373:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 374:communication/can/can_simple.cpp ****     txmsg.len = 8;
 375:communication/can/can_simple.cpp **** 
 376:communication/can/can_simple.cpp ****     auto gpio_num = can_getSignal<uint8_t>(msg, 0, 8, true);
 377:communication/can/can_simple.cpp ****     if (gpio_num < GPIO_COUNT) {
 378:communication/can/can_simple.cpp ****         auto voltage = get_adc_voltage(get_gpio(gpio_num));
 379:communication/can/can_simple.cpp ****         can_setSignal<float>(txmsg, voltage, 0, 32, true);
 380:communication/can/can_simple.cpp ****         return canbus_->send_message(txmsg);
 381:communication/can/can_simple.cpp ****     } else {
 382:communication/can/can_simple.cpp ****         return false;
 383:communication/can/can_simple.cpp ****     }
 384:communication/can/can_simple.cpp **** }
 385:communication/can/can_simple.cpp **** 
 386:communication/can/can_simple.cpp **** void CANSimple::clear_errors_callback(Axis& axis, const can_Message_t& msg) {
 387:communication/can/can_simple.cpp ****     odrv.clear_errors();  // TODO: might want to clear axis errors only
 388:communication/can/can_simple.cpp **** }
 389:communication/can/can_simple.cpp **** 
 390:communication/can/can_simple.cpp **** uint32_t CANSimple::service_stack() {
 391:communication/can/can_simple.cpp ****     uint32_t nextServiceTime = UINT32_MAX;
 392:communication/can/can_simple.cpp ****     uint32_t now = HAL_GetTick();
 393:communication/can/can_simple.cpp **** 
 394:communication/can/can_simple.cpp ****     // TODO: remove this polling loop and replace with protocol hook
 395:communication/can/can_simple.cpp ****     for (size_t i = 0; i < AXIS_COUNT; ++i) {
 396:communication/can/can_simple.cpp ****         bool node_id_changed = (axes[i].config_.can.node_id != node_ids_[i]) || (axes[i].config_.ca
 397:communication/can/can_simple.cpp ****         if (node_id_changed) {
 398:communication/can/can_simple.cpp ****             renew_subscription(i);
 399:communication/can/can_simple.cpp ****         }
 400:communication/can/can_simple.cpp ****     }
 401:communication/can/can_simple.cpp **** 
 402:communication/can/can_simple.cpp ****     struct periodic {
 403:communication/can/can_simple.cpp ****         const uint32_t& rate;
 404:communication/can/can_simple.cpp ****         uint32_t& last_time;
 405:communication/can/can_simple.cpp ****         bool (CANSimple::* callback)(const Axis& axis);
 406:communication/can/can_simple.cpp ****     };
 407:communication/can/can_simple.cpp **** 
 408:communication/can/can_simple.cpp ****     for (auto& axis : axes) {
 409:communication/can/can_simple.cpp ****         std::array<periodic, 10> periodics = {{
 410:communication/can/can_simple.cpp ****             {axis.config_.can.heartbeat_rate_ms, axis.can_.last_heartbeat, &CANSimple::send_heartbe
 411:communication/can/can_simple.cpp ****             {axis.config_.can.encoder_rate_ms, axis.can_.last_encoder, &CANSimple::get_encoder_esti
 412:communication/can/can_simple.cpp ****             {axis.config_.can.motor_error_rate_ms, axis.can_.last_motor_error, &CANSimple::get_moto
 413:communication/can/can_simple.cpp ****             {axis.config_.can.encoder_error_rate_ms, axis.can_.last_encoder_error, &CANSimple::get_
 414:communication/can/can_simple.cpp ****             {axis.config_.can.controller_error_rate_ms, axis.can_.last_controller_error, &CANSimple
 415:communication/can/can_simple.cpp ****             {axis.config_.can.sensorless_error_rate_ms, axis.can_.last_sensorless_error, &CANSimple
 416:communication/can/can_simple.cpp ****             {axis.config_.can.encoder_count_rate_ms, axis.can_.last_encoder_count, &CANSimple::get_
 417:communication/can/can_simple.cpp ****             {axis.config_.can.iq_rate_ms, axis.can_.last_iq, &CANSimple::get_iq_callback},
 418:communication/can/can_simple.cpp ****             {axis.config_.can.sensorless_rate_ms, axis.can_.last_sensorless, &CANSimple::get_sensor
 419:communication/can/can_simple.cpp ****             {axis.config_.can.bus_vi_rate_ms, axis.can_.last_bus_vi, &CANSimple::get_bus_voltage_cu
 420:communication/can/can_simple.cpp ****         }};
 421:communication/can/can_simple.cpp **** 
 422:communication/can/can_simple.cpp ****         MEASURE_TIME(axis.task_times_.can_heartbeat) {
 423:communication/can/can_simple.cpp ****             for (auto& msg : periodics) {
 424:communication/can/can_simple.cpp ****                 if (msg.rate > 0) {
 425:communication/can/can_simple.cpp ****                     if ((now - msg.last_time) >= msg.rate) {
 426:communication/can/can_simple.cpp ****                         if (std::invoke(msg.callback, this, axis)) {
ARM GAS  /tmp/ccoErako.s 			page 51


 427:communication/can/can_simple.cpp ****                             msg.last_time = now;
 428:communication/can/can_simple.cpp ****                         }
 429:communication/can/can_simple.cpp ****                     }
 430:communication/can/can_simple.cpp **** 
 431:communication/can/can_simple.cpp ****                     int nextAxisService = msg.last_time + msg.rate - now;
 432:communication/can/can_simple.cpp ****                     nextServiceTime = std::min(nextServiceTime, static_cast<uint32_t>(std::max(0, n
 433:communication/can/can_simple.cpp ****                 }
 434:communication/can/can_simple.cpp ****             }
 435:communication/can/can_simple.cpp ****         }
 436:communication/can/can_simple.cpp ****     }
 437:communication/can/can_simple.cpp **** 
 438:communication/can/can_simple.cpp ****     return nextServiceTime;
 439:communication/can/can_simple.cpp **** }
 440:communication/can/can_simple.cpp **** 
 441:communication/can/can_simple.cpp **** bool CANSimple::send_heartbeat(const Axis& axis) {
 867              		.loc 3 441 50 is_stmt 1 view -0
 868              		.cfi_startproc
 869              		@ args = 0, pretend = 0, frame = 32
 870              		@ frame_needed = 0, uses_anonymous_args = 0
 871              		.loc 3 441 50 is_stmt 0 view .LVU202
 872 0000 70B5     		push	{r4, r5, r6, lr}
 873              		.save {r4, r5, r6, lr}
 874              	.LCFI17:
 875              		.cfi_def_cfa_offset 16
 876              		.cfi_offset 4, -16
 877              		.cfi_offset 5, -12
 878              		.cfi_offset 6, -8
 879              		.cfi_offset 14, -4
 880              		.pad #32
 881 0002 88B0     		sub	sp, sp, #32
 882              	.LCFI18:
 883              		.cfi_def_cfa_offset 48
 884 0004 0446     		mov	r4, r0
 885 0006 8C46     		mov	ip, r1
 442:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 886              		.loc 3 442 5 is_stmt 1 view .LVU203
 887              		.loc 3 442 19 is_stmt 0 view .LVU204
 888 0008 5C4B     		ldr	r3, .L37
 889 000a 0DF1100E 		add	lr, sp, #16
 890 000e 0FCB     		ldm	r3, {r0, r1, r2, r3}
 891              	.LVL59:
 892              		.loc 3 442 19 view .LVU205
 893 0010 8EE80F00 		stm	lr, {r0, r1, r2, r3}
 443:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 894              		.loc 3 443 5 is_stmt 1 view .LVU206
 895              		.loc 3 443 33 is_stmt 0 view .LVU207
 896 0014 DCF87830 		ldr	r3, [ip, #120]
 897              		.loc 3 443 41 view .LVU208
 898 0018 5B01     		lsls	r3, r3, #5
 899              		.loc 3 443 14 view .LVU209
 900 001a 0493     		str	r3, [sp, #16]
 444:communication/can/can_simple.cpp ****     txmsg.id += MSG_ODRIVE_HEARTBEAT;  // heartbeat ID
 901              		.loc 3 444 5 is_stmt 1 view .LVU210
 902              		.loc 3 444 14 is_stmt 0 view .LVU211
 903 001c 0133     		adds	r3, r3, #1
 904 001e 0493     		str	r3, [sp, #16]
 445:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
ARM GAS  /tmp/ccoErako.s 			page 52


 905              		.loc 3 445 5 is_stmt 1 view .LVU212
 906              		.loc 3 445 36 is_stmt 0 view .LVU213
 907 0020 9CF87C30 		ldrb	r3, [ip, #124]	@ zero_extendqisi2
 908              		.loc 3 445 17 view .LVU214
 909 0024 8DF81430 		strb	r3, [sp, #20]
 446:communication/can/can_simple.cpp ****     txmsg.len = 8;
 910              		.loc 3 446 5 is_stmt 1 view .LVU215
 447:communication/can/can_simple.cpp **** 
 448:communication/can/can_simple.cpp ****     can_setSignal(txmsg, axis.error_, 0, 32, true);
 911              		.loc 3 448 5 view .LVU216
 912              	.LVL60:
 913              	.LBB798:
 914              	.LBI798:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 915              		.loc 4 50 16 view .LVU217
 916              	.LBB799:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 917              		.loc 4 51 14 is_stmt 0 view .LVU218
 918 0028 0022     		movs	r2, #0
 919 002a 0023     		movs	r3, #0
 920 002c CDE90023 		strd	r2, [sp]
 921 0030 DCF84862 		ldr	r6, [ip, #584]	@ unaligned
  52:communication/can/can_helpers.hpp **** 
 922              		.loc 4 52 16 view .LVU219
 923 0034 0096     		str	r6, [sp]
 924              	.LVL61:
 925              	.LBB800:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 926              		.loc 4 57 18 view .LVU220
 927 0036 CDE90223 		strd	r2, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 928              		.loc 4 58 20 view .LVU221
 929 003a 02AD     		add	r5, sp, #8
 930 003c DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 931 0040 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 932 0044 03C5     		stmia	r5!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 933              		.loc 4 60 14 view .LVU222
 934 0046 0021     		movs	r1, #0
 935 0048 0291     		str	r1, [sp, #8]
  61:communication/can/can_helpers.hpp **** 
 936              		.loc 4 61 27 view .LVU223
 937 004a 0198     		ldr	r0, [sp, #4]
  61:communication/can/can_helpers.hpp **** 
 938              		.loc 4 61 14 view .LVU224
 939 004c 0399     		ldr	r1, [sp, #12]
 940 004e 0143     		orrs	r1, r1, r0
 941 0050 0296     		str	r6, [sp, #8]
 942 0052 0391     		str	r1, [sp, #12]
 943              		.loc 4 63 20 view .LVU225
 944 0054 02AD     		add	r5, sp, #8
 945 0056 03CD     		ldmia	r5!, {r0, r1}
 946 0058 CDF81700 		str	r0, [sp, #23]	@ unaligned
 947 005c CDF81B10 		str	r1, [sp, #27]	@ unaligned
 948              	.LVL62:
 949              		.loc 4 63 20 view .LVU226
 950              	.LBE800:
ARM GAS  /tmp/ccoErako.s 			page 53


 951              	.LBE799:
 952              	.LBE798:
 449:communication/can/can_simple.cpp ****     can_setSignal(txmsg, uint8_t(axis.current_state_), 32, 8, true);
 953              		.loc 3 449 5 is_stmt 1 view .LVU227
 954              		.loc 3 449 39 is_stmt 0 view .LVU228
 955 0060 DCF87812 		ldr	r1, [ip, #632]
 956              		.loc 3 449 26 view .LVU229
 957 0064 0978     		ldrb	r1, [r1]	@ zero_extendqisi2
 958              	.LVL63:
 959              	.LBB801:
 960              	.LBI801:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 961              		.loc 4 50 16 is_stmt 1 view .LVU230
 962              	.LBB802:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 963              		.loc 4 51 14 is_stmt 0 view .LVU231
 964 0066 CDE90023 		strd	r2, [sp]
  52:communication/can/can_helpers.hpp **** 
 965              		.loc 4 52 16 view .LVU232
 966 006a 8DF80010 		strb	r1, [sp]
 967              	.LVL64:
 968              	.LBB803:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 969              		.loc 4 57 18 view .LVU233
 970 006e CDE90223 		strd	r2, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 971              		.loc 4 58 20 view .LVU234
 972 0072 02AD     		add	r5, sp, #8
 973 0074 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 974 0078 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 975 007c 03C5     		stmia	r5!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 976              		.loc 4 60 14 view .LVU235
 977 007e 21F0FF01 		bic	r1, r1, #255
 978 0082 0391     		str	r1, [sp, #12]
  61:communication/can/can_helpers.hpp **** 
 979              		.loc 4 61 27 view .LVU236
 980 0084 0098     		ldr	r0, [sp]
  61:communication/can/can_helpers.hpp **** 
 981              		.loc 4 61 14 view .LVU237
 982 0086 0143     		orrs	r1, r1, r0
 983 0088 0391     		str	r1, [sp, #12]
 984              		.loc 4 63 20 view .LVU238
 985 008a 02AD     		add	r5, sp, #8
 986 008c 03CD     		ldmia	r5!, {r0, r1}
 987 008e CDF81700 		str	r0, [sp, #23]	@ unaligned
 988 0092 CDF81B10 		str	r1, [sp, #27]	@ unaligned
 989              	.LVL65:
 990              		.loc 4 63 20 view .LVU239
 991              	.LBE803:
 992              	.LBE802:
 993              	.LBE801:
 450:communication/can/can_simple.cpp **** 
 451:communication/can/can_simple.cpp ****     // Motor flags
 452:communication/can/can_simple.cpp ****     uint8_t motorFlags = axis.motor_.error_ != 0;
 994              		.loc 3 452 5 is_stmt 1 view .LVU240
 995              		.loc 3 452 31 is_stmt 0 view .LVU241
ARM GAS  /tmp/ccoErako.s 			page 54


 996 0096 DCF85811 		ldr	r1, [ip, #344]
 997              		.loc 3 452 38 view .LVU242
 998 009a D1F89000 		ldr	r0, [r1, #144]
 999 009e D1F89410 		ldr	r1, [r1, #148]
 1000              		.loc 3 452 45 view .LVU243
 1001 00a2 0143     		orrs	r1, r0, r1
 1002 00a4 14BF     		ite	ne
 1003 00a6 0120     		movne	r0, #1
 1004 00a8 0020     		moveq	r0, #0
 1005              	.LVL66:
 453:communication/can/can_simple.cpp **** 
 454:communication/can/can_simple.cpp ****     // Encoder flags
 455:communication/can/can_simple.cpp ****     uint8_t encoderFlags = axis.encoder_.error_ != 0;
 1006              		.loc 3 455 5 is_stmt 1 view .LVU244
 1007              		.loc 3 455 33 is_stmt 0 view .LVU245
 1008 00aa DCF8AC10 		ldr	r1, [ip, #172]
 1009              		.loc 3 455 42 view .LVU246
 1010 00ae B1F88C50 		ldrh	r5, [r1, #140]
 1011              		.loc 3 455 49 view .LVU247
 1012 00b2 003D     		subs	r5, r5, #0
 1013 00b4 18BF     		it	ne
 1014 00b6 0125     		movne	r5, #1
 1015              	.LVL67:
 456:communication/can/can_simple.cpp **** 
 457:communication/can/can_simple.cpp ****     // Controller flags
 458:communication/can/can_simple.cpp ****     uint8_t controllerFlags =axis.controller_.error_ != 0;
 1016              		.loc 3 458 5 is_stmt 1 view .LVU248
 1017              		.loc 3 458 35 is_stmt 0 view .LVU249
 1018 00b8 DCF80011 		ldr	r1, [ip, #256]
 1019              		.loc 3 458 47 view .LVU250
 1020 00bc 01F54051 		add	r1, r1, #12288
 1021 00c0 91F8DC68 		ldrb	r6, [r1, #2268]	@ zero_extendqisi2
 1022              	.LVL68:
 459:communication/can/can_simple.cpp ****     uint8_t trajDone = uint8_t(axis.controller_.trajectory_done_) << 7;
 1023              		.loc 3 459 5 is_stmt 1 view .LVU251
 1024              		.loc 3 459 49 is_stmt 0 view .LVU252
 1025 00c4 91F83DC9 		ldrb	ip, [r1, #2365]	@ zero_extendqisi2
 1026              	.LVL69:
 1027              		.loc 3 459 13 view .LVU253
 1028 00c8 4FEACC1C 		lsl	ip, ip, #7
 1029 00cc 5FFA8CFC 		uxtb	ip, ip
 1030              	.LVL70:
 460:communication/can/can_simple.cpp ****     controllerFlags |= trajDone;
 1031              		.loc 3 460 5 is_stmt 1 view .LVU254
 1032              		.loc 3 460 21 is_stmt 0 view .LVU255
 1033 00d0 002E     		cmp	r6, #0
 1034 00d2 18BF     		it	ne
 1035 00d4 4CF0010C 		orrne	ip, ip, #1
 1036              	.LVL71:
 461:communication/can/can_simple.cpp **** 
 462:communication/can/can_simple.cpp ****     can_setSignal(txmsg, motorFlags, 40, 8, true);
 1037              		.loc 3 462 5 is_stmt 1 view .LVU256
 1038              	.LBB804:
 1039              	.LBI804:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 1040              		.loc 4 50 16 view .LVU257
 1041              	.LBB805:
ARM GAS  /tmp/ccoErako.s 			page 55


  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 1042              		.loc 4 51 14 is_stmt 0 view .LVU258
 1043 00d8 CDE90023 		strd	r2, [sp]
 1044              	.LVL72:
  52:communication/can/can_helpers.hpp **** 
 1045              		.loc 4 52 16 view .LVU259
 1046 00dc 8DF80000 		strb	r0, [sp]
 1047              	.LVL73:
 1048              	.LBB806:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 1049              		.loc 4 57 18 view .LVU260
 1050 00e0 CDE90223 		strd	r2, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 1051              		.loc 4 58 20 view .LVU261
 1052 00e4 02AE     		add	r6, sp, #8
 1053 00e6 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 1054              	.LVL74:
  58:communication/can/can_helpers.hpp **** 
 1055              		.loc 4 58 20 view .LVU262
 1056 00ea DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 1057 00ee 03C6     		stmia	r6!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 1058              		.loc 4 60 14 view .LVU263
 1059 00f0 21F47F41 		bic	r1, r1, #65280
 1060 00f4 0391     		str	r1, [sp, #12]
  61:communication/can/can_helpers.hpp **** 
 1061              		.loc 4 61 14 view .LVU264
 1062 00f6 0098     		ldr	r0, [sp]
 1063 00f8 41EA0021 		orr	r1, r1, r0, lsl #8
 1064 00fc 0391     		str	r1, [sp, #12]
 1065              		.loc 4 63 20 view .LVU265
 1066 00fe 02AE     		add	r6, sp, #8
 1067 0100 03CE     		ldmia	r6!, {r0, r1}
 1068 0102 CDF81700 		str	r0, [sp, #23]	@ unaligned
 1069 0106 CDF81B10 		str	r1, [sp, #27]	@ unaligned
 1070              	.LVL75:
 1071              		.loc 4 63 20 view .LVU266
 1072              	.LBE806:
 1073              	.LBE805:
 1074              	.LBE804:
 463:communication/can/can_simple.cpp ****     can_setSignal(txmsg, encoderFlags, 48, 8, true);
 1075              		.loc 3 463 5 is_stmt 1 view .LVU267
 1076              	.LBB807:
 1077              	.LBI807:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 1078              		.loc 4 50 16 view .LVU268
 1079              	.LBB808:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 1080              		.loc 4 51 14 is_stmt 0 view .LVU269
 1081 010a CDE90023 		strd	r2, [sp]
 1082              	.LVL76:
  52:communication/can/can_helpers.hpp **** 
 1083              		.loc 4 52 16 view .LVU270
 1084 010e 8DF80050 		strb	r5, [sp]
 1085              	.LVL77:
 1086              	.LBB809:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
ARM GAS  /tmp/ccoErako.s 			page 56


 1087              		.loc 4 57 18 view .LVU271
 1088 0112 CDE90223 		strd	r2, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 1089              		.loc 4 58 20 view .LVU272
 1090 0116 02AD     		add	r5, sp, #8
 1091              	.LVL78:
  58:communication/can/can_helpers.hpp **** 
 1092              		.loc 4 58 20 view .LVU273
 1093 0118 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 1094 011c DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 1095 0120 03C5     		stmia	r5!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 1096              		.loc 4 60 14 view .LVU274
 1097 0122 21F47F01 		bic	r1, r1, #16711680
 1098 0126 0391     		str	r1, [sp, #12]
  61:communication/can/can_helpers.hpp **** 
 1099              		.loc 4 61 14 view .LVU275
 1100 0128 0098     		ldr	r0, [sp]
 1101 012a 41EA0041 		orr	r1, r1, r0, lsl #16
 1102 012e 0391     		str	r1, [sp, #12]
 1103              		.loc 4 63 20 view .LVU276
 1104 0130 02AD     		add	r5, sp, #8
 1105 0132 03CD     		ldmia	r5!, {r0, r1}
 1106 0134 CDF81700 		str	r0, [sp, #23]	@ unaligned
 1107 0138 CDF81B10 		str	r1, [sp, #27]	@ unaligned
 1108              	.LVL79:
 1109              		.loc 4 63 20 view .LVU277
 1110              	.LBE809:
 1111              	.LBE808:
 1112              	.LBE807:
 464:communication/can/can_simple.cpp ****     can_setSignal(txmsg, controllerFlags, 56, 8, true);
 1113              		.loc 3 464 5 is_stmt 1 view .LVU278
 1114              	.LBB810:
 1115              	.LBI810:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 1116              		.loc 4 50 16 view .LVU279
 1117              	.LBB811:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 1118              		.loc 4 51 14 is_stmt 0 view .LVU280
 1119 013c CDE90023 		strd	r2, [sp]
 1120              	.LVL80:
  52:communication/can/can_helpers.hpp **** 
 1121              		.loc 4 52 16 view .LVU281
 1122 0140 8DF800C0 		strb	ip, [sp]
 1123              	.LVL81:
 1124              	.LBB812:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 1125              		.loc 4 57 18 view .LVU282
 1126 0144 CDE90223 		strd	r2, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 1127              		.loc 4 58 20 view .LVU283
 1128 0148 02AB     		add	r3, sp, #8
 1129 014a DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 1130 014e DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 1131 0152 03C3     		stmia	r3!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 1132              		.loc 4 60 14 view .LVU284
ARM GAS  /tmp/ccoErako.s 			page 57


 1133 0154 21F07F43 		bic	r3, r1, #-16777216
 1134 0158 0393     		str	r3, [sp, #12]
  61:communication/can/can_helpers.hpp **** 
 1135              		.loc 4 61 14 view .LVU285
 1136 015a 009A     		ldr	r2, [sp]
 1137 015c 43EA0263 		orr	r3, r3, r2, lsl #24
 1138 0160 0393     		str	r3, [sp, #12]
 1139              		.loc 4 63 20 view .LVU286
 1140 0162 02AB     		add	r3, sp, #8
 1141 0164 03CB     		ldmia	r3!, {r0, r1}
 1142 0166 CDF81700 		str	r0, [sp, #23]	@ unaligned
 1143 016a CDF81B10 		str	r1, [sp, #27]	@ unaligned
 1144              	.LVL82:
 1145              		.loc 4 63 20 view .LVU287
 1146              	.LBE812:
 1147              	.LBE811:
 1148              	.LBE810:
 465:communication/can/can_simple.cpp **** 
 466:communication/can/can_simple.cpp ****     return canbus_->send_message(txmsg);
 1149              		.loc 3 466 5 is_stmt 1 view .LVU288
 1150              		.loc 3 466 12 is_stmt 0 view .LVU289
 1151 016e 2068     		ldr	r0, [r4]
 1152              		.loc 3 466 39 view .LVU290
 1153 0170 0368     		ldr	r3, [r0]
 1154 0172 1B68     		ldr	r3, [r3]
 1155              		.loc 3 466 33 view .LVU291
 1156 0174 7146     		mov	r1, lr
 1157 0176 9847     		blx	r3
 1158              	.LVL83:
 467:communication/can/can_simple.cpp **** }
 1159              		.loc 3 467 1 view .LVU292
 1160 0178 08B0     		add	sp, sp, #32
 1161              	.LCFI19:
 1162              		.cfi_def_cfa_offset 16
 1163              		@ sp needed
 1164 017a 70BD     		pop	{r4, r5, r6, pc}
 1165              	.LVL84:
 1166              	.L38:
 1167              		.loc 3 467 1 view .LVU293
 1168              		.align	2
 1169              	.L37:
 1170 017c 00000000 		.word	.LANCHOR0
 1171              		.cfi_endproc
 1172              	.LFE5250:
 1173              		.fnend
 1175              		.section	.text._ZN9CANSimple32get_bus_voltage_current_callbackERK4Axis,"ax",%progbits
 1176              		.align	1
 1177              		.global	_ZN9CANSimple32get_bus_voltage_current_callbackERK4Axis
 1178              		.syntax unified
 1179              		.thumb
 1180              		.thumb_func
 1182              	_ZN9CANSimple32get_bus_voltage_current_callbackERK4Axis:
 1183              		.fnstart
 1184              	.LVL85:
 1185              	.LFB5241:
 352:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 1186              		.loc 3 352 68 is_stmt 1 view -0
ARM GAS  /tmp/ccoErako.s 			page 58


 1187              		.cfi_startproc
 1188              		@ args = 0, pretend = 0, frame = 32
 1189              		@ frame_needed = 0, uses_anonymous_args = 0
 352:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 1190              		.loc 3 352 68 is_stmt 0 view .LVU295
 1191 0000 70B5     		push	{r4, r5, r6, lr}
 1192              		.save {r4, r5, r6, lr}
 1193              	.LCFI20:
 1194              		.cfi_def_cfa_offset 16
 1195              		.cfi_offset 4, -16
 1196              		.cfi_offset 5, -12
 1197              		.cfi_offset 6, -8
 1198              		.cfi_offset 14, -4
 1199              		.pad #32
 1200 0002 88B0     		sub	sp, sp, #32
 1201              	.LCFI21:
 1202              		.cfi_def_cfa_offset 48
 1203 0004 0446     		mov	r4, r0
 1204 0006 8E46     		mov	lr, r1
 353:communication/can/can_simple.cpp **** 
 1205              		.loc 3 353 5 is_stmt 1 view .LVU296
 353:communication/can/can_simple.cpp **** 
 1206              		.loc 3 353 19 is_stmt 0 view .LVU297
 1207 0008 254B     		ldr	r3, .L41
 1208 000a 0DF1100C 		add	ip, sp, #16
 1209 000e 0FCB     		ldm	r3, {r0, r1, r2, r3}
 1210              	.LVL86:
 353:communication/can/can_simple.cpp **** 
 1211              		.loc 3 353 19 view .LVU298
 1212 0010 8CE80F00 		stm	ip, {r0, r1, r2, r3}
 355:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_BUS_VOLTAGE_CURRENT;
 1213              		.loc 3 355 5 is_stmt 1 view .LVU299
 355:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_BUS_VOLTAGE_CURRENT;
 1214              		.loc 3 355 33 is_stmt 0 view .LVU300
 1215 0014 DEF87830 		ldr	r3, [lr, #120]
 355:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_BUS_VOLTAGE_CURRENT;
 1216              		.loc 3 355 41 view .LVU301
 1217 0018 5B01     		lsls	r3, r3, #5
 355:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_BUS_VOLTAGE_CURRENT;
 1218              		.loc 3 355 14 view .LVU302
 1219 001a 0493     		str	r3, [sp, #16]
 356:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 1220              		.loc 3 356 5 is_stmt 1 view .LVU303
 356:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 1221              		.loc 3 356 14 is_stmt 0 view .LVU304
 1222 001c 1733     		adds	r3, r3, #23
 1223 001e 0493     		str	r3, [sp, #16]
 357:communication/can/can_simple.cpp ****     txmsg.len = 8;
 1224              		.loc 3 357 5 is_stmt 1 view .LVU305
 357:communication/can/can_simple.cpp ****     txmsg.len = 8;
 1225              		.loc 3 357 36 is_stmt 0 view .LVU306
 1226 0020 9EF87C30 		ldrb	r3, [lr, #124]	@ zero_extendqisi2
 357:communication/can/can_simple.cpp ****     txmsg.len = 8;
 1227              		.loc 3 357 17 view .LVU307
 1228 0024 8DF81430 		strb	r3, [sp, #20]
 358:communication/can/can_simple.cpp **** 
 1229              		.loc 3 358 5 is_stmt 1 view .LVU308
ARM GAS  /tmp/ccoErako.s 			page 59


 360:communication/can/can_simple.cpp ****     static_assert(sizeof(float) == sizeof(ibus_));
 1230              		.loc 3 360 5 view .LVU309
 361:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, vbus_voltage, 0, 32, true);
 1231              		.loc 3 361 5 view .LVU310
 362:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, ibus_, 32, 32, true);
 1232              		.loc 3 362 5 view .LVU311
 1233              	.LVL87:
 1234              	.LBB835:
 1235              	.LBI835:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 1236              		.loc 4 50 16 view .LVU312
 1237              	.LBB836:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 1238              		.loc 4 51 14 is_stmt 0 view .LVU313
 1239 0028 0022     		movs	r2, #0
 1240 002a 0023     		movs	r3, #0
 1241 002c CDE90023 		strd	r2, [sp]
  52:communication/can/can_helpers.hpp **** 
 1242              		.loc 4 52 16 view .LVU314
 1243 0030 1C49     		ldr	r1, .L41+4
 1244 0032 0D68     		ldr	r5, [r1]
 1245 0034 0095     		str	r5, [sp]
 1246              	.LVL88:
 1247              	.LBB837:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 1248              		.loc 4 57 18 view .LVU315
 1249 0036 CDE90223 		strd	r2, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 1250              		.loc 4 58 20 view .LVU316
 1251 003a 0DF1080E 		add	lr, sp, #8
 1252              	.LVL89:
  58:communication/can/can_helpers.hpp **** 
 1253              		.loc 4 58 20 view .LVU317
 1254 003e DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 1255 0042 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 1256 0046 AEE80300 		stmia	lr!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 1257              		.loc 4 60 14 view .LVU318
 1258 004a 0026     		movs	r6, #0
 1259 004c 0296     		str	r6, [sp, #8]
  61:communication/can/can_helpers.hpp **** 
 1260              		.loc 4 61 27 view .LVU319
 1261 004e 0198     		ldr	r0, [sp, #4]
  61:communication/can/can_helpers.hpp **** 
 1262              		.loc 4 61 14 view .LVU320
 1263 0050 0143     		orrs	r1, r1, r0
 1264 0052 0295     		str	r5, [sp, #8]
 1265 0054 0391     		str	r1, [sp, #12]
 1266              		.loc 4 63 20 view .LVU321
 1267 0056 0DF1080E 		add	lr, sp, #8
 1268 005a BEE80300 		ldmia	lr!, {r0, r1}
 1269 005e CDF81700 		str	r0, [sp, #23]	@ unaligned
 1270 0062 CDF81B10 		str	r1, [sp, #27]	@ unaligned
 1271              	.LVL90:
 1272              		.loc 4 63 20 view .LVU322
 1273              	.LBE837:
 1274              	.LBE836:
ARM GAS  /tmp/ccoErako.s 			page 60


 1275              	.LBE835:
 363:communication/can/can_simple.cpp **** 
 1276              		.loc 3 363 5 is_stmt 1 view .LVU323
 1277              	.LBB838:
 1278              	.LBI838:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 1279              		.loc 4 50 16 view .LVU324
 1280              	.LBB839:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 1281              		.loc 4 51 14 is_stmt 0 view .LVU325
 1282 0066 CDE90023 		strd	r2, [sp]
  52:communication/can/can_helpers.hpp **** 
 1283              		.loc 4 52 16 view .LVU326
 1284 006a 0F49     		ldr	r1, .L41+8
 1285 006c 0D68     		ldr	r5, [r1]
 1286 006e 0095     		str	r5, [sp]
 1287              	.LVL91:
 1288              	.LBB840:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 1289              		.loc 4 57 18 view .LVU327
 1290 0070 CDE90223 		strd	r2, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 1291              		.loc 4 58 20 view .LVU328
 1292 0074 02AB     		add	r3, sp, #8
 1293 0076 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 1294 007a DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 1295 007e 03C3     		stmia	r3!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 1296              		.loc 4 60 14 view .LVU329
 1297 0080 0396     		str	r6, [sp, #12]
  61:communication/can/can_helpers.hpp **** 
 1298              		.loc 4 61 14 view .LVU330
 1299 0082 0395     		str	r5, [sp, #12]
 1300              		.loc 4 63 20 view .LVU331
 1301 0084 02AB     		add	r3, sp, #8
 1302 0086 03CB     		ldmia	r3!, {r0, r1}
 1303 0088 CDF81700 		str	r0, [sp, #23]	@ unaligned
 1304 008c CDF81B10 		str	r1, [sp, #27]	@ unaligned
 1305              	.LVL92:
 1306              		.loc 4 63 20 view .LVU332
 1307              	.LBE840:
 1308              	.LBE839:
 1309              	.LBE838:
 365:communication/can/can_simple.cpp **** }
 1310              		.loc 3 365 5 is_stmt 1 view .LVU333
 365:communication/can/can_simple.cpp **** }
 1311              		.loc 3 365 12 is_stmt 0 view .LVU334
 1312 0090 2068     		ldr	r0, [r4]
 365:communication/can/can_simple.cpp **** }
 1313              		.loc 3 365 39 view .LVU335
 1314 0092 0368     		ldr	r3, [r0]
 1315 0094 1B68     		ldr	r3, [r3]
 365:communication/can/can_simple.cpp **** }
 1316              		.loc 3 365 33 view .LVU336
 1317 0096 6146     		mov	r1, ip
 1318 0098 9847     		blx	r3
 1319              	.LVL93:
ARM GAS  /tmp/ccoErako.s 			page 61


 366:communication/can/can_simple.cpp **** 
 1320              		.loc 3 366 1 view .LVU337
 1321 009a 08B0     		add	sp, sp, #32
 1322              	.LCFI22:
 1323              		.cfi_def_cfa_offset 16
 1324              		@ sp needed
 1325 009c 70BD     		pop	{r4, r5, r6, pc}
 1326              	.LVL94:
 1327              	.L42:
 366:communication/can/can_simple.cpp **** 
 1328              		.loc 3 366 1 view .LVU338
 1329 009e 00BF     		.align	2
 1330              	.L41:
 1331 00a0 00000000 		.word	.LANCHOR0
 1332 00a4 00000000 		.word	vbus_voltage
 1333 00a8 00000000 		.word	ibus_
 1334              		.cfi_endproc
 1335              	.LFE5241:
 1336              		.fnend
 1338              		.section	.text._ZN9CANSimple33get_sensorless_estimates_callbackERK4Axis,"ax",%progbits
 1339              		.align	1
 1340              		.global	_ZN9CANSimple33get_sensorless_estimates_callbackERK4Axis
 1341              		.syntax unified
 1342              		.thumb
 1343              		.thumb_func
 1345              	_ZN9CANSimple33get_sensorless_estimates_callbackERK4Axis:
 1346              		.fnstart
 1347              	.LVL95:
 1348              	.LFB5218:
 247:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 1349              		.loc 3 247 69 is_stmt 1 view -0
 1350              		.cfi_startproc
 1351              		@ args = 0, pretend = 0, frame = 40
 1352              		@ frame_needed = 0, uses_anonymous_args = 0
 247:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 1353              		.loc 3 247 69 is_stmt 0 view .LVU340
 1354 0000 10B5     		push	{r4, lr}
 1355              		.save {r4, lr}
 1356              	.LCFI23:
 1357              		.cfi_def_cfa_offset 8
 1358              		.cfi_offset 4, -8
 1359              		.cfi_offset 14, -4
 1360              		.pad #40
 1361 0002 8AB0     		sub	sp, sp, #40
 1362              	.LCFI24:
 1363              		.cfi_def_cfa_offset 48
 1364 0004 8646     		mov	lr, r0
 1365 0006 8C46     		mov	ip, r1
 248:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 1366              		.loc 3 248 5 is_stmt 1 view .LVU341
 248:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 1367              		.loc 3 248 19 is_stmt 0 view .LVU342
 1368 0008 274B     		ldr	r3, .L47
 1369 000a 04AC     		add	r4, sp, #16
 1370 000c 0FCB     		ldm	r3, {r0, r1, r2, r3}
 1371              	.LVL96:
 248:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
ARM GAS  /tmp/ccoErako.s 			page 62


 1372              		.loc 3 248 19 view .LVU343
 1373 000e 84E80F00 		stm	r4, {r0, r1, r2, r3}
 249:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_SENSORLESS_ESTIMATES;  // heartbeat ID
 1374              		.loc 3 249 5 is_stmt 1 view .LVU344
 249:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_SENSORLESS_ESTIMATES;  // heartbeat ID
 1375              		.loc 3 249 33 is_stmt 0 view .LVU345
 1376 0012 DCF87830 		ldr	r3, [ip, #120]
 249:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_SENSORLESS_ESTIMATES;  // heartbeat ID
 1377              		.loc 3 249 41 view .LVU346
 1378 0016 5B01     		lsls	r3, r3, #5
 249:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_SENSORLESS_ESTIMATES;  // heartbeat ID
 1379              		.loc 3 249 14 view .LVU347
 1380 0018 0493     		str	r3, [sp, #16]
 250:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 1381              		.loc 3 250 5 is_stmt 1 view .LVU348
 250:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 1382              		.loc 3 250 14 is_stmt 0 view .LVU349
 1383 001a 1533     		adds	r3, r3, #21
 1384 001c 0493     		str	r3, [sp, #16]
 251:communication/can/can_simple.cpp ****     txmsg.len = 8;
 1385              		.loc 3 251 5 is_stmt 1 view .LVU350
 251:communication/can/can_simple.cpp ****     txmsg.len = 8;
 1386              		.loc 3 251 36 is_stmt 0 view .LVU351
 1387 001e 9CF87C30 		ldrb	r3, [ip, #124]	@ zero_extendqisi2
 251:communication/can/can_simple.cpp ****     txmsg.len = 8;
 1388              		.loc 3 251 17 view .LVU352
 1389 0022 8DF81430 		strb	r3, [sp, #20]
 252:communication/can/can_simple.cpp **** 
 1390              		.loc 3 252 5 is_stmt 1 view .LVU353
 254:communication/can/can_simple.cpp **** 
 1391              		.loc 3 254 5 view .LVU354
 256:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, axis.sensorless_estimator_.vel_estimate_.any().value_or(0.0f), 32, 
 1392              		.loc 3 256 5 view .LVU355
 256:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, axis.sensorless_estimator_.vel_estimate_.any().value_or(0.0f), 32, 
 1393              		.loc 3 256 38 is_stmt 0 view .LVU356
 1394 0026 DCF8FC20 		ldr	r2, [ip, #252]
 1395              	.LVL97:
 1396              	.LBB888:
 1397              	.LBI888:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 1398              		.loc 4 50 16 is_stmt 1 view .LVU357
 1399              	.LBB889:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 1400              		.loc 4 51 14 is_stmt 0 view .LVU358
 1401 002a 0020     		movs	r0, #0
 1402 002c 0021     		movs	r1, #0
 1403 002e CDE90001 		strd	r0, [sp]
 1404 0032 5469     		ldr	r4, [r2, #20]	@ unaligned
 1405              	.LVL98:
  52:communication/can/can_helpers.hpp **** 
 1406              		.loc 4 52 16 view .LVU359
 1407 0034 0094     		str	r4, [sp]
 1408              	.LVL99:
 1409              	.LBB890:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 1410              		.loc 4 57 18 view .LVU360
 1411 0036 CDE90201 		strd	r0, [sp, #8]
ARM GAS  /tmp/ccoErako.s 			page 63


  58:communication/can/can_helpers.hpp **** 
 1412              		.loc 4 58 20 view .LVU361
 1413 003a 02AB     		add	r3, sp, #8
 1414 003c DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 1415 0040 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 1416 0044 03C3     		stmia	r3!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 1417              		.loc 4 60 14 view .LVU362
 1418 0046 0023     		movs	r3, #0
 1419 0048 0293     		str	r3, [sp, #8]
  61:communication/can/can_helpers.hpp **** 
 1420              		.loc 4 61 27 view .LVU363
 1421 004a 0199     		ldr	r1, [sp, #4]
  61:communication/can/can_helpers.hpp **** 
 1422              		.loc 4 61 14 view .LVU364
 1423 004c 039B     		ldr	r3, [sp, #12]
 1424 004e 0B43     		orrs	r3, r3, r1
 1425 0050 0294     		str	r4, [sp, #8]
 1426 0052 0393     		str	r3, [sp, #12]
 1427              		.loc 4 63 20 view .LVU365
 1428 0054 02AB     		add	r3, sp, #8
 1429 0056 03CB     		ldmia	r3!, {r0, r1}
 1430 0058 CDF81700 		str	r0, [sp, #23]	@ unaligned
 1431 005c CDF81B10 		str	r1, [sp, #27]	@ unaligned
 1432              	.LVL100:
 1433              		.loc 4 63 20 view .LVU366
 1434              	.LBE890:
 1435              	.LBE889:
 1436              	.LBE888:
 257:communication/can/can_simple.cpp **** 
 1437              		.loc 3 257 5 is_stmt 1 view .LVU367
 1438              	.LBB891:
 1439              	.LBI891:
 1440              		.file 5 "./MotorControl/component.hpp"
   1:./MotorControl/component.hpp **** #ifndef __COMPONENT_HPP
   2:./MotorControl/component.hpp **** #define __COMPONENT_HPP
   3:./MotorControl/component.hpp **** 
   4:./MotorControl/component.hpp **** #include <stdint.h>
   5:./MotorControl/component.hpp **** #include <optional>
   6:./MotorControl/component.hpp **** #include <variant>
   7:./MotorControl/component.hpp **** 
   8:./MotorControl/component.hpp **** class ComponentBase {
   9:./MotorControl/component.hpp **** public:
  10:./MotorControl/component.hpp ****     /**
  11:./MotorControl/component.hpp ****      * @brief Shall run the update action of this component.
  12:./MotorControl/component.hpp ****      * 
  13:./MotorControl/component.hpp ****      * This function gets called in a low priority interrupt context and is
  14:./MotorControl/component.hpp ****      * allowed to call CMSIS functions.
  15:./MotorControl/component.hpp ****      * 
  16:./MotorControl/component.hpp ****      * @param timestamp: The timestamp (in HCLK ticks) for which this update
  17:./MotorControl/component.hpp ****      * is run.
  18:./MotorControl/component.hpp ****      */
  19:./MotorControl/component.hpp ****     virtual void update(uint32_t timestamp) = 0;
  20:./MotorControl/component.hpp **** };
  21:./MotorControl/component.hpp **** 
  22:./MotorControl/component.hpp **** 
  23:./MotorControl/component.hpp **** template<typename T>
ARM GAS  /tmp/ccoErako.s 			page 64


  24:./MotorControl/component.hpp **** class InputPort;
  25:./MotorControl/component.hpp **** 
  26:./MotorControl/component.hpp **** /**
  27:./MotorControl/component.hpp ****  * @brief An output port stores a value for consumption by a connecting input
  28:./MotorControl/component.hpp ****  * port.
  29:./MotorControl/component.hpp ****  * 
  30:./MotorControl/component.hpp ****  * Output ports are supposed to be reset at the beginning of a control loop
  31:./MotorControl/component.hpp ****  * iteration. This ensures that connecting input ports don't use an outdated
  32:./MotorControl/component.hpp ****  * value and, more importantly, ensures proper handling if the producer of the
  33:./MotorControl/component.hpp ****  * value is incapable of producing the value for any reason.
  34:./MotorControl/component.hpp ****  * 
  35:./MotorControl/component.hpp ****  * Member functions of this class are not thread-safe unless noted otherwise.
  36:./MotorControl/component.hpp ****  */
  37:./MotorControl/component.hpp **** template<typename T>
  38:./MotorControl/component.hpp **** class OutputPort {
  39:./MotorControl/component.hpp **** public:
  40:./MotorControl/component.hpp ****     /**
  41:./MotorControl/component.hpp ****      * @brief Initializes the output port with the specified value.
  42:./MotorControl/component.hpp ****      * 
  43:./MotorControl/component.hpp ****      * An initialization value is required for any() to work properly.
  44:./MotorControl/component.hpp ****      * present() and previous() cannot be used to fetch the
  45:./MotorControl/component.hpp ****      * initialization value.
  46:./MotorControl/component.hpp ****      */
  47:./MotorControl/component.hpp ****     OutputPort(T val) : content_(val) {}
  48:./MotorControl/component.hpp ****     
  49:./MotorControl/component.hpp ****     /**
  50:./MotorControl/component.hpp ****      * @brief Updates the underlying value of this output port.
  51:./MotorControl/component.hpp ****      */
  52:./MotorControl/component.hpp ****     void operator=(T value) {
  53:./MotorControl/component.hpp ****         content_ = value;
  54:./MotorControl/component.hpp ****         age_ = 0;
  55:./MotorControl/component.hpp ****     }
  56:./MotorControl/component.hpp **** 
  57:./MotorControl/component.hpp ****     /**
  58:./MotorControl/component.hpp ****      * @brief Marks the contained value as outdated. The value is not actually
  59:./MotorControl/component.hpp ****      * deleted and can still be accessed through some of the member functions
  60:./MotorControl/component.hpp ****      * of this class.
  61:./MotorControl/component.hpp ****      */
  62:./MotorControl/component.hpp ****     void reset() {
  63:./MotorControl/component.hpp ****         // This will eventually overflow to 0 so present() could
  64:./MotorControl/component.hpp ****         // theoretically return a very old value however it is very likely that
  65:./MotorControl/component.hpp ****         // the motor will be long disarmed by then.
  66:./MotorControl/component.hpp ****         age_++;
  67:./MotorControl/component.hpp ****     }
  68:./MotorControl/component.hpp **** 
  69:./MotorControl/component.hpp ****     /**
  70:./MotorControl/component.hpp ****      * @brief Returns the value from this control loop iteration or std::nullopt
  71:./MotorControl/component.hpp ****      * if the value was not yet set during this control loop iteration.
  72:./MotorControl/component.hpp ****      */
  73:./MotorControl/component.hpp ****     std::optional<T> present() {
  74:./MotorControl/component.hpp ****         if (age_ == 0) {
  75:./MotorControl/component.hpp ****             return content_;
  76:./MotorControl/component.hpp ****         } else {
  77:./MotorControl/component.hpp ****             return std::nullopt;
  78:./MotorControl/component.hpp ****         }
  79:./MotorControl/component.hpp ****     }
  80:./MotorControl/component.hpp **** 
ARM GAS  /tmp/ccoErako.s 			page 65


  81:./MotorControl/component.hpp ****     /**
  82:./MotorControl/component.hpp ****      * @brief Returns the value from exactly the previous control loop iteration.
  83:./MotorControl/component.hpp ****      * 
  84:./MotorControl/component.hpp ****      * If during the last iteration no value was set or the value was already
  85:./MotorControl/component.hpp ****      * overwritten during this control loop iteration then this function returns
  86:./MotorControl/component.hpp ****      * std::nullopt.
  87:./MotorControl/component.hpp ****      */
  88:./MotorControl/component.hpp ****     std::optional<T> previous() {
  89:./MotorControl/component.hpp ****         if (age_ == 1) {
  90:./MotorControl/component.hpp ****             return content_;
  91:./MotorControl/component.hpp ****         } else {
  92:./MotorControl/component.hpp ****             return std::nullopt;
  93:./MotorControl/component.hpp ****         }
  94:./MotorControl/component.hpp ****     }
  95:./MotorControl/component.hpp **** 
  96:./MotorControl/component.hpp ****     /**
  97:./MotorControl/component.hpp ****      * @brief Returns the value contained in this output port with disregard of
  98:./MotorControl/component.hpp ****      * when the value was set.
  99:./MotorControl/component.hpp ****      * 
 100:./MotorControl/component.hpp ****      * This function is thread-safe if load/store operations of T are atomic.
 101:./MotorControl/component.hpp ****      */
 102:./MotorControl/component.hpp ****     std::optional<T> any() {
 1441              		.loc 5 102 22 view .LVU368
 1442              	.LBB892:
 1443              	.LBB893:
 1444              	.LBI893:
 1445              		.file 6 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // <optional> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Copyright (C) 2013-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** /** @file include/optional
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****  *  This is a Standard C++ Library header.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****  */
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #ifndef _GLIBCXX_OPTIONAL
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #define _GLIBCXX_OPTIONAL 1
ARM GAS  /tmp/ccoErako.s 			page 66


  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #pragma GCC system_header
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #if __cplusplus >= 201703L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <utility>
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <type_traits>
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <exception>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <new>
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <initializer_list>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/exception_defines.h>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/functional_hash.h>
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/enable_special_members.h>
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #if __cplusplus > 201703L
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** # include <compare>
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #endif
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** namespace std _GLIBCXX_VISIBILITY(default)
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** {
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @addtogroup utilities
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @{
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    */
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #define __cpp_lib_optional 201606L
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class optional;
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /// Tag type to disengage optional objects.
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   struct nullopt_t
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   {
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Do not user-declare default constructor at all for
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // optional_value = {} syntax to work.
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // nullopt_t() = delete;
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Used for constructing nullopt.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     enum class _Construct { _Token };
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Must be constexpr for nullopt_t to be literal.
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     explicit constexpr nullopt_t(_Construct) { }
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   };
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /// Tag to disengage optional objects.
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   inline constexpr nullopt_t nullopt { nullopt_t::_Construct::_Token };
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @brief Exception class thrown when a disengaged optional object is
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  dereferenced.
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @ingroup exceptions
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    */
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   class bad_optional_access : public exception
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   {
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   public:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     bad_optional_access() = default;
ARM GAS  /tmp/ccoErako.s 			page 67


  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     virtual ~bad_optional_access() = default;
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     const char* what() const noexcept override
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return "bad optional access"; }
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   };
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   void
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __throw_bad_optional_access()
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __attribute__((__noreturn__));
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // XXX Does not belong here.
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   inline void
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __throw_bad_optional_access()
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   { _GLIBCXX_THROW_OR_ABORT(bad_optional_access()); }
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // This class template manages construction/destruction of
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // the contained value for a std::optional.
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload_base
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Stored_type = remove_const_t<_Tp>;
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base() = default;
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_Optional_payload_base(in_place_t __tag, _Args&&... __args)
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_engaged(true)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args>
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_Optional_payload_base(std::initializer_list<_Up> __il,
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			       _Args&&... __args)
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__il, std::forward<_Args>(__args)...),
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_engaged(true)
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructor used by _Optional_base copy constructor when the
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // contained value is not trivially copy constructible.
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(bool __engaged,
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			     const _Optional_payload_base& __other)
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (__other._M_engaged)
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(__other._M_get());
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructor used by _Optional_base move constructor when the
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // contained value is not trivially move constructible.
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(bool __engaged,
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			     _Optional_payload_base&& __other)
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (__other._M_engaged)
ARM GAS  /tmp/ccoErako.s 			page 68


 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(std::move(__other._M_get()));
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy constructor is only used to when the contained value is
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // trivially copy constructible.
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(const _Optional_payload_base&) = default;
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Move constructor is only used to when the contained value is
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // trivially copy constructible.
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(_Optional_payload_base&&) = default;
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base&
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload_base&) = default;
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base&
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload_base&&) = default;
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // used to perform non-trivial copy assignment.
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_copy_assign(const _Optional_payload_base& __other)
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         if (this->_M_engaged && __other._M_engaged)
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           this->_M_get() = __other._M_get();
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         else
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    if (__other._M_engaged)
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_construct(__other._M_get());
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    else
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // used to perform non-trivial move assignment.
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_move_assign(_Optional_payload_base&& __other)
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_engaged && __other._M_engaged)
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_get() = std::move(__other._M_get());
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    if (__other._M_engaged)
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_construct(std::move(__other._M_get()));
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    else
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       struct _Empty_byte { };
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, bool = is_trivially_destructible_v<_Up>>
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	union _Storage
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  constexpr _Storage() noexcept : _M_empty() { }
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename... _Args>
ARM GAS  /tmp/ccoErako.s 			page 69


 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(in_place_t, _Args&&... __args)
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename _Vp, typename... _Args>
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(__il, std::forward<_Args>(__args)...)
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _Empty_byte _M_empty;
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           _Up _M_value;
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	};
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	union _Storage<_Up, false>
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  constexpr _Storage() noexcept : _M_empty() { }
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename... _Args>
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(in_place_t, _Args&&... __args)
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename _Vp, typename... _Args>
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(__il, std::forward<_Args>(__args)...)
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  // User-provided destructor is needed when _Up has non-trivial dtor.
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ~_Storage() { }
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _Empty_byte _M_empty;
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           _Up _M_value;
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	};
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Storage<_Stored_type> _M_payload;
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       bool _M_engaged = false;
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         void
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         _M_construct(_Args&&... __args)
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         {
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           ::new ((void *) std::__addressof(this->_M_payload))
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****             _Stored_type(std::forward<_Args>(__args)...);
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           this->_M_engaged = true;
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         }
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_destroy() noexcept
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_engaged = false;
ARM GAS  /tmp/ccoErako.s 			page 70


 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_payload._M_value.~_Stored_type();
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_get() operations have _M_engaged as a precondition.
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // They exist to access the contained value with the appropriate
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // const-qualification, because _M_payload has had the const removed.
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() noexcept
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_payload._M_value; }
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() const noexcept
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_payload._M_value; }
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // _M_reset is a 'safe' operation with no precondition.
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_reset() noexcept
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_engaged)
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_destroy();
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Class template that manages the payload for optionals.
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp,
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialDestructor*/ =
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_destructible_v<_Tp>,
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialCopy */ =
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_copy_assignable_v<_Tp>
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      && is_trivially_copy_constructible_v<_Tp>,
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialMove */ =
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_move_assignable_v<_Tp>
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      && is_trivially_move_constructible_v<_Tp>>
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload;
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for potentially-constexpr optionals (trivial copy/move/destroy).
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, true, true>
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial copy construction/assignment.
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, false, true>
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
ARM GAS  /tmp/ccoErako.s 			page 71


 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(_Optional_payload&&) = default;
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial copy assignment.
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload& __other)
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_copy_assign(__other);
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial move construction/assignment.
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, true, false>
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(const _Optional_payload&) = default;
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial move assignment.
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload&& __other)
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_move_assign(std::move(__other));
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial copy and move assignment.
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, false, false>
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial copy assignment.
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload& __other)
 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_copy_assign(__other);
 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
ARM GAS  /tmp/ccoErako.s 			page 72


 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial move assignment.
 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload&& __other)
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_move_assign(std::move(__other));
 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial destructors.
 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp, bool _Copy, bool _Move>
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, false, _Copy, _Move>
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload<_Tp, true, false, false>
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Base class implements all the constructors and assignment operators:
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload<_Tp, true, false, false>::_Optional_payload;
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(const _Optional_payload&) = default;
 397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(_Optional_payload&&) = default;
 398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Destructor needs to destroy the contained value:
 400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() { this->_M_reset(); }
 401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Common base class for _Optional_base<T> to avoid repeating these
 404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // member functions in each specialization.
 405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Dp>
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class _Optional_base_impl
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     protected:
 409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Stored_type = remove_const_t<_Tp>;
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_construct operation has !_M_engaged as a precondition
 412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // while _M_destruct has _M_engaged as a precondition.
 413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	void
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_construct(_Args&&... __args)
 416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ::new
 419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    (std::__addressof(static_cast<_Dp*>(this)->_M_payload._M_payload))
 420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Stored_type(std::forward<_Args>(__args)...);
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_cast<_Dp*>(this)->_M_payload._M_engaged = true;
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       void
 425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_destruct() noexcept
 426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { static_cast<_Dp*>(this)->_M_payload._M_destroy(); }
 427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // _M_reset is a 'safe' operation with no precondition.
 429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
ARM GAS  /tmp/ccoErako.s 			page 73


 430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_reset() noexcept
 431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { static_cast<_Dp*>(this)->_M_payload._M_reset(); }
 432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr bool _M_is_engaged() const noexcept
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_get operations have _M_engaged as a precondition.
 437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() noexcept
 439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__glibcxx_assert(this->_M_is_engaged());
 441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return static_cast<_Dp*>(this)->_M_payload._M_get();
 442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() const noexcept
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__glibcxx_assert(this->_M_is_engaged());
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return static_cast<const _Dp*>(this)->_M_payload._M_get();
 449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
 453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @brief Class template that provides copy/move constructors of optional.
 454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * Such a separate base class template is necessary in order to
 456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * conditionally make copy/move constructors trivial.
 457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * When the contained value is trivially copy/move constructible,
 459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * the copy/move constructors of _Optional_base will invoke the
 460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * trivial copy/move constructor of _Optional_payload. Otherwise,
 461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * they will invoke _Optional_payload(bool, const _Optional_payload&)
 462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * or _Optional_payload(bool, _Optional_payload&&) to initialize
 463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * the contained value, if copying/moving an engaged optional.
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * Whether the other special members are trivial is determined by the
 466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * _Optional_payload<_Tp> specialization used for the _M_payload member.
 467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @see optional, _Enable_special_members
 469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     */
 470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp,
 471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	   bool = is_trivially_copy_constructible_v<_Tp>,
 472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	   bool = is_trivially_move_constructible_v<_Tp>>
 473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base
 474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
ARM GAS  /tmp/ccoErako.s 			page 74


 487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other)
 499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __other._M_payload)
 501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other)
 504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>)
 505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::move(__other._M_payload))
 507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, false, true>
 518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other)
 543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
ARM GAS  /tmp/ccoErako.s 			page 75


 544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __other._M_payload)
 545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other) = default;
 548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, true, false>
 558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other) = default;
 583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other)
 585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>)
 586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::move(__other._M_payload))
 588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, true, true>
 599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
ARM GAS  /tmp/ccoErako.s 			page 76


 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other) = default;
 624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other) = default;
 625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   class optional;
 635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __converts_from_optional =
 638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       __or_<is_constructible<_Tp, const optional<_Up>&>,
 639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, optional<_Up>&>,
 640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, const optional<_Up>&&>,
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, optional<_Up>&&>,
 642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<const optional<_Up>&, _Tp>,
 643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<optional<_Up>&, _Tp>,
 644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<const optional<_Up>&&, _Tp>,
 645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<optional<_Up>&&, _Tp>>;
 646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __assigns_from_optional =
 649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       __or_<is_assignable<_Tp&, const optional<_Up>&>,
 650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, optional<_Up>&>,
 651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, const optional<_Up>&&>,
 652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, optional<_Up>&&>>;
 653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
 655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @brief Class template for optional values.
 656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     */
 657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
ARM GAS  /tmp/ccoErako.s 			page 77


 658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class optional
 659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : private _Optional_base<_Tp>,
 660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       private _Enable_copy_move<
 661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Copy constructor.
 662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	is_copy_constructible_v<_Tp>,
 663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Copy assignment.
 664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__and_v<is_copy_constructible<_Tp>, is_copy_assignable<_Tp>>,
 665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Move constructor.
 666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	is_move_constructible_v<_Tp>,
 667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Move assignment.
 668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__and_v<is_move_constructible<_Tp>, is_move_assignable<_Tp>>,
 669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Unique tag type.
 670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional<_Tp>>
 671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_same_v<remove_cv_t<_Tp>, nullopt_t>);
 673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_same_v<remove_cv_t<_Tp>, in_place_t>);
 674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_reference_v<_Tp>);
 675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     private:
 677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Base = _Optional_base<_Tp>;
 678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // SFINAE helpers
 680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using __not_self = __not_<is_same<optional, __remove_cvref_t<_Up>>>;
 682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using __not_tag = __not_<is_same<in_place_t, __remove_cvref_t<_Up>>>;
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Cond>
 685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using _Requires = enable_if_t<__and_v<_Cond...>, bool>;
 686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     public:
 688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using value_type = _Tp;
 689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr optional() = default;
 691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr optional(nullopt_t) noexcept { }
 693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Converting constructors for engaged optionals.
 695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp,
 696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_self<_Up>, __not_tag<_Up>,
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, _Up&&>,
 698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_convertible<_Up&&, _Tp>> = true>
 699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(_Up&& __t)
 1446              		.loc 6 700 2 view .LVU369
 1447              	.LBB894:
 1448              	.LBB895:
 1449              	.LBB896:
 1450              	.LBI896:
 1451              		.file 7 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Move, forward and identity for C++11 + swap -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Copyright (C) 2007-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Free Software Foundation; either version 3, or (at your option)
ARM GAS  /tmp/ccoErako.s 			page 78


   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** /** @file bits/move.h
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****  *  This is an internal header file, included by other library headers.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****  *  Do not attempt to use it directly. @headername{utility}
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****  */
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #ifndef _MOVE_H
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #define _MOVE_H 1
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #include <bits/c++config.h>
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #if __cplusplus < 201103L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** # include <bits/concept_check.h>
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #endif
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** namespace std _GLIBCXX_VISIBILITY(default)
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** {
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   // Used, in C++03 mode too, by allocators, etc.
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief Same as C++11 std::addressof
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @ingroup utilities
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     inline _GLIBCXX_CONSTEXPR _Tp*
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return __builtin_addressof(__r); }
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #if __cplusplus >= 201103L
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** _GLIBCXX_END_NAMESPACE_VERSION
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** } // namespace
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #include <type_traits> // Brings in std::declval too.
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** namespace std _GLIBCXX_VISIBILITY(default)
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** {
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @addtogroup utilities
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @{
ARM GAS  /tmp/ccoErako.s 			page 79


  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief  Forward an lvalue.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @return The parameter cast to the specified type.
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  This function is used to implement "perfect forwarding".
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     constexpr _Tp&&
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 1452              		.loc 7 76 5 view .LVU370
 1453              		.loc 7 76 5 is_stmt 0 view .LVU371
 1454              	.LBE896:
 1455              	.LBB897:
 1456              	.LBI897:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 1457              		.loc 6 607 28 is_stmt 1 view .LVU372
 1458              	.LBB898:
 1459              	.LBB899:
 1460              	.LBB900:
 1461              	.LBI900:
 1462              		.loc 7 76 5 view .LVU373
 1463              		.loc 7 76 5 is_stmt 0 view .LVU374
 1464              	.LBE900:
 1465              	.LBB901:
 1466              	.LBI901:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1467              		.loc 6 300 42 is_stmt 1 view .LVU375
 1468              	.LBB902:
 1469              	.LBB903:
 1470              	.LBB904:
 1471              	.LBI904:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 1472              		.loc 6 115 2 view .LVU376
 1473              	.LBB905:
 1474              	.LBB906:
 1475              	.LBB907:
 1476              	.LBI907:
 1477              		.loc 7 76 5 view .LVU377
 1478              		.loc 7 76 5 is_stmt 0 view .LVU378
 1479              	.LBE907:
 1480              	.LBB908:
 1481              	.LBI908:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 1482              		.loc 6 203 6 is_stmt 1 view .LVU379
 1483              	.LBB909:
 1484              	.LBB910:
 1485              	.LBB911:
 1486              	.LBI911:
 1487              		.loc 7 76 5 view .LVU380
 1488              		.loc 7 76 5 is_stmt 0 view .LVU381
 1489              	.LBE911:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 1490              		.loc 6 204 47 view .LVU382
 1491 0060 D36B     		ldr	r3, [r2, #60]	@ float
 1492 0062 0893     		str	r3, [sp, #32]	@ float
ARM GAS  /tmp/ccoErako.s 			page 80


 1493              	.LVL101:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 1494              		.loc 6 204 47 view .LVU383
 1495              	.LBE910:
 1496              	.LBE909:
 1497              	.LBE908:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 1498              		.loc 6 117 19 view .LVU384
 1499 0064 0123     		movs	r3, #1
 1500 0066 8DF82430 		strb	r3, [sp, #36]
 1501              	.LVL102:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 1502              		.loc 6 117 19 view .LVU385
 1503              	.LBE906:
 1504              	.LBE905:
 1505              	.LBE904:
 1506              	.LBE903:
 1507              	.LBE902:
 1508              	.LBE901:
 1509              	.LBE899:
 1510              	.LBE898:
 1511              	.LBE897:
 1512              	.LBE895:
 1513              	.LBE894:
 1514              	.LBE893:
 1515              	.LBE892:
 1516              	.LBE891:
 1517              	.LBB912:
 1518              	.LBI912:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp,
 704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_self<_Up>, __not_tag<_Up>,
 705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, _Up&&>,
 706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<is_convertible<_Up&&, _Tp>>> = false>
 707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(_Up&& __t)
 709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _Base(std::in_place, std::forward<_Up>(__t)) { }
 710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up,
 712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_<is_same<_Tp, _Up>>,
 713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, const _Up&>,
 714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_convertible<const _Up&, _Tp>,
 715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<__converts_from_optional<_Tp, _Up>>> = true>
 716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(const optional<_Up>& __t)
 718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(*__t);
 721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up,
 724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_<is_same<_Tp, _Up>>,
 725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, const _Up&>,
 726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<is_convertible<const _Up&, _Tp>>,
 727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<__converts_from_optional<_Tp, _Up>>> = false>
 728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
ARM GAS  /tmp/ccoErako.s 			page 81


 729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(const optional<_Up>& __t)
 730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(*__t);
 733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template <typename _Up,
 736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		_Requires<__not_<is_same<_Tp, _Up>>,
 737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_constructible<_Tp, _Up&&>,
 738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_convertible<_Up&&, _Tp>,
 739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<__converts_from_optional<_Tp, _Up>>> = true>
 740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(optional<_Up>&& __t)
 742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(std::move(*__t));
 745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template <typename _Up,
 748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		_Requires<__not_<is_same<_Tp, _Up>>,
 749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_constructible<_Tp, _Up&&>,
 750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<is_convertible<_Up&&, _Tp>>,
 751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<__converts_from_optional<_Tp, _Up>>> = false>
 752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(optional<_Up>&& __t)
 754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(std::move(*__t));
 757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<is_constructible<_Tp, _Args&&...>> = false>
 761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(in_place_t, _Args&&... __args)
 763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Args>(__args)...) { }
 764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<is_constructible<_Tp,
 767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  initializer_list<_Up>&,
 768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  _Args&&...>> = false>
 769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(in_place_t, initializer_list<_Up> __il, _Args&&... __args)
 771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, __il, std::forward<_Args>(__args)...) { }
 772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       optional&
 775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(nullopt_t) noexcept
 776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_reset();
 778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp>
 782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<__and_v<__not_self<_Up>,
 783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__and_<is_scalar<_Tp>,
 784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  is_same<_Tp, decay_t<_Up>>>>,
 785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, _Up>,
ARM GAS  /tmp/ccoErako.s 			page 82


 786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, _Up>>,
 787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(_Up&& __u)
 789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (this->_M_is_engaged())
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_get() = std::forward<_Up>(__u);
 792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_construct(std::forward<_Up>(__u));
 794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
 796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
 800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, const _Up&>,
 801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, const _Up&>,
 802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__converts_from_optional<_Tp, _Up>>,
 803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__assigns_from_optional<_Tp, _Up>>>,
 804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(const optional<_Up>& __u)
 806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__u)
 808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      if (this->_M_is_engaged())
 810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_get() = *__u;
 811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      else
 812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_construct(*__u);
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
 819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, _Up>,
 824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, _Up>,
 825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__converts_from_optional<_Tp, _Up>>,
 826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__assigns_from_optional<_Tp, _Up>>>,
 827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(optional<_Up>&& __u)
 829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__u)
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      if (this->_M_is_engaged())
 833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_get() = std::move(*__u);
 834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      else
 835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_construct(std::move(*__u));
 836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
ARM GAS  /tmp/ccoErako.s 			page 83


 843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<is_constructible_v<_Tp, _Args&&...>, _Tp&>
 847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	emplace(_Args&&... __args)
 848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_reset();
 850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(std::forward<_Args>(__args)...);
 851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_get();
 852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args>
 855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&,
 856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 				       _Args&&...>, _Tp&>
 857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	emplace(initializer_list<_Up> __il, _Args&&... __args)
 858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_reset();
 860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(__il, std::forward<_Args>(__args)...);
 861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_get();
 862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Destructor is implicit, implemented in _Optional_base.
 865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Swap.
 867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       void
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       swap(optional& __other)
 869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>
 870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       && is_nothrow_swappable_v<_Tp>)
 871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using std::swap;
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_is_engaged() && __other._M_is_engaged())
 875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  swap(this->_M_get(), __other._M_get());
 876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else if (this->_M_is_engaged())
 877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    __other._M_construct(std::move(this->_M_get()));
 879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_destruct();
 880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else if (__other._M_is_engaged())
 882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_construct(std::move(__other._M_get()));
 884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    __other._M_destruct();
 885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Observers.
 889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp*
 890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator->() const
 891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::__addressof(this->_M_get()); }
 892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp*
 894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator->()
 895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::__addressof(this->_M_get()); }
 896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*() const&
 899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_get(); }
ARM GAS  /tmp/ccoErako.s 			page 84


 900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*()&
 903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_get(); }
 904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&&
 906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*()&&
 907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::move(this->_M_get()); }
 908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&&
 910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*() const&&
 911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::move(this->_M_get()); }
 912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr explicit operator bool() const noexcept
 914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr bool has_value() const noexcept
 917:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 918:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 919:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 920:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value() const&
 921:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 922:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 923:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? this->_M_get()
 924:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), this->_M_get());
 925:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 926:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 927:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 928:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value()&
 929:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 930:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 931:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? this->_M_get()
 932:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), this->_M_get());
 933:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 934:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 935:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&&
 936:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value()&&
 937:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 938:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 939:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? std::move(this->_M_get())
 940:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), std::move(this->_M_get()));
 941:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 942:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 943:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&&
 944:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value() const&&
 945:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 946:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 947:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? std::move(this->_M_get())
 948:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), std::move(this->_M_get()));
 949:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 950:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 952:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr _Tp
 953:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	value_or(_Up&& __u) const&
 954:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 955:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_copy_constructible_v<_Tp>);
 956:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_convertible_v<_Up&&, _Tp>);
ARM GAS  /tmp/ccoErako.s 			page 85


 957:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 958:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_is_engaged()
 959:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    ? this->_M_get() : static_cast<_Tp>(std::forward<_Up>(__u));
 960:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 961:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 962:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 963:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr _Tp
 964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	value_or(_Up&& __u) &&
 1519              		.loc 6 964 2 is_stmt 1 view .LVU386
 1520              	.LBB913:
 1521              	.LBB914:
 1522              	.LBI914:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 1523              		.loc 6 433 22 view .LVU387
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 1524              		.loc 6 433 22 is_stmt 0 view .LVU388
 1525              	.LBE914:
 1526              	.LBE913:
 1527              	.LBE912:
 1528              	.LBB915:
 1529              	.LBI915:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 1530              		.loc 4 50 16 is_stmt 1 view .LVU389
 1531              	.LBB916:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 1532              		.loc 4 51 14 is_stmt 0 view .LVU390
 1533 006a 0020     		movs	r0, #0
 1534 006c 0021     		movs	r1, #0
 1535 006e CDE90001 		strd	r0, [sp]
  52:communication/can/can_helpers.hpp **** 
 1536              		.loc 4 52 16 view .LVU391
 1537 0072 089A     		ldr	r2, [sp, #32]
 1538 0074 0092     		str	r2, [sp]
 1539              	.LVL103:
 1540              	.LBB917:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 1541              		.loc 4 57 18 view .LVU392
 1542 0076 CDE90201 		strd	r0, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 1543              		.loc 4 58 20 view .LVU393
 1544 007a 02AB     		add	r3, sp, #8
 1545 007c DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 1546 0080 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 1547 0084 03C3     		stmia	r3!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 1548              		.loc 4 60 14 view .LVU394
 1549 0086 0023     		movs	r3, #0
 1550 0088 0393     		str	r3, [sp, #12]
  61:communication/can/can_helpers.hpp **** 
 1551              		.loc 4 61 14 view .LVU395
 1552 008a 0392     		str	r2, [sp, #12]
 1553              		.loc 4 63 20 view .LVU396
 1554 008c 02AB     		add	r3, sp, #8
 1555 008e 03CB     		ldmia	r3!, {r0, r1}
 1556 0090 CDF81700 		str	r0, [sp, #23]	@ unaligned
 1557 0094 CDF81B10 		str	r1, [sp, #27]	@ unaligned
 1558              	.LVL104:
ARM GAS  /tmp/ccoErako.s 			page 86


 1559              		.loc 4 63 20 view .LVU397
 1560              	.LBE917:
 1561              	.LBE916:
 1562              	.LBE915:
 259:communication/can/can_simple.cpp **** }
 1563              		.loc 3 259 5 is_stmt 1 view .LVU398
 259:communication/can/can_simple.cpp **** }
 1564              		.loc 3 259 12 is_stmt 0 view .LVU399
 1565 0098 DEF80000 		ldr	r0, [lr]
 259:communication/can/can_simple.cpp **** }
 1566              		.loc 3 259 39 view .LVU400
 1567 009c 0368     		ldr	r3, [r0]
 1568 009e 1B68     		ldr	r3, [r3]
 259:communication/can/can_simple.cpp **** }
 1569              		.loc 3 259 33 view .LVU401
 1570 00a0 04A9     		add	r1, sp, #16
 1571 00a2 9847     		blx	r3
 1572              	.LVL105:
 260:communication/can/can_simple.cpp **** 
 1573              		.loc 3 260 1 view .LVU402
 1574 00a4 0AB0     		add	sp, sp, #40
 1575              	.LCFI25:
 1576              		.cfi_def_cfa_offset 8
 1577              		@ sp needed
 1578 00a6 10BD     		pop	{r4, pc}
 1579              	.L48:
 1580              		.align	2
 1581              	.L47:
 1582 00a8 00000000 		.word	.LANCHOR0
 1583              		.cfi_endproc
 1584              	.LFE5218:
 1585              		.fnend
 1587              		.section	.text._ZN9CANSimple15get_iq_callbackERK4Axis,"ax",%progbits
 1588              		.align	1
 1589              		.global	_ZN9CANSimple15get_iq_callbackERK4Axis
 1590              		.syntax unified
 1591              		.thumb
 1592              		.thumb_func
 1594              	_ZN9CANSimple15get_iq_callbackERK4Axis:
 1595              		.fnstart
 1596              	.LVL106:
 1597              	.LFB5233:
 332:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 1598              		.loc 3 332 51 is_stmt 1 view -0
 1599              		.cfi_startproc
 1600              		@ args = 0, pretend = 0, frame = 56
 1601              		@ frame_needed = 0, uses_anonymous_args = 0
 332:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 1602              		.loc 3 332 51 is_stmt 0 view .LVU404
 1603 0000 70B5     		push	{r4, r5, r6, lr}
 1604              		.save {r4, r5, r6, lr}
 1605              	.LCFI26:
 1606              		.cfi_def_cfa_offset 16
 1607              		.cfi_offset 4, -16
 1608              		.cfi_offset 5, -12
 1609              		.cfi_offset 6, -8
 1610              		.cfi_offset 14, -4
ARM GAS  /tmp/ccoErako.s 			page 87


 1611              		.pad #56
 1612 0002 8EB0     		sub	sp, sp, #56
 1613              	.LCFI27:
 1614              		.cfi_def_cfa_offset 72
 1615 0004 8646     		mov	lr, r0
 1616 0006 8C46     		mov	ip, r1
 333:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 1617              		.loc 3 333 5 is_stmt 1 view .LVU405
 333:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 1618              		.loc 3 333 19 is_stmt 0 view .LVU406
 1619 0008 2F4B     		ldr	r3, .L52
 1620 000a 08AC     		add	r4, sp, #32
 1621 000c 0FCB     		ldm	r3, {r0, r1, r2, r3}
 1622              	.LVL107:
 333:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 1623              		.loc 3 333 19 view .LVU407
 1624 000e 84E80F00 		stm	r4, {r0, r1, r2, r3}
 334:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_IQ;
 1625              		.loc 3 334 5 is_stmt 1 view .LVU408
 334:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_IQ;
 1626              		.loc 3 334 33 is_stmt 0 view .LVU409
 1627 0012 DCF87830 		ldr	r3, [ip, #120]
 334:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_IQ;
 1628              		.loc 3 334 41 view .LVU410
 1629 0016 5B01     		lsls	r3, r3, #5
 334:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_IQ;
 1630              		.loc 3 334 14 view .LVU411
 1631 0018 0893     		str	r3, [sp, #32]
 335:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 1632              		.loc 3 335 5 is_stmt 1 view .LVU412
 335:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 1633              		.loc 3 335 14 is_stmt 0 view .LVU413
 1634 001a 1433     		adds	r3, r3, #20
 1635 001c 0893     		str	r3, [sp, #32]
 336:communication/can/can_simple.cpp ****     txmsg.len = 8;
 1636              		.loc 3 336 5 is_stmt 1 view .LVU414
 336:communication/can/can_simple.cpp ****     txmsg.len = 8;
 1637              		.loc 3 336 36 is_stmt 0 view .LVU415
 1638 001e 9CF87C30 		ldrb	r3, [ip, #124]	@ zero_extendqisi2
 336:communication/can/can_simple.cpp ****     txmsg.len = 8;
 1639              		.loc 3 336 17 view .LVU416
 1640 0022 8DF82430 		strb	r3, [sp, #36]
 337:communication/can/can_simple.cpp **** 
 1641              		.loc 3 337 5 is_stmt 1 view .LVU417
 339:communication/can/can_simple.cpp ****     if (!Idq_setpoint.has_value()) {
 1642              		.loc 3 339 5 view .LVU418
 339:communication/can/can_simple.cpp ****     if (!Idq_setpoint.has_value()) {
 1643              		.loc 3 339 48 is_stmt 0 view .LVU419
 1644 0026 DCF85831 		ldr	r3, [ip, #344]
 339:communication/can/can_simple.cpp ****     if (!Idq_setpoint.has_value()) {
 1645              		.loc 3 339 28 view .LVU420
 1646 002a 05AC     		add	r4, sp, #20
 1647 002c 03F58A73 		add	r3, r3, #276
 1648 0030 93E80700 		ldm	r3, {r0, r1, r2}
 1649 0034 84E80700 		stm	r4, {r0, r1, r2}
 340:communication/can/can_simple.cpp ****         Idq_setpoint = {0.0f, 0.0f};
 1650              		.loc 3 340 5 is_stmt 1 view .LVU421
ARM GAS  /tmp/ccoErako.s 			page 88


 1651              	.LVL108:
 1652              	.LBB951:
 1653              	.LBI951:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 1654              		.loc 6 916 22 view .LVU422
 1655              	.LBB952:
 1656              	.LBI952:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 1657              		.loc 6 433 22 view .LVU423
 1658              	.LBB953:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1659              		.loc 6 434 58 is_stmt 0 view .LVU424
 1660 0038 9DF81C30 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 1661              	.LVL109:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1662              		.loc 6 434 58 view .LVU425
 1663              	.LBE953:
 1664              	.LBE952:
 1665              	.LBE951:
 340:communication/can/can_simple.cpp ****         Idq_setpoint = {0.0f, 0.0f};
 1666              		.loc 3 340 5 view .LVU426
 1667 003c 53B9     		cbnz	r3, .L50
 341:communication/can/can_simple.cpp ****     }
 1668              		.loc 3 341 9 is_stmt 1 view .LVU427
 1669              	.LVL110:
 1670              	.LBB954:
 1671              	.LBI954:
 1672              		.file 8 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // Pair implementation -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // Copyright (C) 2001-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** /*
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  *
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * Copyright (c) 1994
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * Hewlett-Packard Company
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  *
ARM GAS  /tmp/ccoErako.s 			page 89


  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * Permission to use, copy, modify, distribute and sell this software
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * and its documentation for any purpose is hereby granted without fee,
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * provided that the above copyright notice appear in all copies and
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * that both that copyright notice and this permission notice appear
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * in supporting documentation.  Hewlett-Packard Company makes no
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * representations about the suitability of this software for any
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  *
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  *
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * Copyright (c) 1996,1997
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * Silicon Graphics Computer Systems, Inc.
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  *
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * Permission to use, copy, modify, distribute and sell this software
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * and its documentation for any purpose is hereby granted without fee,
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * provided that the above copyright notice appear in all copies and
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * that both that copyright notice and this permission notice appear
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * in supporting documentation.  Silicon Graphics makes no
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * representations about the suitability of this software for any
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  */
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** /** @file bits/stl_pair.h
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  *  This is an internal header file, included by other library headers.
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  *  Do not attempt to use it directly. @headername{utility}
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  */
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #ifndef _STL_PAIR_H
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #define _STL_PAIR_H 1
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #include <bits/move.h> // for std::move / std::forward, and std::swap
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus >= 201103L
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** # include <type_traits> // for std::__decay_and_strip, std::is_reference_v
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus > 201703L
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** # include <compare>
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** # define __cpp_lib_constexpr_utility 201811L
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** namespace std _GLIBCXX_VISIBILITY(default)
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** {
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   /**
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *  @addtogroup utilities
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *  @{
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    */
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus >= 201103L
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   /// Tag type for piecewise construction of std::pair objects.
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   struct piecewise_construct_t { explicit piecewise_construct_t() = default; };
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   /// Tag for piecewise construction of std::pair objects.
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   _GLIBCXX17_INLINE constexpr piecewise_construct_t piecewise_construct =
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     piecewise_construct_t();
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   /// @cond undocumented
ARM GAS  /tmp/ccoErako.s 			page 90


  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   // Forward declarations.
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   template<typename...>
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     class tuple;
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   template<std::size_t...>
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     struct _Index_tuple;
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   // Concept utility functions, reused in conditionally-explicit
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   // constructors.
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   // See PR 70437, don't look at is_constructible or
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   // is_convertible if the types are the same to
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   // avoid querying those properties for incomplete types.
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   template <bool, typename _T1, typename _T2>
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     struct _PCC
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     {
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _ConstructiblePair()
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return __and_<is_constructible<_T1, const _U1&>,
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      is_constructible<_T2, const _U2&>>::value;
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _ImplicitlyConvertiblePair()
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return __and_<is_convertible<const _U1&, _T1>,
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      is_convertible<const _U2&, _T2>>::value;
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _MoveConstructiblePair()
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return __and_<is_constructible<_T1, _U1&&>,
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      is_constructible<_T2, _U2&&>>::value;
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _ImplicitlyMoveConvertiblePair()
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return __and_<is_convertible<_U1&&, _T1>,
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      is_convertible<_U2&&, _T2>>::value;
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <bool __implicit, typename _U1, typename _U2>
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _CopyMovePair()
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	using __do_converts = __and_<is_convertible<const _U1&, _T1>,
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 				  is_convertible<_U2&&, _T2>>;
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	using __converts = typename conditional<__implicit,
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 				       __do_converts,
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 				       __not_<__do_converts>>::type;
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return __and_<is_constructible<_T1, const _U1&>,
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      is_constructible<_T2, _U2&&>,
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      __converts
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      >::value;
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
ARM GAS  /tmp/ccoErako.s 			page 91


 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <bool __implicit, typename _U1, typename _U2>
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _MoveCopyPair()
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	using __do_converts = __and_<is_convertible<_U1&&, _T1>,
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 				  is_convertible<const _U2&, _T2>>;
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	using __converts = typename conditional<__implicit,
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 				       __do_converts,
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 				       __not_<__do_converts>>::type;
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return __and_<is_constructible<_T1, _U1&&>,
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      is_constructible<_T2, const _U2&&>,
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      __converts
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      >::value;
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   };
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   template <typename _T1, typename _T2>
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     struct _PCC<false, _T1, _T2>
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     {
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _ConstructiblePair()
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return false;
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _ImplicitlyConvertiblePair()
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return false;
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _MoveConstructiblePair()
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return false;
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _ImplicitlyMoveConvertiblePair()
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return false;
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   };
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif // C++11
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   template<typename _U1, typename _U2> class __pair_base
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   {
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus >= 201103L
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     template<typename _T1, typename _T2> friend struct pair;
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     __pair_base() = default;
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     ~__pair_base() = default;
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     __pair_base(const __pair_base&) = default;
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     __pair_base& operator=(const __pair_base&) = delete;
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif // C++11
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   };
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   /// @endcond
ARM GAS  /tmp/ccoErako.s 			page 92


 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  /**
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *  @brief Struct holding two objects of arbitrary type.
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *  @tparam _T1  Type of first object.
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *  @tparam _T2  Type of second object.
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *  <https://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    */
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   template<typename _T1, typename _T2>
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     struct pair
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     : private __pair_base<_T1, _T2>
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     {
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       typedef _T1 first_type;    ///< The type of the `first` member
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       typedef _T2 second_type;   ///< The type of the `second` member
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       _T1 first;                 ///< The first member
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       _T2 second;                ///< The second member
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       // _GLIBCXX_RESOLVE_LIB_DEFECTS
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       // 265.  std::pair::pair() effects overly restrictive
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /** The default constructor creates @c first and @c second using their
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        *  respective default constructors.  */
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus >= 201103L
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1 = _T1,
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                 typename _U2 = _T2,
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                 typename enable_if<__and_<
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                                      __is_implicitly_default_constructible<_U1>,
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                                      __is_implicitly_default_constructible<_U2>>
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                                    ::value, bool>::type = true>
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       _GLIBCXX_CONSTEXPR pair()
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       : first(), second() { }
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus >= 201103L
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1 = _T1,
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                 typename _U2 = _T2,
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                 typename enable_if<__and_<
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                        is_default_constructible<_U1>,
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                        is_default_constructible<_U2>,
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                        __not_<
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          __and_<__is_implicitly_default_constructible<_U1>,
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                                 __is_implicitly_default_constructible<_U2>>>>
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                                    ::value, bool>::type = false>
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       explicit constexpr pair()
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       : first(), second() { }
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus < 201103L
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// Two objects may be passed to a @c pair constructor to be copied.
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       pair(const _T1& __a, const _T2& __b)
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       : first(__a), second(__b) { }
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #else
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       // Shortcut for constraining the templates that don't take pairs.
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// @cond undocumented
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       using _PCCP = _PCC<true, _T1, _T2>;
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// @endcond
ARM GAS  /tmp/ccoErako.s 			page 93


 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// Construct from two const lvalues, allowing implicit conversions.
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1 = _T1, typename _U2=_T2, typename
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCP::template
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ConstructiblePair<_U1, _U2>()
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	                 && _PCCP::template
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ImplicitlyConvertiblePair<_U1, _U2>(),
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=true>
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       constexpr pair(const _T1& __a, const _T2& __b)
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       : first(__a), second(__b) { }
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// Construct from two const lvalues, disallowing implicit conversions.
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        template<typename _U1 = _T1, typename _U2=_T2, typename
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		enable_if<_PCCP::template
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			    _ConstructiblePair<_U1, _U2>()
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	                  && !_PCCP::template
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			    _ImplicitlyConvertiblePair<_U1, _U2>(),
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=false>
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       explicit constexpr pair(const _T1& __a, const _T2& __b)
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       : first(__a), second(__b) { }
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus < 201103L
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// There is also a templated constructor to convert from other pairs.
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename _U2>
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	pair(const pair<_U1, _U2>& __p)
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	: first(__p.first), second(__p.second) { }
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #else
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       // Shortcut for constraining the templates that take pairs.
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// @cond undocumented
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****         using _PCCFP = _PCC<!is_same<_T1, _U1>::value
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			    || !is_same<_T2, _U2>::value,
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			    _T1, _T2>;
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// @endcond
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename _U2, typename
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCFP<_U1, _U2>::template
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ConstructiblePair<_U1, _U2>()
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	                 && _PCCFP<_U1, _U2>::template
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ImplicitlyConvertiblePair<_U1, _U2>(),
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			  bool>::type=true>
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****         constexpr pair(const pair<_U1, _U2>& __p)
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****         : first(__p.first), second(__p.second) { }
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename _U2, typename
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCFP<_U1, _U2>::template
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ConstructiblePair<_U1, _U2>()
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			 && !_PCCFP<_U1, _U2>::template
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ImplicitlyConvertiblePair<_U1, _U2>(),
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=false>
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	explicit constexpr pair(const pair<_U1, _U2>& __p)
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	: first(__p.first), second(__p.second) { }
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus >= 201103L
 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       constexpr pair(const pair&) = default;	///< Copy constructor
ARM GAS  /tmp/ccoErako.s 			page 94


 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       constexpr pair(pair&&) = default;		///< Move constructor
 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       // DR 811.
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCP::template
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _MoveCopyPair<true, _U1, _T2>(),
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=true>
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        constexpr pair(_U1&& __x, const _T2& __y)
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        : first(std::forward<_U1>(__x)), second(__y) { }
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCP::template
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _MoveCopyPair<false, _U1, _T2>(),
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=false>
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        explicit constexpr pair(_U1&& __x, const _T2& __y)
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        : first(std::forward<_U1>(__x)), second(__y) { }
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U2, typename
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCP::template
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _CopyMovePair<true, _T1, _U2>(),
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=true>
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        constexpr pair(const _T1& __x, _U2&& __y)
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        : first(__x), second(std::forward<_U2>(__y)) { }
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U2, typename
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCP::template
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _CopyMovePair<false, _T1, _U2>(),
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=false>
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        explicit pair(const _T1& __x, _U2&& __y)
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        : first(__x), second(std::forward<_U2>(__y)) { }
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename _U2, typename
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCP::template
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _MoveConstructiblePair<_U1, _U2>()
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			  && _PCCP::template
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=true>
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	constexpr pair(_U1&& __x, _U2&& __y)
 1673              		.loc 8 352 12 view .LVU428
 1674              	.LBB955:
 1675              	.LBB956:
 1676              	.LBB957:
 1677              	.LBI957:
 1678              		.loc 7 76 5 view .LVU429
 1679              		.loc 7 76 5 is_stmt 0 view .LVU430
 1680              	.LBE957:
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
 1681              		.loc 8 353 64 view .LVU431
 1682 003e 0023     		movs	r3, #0
 1683 0040 0C93     		str	r3, [sp, #48]	@ float
 1684              	.LVL111:
 1685              	.LBB958:
 1686              	.LBI958:
 1687              		.loc 7 76 5 is_stmt 1 view .LVU432
 1688              		.loc 7 76 5 is_stmt 0 view .LVU433
 1689              	.LBE958:
 1690              		.loc 8 353 64 view .LVU434
ARM GAS  /tmp/ccoErako.s 			page 95


 1691 0042 0D93     		str	r3, [sp, #52]	@ float
 1692              	.LVL112:
 1693              		.loc 8 353 64 view .LVU435
 1694              	.LBE956:
 1695              	.LBE955:
 1696              	.LBE954:
 1697              	.LBB959:
 1698              	.LBI959:
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 1699              		.loc 6 788 2 is_stmt 1 view .LVU436
 1700              	.LBB960:
 1701              	.LBI960:
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 1702              		.loc 6 415 2 view .LVU437
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 1703              		.loc 6 415 2 is_stmt 0 view .LVU438
 1704              	.LBE960:
 1705              	.LBE959:
 1706              		.file 9 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // The -*- C++ -*- dynamic memory management header.
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // Copyright (C) 1994-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // This file is part of GCC.
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** //
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // GCC is free software; you can redistribute it and/or modify
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // it under the terms of the GNU General Public License as published by
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // the Free Software Foundation; either version 3, or (at your option)
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // any later version.
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // 
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // GCC is distributed in the hope that it will be useful,
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // GNU General Public License for more details.
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // 
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // Under Section 7 of GPL version 3, you are granted additional
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // permissions described in the GCC Runtime Library Exception, version
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // 3.1, as published by the Free Software Foundation.
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // You should have received a copy of the GNU General Public License and
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // a copy of the GCC Runtime Library Exception along with this program;
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // <http://www.gnu.org/licenses/>.
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** /** @file new
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  This is a Standard C++ Library header.
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  The header @c new defines several functions to manage dynamic memory and
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  handling memory allocation errors; see
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/dynamic_memory.html
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  for more.
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  */
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #ifndef _NEW
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #define _NEW
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #pragma GCC system_header
ARM GAS  /tmp/ccoErako.s 			page 96


  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #include <bits/c++config.h>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #include <exception>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #pragma GCC visibility push(default)
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** extern "C++" {
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** namespace std 
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** {
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /**
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  @brief  Exception possibly thrown by @c new.
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  @ingroup exceptions
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  @c bad_alloc (or classes derived from it) is used to report allocation
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  errors from the throwing forms of @c new.  */
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   class bad_alloc : public exception 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   {
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   public:
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_alloc() throw() { }
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_alloc(const bad_alloc&) = default;
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_alloc& operator=(const bad_alloc&) = default;
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // This declaration is not useless:
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual ~bad_alloc() throw();
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // See comment in eh_exception.cc.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual const char* what() const throw();
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   };
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   class bad_array_new_length : public bad_alloc
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   {
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   public:
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_array_new_length() throw() { }
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // This declaration is not useless:
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual ~bad_array_new_length() throw();
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // See comment in eh_exception.cc.
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual const char* what() const throw();
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   };
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_aligned_new
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   enum class align_val_t: size_t {};
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   struct nothrow_t
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   {
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     explicit nothrow_t() = default;
ARM GAS  /tmp/ccoErako.s 			page 97


  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   };
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   extern const nothrow_t nothrow;
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /** If you write your own error handler to be called by @c new, it must
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  be of this type.  */
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   typedef void (*new_handler)();
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /// Takes a replacement handler as the argument, returns the
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /// previous handler.
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   new_handler set_new_handler(new_handler) throw();
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /// Return the current new handler.
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   new_handler get_new_handler() noexcept;
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** } // namespace std
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** //@{
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** /** These are replaceable signatures:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - normal array new and delete (same)
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - @c nothrow single new and delete (take a @c nothrow argument, return
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *    @c NULL on error)
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - @c nothrow array new and delete (same)
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  Placement new and delete signatures (take a memory address argument,
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  does nothing) may not be replaced by a user's program.
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** */
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t) _GLIBCXX_THROW (std::bad_alloc)
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*) _GLIBCXX_USE_NOEXCEPT
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*) _GLIBCXX_USE_NOEXCEPT
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_sized_deallocation
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__, __malloc__));
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__, __malloc__));
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_aligned_new
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t)
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __malloc__));
ARM GAS  /tmp/ccoErako.s 			page 98


 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::align_val_t)
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::align_val_t, const std::nothrow_t&)
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t)
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __malloc__));
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::align_val_t)
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_sized_deallocation
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::size_t, std::align_val_t)
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::size_t, std::align_val_t)
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif // __cpp_sized_deallocation
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif // __cpp_aligned_new
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // Default placement versions of operator new.
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** { return __p; }
 1707              		.loc 9 175 3 is_stmt 1 view .LVU439
 1708              	.LBB963:
 1709              	.LBB962:
 1710              	.LBB961:
 1711              		.loc 9 175 3 is_stmt 0 view .LVU440
 1712 0044 0EAA     		add	r2, sp, #56
 1713 0046 12E90300 		ldmdb	r2, {r0, r1}
 1714 004a C4E90001 		strd	r0, r1, [r4]
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 1715              		.loc 6 421 51 view .LVU441
 1716 004e 0123     		movs	r3, #1
 1717 0050 8DF81C30 		strb	r3, [sp, #28]
 1718              	.LVL113:
 1719              	.L50:
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 1720              		.loc 6 421 51 view .LVU442
 1721              	.LBE961:
 1722              	.LBE962:
 1723              	.LBE963:
 344:communication/can/can_simple.cpp ****     static_assert(sizeof(float) == sizeof(axis.motor_.current_control_.Iq_measured_));
 1724              		.loc 3 344 5 is_stmt 1 view .LVU443
 345:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, Idq_setpoint->second, 0, 32, true);
 1725              		.loc 3 345 5 view .LVU444
 346:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, axis.motor_.current_control_.Iq_measured_, 32, 32, true);
 1726              		.loc 3 346 5 view .LVU445
 1727              	.LBB964:
 1728              	.LBI964:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 1729              		.loc 4 50 16 view .LVU446
 1730              	.LBB965:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 1731              		.loc 4 51 14 is_stmt 0 view .LVU447
 1732 0054 0022     		movs	r2, #0
 1733 0056 0023     		movs	r3, #0
ARM GAS  /tmp/ccoErako.s 			page 99


 1734 0058 CDE90023 		strd	r2, [sp]
  52:communication/can/can_helpers.hpp **** 
 1735              		.loc 4 52 16 view .LVU448
 1736 005c 069E     		ldr	r6, [sp, #24]
 1737 005e 0096     		str	r6, [sp]
 1738              	.LVL114:
 1739              	.LBB966:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 1740              		.loc 4 57 18 view .LVU449
 1741 0060 CDE90223 		strd	r2, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 1742              		.loc 4 58 20 view .LVU450
 1743 0064 02AC     		add	r4, sp, #8
 1744 0066 DDF82700 		ldr	r0, [sp, #39]	@ unaligned
 1745 006a DDF82B10 		ldr	r1, [sp, #43]	@ unaligned
 1746 006e 03C4     		stmia	r4!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 1747              		.loc 4 60 14 view .LVU451
 1748 0070 0025     		movs	r5, #0
 1749 0072 0295     		str	r5, [sp, #8]
  61:communication/can/can_helpers.hpp **** 
 1750              		.loc 4 61 27 view .LVU452
 1751 0074 0198     		ldr	r0, [sp, #4]
  61:communication/can/can_helpers.hpp **** 
 1752              		.loc 4 61 14 view .LVU453
 1753 0076 0143     		orrs	r1, r1, r0
 1754 0078 0296     		str	r6, [sp, #8]
 1755 007a 0391     		str	r1, [sp, #12]
 1756              		.loc 4 63 20 view .LVU454
 1757 007c 02AC     		add	r4, sp, #8
 1758 007e 03CC     		ldmia	r4!, {r0, r1}
 1759 0080 CDF82700 		str	r0, [sp, #39]	@ unaligned
 1760 0084 CDF82B10 		str	r1, [sp, #43]	@ unaligned
 1761              	.LVL115:
 1762              		.loc 4 63 20 view .LVU455
 1763              	.LBE966:
 1764              	.LBE965:
 1765              	.LBE964:
 347:communication/can/can_simple.cpp **** 
 1766              		.loc 3 347 5 is_stmt 1 view .LVU456
 347:communication/can/can_simple.cpp **** 
 1767              		.loc 3 347 38 is_stmt 0 view .LVU457
 1768 0088 DCF85811 		ldr	r1, [ip, #344]
 1769              	.LVL116:
 1770              	.LBB967:
 1771              	.LBI967:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 1772              		.loc 4 50 16 is_stmt 1 view .LVU458
 1773              	.LBB968:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 1774              		.loc 4 51 14 is_stmt 0 view .LVU459
 1775 008c CDE90023 		strd	r2, [sp]
 1776 0090 D1F85841 		ldr	r4, [r1, #344]	@ unaligned
  52:communication/can/can_helpers.hpp **** 
 1777              		.loc 4 52 16 view .LVU460
 1778 0094 0094     		str	r4, [sp]
 1779              	.LVL117:
ARM GAS  /tmp/ccoErako.s 			page 100


 1780              	.LBB969:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 1781              		.loc 4 57 18 view .LVU461
 1782 0096 CDE90223 		strd	r2, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 1783              		.loc 4 58 20 view .LVU462
 1784 009a 02AB     		add	r3, sp, #8
 1785 009c DDF82700 		ldr	r0, [sp, #39]	@ unaligned
 1786 00a0 DDF82B10 		ldr	r1, [sp, #43]	@ unaligned
 1787              	.LVL118:
  58:communication/can/can_helpers.hpp **** 
 1788              		.loc 4 58 20 view .LVU463
 1789 00a4 03C3     		stmia	r3!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 1790              		.loc 4 60 14 view .LVU464
 1791 00a6 0395     		str	r5, [sp, #12]
  61:communication/can/can_helpers.hpp **** 
 1792              		.loc 4 61 14 view .LVU465
 1793 00a8 0394     		str	r4, [sp, #12]
 1794              		.loc 4 63 20 view .LVU466
 1795 00aa 02AB     		add	r3, sp, #8
 1796 00ac 03CB     		ldmia	r3!, {r0, r1}
 1797 00ae CDF82700 		str	r0, [sp, #39]	@ unaligned
 1798 00b2 CDF82B10 		str	r1, [sp, #43]	@ unaligned
 1799              	.LVL119:
 1800              		.loc 4 63 20 view .LVU467
 1801              	.LBE969:
 1802              	.LBE968:
 1803              	.LBE967:
 349:communication/can/can_simple.cpp **** }
 1804              		.loc 3 349 5 is_stmt 1 view .LVU468
 349:communication/can/can_simple.cpp **** }
 1805              		.loc 3 349 12 is_stmt 0 view .LVU469
 1806 00b6 DEF80000 		ldr	r0, [lr]
 349:communication/can/can_simple.cpp **** }
 1807              		.loc 3 349 39 view .LVU470
 1808 00ba 0368     		ldr	r3, [r0]
 1809 00bc 1B68     		ldr	r3, [r3]
 349:communication/can/can_simple.cpp **** }
 1810              		.loc 3 349 33 view .LVU471
 1811 00be 08A9     		add	r1, sp, #32
 1812 00c0 9847     		blx	r3
 1813              	.LVL120:
 350:communication/can/can_simple.cpp **** 
 1814              		.loc 3 350 1 view .LVU472
 1815 00c2 0EB0     		add	sp, sp, #56
 1816              	.LCFI28:
 1817              		.cfi_def_cfa_offset 16
 1818              		@ sp needed
 1819 00c4 70BD     		pop	{r4, r5, r6, pc}
 1820              	.L53:
 1821 00c6 00BF     		.align	2
 1822              	.L52:
 1823 00c8 00000000 		.word	.LANCHOR0
 1824              		.cfi_endproc
 1825              	.LFE5233:
 1826              		.fnend
ARM GAS  /tmp/ccoErako.s 			page 101


 1828              		.section	.text._ZSt26__throw_bad_variant_accessPKc,"axG",%progbits,_ZSt26__throw_bad_variant_acces
 1829              		.align	1
 1830              		.weak	_ZSt26__throw_bad_variant_accessPKc
 1831              		.syntax unified
 1832              		.thumb
 1833              		.thumb_func
 1835              	_ZSt26__throw_bad_variant_accessPKc:
 1836              		.fnstart
 1837              	.LVL121:
 1838              	.LFB3284:
1271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   private:
1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     bad_variant_access(const char* __reason) noexcept : _M_reason(__reason) { }
1274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     // Must point to a string with static storage duration:
1276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     const char* _M_reason = "bad variant access";
1277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     friend void __throw_bad_variant_access(const char* __what);
1279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   };
1280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Must only be called with a string literal
1282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   inline void
1283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   __throw_bad_variant_access(const char* __what)
1284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   { _GLIBCXX_THROW_OR_ABORT(bad_variant_access(__what)); }
 1839              		.loc 1 1284 3 is_stmt 1 view -0
 1840              		.cfi_startproc
 1841              		@ args = 0, pretend = 0, frame = 0
 1842              		@ frame_needed = 0, uses_anonymous_args = 0
 1843              		.loc 1 1284 3 is_stmt 0 view .LVU474
 1844 0000 10B5     		push	{r4, lr}
 1845              		.save {r4, lr}
 1846              	.LCFI29:
 1847              		.cfi_def_cfa_offset 8
 1848              		.cfi_offset 4, -8
 1849              		.cfi_offset 14, -4
 1850 0002 0446     		mov	r4, r0
 1851              		.loc 1 1284 5 is_stmt 1 view .LVU475
 1852 0004 0820     		movs	r0, #8
 1853              	.LVL122:
 1854              		.loc 1 1284 5 is_stmt 0 view .LVU476
 1855 0006 FFF7FEFF 		bl	__cxa_allocate_exception
 1856              	.LVL123:
 1857              	.LBB970:
 1858              	.LBI970:
1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 1859              		.loc 1 1273 5 is_stmt 1 view .LVU477
 1860              	.LBB971:
 1861              	.LBB972:
 1862              	.LBI972:
 1863              		.file 10 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // Exception Handling support header for -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // Copyright (C) 2016-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // This file is part of GCC.
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** //
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // GCC is free software; you can redistribute it and/or modify
ARM GAS  /tmp/ccoErako.s 			page 102


   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // it under the terms of the GNU General Public License as published by
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // the Free Software Foundation; either version 3, or (at your option)
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // any later version.
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** //
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // GCC is distributed in the hope that it will be useful,
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // GNU General Public License for more details.
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** //
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // Under Section 7 of GPL version 3, you are granted additional
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // permissions described in the GCC Runtime Library Exception, version
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // 3.1, as published by the Free Software Foundation.
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // You should have received a copy of the GNU General Public License and
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // a copy of the GCC Runtime Library Exception along with this program;
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // <http://www.gnu.org/licenses/>.
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** /** @file bits/exception.h
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****  *  This is an internal header file, included by other library headers.
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****  *  Do not attempt to use it directly.
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****  */
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #ifndef __EXCEPTION_H
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #define __EXCEPTION_H 1
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #pragma GCC system_header
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #pragma GCC visibility push(default)
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #include <bits/c++config.h>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** extern "C++" {
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** namespace std
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** {
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   /**
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    * @defgroup exceptions Exceptions
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    * @ingroup diagnostics
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    * Classes and functions for reporting errors via exceptions.
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    * @{
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    */
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   /**
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  @brief Base class for all library exceptions.
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  This is the base class for all exceptions thrown by the standard
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  library, and by certain language expressions.  You are free to derive
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  your own %exception classes, or use a different hierarchy, or to
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  throw non-class data (e.g., fundamental types).
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    */
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   class exception
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   {
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   public:
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****     exception() _GLIBCXX_NOTHROW { }
 1864              		.loc 10 63 5 view .LVU478
ARM GAS  /tmp/ccoErako.s 			page 103


 1865              	.LBB973:
 1866              		.loc 10 63 34 is_stmt 0 view .LVU479
 1867 000a 044A     		ldr	r2, .L56
 1868 000c 0260     		str	r2, [r0]
 1869              	.LVL124:
 1870              		.loc 10 63 34 view .LVU480
 1871              	.LBE973:
 1872              	.LBE972:
1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 1873              		.loc 1 1273 75 view .LVU481
 1874 000e 044A     		ldr	r2, .L56+4
 1875 0010 0260     		str	r2, [r0]
 1876 0012 4460     		str	r4, [r0, #4]
 1877              	.LVL125:
1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 1878              		.loc 1 1273 75 view .LVU482
 1879              	.LBE971:
 1880              	.LBE970:
 1881              		.loc 1 1284 5 view .LVU483
 1882 0014 034A     		ldr	r2, .L56+8
 1883 0016 0449     		ldr	r1, .L56+12
 1884 0018 FFF7FEFF 		bl	__cxa_throw
 1885              	.LVL126:
 1886              	.L57:
 1887              		.align	2
 1888              	.L56:
 1889 001c 08000000 		.word	_ZTVSt9exception+8
 1890 0020 08000000 		.word	_ZTVSt18bad_variant_access+8
 1891 0024 00000000 		.word	_ZNSt18bad_variant_accessD1Ev
 1892 0028 00000000 		.word	_ZTISt18bad_variant_access
 1893              		.cfi_endproc
 1894              	.LFE3284:
 1895              		.fnend
 1897              		.section	.rodata._ZN9CANSimple30get_encoder_estimates_callbackERK4Axis.str1.4,"aMS",%progbits,1
 1898              		.align	2
 1899              	.LC1:
 1900 0000 7374643A 		.ascii	"std::get: wrong index for variant\000"
 1900      3A676574 
 1900      3A207772 
 1900      6F6E6720 
 1900      696E6465 
 1901              		.section	.text._ZN9CANSimple30get_encoder_estimates_callbackERK4Axis,"ax",%progbits
 1902              		.align	1
 1903              		.global	_ZN9CANSimple30get_encoder_estimates_callbackERK4Axis
 1904              		.syntax unified
 1905              		.thumb
 1906              		.thumb_func
 1908              	_ZN9CANSimple30get_encoder_estimates_callbackERK4Axis:
 1909              		.fnstart
 1910              	.LVL127:
 1911              	.LFB5217:
 234:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 1912              		.loc 3 234 66 is_stmt 1 view -0
 1913              		.cfi_startproc
 1914              		@ args = 0, pretend = 0, frame = 48
 1915              		@ frame_needed = 0, uses_anonymous_args = 0
 234:communication/can/can_simple.cpp ****     can_Message_t txmsg;
ARM GAS  /tmp/ccoErako.s 			page 104


 1916              		.loc 3 234 66 is_stmt 0 view .LVU485
 1917 0000 10B5     		push	{r4, lr}
 1918              		.save {r4, lr}
 1919              	.LCFI30:
 1920              		.cfi_def_cfa_offset 8
 1921              		.cfi_offset 4, -8
 1922              		.cfi_offset 14, -4
 1923              		.pad #48
 1924 0002 8CB0     		sub	sp, sp, #48
 1925              	.LCFI31:
 1926              		.cfi_def_cfa_offset 56
 1927 0004 8646     		mov	lr, r0
 1928 0006 8C46     		mov	ip, r1
 235:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 1929              		.loc 3 235 5 is_stmt 1 view .LVU486
 235:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 1930              		.loc 3 235 19 is_stmt 0 view .LVU487
 1931 0008 614B     		ldr	r3, .L90
 1932 000a 04AC     		add	r4, sp, #16
 1933 000c 0FCB     		ldm	r3, {r0, r1, r2, r3}
 1934              	.LVL128:
 235:communication/can/can_simple.cpp ****     txmsg.id = axis.config_.can.node_id << NUM_CMD_ID_BITS;
 1935              		.loc 3 235 19 view .LVU488
 1936 000e 84E80F00 		stm	r4, {r0, r1, r2, r3}
 236:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_ENCODER_ESTIMATES;  // heartbeat ID
 1937              		.loc 3 236 5 is_stmt 1 view .LVU489
 236:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_ENCODER_ESTIMATES;  // heartbeat ID
 1938              		.loc 3 236 33 is_stmt 0 view .LVU490
 1939 0012 DCF87830 		ldr	r3, [ip, #120]
 236:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_ENCODER_ESTIMATES;  // heartbeat ID
 1940              		.loc 3 236 41 view .LVU491
 1941 0016 5B01     		lsls	r3, r3, #5
 236:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_ENCODER_ESTIMATES;  // heartbeat ID
 1942              		.loc 3 236 14 view .LVU492
 1943 0018 0493     		str	r3, [sp, #16]
 237:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 1944              		.loc 3 237 5 is_stmt 1 view .LVU493
 237:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 1945              		.loc 3 237 14 is_stmt 0 view .LVU494
 1946 001a 0933     		adds	r3, r3, #9
 1947 001c 0493     		str	r3, [sp, #16]
 238:communication/can/can_simple.cpp ****     txmsg.len = 8;
 1948              		.loc 3 238 5 is_stmt 1 view .LVU495
 238:communication/can/can_simple.cpp ****     txmsg.len = 8;
 1949              		.loc 3 238 36 is_stmt 0 view .LVU496
 1950 001e 9CF87C30 		ldrb	r3, [ip, #124]	@ zero_extendqisi2
 238:communication/can/can_simple.cpp ****     txmsg.len = 8;
 1951              		.loc 3 238 17 view .LVU497
 1952 0022 8DF81430 		strb	r3, [sp, #20]
 239:communication/can/can_simple.cpp **** 
 1953              		.loc 3 239 5 is_stmt 1 view .LVU498
 241:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, axis.controller_.vel_estimate_src_.any().value_or(0.0f), 32, 32, tr
 1954              		.loc 3 241 5 view .LVU499
 241:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, axis.controller_.vel_estimate_src_.any().value_or(0.0f), 32, 32, tr
 1955              		.loc 3 241 38 is_stmt 0 view .LVU500
 1956 0026 DCF80001 		ldr	r0, [ip, #256]
 241:communication/can/can_simple.cpp ****     can_setSignal<float>(txmsg, axis.controller_.vel_estimate_src_.any().value_or(0.0f), 32, 32, tr
ARM GAS  /tmp/ccoErako.s 			page 105


 1957              		.loc 3 241 79 view .LVU501
 1958 002a 43F6E401 		movw	r1, #14564
 1959 002e 4318     		adds	r3, r0, r1
 1960              	.LVL129:
 1961              	.LBB1252:
 1962              	.LBI1252:
 103:./MotorControl/component.hpp ****         return content_;
 104:./MotorControl/component.hpp ****     }
 105:./MotorControl/component.hpp ****     
 106:./MotorControl/component.hpp **** private:
 107:./MotorControl/component.hpp ****     uint32_t age_ = 2; // Age in number of control loop iterations
 108:./MotorControl/component.hpp ****     T content_;
 109:./MotorControl/component.hpp **** };
 110:./MotorControl/component.hpp **** 
 111:./MotorControl/component.hpp **** /**
 112:./MotorControl/component.hpp ****  * @brief An input port provides a value from the source to which it's configured.
 113:./MotorControl/component.hpp ****  * 
 114:./MotorControl/component.hpp ****  * The source can be one of:
 115:./MotorControl/component.hpp ****  *  - an internally stored value
 116:./MotorControl/component.hpp ****  *  - an externally stored value (referenced by a pointer)
 117:./MotorControl/component.hpp ****  *  - an external OutputPort (referenced by a pointer)
 118:./MotorControl/component.hpp ****  *  - none (all queries will return std::nullopt)
 119:./MotorControl/component.hpp ****  * 
 120:./MotorControl/component.hpp ****  * Member functions of this class are not thread-safe unless otherwise noted.
 121:./MotorControl/component.hpp ****  */
 122:./MotorControl/component.hpp **** template<typename T>
 123:./MotorControl/component.hpp **** class InputPort {
 124:./MotorControl/component.hpp **** public:
 125:./MotorControl/component.hpp ****     void connect_to(OutputPort<T>* input_port) {
 126:./MotorControl/component.hpp ****         content_ = input_port;
 127:./MotorControl/component.hpp ****     }
 128:./MotorControl/component.hpp **** 
 129:./MotorControl/component.hpp ****     void connect_to(T* input_ptr) {
 130:./MotorControl/component.hpp ****         content_ = input_ptr;
 131:./MotorControl/component.hpp ****     }
 132:./MotorControl/component.hpp **** 
 133:./MotorControl/component.hpp ****     void disconnect() {
 134:./MotorControl/component.hpp ****         content_ = (OutputPort<T>*)nullptr;
 135:./MotorControl/component.hpp ****     }
 136:./MotorControl/component.hpp **** 
 137:./MotorControl/component.hpp ****     std::optional<T> present() {
 138:./MotorControl/component.hpp ****         if (content_.index() == 2) {
 139:./MotorControl/component.hpp ****             OutputPort<T>* ptr = std::get<2>(content_);
 140:./MotorControl/component.hpp ****             return ptr ? ptr->present() : std::nullopt;
 141:./MotorControl/component.hpp ****         } else if (content_.index() == 1) {
 142:./MotorControl/component.hpp ****             T* ptr = std::get<1>(content_);
 143:./MotorControl/component.hpp ****             return ptr ? std::make_optional(*ptr) : std::nullopt;
 144:./MotorControl/component.hpp ****         } else {
 145:./MotorControl/component.hpp ****             return std::get<0>(content_);
 146:./MotorControl/component.hpp ****         }
 147:./MotorControl/component.hpp ****     }
 148:./MotorControl/component.hpp **** 
 149:./MotorControl/component.hpp ****     // TODO: probably it makes sense to let the application define that it's
 150:./MotorControl/component.hpp ****     // ok for this input port to fetch the value from the last iteration.
 151:./MotorControl/component.hpp ****     // This would provide a general way to resolve same-iteration data path cycles.
 152:./MotorControl/component.hpp **** 
 153:./MotorControl/component.hpp ****     //std::optional<T> previous() {
ARM GAS  /tmp/ccoErako.s 			page 106


 154:./MotorControl/component.hpp ****     //    if (content_.index() == 2) {
 155:./MotorControl/component.hpp ****     //        OutputPort<T>* ptr = std::get<2>(content_);
 156:./MotorControl/component.hpp ****     //        return ptr ? ptr->previous() : std::nullopt;
 157:./MotorControl/component.hpp ****     //    } else if (content_.index() == 1) {
 158:./MotorControl/component.hpp ****     //        T* ptr = std::get<1>(content_);
 159:./MotorControl/component.hpp ****     //        return ptr ? std::make_optional(*ptr) : std::nullopt;
 160:./MotorControl/component.hpp ****     //    } else {
 161:./MotorControl/component.hpp ****     //        return std::get<0>(content_);
 162:./MotorControl/component.hpp ****     //    }
 163:./MotorControl/component.hpp ****     //}
 164:./MotorControl/component.hpp **** 
 165:./MotorControl/component.hpp ****     std::optional<T> any() {
 1963              		.loc 5 165 22 is_stmt 1 view .LVU502
 1964              	.LBB1253:
 1965              	.LBB1254:
 1966              	.LBI1254:
1285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   inline void
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   __throw_bad_variant_access(bool __valueless)
1288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     if (__valueless) [[__unlikely__]]
1290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
1291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     else
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: wrong index for variant");
1293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
1294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     class variant
1297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : private __detail::__variant::_Variant_base<_Types...>,
1298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       private _Enable_default_constructor<
1299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_default_ctor,
1300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  variant<_Types...>>,
1301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       private _Enable_copy_move<
1302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_copy_ctor,
1303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_copy_assign,
1304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_move_ctor,
1305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_move_assign,
1306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant<_Types...>>
1307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     private:
1309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _UTypes, typename _Tp>
1310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend decltype(auto) __variant_cast(_Tp&&);
1311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename _Variant, typename... _Args>
1312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend void __variant_construct_by_index(_Variant& __v,
1313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						 _Args&&... __args);
1314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(sizeof...(_Types) > 0,
1316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "variant must have at least one alternative");
1317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!(std::is_reference_v<_Types> || ...),
1318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "variant must have no reference alternative");
1319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!(std::is_void_v<_Types> || ...),
1320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "variant must have no void alternative");
1321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = __detail::__variant::_Variant_base<_Types...>;
1323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Default_ctor_enabler =
1324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Enable_default_constructor<
1325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __detail::__variant::_Traits<_Types...>::_S_default_ctor,
ARM GAS  /tmp/ccoErako.s 			page 107


1326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    variant<_Types...>>;
1327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr bool __not_self
1330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  = !is_same_v<__remove_cvref_t<_Tp>, variant>;
1331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr bool
1334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__exactly_once = __detail::__variant::__exactly_once<_Tp, _Types...>;
1335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr size_t __accepted_index
1338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  = __detail::__variant::__accepted_index<_Tp, variant>::value;
1339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename = enable_if_t<(_Np < sizeof...(_Types))>>
1341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	using __to_type = variant_alternative_t<_Np, variant>;
1342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename = enable_if_t<__not_self<_Tp>>>
1344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	using __accepted_type = __to_type<__accepted_index<_Tp>>;
1345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr size_t __index_of =
1348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __detail::__variant::__index_of_v<_Tp, _Types...>;
1349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Traits = __detail::__variant::_Traits<_Types...>;
1351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __is_in_place_tag : false_type { };
1354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __is_in_place_tag<in_place_type_t<_Tp>> : true_type { };
1356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np>
1357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __is_in_place_tag<in_place_index_t<_Np>> : true_type { };
1358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr bool __not_in_place_tag
1361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  = !__is_in_place_tag<__remove_cvref_t<_Tp>>::value;
1362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     public:
1364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant() = default;
1365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant(const variant& __rhs) = default;
1366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant(variant&&) = default;
1367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant& operator=(const variant&) = default;
1368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant& operator=(variant&&) = default;
1369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       ~variant() = default;
1370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp,
1372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<sizeof...(_Types) != 0>,
1373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<__not_in_place_tag<_Tp>>,
1374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename _Tj = __accepted_type<_Tp&&>,
1375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<__exactly_once<_Tj>
1376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				      && is_constructible_v<_Tj, _Tp>>>
1377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
1378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(_Tp&& __t)
1379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	noexcept(is_nothrow_constructible_v<_Tj, _Tp>)
1380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: variant(in_place_index<__accepted_index<_Tp>>,
1381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Tp>(__t))
1382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
ARM GAS  /tmp/ccoErako.s 			page 108


1383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename... _Args,
1385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<__exactly_once<_Tp>
1386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				      && is_constructible_v<_Tp, _Args...>>>
1387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
1388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(in_place_type_t<_Tp>, _Args&&... __args)
1389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: variant(in_place_index<__index_of<_Tp>>,
1390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...)
1391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
1392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename _Up, typename... _Args,
1394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<__exactly_once<_Tp>
1395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				      && is_constructible_v<_Tp,
1396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					   initializer_list<_Up>&, _Args...>>>
1397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
1398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(in_place_type_t<_Tp>, initializer_list<_Up> __il,
1399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		_Args&&... __args)
1400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: variant(in_place_index<__index_of<_Tp>>, __il,
1401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...)
1402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
1403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args,
1405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename _Tp = __to_type<_Np>,
1406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<is_constructible_v<_Tp, _Args...>>>
1407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
1408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(in_place_index_t<_Np>, _Args&&... __args)
1409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _Base(in_place_index<_Np>, std::forward<_Args>(__args)...),
1410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Default_ctor_enabler(_Enable_default_constructor_tag{})
1411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
1412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename _Up, typename... _Args,
1414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename _Tp = __to_type<_Np>,
1415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<is_constructible_v<_Tp,
1416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 							 initializer_list<_Up>&,
1417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 							 _Args...>>>
1418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
1419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(in_place_index_t<_Np>, initializer_list<_Up> __il,
1420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		_Args&&... __args)
1421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _Base(in_place_index<_Np>, __il, std::forward<_Args>(__args)...),
1422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Default_ctor_enabler(_Enable_default_constructor_tag{})
1423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
1424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<__exactly_once<__accepted_type<_Tp&&>>
1427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    && is_constructible_v<__accepted_type<_Tp&&>, _Tp>
1428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    && is_assignable_v<__accepted_type<_Tp&&>&, _Tp>,
1429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    variant&>
1430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	operator=(_Tp&& __rhs)
1431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
1432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		 && is_nothrow_constructible_v<__accepted_type<_Tp&&>, _Tp>)
1433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  constexpr auto __index = __accepted_index<_Tp>;
1435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if (index() == __index)
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
1437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
1438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      using _Tj = __accepted_type<_Tp&&>;
ARM GAS  /tmp/ccoErako.s 			page 109


1440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      if constexpr (is_nothrow_constructible_v<_Tj, _Tp>
1441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			    || !is_nothrow_move_constructible_v<_Tj>)
1442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		this->emplace<__index>(std::forward<_Tp>(__rhs));
1443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      else
1444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		operator=(variant(std::forward<_Tp>(__rhs)));
1445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return *this;
1447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename... _Args>
1450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<is_constructible_v<_Tp, _Args...> && __exactly_once<_Tp>,
1451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    _Tp&>
1452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	emplace(_Args&&... __args)
1453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  constexpr size_t __index = __index_of<_Tp>;
1455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return this->emplace<__index>(std::forward<_Args>(__args)...);
1456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename _Up, typename... _Args>
1459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>
1460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    && __exactly_once<_Tp>,
1461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    _Tp&>
1462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	emplace(initializer_list<_Up> __il, _Args&&... __args)
1463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  constexpr size_t __index = __index_of<_Tp>;
1465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return this->emplace<__index>(__il, std::forward<_Args>(__args)...);
1466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
1469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<is_constructible_v<variant_alternative_t<_Np, variant>,
1470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				       _Args...>,
1471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    variant_alternative_t<_Np, variant>&>
1472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	emplace(_Args&&... __args)
1473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  static_assert(_Np < sizeof...(_Types),
1475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			"The index must be in [0, number of alternatives)");
1476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  using type = variant_alternative_t<_Np, variant>;
1477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // Provide the strong exception-safety guarantee when possible,
1478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // to avoid becoming valueless.
1479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (is_nothrow_constructible_v<type, _Args...>)
1480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __variant_construct_by_index<_Np>(*this,
1483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
1484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else if constexpr (is_scalar_v<type>)
1486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This might invoke a potentially-throwing conversion operator:
1488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      const type __tmp(std::forward<_Args>(__args)...);
1489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // But these steps won't throw:
1490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
1491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __variant_construct_by_index<_Np>(*this, __tmp);
1492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()
1494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      && _Traits::_S_move_assign)
1495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This construction might throw:
ARM GAS  /tmp/ccoErako.s 			page 110


1497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      variant __tmp(in_place_index<_Np>,
1498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			    std::forward<_Args>(__args)...);
1499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // But _Never_valueless_alt<type> means this won't:
1500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      *this = std::move(__tmp);
1501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
1503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This case only provides the basic exception-safety guarantee,
1505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // i.e. the variant can become valueless.
1506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
1507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __try
1508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant_construct_by_index<_Np>(*this,
1510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    std::forward<_Args>(__args)...);
1511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __catch (...)
1513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  this->_M_index = variant_npos;
1515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __throw_exception_again;
1516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return std::get<_Np>(*this);
1519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename _Up, typename... _Args>
1522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<is_constructible_v<variant_alternative_t<_Np, variant>,
1523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				       initializer_list<_Up>&, _Args...>,
1524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    variant_alternative_t<_Np, variant>&>
1525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	emplace(initializer_list<_Up> __il, _Args&&... __args)
1526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  static_assert(_Np < sizeof...(_Types),
1528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			"The index must be in [0, number of alternatives)");
1529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  using type = variant_alternative_t<_Np, variant>;
1530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // Provide the strong exception-safety guarantee when possible,
1531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // to avoid becoming valueless.
1532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (is_nothrow_constructible_v<type,
1533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						   initializer_list<_Up>&,
1534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						   _Args...>)
1535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
1537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __variant_construct_by_index<_Np>(*this, __il,
1538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
1539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()
1541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      && _Traits::_S_move_assign)
1542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This construction might throw:
1544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      variant __tmp(in_place_index<_Np>, __il,
1545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			    std::forward<_Args>(__args)...);
1546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // But _Never_valueless_alt<type> means this won't:
1547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      *this = std::move(__tmp);
1548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
1550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This case only provides the basic exception-safety guarantee,
1552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // i.e. the variant can become valueless.
1553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
ARM GAS  /tmp/ccoErako.s 			page 111


1554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __try
1555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant_construct_by_index<_Np>(*this, __il,
1557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    std::forward<_Args>(__args)...);
1558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __catch (...)
1560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  this->_M_index = variant_npos;
1562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __throw_exception_again;
1563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return std::get<_Np>(*this);
1566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr bool valueless_by_exception() const noexcept
1569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return !this->_M_valid(); }
1570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr size_t index() const noexcept
 1967              		.loc 1 1571 24 view .LVU503
 1968              	.LBB1255:
1572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
1573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	using __index_type = typename _Base::__index_type;
1574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (__detail::__variant::__never_valueless<_Types...>())
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return this->_M_index;
 1969              		.loc 1 1575 17 is_stmt 0 view .LVU504
 1970 0030 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 1971              	.LVL130:
 1972              		.loc 1 1575 17 view .LVU505
 1973              	.LBE1255:
 1974              	.LBE1254:
 166:./MotorControl/component.hpp ****         if (content_.index() == 2) {
 1975              		.loc 5 166 9 view .LVU506
 1976 0032 022A     		cmp	r2, #2
 1977 0034 5DD0     		beq	.L80
 1978              	.LBB1256:
 167:./MotorControl/component.hpp ****             OutputPort<T>* ptr = std::get<2>(content_);
 168:./MotorControl/component.hpp ****             return ptr ? ptr->any() : std::nullopt;
 169:./MotorControl/component.hpp ****         } else if (content_.index() == 1) {
 1979              		.loc 5 169 16 view .LVU507
 1980 0036 012A     		cmp	r2, #1
 1981 0038 6BD0     		beq	.L81
 1982              	.LVL131:
 1983              	.LBB1257:
 1984              	.LBI1257:
1576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
1577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return make_signed_t<__index_type>(this->_M_index);
1578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else
1579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return size_t(__index_type(this->_M_index + 1)) - 1;
1580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
1581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void
1583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       swap(variant& __rhs)
1584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       noexcept((__is_nothrow_swappable<_Types>::value && ...)
1585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       && is_nothrow_move_constructible_v<variant>)
1586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
1587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::__raw_idx_visit(
1588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  [this, &__rhs](auto&& __rhs_mem, auto __rhs_index) mutable
ARM GAS  /tmp/ccoErako.s 			page 112


1589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
1590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    if constexpr (__rhs_index != variant_npos)
1591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      {
1592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		if (this->index() == __rhs_index)
1593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  {
1594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    auto& __this_mem =
1595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      std::get<__rhs_index>(*this);
1596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    using std::swap;
1597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    swap(__this_mem, __rhs_mem);
1598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  }
1599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		else
1600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  {
1601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    if (!this->valueless_by_exception()) [[__likely__]]
1602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      {
1603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			auto __tmp(std::move(__rhs_mem));
1604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			__rhs = std::move(*this);
1605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			this->_M_destructive_move(__rhs_index,
1606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						  std::move(__tmp));
1607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      }
1608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    else
1609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      {
1610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			this->_M_destructive_move(__rhs_index,
1611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						  std::move(__rhs_mem));
1612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			__rhs._M_reset();
1613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      }
1614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  }
1615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      }
1616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    else
1617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      {
1618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		if (!this->valueless_by_exception()) [[__likely__]]
1619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  {
1620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    __rhs = std::move(*this);
1621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    this->_M_reset();
1622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  }
1623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      }
1624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __rhs);
1625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
1626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     private:
1628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #if defined(__clang__) && __clang_major__ <= 7
1630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     public:
1631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_M_u; // See https://bugs.llvm.org/show_bug.cgi?id=31852
1632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     private:
1633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #endif
1634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename _Vp>
1636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend constexpr decltype(auto)
1637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::__get(_Vp&& __v) noexcept;
1638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Vp>
1640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend void*
1641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::__get_storage(_Vp&& __v) noexcept;
1642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP) \
1644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Tp> \
1645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend constexpr bool \
ARM GAS  /tmp/ccoErako.s 			page 113


1646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	operator __OP(const variant<_Tp...>& __lhs, \
1647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      const variant<_Tp...>& __rhs);
1648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(<)
1650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(<=)
1651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(==)
1652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(!=)
1653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(>=)
1654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(>)
1655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #undef _VARIANT_RELATION_FUNCTION_TEMPLATE
1657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
1658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
1660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>>&
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(variant<_Types...>& __v)
 1985              		.loc 1 1661 5 is_stmt 1 view .LVU508
 1986              	.LBB1258:
 1987              	.LBB1259:
 1988              	.LBI1259:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 1989              		.loc 1 1571 24 view .LVU509
 1990              	.LBB1260:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 1991              		.loc 1 1575 17 is_stmt 0 view .LVU510
 1992 003a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 1993              	.LVL132:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 1994              		.loc 1 1575 17 view .LVU511
 1995              	.LBE1260:
 1996              	.LBE1259:
1662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(_Np < sizeof...(_Types),
1664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "The index must be in [0, number of alternatives)");
1665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if (__v.index() != _Np)
 1997              		.loc 1 1665 7 view .LVU512
 1998 003c 002A     		cmp	r2, #0
 1999 003e 7AD1     		bne	.L82
 2000              	.LVL133:
 2001              	.LBB1261:
 2002              	.LBI1261:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2003              		.loc 1 276 5 is_stmt 1 view .LVU513
 2004              	.LBB1262:
 2005              	.LBB1263:
 2006              	.LBI1263:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 2007              		.loc 1 262 5 view .LVU514
 2008              	.LBB1264:
 2009              	.LBI1264:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2010              		.loc 1 222 24 view .LVU515
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2011              		.loc 1 222 24 is_stmt 0 view .LVU516
 2012              	.LBE1264:
 2013              	.LBE1263:
 2014              	.LBE1262:
ARM GAS  /tmp/ccoErako.s 			page 114


 2015              	.LBE1261:
 2016              	.LBE1258:
 2017              	.LBE1257:
 2018              	.LBB1268:
 2019              	.LBI1268:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 2020              		.loc 6 700 2 is_stmt 1 view .LVU517
 2021              	.LBB1269:
 2022              	.LBB1270:
 2023              	.LBB1271:
 2024              	.LBI1271:
 2025              		.loc 7 76 5 view .LVU518
 2026              		.loc 7 76 5 is_stmt 0 view .LVU519
 2027              	.LBE1271:
 2028              	.LBB1272:
 2029              	.LBI1272:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 2030              		.loc 6 607 28 is_stmt 1 view .LVU520
 2031              	.LBB1273:
 2032              	.LBB1274:
 2033              	.LBB1275:
 2034              	.LBI1275:
 2035              		.loc 7 76 5 view .LVU521
 2036              		.loc 7 76 5 is_stmt 0 view .LVU522
 2037              	.LBE1275:
 2038              	.LBB1276:
 2039              	.LBI1276:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2040              		.loc 6 300 42 is_stmt 1 view .LVU523
 2041              	.LBB1277:
 2042              	.LBB1278:
 2043              	.LBB1279:
 2044              	.LBI1279:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 2045              		.loc 6 115 2 view .LVU524
 2046              	.LBB1280:
 2047              	.LBB1281:
 2048              	.LBB1282:
 2049              	.LBI1282:
 2050              		.loc 7 76 5 view .LVU525
 2051              		.loc 7 76 5 is_stmt 0 view .LVU526
 2052              	.LBE1282:
 2053              	.LBB1283:
 2054              	.LBI1283:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 2055              		.loc 6 203 6 is_stmt 1 view .LVU527
 2056              	.LBB1284:
 2057              	.LBB1285:
 2058              	.LBB1286:
 2059              	.LBI1286:
 2060              		.loc 7 76 5 view .LVU528
 2061              		.loc 7 76 5 is_stmt 0 view .LVU529
 2062              	.LBE1286:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2063              		.loc 6 204 47 view .LVU530
 2064 0040 1B68     		ldr	r3, [r3]	@ float
 2065              	.LVL134:
ARM GAS  /tmp/ccoErako.s 			page 115


 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2066              		.loc 6 204 47 view .LVU531
 2067 0042 0893     		str	r3, [sp, #32]	@ float
 2068              	.LVL135:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2069              		.loc 6 204 47 view .LVU532
 2070              	.LBE1285:
 2071              	.LBE1284:
 2072              	.LBE1283:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2073              		.loc 6 117 19 view .LVU533
 2074 0044 0123     		movs	r3, #1
 2075 0046 8DF82430 		strb	r3, [sp, #36]
 2076              	.LVL136:
 2077              	.L62:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2078              		.loc 6 117 19 view .LVU534
 2079              	.LBE1281:
 2080              	.LBE1280:
 2081              	.LBE1279:
 2082              	.LBE1278:
 2083              	.LBE1277:
 2084              	.LBE1276:
 2085              	.LBE1274:
 2086              	.LBE1273:
 2087              	.LBE1272:
 2088              	.LBE1270:
 2089              	.LBE1269:
 2090              	.LBE1268:
 2091              	.LBE1256:
 2092              	.LBE1253:
 2093              	.LBE1252:
 2094              	.LBB1377:
 2095              	.LBI1377:
 2096              		.loc 6 964 2 is_stmt 1 view .LVU535
 2097              	.LBB1378:
 2098              	.LBB1379:
 2099              	.LBI1379:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 2100              		.loc 6 433 22 view .LVU536
 2101              	.LBB1380:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2102              		.loc 6 434 58 is_stmt 0 view .LVU537
 2103 004a 9DF82430 		ldrb	r3, [sp, #36]	@ zero_extendqisi2
 2104              	.LVL137:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2105              		.loc 6 434 58 view .LVU538
 2106              	.LBE1380:
 2107              	.LBE1379:
 965:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 966:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_move_constructible_v<_Tp>);
 967:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_convertible_v<_Up&&, _Tp>);
 968:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 969:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_is_engaged()
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    ? std::move(this->_M_get())
 2108              		.loc 6 970 6 view .LVU539
 2109 004e 002B     		cmp	r3, #0
ARM GAS  /tmp/ccoErako.s 			page 116


 2110 0050 74D0     		beq	.L77
 2111 0052 089B     		ldr	r3, [sp, #32]	@ float
 2112              	.L67:
 2113              	.LVL138:
 2114              		.loc 6 970 6 view .LVU540
 2115              	.LBE1378:
 2116              	.LBE1377:
 2117              	.LBB1382:
 2118              	.LBI1382:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 2119              		.loc 4 50 16 is_stmt 1 view .LVU541
 2120              	.LBB1383:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 2121              		.loc 4 51 14 is_stmt 0 view .LVU542
 2122 0054 0020     		movs	r0, #0
 2123 0056 0021     		movs	r1, #0
 2124 0058 CDE90001 		strd	r0, [sp]
  52:communication/can/can_helpers.hpp **** 
 2125              		.loc 4 52 16 view .LVU543
 2126 005c 0093     		str	r3, [sp]
 2127              	.LVL139:
 2128              	.LBB1384:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 2129              		.loc 4 57 18 view .LVU544
 2130 005e CDE90201 		strd	r0, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 2131              		.loc 4 58 20 view .LVU545
 2132 0062 02AA     		add	r2, sp, #8
 2133 0064 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 2134 0068 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 2135 006c 03C2     		stmia	r2!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 2136              		.loc 4 60 14 view .LVU546
 2137 006e 0022     		movs	r2, #0
 2138 0070 0292     		str	r2, [sp, #8]
  61:communication/can/can_helpers.hpp **** 
 2139              		.loc 4 61 27 view .LVU547
 2140 0072 0199     		ldr	r1, [sp, #4]
  61:communication/can/can_helpers.hpp **** 
 2141              		.loc 4 61 14 view .LVU548
 2142 0074 039A     		ldr	r2, [sp, #12]
 2143 0076 0A43     		orrs	r2, r2, r1
 2144 0078 0293     		str	r3, [sp, #8]
 2145 007a 0392     		str	r2, [sp, #12]
 2146              		.loc 4 63 20 view .LVU549
 2147 007c 02AB     		add	r3, sp, #8
 2148 007e 03CB     		ldmia	r3!, {r0, r1}
 2149 0080 CDF81700 		str	r0, [sp, #23]	@ unaligned
 2150 0084 CDF81B10 		str	r1, [sp, #27]	@ unaligned
 2151              	.LVL140:
 2152              		.loc 4 63 20 view .LVU550
 2153              	.LBE1384:
 2154              	.LBE1383:
 2155              	.LBE1382:
 242:communication/can/can_simple.cpp **** 
 2156              		.loc 3 242 5 is_stmt 1 view .LVU551
 242:communication/can/can_simple.cpp **** 
ARM GAS  /tmp/ccoErako.s 			page 117


 2157              		.loc 3 242 38 is_stmt 0 view .LVU552
 2158 0088 DCF80001 		ldr	r0, [ip, #256]
 242:communication/can/can_simple.cpp **** 
 2159              		.loc 3 242 72 view .LVU553
 2160 008c 43F6F401 		movw	r1, #14580
 2161 0090 4318     		adds	r3, r0, r1
 2162              	.LVL141:
 2163              	.LBB1385:
 2164              	.LBI1385:
 165:./MotorControl/component.hpp ****         if (content_.index() == 2) {
 2165              		.loc 5 165 22 is_stmt 1 view .LVU554
 2166              	.LBB1386:
 2167              	.LBB1387:
 2168              	.LBI1387:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 2169              		.loc 1 1571 24 view .LVU555
 2170              	.LBB1388:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 2171              		.loc 1 1575 17 is_stmt 0 view .LVU556
 2172 0092 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 2173              	.LVL142:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 2174              		.loc 1 1575 17 view .LVU557
 2175              	.LBE1388:
 2176              	.LBE1387:
 166:./MotorControl/component.hpp ****             OutputPort<T>* ptr = std::get<2>(content_);
 2177              		.loc 5 166 9 view .LVU558
 2178 0094 022A     		cmp	r2, #2
 2179 0096 53D0     		beq	.L83
 2180              	.LBB1389:
 2181              		.loc 5 169 16 view .LVU559
 2182 0098 012A     		cmp	r2, #1
 2183 009a 61D0     		beq	.L84
 2184              	.LVL143:
 2185              	.LBB1390:
 2186              	.LBI1390:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2187              		.loc 1 1661 5 is_stmt 1 view .LVU560
 2188              	.LBB1391:
 2189              	.LBB1392:
 2190              	.LBI1392:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 2191              		.loc 1 1571 24 view .LVU561
 2192              	.LBB1393:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 2193              		.loc 1 1575 17 is_stmt 0 view .LVU562
 2194 009c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 2195              	.LVL144:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 2196              		.loc 1 1575 17 view .LVU563
 2197              	.LBE1393:
 2198              	.LBE1392:
 2199              		.loc 1 1665 7 view .LVU564
 2200 009e 002A     		cmp	r2, #0
 2201 00a0 70D1     		bne	.L85
 2202              	.LVL145:
 2203              	.LBB1394:
ARM GAS  /tmp/ccoErako.s 			page 118


 2204              	.LBI1394:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2205              		.loc 1 276 5 is_stmt 1 view .LVU565
 2206              	.LBB1395:
 2207              	.LBB1396:
 2208              	.LBI1396:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 2209              		.loc 1 262 5 view .LVU566
 2210              	.LBB1397:
 2211              	.LBI1397:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2212              		.loc 1 222 24 view .LVU567
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2213              		.loc 1 222 24 is_stmt 0 view .LVU568
 2214              	.LBE1397:
 2215              	.LBE1396:
 2216              	.LBE1395:
 2217              	.LBE1394:
 2218              	.LBE1391:
 2219              	.LBE1390:
 2220              	.LBB1401:
 2221              	.LBI1401:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 2222              		.loc 6 700 2 is_stmt 1 view .LVU569
 2223              	.LBB1402:
 2224              	.LBB1403:
 2225              	.LBB1404:
 2226              	.LBI1404:
 2227              		.loc 7 76 5 view .LVU570
 2228              		.loc 7 76 5 is_stmt 0 view .LVU571
 2229              	.LBE1404:
 2230              	.LBB1405:
 2231              	.LBI1405:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 2232              		.loc 6 607 28 is_stmt 1 view .LVU572
 2233              	.LBB1406:
 2234              	.LBB1407:
 2235              	.LBB1408:
 2236              	.LBI1408:
 2237              		.loc 7 76 5 view .LVU573
 2238              		.loc 7 76 5 is_stmt 0 view .LVU574
 2239              	.LBE1408:
 2240              	.LBB1409:
 2241              	.LBI1409:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2242              		.loc 6 300 42 is_stmt 1 view .LVU575
 2243              	.LBB1410:
 2244              	.LBB1411:
 2245              	.LBB1412:
 2246              	.LBI1412:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 2247              		.loc 6 115 2 view .LVU576
 2248              	.LBB1413:
 2249              	.LBB1414:
 2250              	.LBB1415:
 2251              	.LBI1415:
 2252              		.loc 7 76 5 view .LVU577
ARM GAS  /tmp/ccoErako.s 			page 119


 2253              		.loc 7 76 5 is_stmt 0 view .LVU578
 2254              	.LBE1415:
 2255              	.LBB1416:
 2256              	.LBI1416:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 2257              		.loc 6 203 6 is_stmt 1 view .LVU579
 2258              	.LBB1417:
 2259              	.LBB1418:
 2260              	.LBB1419:
 2261              	.LBI1419:
 2262              		.loc 7 76 5 view .LVU580
 2263              		.loc 7 76 5 is_stmt 0 view .LVU581
 2264              	.LBE1419:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2265              		.loc 6 204 47 view .LVU582
 2266 00a2 1B68     		ldr	r3, [r3]	@ float
 2267              	.LVL146:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2268              		.loc 6 204 47 view .LVU583
 2269 00a4 0A93     		str	r3, [sp, #40]	@ float
 2270              	.LVL147:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2271              		.loc 6 204 47 view .LVU584
 2272              	.LBE1418:
 2273              	.LBE1417:
 2274              	.LBE1416:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2275              		.loc 6 117 19 view .LVU585
 2276 00a6 0123     		movs	r3, #1
 2277 00a8 8DF82C30 		strb	r3, [sp, #44]
 2278              	.LVL148:
 2279              	.L71:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2280              		.loc 6 117 19 view .LVU586
 2281              	.LBE1414:
 2282              	.LBE1413:
 2283              	.LBE1412:
 2284              	.LBE1411:
 2285              	.LBE1410:
 2286              	.LBE1409:
 2287              	.LBE1407:
 2288              	.LBE1406:
 2289              	.LBE1405:
 2290              	.LBE1403:
 2291              	.LBE1402:
 2292              	.LBE1401:
 2293              	.LBE1389:
 2294              	.LBE1386:
 2295              	.LBE1385:
 2296              	.LBB1510:
 2297              	.LBI1510:
 964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 2298              		.loc 6 964 2 is_stmt 1 view .LVU587
 2299              	.LBB1511:
 2300              	.LBB1512:
 2301              	.LBI1512:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
ARM GAS  /tmp/ccoErako.s 			page 120


 2302              		.loc 6 433 22 view .LVU588
 2303              	.LBB1513:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2304              		.loc 6 434 58 is_stmt 0 view .LVU589
 2305 00ac 9DF82C30 		ldrb	r3, [sp, #44]	@ zero_extendqisi2
 2306              	.LVL149:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2307              		.loc 6 434 58 view .LVU590
 2308              	.LBE1513:
 2309              	.LBE1512:
 2310              		.loc 6 970 6 view .LVU591
 2311 00b0 002B     		cmp	r3, #0
 2312 00b2 6AD0     		beq	.L78
 2313 00b4 0A9B     		ldr	r3, [sp, #40]	@ float
 2314              	.L76:
 2315              	.LVL150:
 2316              		.loc 6 970 6 view .LVU592
 2317              	.LBE1511:
 2318              	.LBE1510:
 2319              	.LBB1515:
 2320              	.LBI1515:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 2321              		.loc 4 50 16 is_stmt 1 view .LVU593
 2322              	.LBB1516:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 2323              		.loc 4 51 14 is_stmt 0 view .LVU594
 2324 00b6 0020     		movs	r0, #0
 2325 00b8 0021     		movs	r1, #0
 2326 00ba CDE90001 		strd	r0, [sp]
  52:communication/can/can_helpers.hpp **** 
 2327              		.loc 4 52 16 view .LVU595
 2328 00be 0093     		str	r3, [sp]
 2329              	.LVL151:
 2330              	.LBB1517:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 2331              		.loc 4 57 18 view .LVU596
 2332 00c0 CDE90201 		strd	r0, [sp, #8]
  58:communication/can/can_helpers.hpp **** 
 2333              		.loc 4 58 20 view .LVU597
 2334 00c4 02AA     		add	r2, sp, #8
 2335 00c6 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 2336 00ca DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 2337 00ce 03C2     		stmia	r2!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 2338              		.loc 4 60 14 view .LVU598
 2339 00d0 0022     		movs	r2, #0
 2340 00d2 0392     		str	r2, [sp, #12]
  61:communication/can/can_helpers.hpp **** 
 2341              		.loc 4 61 14 view .LVU599
 2342 00d4 0393     		str	r3, [sp, #12]
 2343              		.loc 4 63 20 view .LVU600
 2344 00d6 02AB     		add	r3, sp, #8
 2345 00d8 03CB     		ldmia	r3!, {r0, r1}
 2346 00da CDF81700 		str	r0, [sp, #23]	@ unaligned
 2347 00de CDF81B10 		str	r1, [sp, #27]	@ unaligned
 2348              	.LVL152:
 2349              		.loc 4 63 20 view .LVU601
ARM GAS  /tmp/ccoErako.s 			page 121


 2350              	.LBE1517:
 2351              	.LBE1516:
 2352              	.LBE1515:
 244:communication/can/can_simple.cpp **** }
 2353              		.loc 3 244 5 is_stmt 1 view .LVU602
 244:communication/can/can_simple.cpp **** }
 2354              		.loc 3 244 12 is_stmt 0 view .LVU603
 2355 00e2 DEF80000 		ldr	r0, [lr]
 244:communication/can/can_simple.cpp **** }
 2356              		.loc 3 244 39 view .LVU604
 2357 00e6 0368     		ldr	r3, [r0]
 2358 00e8 1B68     		ldr	r3, [r3]
 244:communication/can/can_simple.cpp **** }
 2359              		.loc 3 244 33 view .LVU605
 2360 00ea 04A9     		add	r1, sp, #16
 2361 00ec 9847     		blx	r3
 2362              	.LVL153:
 245:communication/can/can_simple.cpp **** 
 2363              		.loc 3 245 1 view .LVU606
 2364 00ee 0CB0     		add	sp, sp, #48
 2365              	.LCFI32:
 2366              		.cfi_remember_state
 2367              		.cfi_def_cfa_offset 8
 2368              		@ sp needed
 2369 00f0 10BD     		pop	{r4, pc}
 2370              	.LVL154:
 2371              	.L80:
 2372              	.LCFI33:
 2373              		.cfi_restore_state
 2374              	.LBB1518:
 2375              	.LBB1376:
 2376              	.LBB1331:
 2377              	.LBB1332:
 2378              	.LBI1332:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2379              		.loc 1 1661 5 is_stmt 1 view .LVU607
 2380              	.LBB1333:
 2381              	.LBB1334:
 2382              	.LBI1334:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 2383              		.loc 1 1571 24 view .LVU608
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 2384              		.loc 1 1571 24 is_stmt 0 view .LVU609
 2385              	.LBE1334:
 2386              		.loc 1 1665 7 view .LVU610
 2387 00f2 07D1     		bne	.L86
 2388              	.LVL155:
 2389              	.LBB1335:
 2390              	.LBI1335:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2391              		.loc 1 276 5 is_stmt 1 view .LVU611
 2392              	.LBB1336:
 2393              	.LBB1337:
 2394              	.LBI1337:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2395              		.loc 1 267 5 view .LVU612
 2396              	.LBB1338:
ARM GAS  /tmp/ccoErako.s 			page 122


 2397              	.LBB1339:
 2398              	.LBI1339:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2399              		.loc 1 267 5 view .LVU613
 2400              	.LBB1340:
 2401              	.LBB1341:
 2402              	.LBI1341:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 2403              		.loc 1 262 5 view .LVU614
 2404              	.LBB1342:
 2405              	.LBI1342:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2406              		.loc 1 222 24 view .LVU615
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2407              		.loc 1 222 24 is_stmt 0 view .LVU616
 2408              	.LBE1342:
 2409              	.LBE1341:
 2410              	.LBE1340:
 2411              	.LBE1339:
 2412              	.LBE1338:
 2413              	.LBE1337:
 2414              	.LBE1336:
 2415              	.LBE1335:
 2416              	.LBE1333:
 2417              	.LBE1332:
 167:./MotorControl/component.hpp ****             return ptr ? ptr->any() : std::nullopt;
 2418              		.loc 5 167 28 view .LVU617
 2419 00f4 4358     		ldr	r3, [r0, r1]
 2420              	.LVL156:
 168:./MotorControl/component.hpp ****         } else if (content_.index() == 1) {
 2421              		.loc 5 168 44 view .LVU618
 2422 00f6 43B1     		cbz	r3, .L61
 2423              	.LVL157:
 2424              	.LBB1346:
 2425              	.LBI1346:
 102:./MotorControl/component.hpp ****         return content_;
 2426              		.loc 5 102 22 is_stmt 1 view .LVU619
 2427              	.LBB1347:
 2428              	.LBB1348:
 2429              	.LBI1348:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 2430              		.loc 6 700 2 view .LVU620
 2431              	.LBB1349:
 2432              	.LBB1350:
 2433              	.LBB1351:
 2434              	.LBI1351:
 2435              		.loc 7 76 5 view .LVU621
 2436              		.loc 7 76 5 is_stmt 0 view .LVU622
 2437              	.LBE1351:
 2438              	.LBB1352:
 2439              	.LBI1352:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 2440              		.loc 6 607 28 is_stmt 1 view .LVU623
 2441              	.LBB1353:
 2442              	.LBB1354:
 2443              	.LBB1355:
 2444              	.LBI1355:
ARM GAS  /tmp/ccoErako.s 			page 123


 2445              		.loc 7 76 5 view .LVU624
 2446              		.loc 7 76 5 is_stmt 0 view .LVU625
 2447              	.LBE1355:
 2448              	.LBB1356:
 2449              	.LBI1356:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2450              		.loc 6 300 42 is_stmt 1 view .LVU626
 2451              	.LBB1357:
 2452              	.LBB1358:
 2453              	.LBB1359:
 2454              	.LBI1359:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 2455              		.loc 6 115 2 view .LVU627
 2456              	.LBB1360:
 2457              	.LBB1361:
 2458              	.LBB1362:
 2459              	.LBI1362:
 2460              		.loc 7 76 5 view .LVU628
 2461              		.loc 7 76 5 is_stmt 0 view .LVU629
 2462              	.LBE1362:
 2463              	.LBB1363:
 2464              	.LBI1363:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 2465              		.loc 6 203 6 is_stmt 1 view .LVU630
 2466              	.LBB1364:
 2467              	.LBB1365:
 2468              	.LBB1366:
 2469              	.LBI1366:
 2470              		.loc 7 76 5 view .LVU631
 2471              		.loc 7 76 5 is_stmt 0 view .LVU632
 2472              	.LBE1366:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2473              		.loc 6 204 47 view .LVU633
 2474 00f8 5B68     		ldr	r3, [r3, #4]	@ float
 2475              	.LVL158:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2476              		.loc 6 204 47 view .LVU634
 2477 00fa 0893     		str	r3, [sp, #32]	@ float
 2478              	.LVL159:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2479              		.loc 6 204 47 view .LVU635
 2480              	.LBE1365:
 2481              	.LBE1364:
 2482              	.LBE1363:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2483              		.loc 6 117 19 view .LVU636
 2484 00fc 0123     		movs	r3, #1
 2485 00fe 8DF82430 		strb	r3, [sp, #36]
 2486              	.LVL160:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2487              		.loc 6 117 19 view .LVU637
 2488              	.LBE1361:
 2489              	.LBE1360:
 2490              	.LBE1359:
 2491              	.LBE1358:
 2492              	.LBE1357:
 2493              	.LBE1356:
ARM GAS  /tmp/ccoErako.s 			page 124


 2494              	.LBE1354:
 2495              	.LBE1353:
 2496              	.LBE1352:
 2497              	.LBE1350:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2498              		.loc 6 701 51 view .LVU638
 2499 0102 A2E7     		b	.L62
 2500              	.LVL161:
 2501              	.L86:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2502              		.loc 6 701 51 view .LVU639
 2503              	.LBE1349:
 2504              	.LBE1348:
 2505              	.LBE1347:
 2506              	.LBE1346:
 2507              	.LBB1367:
 2508              	.LBB1345:
 2509              	.LBB1343:
 2510              	.LBI1343:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 2511              		.loc 1 1287 3 is_stmt 1 view .LVU640
 2512              	.LBB1344:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 2513              		.loc 1 1289 5 view .LVU641
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2514              		.loc 1 1292 7 view .LVU642
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2515              		.loc 1 1292 33 is_stmt 0 view .LVU643
 2516 0104 2348     		ldr	r0, .L90+4
 2517 0106 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 2518              	.LVL162:
 2519              	.L61:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2520              		.loc 1 1292 33 view .LVU644
 2521              	.LBE1344:
 2522              	.LBE1343:
 2523              	.LBE1345:
 2524              	.LBE1367:
 2525              	.LBB1368:
 2526              	.LBI1368:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2527              		.loc 6 692 17 is_stmt 1 view .LVU645
 2528              	.LBB1369:
 2529              	.LBB1370:
 2530              	.LBI1370:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2531              		.loc 6 602 17 view .LVU646
 2532              	.LBB1371:
 2533              	.LBI1371:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 2534              		.loc 6 302 7 view .LVU647
 2535              	.LBB1372:
 2536              	.LBI1372:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2537              		.loc 6 110 7 view .LVU648
 2538              	.LBB1373:
 2539              	.LBB1374:
ARM GAS  /tmp/ccoErako.s 			page 125


 2540              	.LBI1374:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2541              		.loc 6 199 14 view .LVU649
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2542              		.loc 6 199 14 is_stmt 0 view .LVU650
 2543              	.LBE1374:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2544              		.loc 6 110 7 view .LVU651
 2545 010a 0023     		movs	r3, #0
 2546              	.LVL163:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2547              		.loc 6 110 7 view .LVU652
 2548 010c 8DF82430 		strb	r3, [sp, #36]
 2549              	.LVL164:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2550              		.loc 6 110 7 view .LVU653
 2551 0110 9BE7     		b	.L62
 2552              	.LVL165:
 2553              	.L81:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2554              		.loc 6 110 7 view .LVU654
 2555              	.LBE1373:
 2556              	.LBE1372:
 2557              	.LBE1371:
 2558              	.LBE1370:
 2559              	.LBE1369:
 2560              	.LBE1368:
 2561              	.LBE1331:
 2562              	.LBB1375:
 2563              	.LBB1287:
 2564              	.LBB1288:
 2565              	.LBI1288:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2566              		.loc 1 1661 5 is_stmt 1 view .LVU655
 2567              	.LBB1289:
 2568              	.LBB1290:
 2569              	.LBI1290:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 2570              		.loc 1 1571 24 view .LVU656
 2571              	.LBB1291:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 2572              		.loc 1 1575 17 is_stmt 0 view .LVU657
 2573 0112 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2574              	.LVL166:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 2575              		.loc 1 1575 17 view .LVU658
 2576              	.LBE1291:
 2577              	.LBE1290:
 2578              		.loc 1 1665 7 view .LVU659
 2579 0114 012B     		cmp	r3, #1
 2580 0116 07D1     		bne	.L87
 2581              	.LVL167:
 2582              	.LBB1292:
 2583              	.LBI1292:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2584              		.loc 1 276 5 is_stmt 1 view .LVU660
 2585              	.LBB1293:
ARM GAS  /tmp/ccoErako.s 			page 126


 2586              	.LBB1294:
 2587              	.LBI1294:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2588              		.loc 1 267 5 view .LVU661
 2589              	.LBB1295:
 2590              	.LBB1296:
 2591              	.LBI1296:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 2592              		.loc 1 262 5 view .LVU662
 2593              	.LBB1297:
 2594              	.LBI1297:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2595              		.loc 1 222 24 view .LVU663
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2596              		.loc 1 222 24 is_stmt 0 view .LVU664
 2597              	.LBE1297:
 2598              	.LBE1296:
 2599              	.LBE1295:
 2600              	.LBE1294:
 2601              	.LBE1293:
 2602              	.LBE1292:
 2603              	.LBE1289:
 2604              	.LBE1288:
 170:./MotorControl/component.hpp ****             T* ptr = std::get<1>(content_);
 2605              		.loc 5 170 16 view .LVU665
 2606 0118 4358     		ldr	r3, [r0, r1]
 2607              	.LVL168:
 171:./MotorControl/component.hpp ****             return ptr ? std::make_optional(*ptr) : std::nullopt;
 2608              		.loc 5 171 58 view .LVU666
 2609 011a 43B1     		cbz	r3, .L65
 2610              	.LVL169:
 2611              	.LBB1301:
 2612              	.LBI1301:
 971:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : static_cast<_Tp>(std::forward<_Up>(__u));
 972:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 973:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 974:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       void reset() noexcept { this->_M_reset(); }
 975:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 976:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 977:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 978:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __optional_relop_t =
 979:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       enable_if_t<is_convertible<_Tp, bool>::value, bool>;
 980:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 981:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 982:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __optional_eq_t = __optional_relop_t<
 983:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       decltype(std::declval<const _Tp&>() == std::declval<const _Up&>())
 984:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       >;
 985:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 986:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 987:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __optional_ne_t = __optional_relop_t<
 988:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       decltype(std::declval<const _Tp&>() != std::declval<const _Up&>())
 989:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       >;
 990:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 991:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 992:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __optional_lt_t = __optional_relop_t<
 993:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       decltype(std::declval<const _Tp&>() < std::declval<const _Up&>())
 994:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       >;
ARM GAS  /tmp/ccoErako.s 			page 127


 995:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 996:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 997:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __optional_gt_t = __optional_relop_t<
 998:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       decltype(std::declval<const _Tp&>() > std::declval<const _Up&>())
 999:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       >;
1000:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1001:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1002:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __optional_le_t = __optional_relop_t<
1003:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       decltype(std::declval<const _Tp&>() <= std::declval<const _Up&>())
1004:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       >;
1005:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1006:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1007:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __optional_ge_t = __optional_relop_t<
1008:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       decltype(std::declval<const _Tp&>() >= std::declval<const _Up&>())
1009:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       >;
1010:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1011:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Comparisons between optional values.
1012:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1013:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1014:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator==(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
1015:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_eq_t<_Tp, _Up>
1016:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
1017:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       return static_cast<bool>(__lhs) == static_cast<bool>(__rhs)
1018:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	     && (!__lhs || *__lhs == *__rhs);
1019:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     }
1020:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1021:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1022:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1023:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator!=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
1024:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_ne_t<_Tp, _Up>
1025:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
1026:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       return static_cast<bool>(__lhs) != static_cast<bool>(__rhs)
1027:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	|| (static_cast<bool>(__lhs) && *__lhs != *__rhs);
1028:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     }
1029:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1030:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1031:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1032:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
1033:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_lt_t<_Tp, _Up>
1034:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
1035:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       return static_cast<bool>(__rhs) && (!__lhs || *__lhs < *__rhs);
1036:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     }
1037:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1038:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1039:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1040:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
1041:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_gt_t<_Tp, _Up>
1042:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
1043:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       return static_cast<bool>(__lhs) && (!__rhs || *__lhs > *__rhs);
1044:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     }
1045:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1046:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1047:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1048:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
1049:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_le_t<_Tp, _Up>
1050:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
1051:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       return !__lhs || (static_cast<bool>(__rhs) && *__lhs <= *__rhs);
ARM GAS  /tmp/ccoErako.s 			page 128


1052:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     }
1053:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1055:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1056:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
1057:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_ge_t<_Tp, _Up>
1058:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
1059:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       return !__rhs || (static_cast<bool>(__lhs) && *__lhs >= *__rhs);
1060:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     }
1061:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1062:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #ifdef __cpp_lib_three_way_comparison
1063:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, three_way_comparable_with<_Tp> _Up>
1064:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr compare_three_way_result_t<_Tp, _Up>
1065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=>(const optional<_Tp>& __x, const optional<_Up>& __y)
1066:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
1067:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       return __x && __y ? *__x <=> *__y : bool(__x) <=> bool(__y);
1068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     }
1069:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #endif
1070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1071:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Comparisons with nullopt.
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1073:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1074:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator==(const optional<_Tp>& __lhs, nullopt_t) noexcept
1075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__lhs; }
1076:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1077:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #ifdef __cpp_lib_three_way_comparison
1078:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1079:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr strong_ordering
1080:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=>(const optional<_Tp>& __x, nullopt_t) noexcept
1081:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return bool(__x) <=> false; }
1082:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #else
1083:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1084:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1085:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator==(nullopt_t, const optional<_Tp>& __rhs) noexcept
1086:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__rhs; }
1087:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1088:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1089:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1090:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator!=(const optional<_Tp>& __lhs, nullopt_t) noexcept
1091:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return static_cast<bool>(__lhs); }
1092:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1093:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1094:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1095:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator!=(nullopt_t, const optional<_Tp>& __rhs) noexcept
1096:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return static_cast<bool>(__rhs); }
1097:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1098:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1099:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<(const optional<_Tp>& /* __lhs */, nullopt_t) noexcept
1101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return false; }
1102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<(nullopt_t, const optional<_Tp>& __rhs) noexcept
1106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return static_cast<bool>(__rhs); }
1107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
ARM GAS  /tmp/ccoErako.s 			page 129


1109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>(const optional<_Tp>& __lhs, nullopt_t) noexcept
1111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return static_cast<bool>(__lhs); }
1112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>(nullopt_t, const optional<_Tp>& /* __rhs */) noexcept
1116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return false; }
1117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=(const optional<_Tp>& __lhs, nullopt_t) noexcept
1121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__lhs; }
1122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=(nullopt_t, const optional<_Tp>& /* __rhs */) noexcept
1126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return true; }
1127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>=(const optional<_Tp>& /* __lhs */, nullopt_t) noexcept
1131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return true; }
1132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>=(nullopt_t, const optional<_Tp>& __rhs) noexcept
1136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__rhs; }
1137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #endif // three-way-comparison
1138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Comparisons with value type.
1140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator==(const optional<_Tp>& __lhs, const _Up& __rhs)
1143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_eq_t<_Tp, _Up>
1144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return __lhs && *__lhs == __rhs; }
1145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator==(const _Up& __lhs, const optional<_Tp>& __rhs)
1149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_eq_t<_Up, _Tp>
1150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return __rhs && __lhs == *__rhs; }
1151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator!=(const optional<_Tp>& __lhs, const _Up& __rhs)
1155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_ne_t<_Tp, _Up>
1156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__lhs || *__lhs != __rhs; }
1157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator!=(const _Up& __lhs, const optional<_Tp>& __rhs)
1161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_ne_t<_Up, _Tp>
1162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__rhs || __lhs != *__rhs; }
1163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
ARM GAS  /tmp/ccoErako.s 			page 130


1166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<(const optional<_Tp>& __lhs, const _Up& __rhs)
1167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_lt_t<_Tp, _Up>
1168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__lhs || *__lhs < __rhs; }
1169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<(const _Up& __lhs, const optional<_Tp>& __rhs)
1173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_lt_t<_Up, _Tp>
1174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return __rhs && __lhs < *__rhs; }
1175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>(const optional<_Tp>& __lhs, const _Up& __rhs)
1179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_gt_t<_Tp, _Up>
1180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return __lhs && *__lhs > __rhs; }
1181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>(const _Up& __lhs, const optional<_Tp>& __rhs)
1185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_gt_t<_Up, _Tp>
1186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__rhs || __lhs > *__rhs; }
1187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=(const optional<_Tp>& __lhs, const _Up& __rhs)
1191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_le_t<_Tp, _Up>
1192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__lhs || *__lhs <= __rhs; }
1193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=(const _Up& __lhs, const optional<_Tp>& __rhs)
1197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_le_t<_Up, _Tp>
1198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return __rhs && __lhs <= *__rhs; }
1199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>=(const optional<_Tp>& __lhs, const _Up& __rhs)
1203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_ge_t<_Tp, _Up>
1204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return __lhs && *__lhs >= __rhs; }
1205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>=(const _Up& __lhs, const optional<_Tp>& __rhs)
1209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_ge_t<_Up, _Tp>
1210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__rhs || __lhs >= *__rhs; }
1211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #ifdef __cpp_lib_three_way_comparison
1213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     inline constexpr bool __is_optional_v = false;
1215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     inline constexpr bool __is_optional_v<optional<_Tp>> = true;
1217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     requires (!__is_optional_v<_Up>)
1220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       && three_way_comparable_with<_Tp, _Up>
1221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr compare_three_way_result_t<_Tp, _Up>
1222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=>(const optional<_Tp>& __x, const _Up& __v)
ARM GAS  /tmp/ccoErako.s 			page 131


1223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return bool(__x) ? *__x <=> __v : strong_ordering::less; }
1224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #endif
1225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Swap and creation functions.
1227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // _GLIBCXX_RESOLVE_LIB_DEFECTS
1229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // 2748. swappable traits for optionals
1230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     inline enable_if_t<is_move_constructible_v<_Tp> && is_swappable_v<_Tp>>
1232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     swap(optional<_Tp>& __lhs, optional<_Tp>& __rhs)
1233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     noexcept(noexcept(__lhs.swap(__rhs)))
1234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { __lhs.swap(__rhs); }
1235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     enable_if_t<!(is_move_constructible_v<_Tp> && is_swappable_v<_Tp>)>
1238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     swap(optional<_Tp>&, optional<_Tp>&) = delete;
1239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr optional<decay_t<_Tp>>
1242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     make_optional(_Tp&& __t)
 2613              		.loc 6 1242 5 is_stmt 1 view .LVU667
 2614              	.LBB1302:
 2615              	.LBB1303:
 2616              	.LBI1303:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 2617              		.loc 6 700 2 view .LVU668
 2618              	.LBB1304:
 2619              	.LBB1305:
 2620              	.LBB1306:
 2621              	.LBI1306:
 2622              		.loc 7 76 5 view .LVU669
 2623              		.loc 7 76 5 is_stmt 0 view .LVU670
 2624              	.LBE1306:
 2625              	.LBB1307:
 2626              	.LBI1307:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 2627              		.loc 6 607 28 is_stmt 1 view .LVU671
 2628              	.LBB1308:
 2629              	.LBB1309:
 2630              	.LBB1310:
 2631              	.LBI1310:
 2632              		.loc 7 76 5 view .LVU672
 2633              		.loc 7 76 5 is_stmt 0 view .LVU673
 2634              	.LBE1310:
 2635              	.LBB1311:
 2636              	.LBI1311:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2637              		.loc 6 300 42 is_stmt 1 view .LVU674
 2638              	.LBB1312:
 2639              	.LBB1313:
 2640              	.LBB1314:
 2641              	.LBI1314:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 2642              		.loc 6 115 2 view .LVU675
 2643              	.LBB1315:
 2644              	.LBB1316:
 2645              	.LBB1317:
ARM GAS  /tmp/ccoErako.s 			page 132


 2646              	.LBI1317:
 2647              		.loc 7 76 5 view .LVU676
 2648              		.loc 7 76 5 is_stmt 0 view .LVU677
 2649              	.LBE1317:
 2650              	.LBB1318:
 2651              	.LBI1318:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 2652              		.loc 6 203 6 is_stmt 1 view .LVU678
 2653              	.LBB1319:
 2654              	.LBB1320:
 2655              	.LBB1321:
 2656              	.LBI1321:
 2657              		.loc 7 76 5 view .LVU679
 2658              		.loc 7 76 5 is_stmt 0 view .LVU680
 2659              	.LBE1321:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2660              		.loc 6 204 47 view .LVU681
 2661 011c 1B68     		ldr	r3, [r3]	@ float
 2662              	.LVL170:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2663              		.loc 6 204 47 view .LVU682
 2664 011e 0893     		str	r3, [sp, #32]	@ float
 2665              	.LVL171:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2666              		.loc 6 204 47 view .LVU683
 2667              	.LBE1320:
 2668              	.LBE1319:
 2669              	.LBE1318:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2670              		.loc 6 117 19 view .LVU684
 2671 0120 0123     		movs	r3, #1
 2672 0122 8DF82430 		strb	r3, [sp, #36]
 2673              	.LVL172:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2674              		.loc 6 117 19 view .LVU685
 2675              	.LBE1316:
 2676              	.LBE1315:
 2677              	.LBE1314:
 2678              	.LBE1313:
 2679              	.LBE1312:
 2680              	.LBE1311:
 2681              	.LBE1309:
 2682              	.LBE1308:
 2683              	.LBE1307:
 2684              	.LBE1305:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2685              		.loc 6 701 51 view .LVU686
 2686 0126 90E7     		b	.L62
 2687              	.LVL173:
 2688              	.L87:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2689              		.loc 6 701 51 view .LVU687
 2690              	.LBE1304:
 2691              	.LBE1303:
 2692              	.LBE1302:
 2693              	.LBE1301:
 2694              	.LBB1322:
ARM GAS  /tmp/ccoErako.s 			page 133


 2695              	.LBB1300:
 2696              	.LBB1298:
 2697              	.LBI1298:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 2698              		.loc 1 1287 3 is_stmt 1 view .LVU688
 2699              	.LBB1299:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 2700              		.loc 1 1289 5 view .LVU689
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2701              		.loc 1 1292 7 view .LVU690
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2702              		.loc 1 1292 33 is_stmt 0 view .LVU691
 2703 0128 1A48     		ldr	r0, .L90+4
 2704              	.LVL174:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2705              		.loc 1 1292 33 view .LVU692
 2706 012a FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 2707              	.LVL175:
 2708              	.L65:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2709              		.loc 1 1292 33 view .LVU693
 2710              	.LBE1299:
 2711              	.LBE1298:
 2712              	.LBE1300:
 2713              	.LBE1322:
 2714              	.LBB1323:
 2715              	.LBI1323:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2716              		.loc 6 692 17 is_stmt 1 view .LVU694
 2717              	.LBB1324:
 2718              	.LBB1325:
 2719              	.LBI1325:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2720              		.loc 6 602 17 view .LVU695
 2721              	.LBB1326:
 2722              	.LBI1326:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 2723              		.loc 6 302 7 view .LVU696
 2724              	.LBB1327:
 2725              	.LBI1327:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2726              		.loc 6 110 7 view .LVU697
 2727              	.LBB1328:
 2728              	.LBB1329:
 2729              	.LBI1329:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2730              		.loc 6 199 14 view .LVU698
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2731              		.loc 6 199 14 is_stmt 0 view .LVU699
 2732              	.LBE1329:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2733              		.loc 6 110 7 view .LVU700
 2734 012e 0023     		movs	r3, #0
 2735              	.LVL176:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2736              		.loc 6 110 7 view .LVU701
 2737 0130 8DF82430 		strb	r3, [sp, #36]
ARM GAS  /tmp/ccoErako.s 			page 134


 2738              	.LVL177:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2739              		.loc 6 110 7 view .LVU702
 2740 0134 89E7     		b	.L62
 2741              	.LVL178:
 2742              	.L82:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2743              		.loc 6 110 7 view .LVU703
 2744              	.LBE1328:
 2745              	.LBE1327:
 2746              	.LBE1326:
 2747              	.LBE1325:
 2748              	.LBE1324:
 2749              	.LBE1323:
 2750              	.LBE1287:
 2751              	.LBB1330:
 2752              	.LBB1267:
 2753              	.LBB1265:
 2754              	.LBI1265:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 2755              		.loc 1 1287 3 is_stmt 1 view .LVU704
 2756              	.LBB1266:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 2757              		.loc 1 1289 5 view .LVU705
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2758              		.loc 1 1292 7 view .LVU706
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2759              		.loc 1 1292 33 is_stmt 0 view .LVU707
 2760 0136 1748     		ldr	r0, .L90+4
 2761 0138 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 2762              	.LVL179:
 2763              	.L77:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2764              		.loc 1 1292 33 view .LVU708
 2765              	.LBE1266:
 2766              	.LBE1265:
 2767              	.LBE1267:
 2768              	.LBE1330:
 2769              	.LBE1375:
 2770              	.LBE1376:
 2771              	.LBE1518:
 2772              	.LBB1519:
 2773              	.LBB1381:
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : static_cast<_Tp>(std::forward<_Up>(__u));
 2774              		.loc 6 970 6 view .LVU709
 2775 013c 0023     		movs	r3, #0
 2776 013e 89E7     		b	.L67
 2777              	.LVL180:
 2778              	.L83:
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : static_cast<_Tp>(std::forward<_Up>(__u));
 2779              		.loc 6 970 6 view .LVU710
 2780              	.LBE1381:
 2781              	.LBE1519:
 2782              	.LBB1520:
 2783              	.LBB1509:
 2784              	.LBB1464:
 2785              	.LBB1465:
ARM GAS  /tmp/ccoErako.s 			page 135


 2786              	.LBI1465:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2787              		.loc 1 1661 5 is_stmt 1 view .LVU711
 2788              	.LBB1466:
 2789              	.LBB1467:
 2790              	.LBI1467:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 2791              		.loc 1 1571 24 view .LVU712
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 2792              		.loc 1 1571 24 is_stmt 0 view .LVU713
 2793              	.LBE1467:
 2794              		.loc 1 1665 7 view .LVU714
 2795 0140 07D1     		bne	.L88
 2796              	.LVL181:
 2797              	.LBB1468:
 2798              	.LBI1468:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2799              		.loc 1 276 5 is_stmt 1 view .LVU715
 2800              	.LBB1469:
 2801              	.LBB1470:
 2802              	.LBI1470:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2803              		.loc 1 267 5 view .LVU716
 2804              	.LBB1471:
 2805              	.LBB1472:
 2806              	.LBI1472:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2807              		.loc 1 267 5 view .LVU717
 2808              	.LBB1473:
 2809              	.LBB1474:
 2810              	.LBI1474:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 2811              		.loc 1 262 5 view .LVU718
 2812              	.LBB1475:
 2813              	.LBI1475:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2814              		.loc 1 222 24 view .LVU719
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2815              		.loc 1 222 24 is_stmt 0 view .LVU720
 2816              	.LBE1475:
 2817              	.LBE1474:
 2818              	.LBE1473:
 2819              	.LBE1472:
 2820              	.LBE1471:
 2821              	.LBE1470:
 2822              	.LBE1469:
 2823              	.LBE1468:
 2824              	.LBE1466:
 2825              	.LBE1465:
 167:./MotorControl/component.hpp ****             return ptr ? ptr->any() : std::nullopt;
 2826              		.loc 5 167 28 view .LVU721
 2827 0142 4358     		ldr	r3, [r0, r1]
 2828              	.LVL182:
 168:./MotorControl/component.hpp ****         } else if (content_.index() == 1) {
 2829              		.loc 5 168 44 view .LVU722
 2830 0144 43B1     		cbz	r3, .L70
 2831              	.LVL183:
ARM GAS  /tmp/ccoErako.s 			page 136


 2832              	.LBB1479:
 2833              	.LBI1479:
 102:./MotorControl/component.hpp ****         return content_;
 2834              		.loc 5 102 22 is_stmt 1 view .LVU723
 2835              	.LBB1480:
 2836              	.LBB1481:
 2837              	.LBI1481:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 2838              		.loc 6 700 2 view .LVU724
 2839              	.LBB1482:
 2840              	.LBB1483:
 2841              	.LBB1484:
 2842              	.LBI1484:
 2843              		.loc 7 76 5 view .LVU725
 2844              		.loc 7 76 5 is_stmt 0 view .LVU726
 2845              	.LBE1484:
 2846              	.LBB1485:
 2847              	.LBI1485:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 2848              		.loc 6 607 28 is_stmt 1 view .LVU727
 2849              	.LBB1486:
 2850              	.LBB1487:
 2851              	.LBB1488:
 2852              	.LBI1488:
 2853              		.loc 7 76 5 view .LVU728
 2854              		.loc 7 76 5 is_stmt 0 view .LVU729
 2855              	.LBE1488:
 2856              	.LBB1489:
 2857              	.LBI1489:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2858              		.loc 6 300 42 is_stmt 1 view .LVU730
 2859              	.LBB1490:
 2860              	.LBB1491:
 2861              	.LBB1492:
 2862              	.LBI1492:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 2863              		.loc 6 115 2 view .LVU731
 2864              	.LBB1493:
 2865              	.LBB1494:
 2866              	.LBB1495:
 2867              	.LBI1495:
 2868              		.loc 7 76 5 view .LVU732
 2869              		.loc 7 76 5 is_stmt 0 view .LVU733
 2870              	.LBE1495:
 2871              	.LBB1496:
 2872              	.LBI1496:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 2873              		.loc 6 203 6 is_stmt 1 view .LVU734
 2874              	.LBB1497:
 2875              	.LBB1498:
 2876              	.LBB1499:
 2877              	.LBI1499:
 2878              		.loc 7 76 5 view .LVU735
 2879              		.loc 7 76 5 is_stmt 0 view .LVU736
 2880              	.LBE1499:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2881              		.loc 6 204 47 view .LVU737
ARM GAS  /tmp/ccoErako.s 			page 137


 2882 0146 5B68     		ldr	r3, [r3, #4]	@ float
 2883              	.LVL184:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2884              		.loc 6 204 47 view .LVU738
 2885 0148 0A93     		str	r3, [sp, #40]	@ float
 2886              	.LVL185:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2887              		.loc 6 204 47 view .LVU739
 2888              	.LBE1498:
 2889              	.LBE1497:
 2890              	.LBE1496:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2891              		.loc 6 117 19 view .LVU740
 2892 014a 0123     		movs	r3, #1
 2893 014c 8DF82C30 		strb	r3, [sp, #44]
 2894              	.LVL186:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2895              		.loc 6 117 19 view .LVU741
 2896              	.LBE1494:
 2897              	.LBE1493:
 2898              	.LBE1492:
 2899              	.LBE1491:
 2900              	.LBE1490:
 2901              	.LBE1489:
 2902              	.LBE1487:
 2903              	.LBE1486:
 2904              	.LBE1485:
 2905              	.LBE1483:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2906              		.loc 6 701 51 view .LVU742
 2907 0150 ACE7     		b	.L71
 2908              	.LVL187:
 2909              	.L88:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2910              		.loc 6 701 51 view .LVU743
 2911              	.LBE1482:
 2912              	.LBE1481:
 2913              	.LBE1480:
 2914              	.LBE1479:
 2915              	.LBB1500:
 2916              	.LBB1478:
 2917              	.LBB1476:
 2918              	.LBI1476:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 2919              		.loc 1 1287 3 is_stmt 1 view .LVU744
 2920              	.LBB1477:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 2921              		.loc 1 1289 5 view .LVU745
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2922              		.loc 1 1292 7 view .LVU746
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2923              		.loc 1 1292 33 is_stmt 0 view .LVU747
 2924 0152 1048     		ldr	r0, .L90+4
 2925 0154 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 2926              	.LVL188:
 2927              	.L70:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
ARM GAS  /tmp/ccoErako.s 			page 138


 2928              		.loc 1 1292 33 view .LVU748
 2929              	.LBE1477:
 2930              	.LBE1476:
 2931              	.LBE1478:
 2932              	.LBE1500:
 2933              	.LBB1501:
 2934              	.LBI1501:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2935              		.loc 6 692 17 is_stmt 1 view .LVU749
 2936              	.LBB1502:
 2937              	.LBB1503:
 2938              	.LBI1503:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2939              		.loc 6 602 17 view .LVU750
 2940              	.LBB1504:
 2941              	.LBI1504:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 2942              		.loc 6 302 7 view .LVU751
 2943              	.LBB1505:
 2944              	.LBI1505:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2945              		.loc 6 110 7 view .LVU752
 2946              	.LBB1506:
 2947              	.LBB1507:
 2948              	.LBI1507:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2949              		.loc 6 199 14 view .LVU753
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2950              		.loc 6 199 14 is_stmt 0 view .LVU754
 2951              	.LBE1507:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2952              		.loc 6 110 7 view .LVU755
 2953 0158 0023     		movs	r3, #0
 2954              	.LVL189:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2955              		.loc 6 110 7 view .LVU756
 2956 015a 8DF82C30 		strb	r3, [sp, #44]
 2957              	.LVL190:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2958              		.loc 6 110 7 view .LVU757
 2959 015e A5E7     		b	.L71
 2960              	.LVL191:
 2961              	.L84:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2962              		.loc 6 110 7 view .LVU758
 2963              	.LBE1506:
 2964              	.LBE1505:
 2965              	.LBE1504:
 2966              	.LBE1503:
 2967              	.LBE1502:
 2968              	.LBE1501:
 2969              	.LBE1464:
 2970              	.LBB1508:
 2971              	.LBB1420:
 2972              	.LBB1421:
 2973              	.LBI1421:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
ARM GAS  /tmp/ccoErako.s 			page 139


 2974              		.loc 1 1661 5 is_stmt 1 view .LVU759
 2975              	.LBB1422:
 2976              	.LBB1423:
 2977              	.LBI1423:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 2978              		.loc 1 1571 24 view .LVU760
 2979              	.LBB1424:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 2980              		.loc 1 1575 17 is_stmt 0 view .LVU761
 2981 0160 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2982              	.LVL192:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 2983              		.loc 1 1575 17 view .LVU762
 2984              	.LBE1424:
 2985              	.LBE1423:
 2986              		.loc 1 1665 7 view .LVU763
 2987 0162 012B     		cmp	r3, #1
 2988 0164 07D1     		bne	.L89
 2989              	.LVL193:
 2990              	.LBB1425:
 2991              	.LBI1425:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2992              		.loc 1 276 5 is_stmt 1 view .LVU764
 2993              	.LBB1426:
 2994              	.LBB1427:
 2995              	.LBI1427:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2996              		.loc 1 267 5 view .LVU765
 2997              	.LBB1428:
 2998              	.LBB1429:
 2999              	.LBI1429:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 3000              		.loc 1 262 5 view .LVU766
 3001              	.LBB1430:
 3002              	.LBI1430:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 3003              		.loc 1 222 24 view .LVU767
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 3004              		.loc 1 222 24 is_stmt 0 view .LVU768
 3005              	.LBE1430:
 3006              	.LBE1429:
 3007              	.LBE1428:
 3008              	.LBE1427:
 3009              	.LBE1426:
 3010              	.LBE1425:
 3011              	.LBE1422:
 3012              	.LBE1421:
 170:./MotorControl/component.hpp ****             return ptr ? std::make_optional(*ptr) : std::nullopt;
 3013              		.loc 5 170 16 view .LVU769
 3014 0166 4358     		ldr	r3, [r0, r1]
 3015              	.LVL194:
 3016              		.loc 5 171 58 view .LVU770
 3017 0168 43B1     		cbz	r3, .L74
 3018              	.LVL195:
 3019              	.LBB1434:
 3020              	.LBI1434:
 3021              		.loc 6 1242 5 is_stmt 1 view .LVU771
ARM GAS  /tmp/ccoErako.s 			page 140


 3022              	.LBB1435:
 3023              	.LBB1436:
 3024              	.LBI1436:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 3025              		.loc 6 700 2 view .LVU772
 3026              	.LBB1437:
 3027              	.LBB1438:
 3028              	.LBB1439:
 3029              	.LBI1439:
 3030              		.loc 7 76 5 view .LVU773
 3031              		.loc 7 76 5 is_stmt 0 view .LVU774
 3032              	.LBE1439:
 3033              	.LBB1440:
 3034              	.LBI1440:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 3035              		.loc 6 607 28 is_stmt 1 view .LVU775
 3036              	.LBB1441:
 3037              	.LBB1442:
 3038              	.LBB1443:
 3039              	.LBI1443:
 3040              		.loc 7 76 5 view .LVU776
 3041              		.loc 7 76 5 is_stmt 0 view .LVU777
 3042              	.LBE1443:
 3043              	.LBB1444:
 3044              	.LBI1444:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3045              		.loc 6 300 42 is_stmt 1 view .LVU778
 3046              	.LBB1445:
 3047              	.LBB1446:
 3048              	.LBB1447:
 3049              	.LBI1447:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 3050              		.loc 6 115 2 view .LVU779
 3051              	.LBB1448:
 3052              	.LBB1449:
 3053              	.LBB1450:
 3054              	.LBI1450:
 3055              		.loc 7 76 5 view .LVU780
 3056              		.loc 7 76 5 is_stmt 0 view .LVU781
 3057              	.LBE1450:
 3058              	.LBB1451:
 3059              	.LBI1451:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 3060              		.loc 6 203 6 is_stmt 1 view .LVU782
 3061              	.LBB1452:
 3062              	.LBB1453:
 3063              	.LBB1454:
 3064              	.LBI1454:
 3065              		.loc 7 76 5 view .LVU783
 3066              		.loc 7 76 5 is_stmt 0 view .LVU784
 3067              	.LBE1454:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 3068              		.loc 6 204 47 view .LVU785
 3069 016a 1B68     		ldr	r3, [r3]	@ float
 3070              	.LVL196:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 3071              		.loc 6 204 47 view .LVU786
ARM GAS  /tmp/ccoErako.s 			page 141


 3072 016c 0A93     		str	r3, [sp, #40]	@ float
 3073              	.LVL197:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 3074              		.loc 6 204 47 view .LVU787
 3075              	.LBE1453:
 3076              	.LBE1452:
 3077              	.LBE1451:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 3078              		.loc 6 117 19 view .LVU788
 3079 016e 0123     		movs	r3, #1
 3080 0170 8DF82C30 		strb	r3, [sp, #44]
 3081              	.LVL198:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 3082              		.loc 6 117 19 view .LVU789
 3083              	.LBE1449:
 3084              	.LBE1448:
 3085              	.LBE1447:
 3086              	.LBE1446:
 3087              	.LBE1445:
 3088              	.LBE1444:
 3089              	.LBE1442:
 3090              	.LBE1441:
 3091              	.LBE1440:
 3092              	.LBE1438:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3093              		.loc 6 701 51 view .LVU790
 3094 0174 9AE7     		b	.L71
 3095              	.LVL199:
 3096              	.L89:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3097              		.loc 6 701 51 view .LVU791
 3098              	.LBE1437:
 3099              	.LBE1436:
 3100              	.LBE1435:
 3101              	.LBE1434:
 3102              	.LBB1455:
 3103              	.LBB1433:
 3104              	.LBB1431:
 3105              	.LBI1431:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 3106              		.loc 1 1287 3 is_stmt 1 view .LVU792
 3107              	.LBB1432:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 3108              		.loc 1 1289 5 view .LVU793
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 3109              		.loc 1 1292 7 view .LVU794
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 3110              		.loc 1 1292 33 is_stmt 0 view .LVU795
 3111 0176 0748     		ldr	r0, .L90+4
 3112              	.LVL200:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 3113              		.loc 1 1292 33 view .LVU796
 3114 0178 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 3115              	.LVL201:
 3116              	.L74:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 3117              		.loc 1 1292 33 view .LVU797
ARM GAS  /tmp/ccoErako.s 			page 142


 3118              	.LBE1432:
 3119              	.LBE1431:
 3120              	.LBE1433:
 3121              	.LBE1455:
 3122              	.LBB1456:
 3123              	.LBI1456:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3124              		.loc 6 692 17 is_stmt 1 view .LVU798
 3125              	.LBB1457:
 3126              	.LBB1458:
 3127              	.LBI1458:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3128              		.loc 6 602 17 view .LVU799
 3129              	.LBB1459:
 3130              	.LBI1459:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 3131              		.loc 6 302 7 view .LVU800
 3132              	.LBB1460:
 3133              	.LBI1460:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 3134              		.loc 6 110 7 view .LVU801
 3135              	.LBB1461:
 3136              	.LBB1462:
 3137              	.LBI1462:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3138              		.loc 6 199 14 view .LVU802
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3139              		.loc 6 199 14 is_stmt 0 view .LVU803
 3140              	.LBE1462:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 3141              		.loc 6 110 7 view .LVU804
 3142 017c 0023     		movs	r3, #0
 3143              	.LVL202:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 3144              		.loc 6 110 7 view .LVU805
 3145 017e 8DF82C30 		strb	r3, [sp, #44]
 3146              	.LVL203:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 3147              		.loc 6 110 7 view .LVU806
 3148 0182 93E7     		b	.L71
 3149              	.LVL204:
 3150              	.L85:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 3151              		.loc 6 110 7 view .LVU807
 3152              	.LBE1461:
 3153              	.LBE1460:
 3154              	.LBE1459:
 3155              	.LBE1458:
 3156              	.LBE1457:
 3157              	.LBE1456:
 3158              	.LBE1420:
 3159              	.LBB1463:
 3160              	.LBB1400:
 3161              	.LBB1398:
 3162              	.LBI1398:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 3163              		.loc 1 1287 3 is_stmt 1 view .LVU808
ARM GAS  /tmp/ccoErako.s 			page 143


 3164              	.LBB1399:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 3165              		.loc 1 1289 5 view .LVU809
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 3166              		.loc 1 1292 7 view .LVU810
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 3167              		.loc 1 1292 33 is_stmt 0 view .LVU811
 3168 0184 0348     		ldr	r0, .L90+4
 3169 0186 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 3170              	.LVL205:
 3171              	.L78:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 3172              		.loc 1 1292 33 view .LVU812
 3173              	.LBE1399:
 3174              	.LBE1398:
 3175              	.LBE1400:
 3176              	.LBE1463:
 3177              	.LBE1508:
 3178              	.LBE1509:
 3179              	.LBE1520:
 3180              	.LBB1521:
 3181              	.LBB1514:
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : static_cast<_Tp>(std::forward<_Up>(__u));
 3182              		.loc 6 970 6 view .LVU813
 3183 018a 0023     		movs	r3, #0
 3184 018c 93E7     		b	.L76
 3185              	.L91:
 3186 018e 00BF     		.align	2
 3187              	.L90:
 3188 0190 00000000 		.word	.LANCHOR0
 3189 0194 00000000 		.word	.LC1
 3190              	.LBE1514:
 3191              	.LBE1521:
 3192              		.cfi_endproc
 3193              	.LFE5217:
 3194              		.fnend
 3196              		.section	.text._ZoRRN10ODriveIntf8AxisIntf5ErrorES1_,"axG",%progbits,_ZoRRN10ODriveIntf8AxisIntf5E
 3197              		.align	1
 3198              		.weak	_ZoRRN10ODriveIntf8AxisIntf5ErrorES1_
 3199              		.syntax unified
 3200              		.thumb
 3201              		.thumb_func
 3203              	_ZoRRN10ODriveIntf8AxisIntf5ErrorES1_:
 3204              		.fnstart
 3205              	.LVL206:
 3206              	.LFB4969:
 3207              		.file 11 "./autogen/interfaces.hpp"
   1:./autogen/interfaces.hpp **** /*
   2:./autogen/interfaces.hpp ****  * ============================ WARNING ============================
   3:./autogen/interfaces.hpp ****  * ==== This is an autogenerated file.                          ====
   4:./autogen/interfaces.hpp ****  * ==== Any changes to this file will be lost when recompiling. ====
   5:./autogen/interfaces.hpp ****  * =================================================================
   6:./autogen/interfaces.hpp ****  *
   7:./autogen/interfaces.hpp ****  * This file contains base classes that correspond to the interfaces defined in
   8:./autogen/interfaces.hpp ****  * your interface file. The objects you publish should inherit from these
   9:./autogen/interfaces.hpp ****  * interfaces.
  10:./autogen/interfaces.hpp ****  *
ARM GAS  /tmp/ccoErako.s 			page 144


  11:./autogen/interfaces.hpp ****  */
  12:./autogen/interfaces.hpp **** #ifndef __FIBRE_INTERFACES_HPP
  13:./autogen/interfaces.hpp **** #define __FIBRE_INTERFACES_HPP
  14:./autogen/interfaces.hpp **** 
  15:./autogen/interfaces.hpp **** #include <tuple>
  16:./autogen/interfaces.hpp **** using float2D = std::pair<float, float>;
  17:./autogen/interfaces.hpp **** struct Iph_ABC_t { float phA; float phB; float phC; };
  18:./autogen/interfaces.hpp **** 
  19:./autogen/interfaces.hpp **** 
  20:./autogen/interfaces.hpp **** #include <fibre/../../protocol.hpp>
  21:./autogen/interfaces.hpp **** 
  22:./autogen/interfaces.hpp **** #pragma GCC push_options
  23:./autogen/interfaces.hpp **** #pragma GCC optimize ("s")
  24:./autogen/interfaces.hpp **** 
  25:./autogen/interfaces.hpp **** 
  26:./autogen/interfaces.hpp **** 
  27:./autogen/interfaces.hpp **** class ODriveIntf {
  28:./autogen/interfaces.hpp **** public:
  29:./autogen/interfaces.hpp ****     class ConfigIntf {
  30:./autogen/interfaces.hpp ****     public:
  31:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_a(T* obj) { return Property<bool>{&
  32:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_a(T* obj, void* ptr) { new (ptr) Pr
  33:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_b(T* obj) { return Property<bool>{&
  34:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_b(T* obj, void* ptr) { new (ptr) Pr
  35:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_c(T* obj) { return Property<bool>{&
  36:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_c(T* obj, void* ptr) { new (ptr) Pr
  37:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_a_baudrate(T* obj) { return Property<uint3
  38:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_a_baudrate(T* obj, void* ptr) { new (ptr) 
  39:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_b_baudrate(T* obj) { return Property<uint3
  40:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_b_baudrate(T* obj, void* ptr) { new (ptr) 
  41:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_c_baudrate(T* obj) { return Property<uint3
  42:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_c_baudrate(T* obj, void* ptr) { new (ptr) 
  43:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_can_a(T* obj) { return Property<bool>{&o
  44:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_can_a(T* obj, void* ptr) { new (ptr) Pro
  45:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_i2c_a(T* obj) { return Property<bool>{&o
  46:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_i2c_a(T* obj, void* ptr) { new (ptr) Pro
  47:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_usb_cdc_protocol(T* obj) { return Property<ODri
  48:./autogen/interfaces.hpp ****         template<typename T> static inline void get_usb_cdc_protocol(T* obj, void* ptr) { new (ptr)
  49:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart0_protocol(T* obj) { return Property<ODrive
  50:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart0_protocol(T* obj, void* ptr) { new (ptr) P
  51:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart1_protocol(T* obj) { return Property<ODrive
  52:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart1_protocol(T* obj, void* ptr) { new (ptr) P
  53:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart2_protocol(T* obj) { return Property<ODrive
  54:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart2_protocol(T* obj, void* ptr) { new (ptr) P
  55:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_regen_current(T* obj) { return Property<flo
  56:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_regen_current(T* obj, void* ptr) { new (ptr
  57:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_brake_resistance(T* obj) { return Property<floa
  58:./autogen/interfaces.hpp ****         template<typename T> static inline void get_brake_resistance(T* obj, void* ptr) { new (ptr)
  59:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_brake_resistor(T* obj) { return Property
  60:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_brake_resistor(T* obj, void* ptr) { new 
  61:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_undervoltage_trip_level(T* obj) { return
  62:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_undervoltage_trip_level(T* obj, void* pt
  63:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_trip_level(T* obj) { return 
  64:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_trip_level(T* obj, void* ptr
  65:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_dc_bus_overvoltage_ramp(T* obj) { return
  66:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_dc_bus_overvoltage_ramp(T* obj, void* pt
  67:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_ramp_start(T* obj) { return 
ARM GAS  /tmp/ccoErako.s 			page 145


  68:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_ramp_start(T* obj, void* ptr
  69:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_ramp_end(T* obj) { return Pr
  70:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_ramp_end(T* obj, void* ptr) 
  71:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_max_positive_current(T* obj) { return Proper
  72:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_max_positive_current(T* obj, void* ptr) { ne
  73:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_max_negative_current(T* obj) { return Proper
  74:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_max_negative_current(T* obj, void* ptr) { ne
  75:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error_gpio_pin(T* obj) { return Property<uint32
  76:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error_gpio_pin(T* obj, void* ptr) { new (ptr) P
  77:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio3_analog_mapping(T* obj) { return &obj->ana
  78:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio4_analog_mapping(T* obj) { return &obj->ana
  79:./autogen/interfaces.hpp ****     };
  80:./autogen/interfaces.hpp ****     class CanIntf {
  81:./autogen/interfaces.hpp ****     public:
  82:./autogen/interfaces.hpp ****         class ConfigIntf {
  83:./autogen/interfaces.hpp ****         public:
  84:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_baud_rate(T* obj) { return Property<uint32_
  85:./autogen/interfaces.hpp ****             template<typename T> static inline void get_baud_rate(T* obj, void* ptr) { new (ptr) Pr
  86:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_protocol(T* obj) { return Property<ODriveIn
  87:./autogen/interfaces.hpp ****             template<typename T> static inline void get_protocol(T* obj, void* ptr) { new (ptr) Pro
  88:./autogen/interfaces.hpp ****         };
  89:./autogen/interfaces.hpp ****         enum Error {
  90:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
  91:./autogen/interfaces.hpp ****             ERROR_DUPLICATE_CAN_IDS          = 0x00000001,
  92:./autogen/interfaces.hpp ****         };
  93:./autogen/interfaces.hpp ****         enum Protocol {
  94:./autogen/interfaces.hpp ****             PROTOCOL_SIMPLE                  = 0x00000001,
  95:./autogen/interfaces.hpp ****         };
  96:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Can
  97:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
  98:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
  99:./autogen/interfaces.hpp ****     };
 100:./autogen/interfaces.hpp ****     class EndpointIntf {
 101:./autogen/interfaces.hpp ****     public:
 102:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_endpoint(T* obj) { return Property<endpoint_ref
 103:./autogen/interfaces.hpp ****         template<typename T> static inline void get_endpoint(T* obj, void* ptr) { new (ptr) Propert
 104:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_min(T* obj) { return Property<float>{&obj->min}
 105:./autogen/interfaces.hpp ****         template<typename T> static inline void get_min(T* obj, void* ptr) { new (ptr) Property<flo
 106:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max(T* obj) { return Property<float>{&obj->max}
 107:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max(T* obj, void* ptr) { new (ptr) Property<flo
 108:./autogen/interfaces.hpp ****     };
 109:./autogen/interfaces.hpp ****     class AxisIntf {
 110:./autogen/interfaces.hpp ****     public:
 111:./autogen/interfaces.hpp ****         class LockinConfigIntf {
 112:./autogen/interfaces.hpp ****         public:
 113:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current(T* obj) { return Property<float>{&o
 114:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current(T* obj, void* ptr) { new (ptr) Prop
 115:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ramp_time(T* obj) { return Property<float>{
 116:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ramp_time(T* obj, void* ptr) { new (ptr) Pr
 117:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ramp_distance(T* obj) { return Property<flo
 118:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ramp_distance(T* obj, void* ptr) { new (ptr
 119:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_accel(T* obj) { return Property<float>{&obj
 120:./autogen/interfaces.hpp ****             template<typename T> static inline void get_accel(T* obj, void* ptr) { new (ptr) Proper
 121:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel(T* obj) { return Property<float>{&obj->
 122:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel(T* obj, void* ptr) { new (ptr) Property
 123:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_distance(T* obj) { return Property<f
 124:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_distance(T* obj, void* ptr) { new (p
ARM GAS  /tmp/ccoErako.s 			page 146


 125:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_vel(T* obj) { return Property<boo
 126:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_vel(T* obj, void* ptr) { new (ptr
 127:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_distance(T* obj) { return Propert
 128:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_distance(T* obj, void* ptr) { new
 129:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_enc_idx(T* obj) { return Property
 130:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_enc_idx(T* obj, void* ptr) { new 
 131:./autogen/interfaces.hpp ****         };
 132:./autogen/interfaces.hpp ****         class CanConfigIntf {
 133:./autogen/interfaces.hpp ****         public:
 134:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_node_id(T* obj) { return Property<uint32_t>
 135:./autogen/interfaces.hpp ****             template<typename T> static inline void get_node_id(T* obj, void* ptr) { new (ptr) Prop
 136:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_is_extended(T* obj) { return Property<bool>
 137:./autogen/interfaces.hpp ****             template<typename T> static inline void get_is_extended(T* obj, void* ptr) { new (ptr) 
 138:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_heartbeat_rate_ms(T* obj) { return Property
 139:./autogen/interfaces.hpp ****             template<typename T> static inline void get_heartbeat_rate_ms(T* obj, void* ptr) { new 
 140:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_rate_ms(T* obj) { return Property<u
 141:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_rate_ms(T* obj, void* ptr) { new (p
 142:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_error_rate_ms(T* obj) { return Proper
 143:./autogen/interfaces.hpp ****             template<typename T> static inline void get_motor_error_rate_ms(T* obj, void* ptr) { ne
 144:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_error_rate_ms(T* obj) { return Prop
 145:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_error_rate_ms(T* obj, void* ptr) { 
 146:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_controller_error_rate_ms(T* obj) { return P
 147:./autogen/interfaces.hpp ****             template<typename T> static inline void get_controller_error_rate_ms(T* obj, void* ptr)
 148:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_error_rate_ms(T* obj) { return P
 149:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sensorless_error_rate_ms(T* obj, void* ptr)
 150:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_count_rate_ms(T* obj) { return Prop
 151:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_count_rate_ms(T* obj, void* ptr) { 
 152:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_iq_rate_ms(T* obj) { return Property<uint32
 153:./autogen/interfaces.hpp ****             template<typename T> static inline void get_iq_rate_ms(T* obj, void* ptr) { new (ptr) P
 154:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_rate_ms(T* obj) { return Propert
 155:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sensorless_rate_ms(T* obj, void* ptr) { new
 156:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bus_vi_rate_ms(T* obj) { return Property<ui
 157:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bus_vi_rate_ms(T* obj, void* ptr) { new (pt
 158:./autogen/interfaces.hpp ****         };
 159:./autogen/interfaces.hpp ****         class ConfigIntf {
 160:./autogen/interfaces.hpp ****         public:
 161:./autogen/interfaces.hpp ****             class CalibrationLockinIntf {
 162:./autogen/interfaces.hpp ****             public:
 163:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_current(T* obj) { return Property<float
 164:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_current(T* obj, void* ptr) { new (ptr) 
 165:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_ramp_time(T* obj) { return Property<flo
 166:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_ramp_time(T* obj, void* ptr) { new (ptr
 167:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_ramp_distance(T* obj) { return Property
 168:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_ramp_distance(T* obj, void* ptr) { new 
 169:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_accel(T* obj) { return Property<float>{
 170:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_accel(T* obj, void* ptr) { new (ptr) Pr
 171:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_vel(T* obj) { return Property<float>{&o
 172:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_vel(T* obj, void* ptr) { new (ptr) Prop
 173:./autogen/interfaces.hpp ****             };
 174:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_motor_calibration(T* obj) { return 
 175:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_motor_calibration(T* obj, void* ptr
 176:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_encoder_index_search(T* obj) { retu
 177:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_encoder_index_search(T* obj, void* 
 178:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_encoder_offset_calibration(T* obj) 
 179:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_encoder_offset_calibration(T* obj, 
 180:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_closed_loop_control(T* obj) { retur
 181:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_closed_loop_control(T* obj, void* p
ARM GAS  /tmp/ccoErako.s 			page 147


 182:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_homing(T* obj) { return Property<bo
 183:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_homing(T* obj, void* ptr) { new (pt
 184:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_step_dir(T* obj) { return Property<b
 185:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_step_dir(T* obj, void* ptr) { new (p
 186:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_step_dir_always_on(T* obj) { return Propert
 187:./autogen/interfaces.hpp ****             template<typename T> static inline void get_step_dir_always_on(T* obj, void* ptr) { new
 188:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_sensorless_mode(T* obj) { return Pro
 189:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_sensorless_mode(T* obj, void* ptr) {
 190:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_watchdog_timeout(T* obj) { return Property<
 191:./autogen/interfaces.hpp ****             template<typename T> static inline void get_watchdog_timeout(T* obj, void* ptr) { new (
 192:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_watchdog(T* obj) { return Property<b
 193:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_watchdog(T* obj, void* ptr) { new (p
 194:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_step_gpio_pin(T* obj) { return Property<uin
 195:./autogen/interfaces.hpp ****             template<typename T> static inline void get_step_gpio_pin(T* obj, void* ptr) { new (ptr
 196:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dir_gpio_pin(T* obj) { return Property<uint
 197:./autogen/interfaces.hpp ****             template<typename T> static inline void get_dir_gpio_pin(T* obj, void* ptr) { new (ptr)
 198:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calibration_lockin(T* obj) { return &obj->c
 199:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_ramp(T* obj) { return &obj->sens
 200:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_general_lockin(T* obj) { return &obj->gener
 201:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_can(T* obj) { return &obj->can; }
 202:./autogen/interfaces.hpp ****         };
 203:./autogen/interfaces.hpp ****         class TaskTimesIntf {
 204:./autogen/interfaces.hpp ****         public:
 205:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_thermistor_update(T* obj) { return &obj->th
 206:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_update(T* obj) { return &obj->encod
 207:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_estimator_update(T* obj) { retur
 208:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_endstop_update(T* obj) { return &obj->endst
 209:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_can_heartbeat(T* obj) { return &obj->can_he
 210:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_controller_update(T* obj) { return &obj->co
 211:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_open_loop_controller_update(T* obj) { retur
 212:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_estimator_update(T* obj) { return &obj
 213:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_update(T* obj) { return &obj->motor_u
 214:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_controller_update(T* obj) { return 
 215:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dc_calib(T* obj) { return &obj->dc_calib; }
 216:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_sense(T* obj) { return &obj->curren
 217:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pwm_update(T* obj) { return &obj->pwm_updat
 218:./autogen/interfaces.hpp ****         };
 219:./autogen/interfaces.hpp ****         enum Error {
 220:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 221:./autogen/interfaces.hpp ****             ERROR_INVALID_STATE              = 0x00000001,
 222:./autogen/interfaces.hpp ****             ERROR_MOTOR_FAILED               = 0x00000040,
 223:./autogen/interfaces.hpp ****             ERROR_SENSORLESS_ESTIMATOR_FAILED = 0x00000080,
 224:./autogen/interfaces.hpp ****             ERROR_ENCODER_FAILED             = 0x00000100,
 225:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_FAILED          = 0x00000200,
 226:./autogen/interfaces.hpp ****             ERROR_WATCHDOG_TIMER_EXPIRED     = 0x00000800,
 227:./autogen/interfaces.hpp ****             ERROR_MIN_ENDSTOP_PRESSED        = 0x00001000,
 228:./autogen/interfaces.hpp ****             ERROR_MAX_ENDSTOP_PRESSED        = 0x00002000,
 229:./autogen/interfaces.hpp ****             ERROR_ESTOP_REQUESTED            = 0x00004000,
 230:./autogen/interfaces.hpp ****             ERROR_HOMING_WITHOUT_ENDSTOP     = 0x00020000,
 231:./autogen/interfaces.hpp ****             ERROR_OVER_TEMP                  = 0x00040000,
 232:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_POSITION           = 0x00080000,
 233:./autogen/interfaces.hpp ****         };
 234:./autogen/interfaces.hpp ****         enum AxisState {
 235:./autogen/interfaces.hpp ****             AXIS_STATE_UNDEFINED             = 0,
 236:./autogen/interfaces.hpp ****             AXIS_STATE_IDLE                  = 1,
 237:./autogen/interfaces.hpp ****             AXIS_STATE_STARTUP_SEQUENCE      = 2,
 238:./autogen/interfaces.hpp ****             AXIS_STATE_FULL_CALIBRATION_SEQUENCE = 3,
ARM GAS  /tmp/ccoErako.s 			page 148


 239:./autogen/interfaces.hpp ****             AXIS_STATE_MOTOR_CALIBRATION     = 4,
 240:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_INDEX_SEARCH  = 6,
 241:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_OFFSET_CALIBRATION = 7,
 242:./autogen/interfaces.hpp ****             AXIS_STATE_CLOSED_LOOP_CONTROL   = 8,
 243:./autogen/interfaces.hpp ****             AXIS_STATE_LOCKIN_SPIN           = 9,
 244:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_DIR_FIND      = 10,
 245:./autogen/interfaces.hpp ****             AXIS_STATE_HOMING                = 11,
 246:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_HALL_POLARITY_CALIBRATION = 12,
 247:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_HALL_PHASE_CALIBRATION = 13,
 248:./autogen/interfaces.hpp ****         };
 249:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Axi
 250:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 251:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_step_dir_active(T* obj) { return Property<const
 252:./autogen/interfaces.hpp ****         template<typename T> static inline void get_step_dir_active(T* obj, void* ptr) { new (ptr) 
 253:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_drv_fault(T* obj) { return Property<const 
 254:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_drv_fault(T* obj, void* ptr) { new (ptr) P
 255:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_steps(T* obj) { return Property<const int64_t>{
 256:./autogen/interfaces.hpp ****         template<typename T> static inline void get_steps(T* obj, void* ptr) { new (ptr) Property<c
 257:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_state(T* obj) { return Property<const O
 258:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_state(T* obj, void* ptr) { new (ptr) Pr
 259:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_requested_state(T* obj) { return Property<ODriv
 260:./autogen/interfaces.hpp ****         template<typename T> static inline void get_requested_state(T* obj, void* ptr) { new (ptr) 
 261:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_homed(T* obj) { return Property<bool>{&obj->
 262:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_homed(T* obj, void* ptr) { new (ptr) Propert
 263:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 264:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_motor(T* obj) { return &obj->motor_; }
 265:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_controller(T* obj) { return &obj->controller_; 
 266:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_encoder(T* obj) { return &obj->encoder_; }
 267:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_acim_estimator(T* obj) { return &obj->acim_esti
 268:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_sensorless_estimator(T* obj) { return &obj->sen
 269:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_trap_traj(T* obj) { return &obj->trap_traj_; }
 270:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_min_endstop(T* obj) { return &obj->min_endstop_
 271:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_endstop(T* obj) { return &obj->max_endstop_
 272:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_mechanical_brake(T* obj) { return &obj->mechani
 273:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_task_times(T* obj) { return &obj->task_times_; 
 274:./autogen/interfaces.hpp ****         virtual void watchdog_feed() = 0;
 275:./autogen/interfaces.hpp ****     };
 276:./autogen/interfaces.hpp ****     class ThermistorCurrentLimiterIntf {
 277:./autogen/interfaces.hpp ****     public:
 278:./autogen/interfaces.hpp ****     };
 279:./autogen/interfaces.hpp ****     class OnboardThermistorCurrentLimiterIntf {
 280:./autogen/interfaces.hpp ****     public:
 281:./autogen/interfaces.hpp ****         class ConfigIntf {
 282:./autogen/interfaces.hpp ****         public:
 283:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_lower(T* obj) { return Property<
 284:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_lower(T* obj, void* ptr) { new (
 285:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_upper(T* obj) { return Property<
 286:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_upper(T* obj, void* ptr) { new (
 287:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{&ob
 288:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
 289:./autogen/interfaces.hpp ****         };
 290:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_temperature(T* obj) { return Property<const flo
 291:./autogen/interfaces.hpp ****         template<typename T> static inline void get_temperature(T* obj, void* ptr) { new (ptr) Prop
 292:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 293:./autogen/interfaces.hpp ****     };
 294:./autogen/interfaces.hpp ****     class OffboardThermistorCurrentLimiterIntf {
 295:./autogen/interfaces.hpp ****     public:
ARM GAS  /tmp/ccoErako.s 			page 149


 296:./autogen/interfaces.hpp ****         class ConfigIntf {
 297:./autogen/interfaces.hpp ****         public:
 298:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gpio_pin(T* obj) { return Property<uint16_t
 299:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gpio_pin(T* obj, void* ptr) { new (ptr) Pro
 300:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_0(T* obj) { return Propert
 301:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_0(T* obj, void* ptr) { new
 302:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_1(T* obj) { return Propert
 303:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_1(T* obj, void* ptr) { new
 304:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_2(T* obj) { return Propert
 305:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_2(T* obj, void* ptr) { new
 306:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_3(T* obj) { return Propert
 307:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_3(T* obj, void* ptr) { new
 308:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_lower(T* obj) { return Property<
 309:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_lower(T* obj, void* ptr) { new (
 310:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_upper(T* obj) { return Property<
 311:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_upper(T* obj, void* ptr) { new (
 312:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{&ob
 313:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
 314:./autogen/interfaces.hpp ****         };
 315:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_temperature(T* obj) { return Property<const flo
 316:./autogen/interfaces.hpp ****         template<typename T> static inline void get_temperature(T* obj, void* ptr) { new (ptr) Prop
 317:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 318:./autogen/interfaces.hpp ****     };
 319:./autogen/interfaces.hpp ****     class MotorIntf {
 320:./autogen/interfaces.hpp ****     public:
 321:./autogen/interfaces.hpp ****         class CurrentControlIntf {
 322:./autogen/interfaces.hpp ****         public:
 323:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_p_gain(T* obj) { return Property<const floa
 324:./autogen/interfaces.hpp ****             template<typename T> static inline void get_p_gain(T* obj, void* ptr) { new (ptr) Prope
 325:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_i_gain(T* obj) { return Property<const floa
 326:./autogen/interfaces.hpp ****             template<typename T> static inline void get_i_gain(T* obj, void* ptr) { new (ptr) Prope
 327:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_measured_report_filter_k(T* obj) { return
 328:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_measured_report_filter_k(T* obj, void* pt
 329:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Id_setpoint(T* obj) { return Property<const
 330:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Id_setpoint(T* obj, void* ptr) { new (ptr) 
 331:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Iq_setpoint(T* obj) { return Property<const
 332:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Iq_setpoint(T* obj, void* ptr) { new (ptr) 
 333:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Vd_setpoint(T* obj) { return Property<const
 334:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Vd_setpoint(T* obj, void* ptr) { new (ptr) 
 335:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Vq_setpoint(T* obj) { return Property<const
 336:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Vq_setpoint(T* obj, void* ptr) { new (ptr) 
 337:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase(T* obj) { return Property<const float
 338:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Proper
 339:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_vel(T* obj) { return Property<const f
 340:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_vel(T* obj, void* ptr) { new (ptr) Pr
 341:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Ialpha_measured(T* obj) { return Property<c
 342:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Ialpha_measured(T* obj, void* ptr) { new (p
 343:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Ibeta_measured(T* obj) { return Property<co
 344:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Ibeta_measured(T* obj, void* ptr) { new (pt
 345:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Id_measured(T* obj) { return Property<const
 346:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Id_measured(T* obj, void* ptr) { new (ptr) 
 347:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Iq_measured(T* obj) { return Property<const
 348:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Iq_measured(T* obj, void* ptr) { new (ptr) 
 349:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_power(T* obj) { return Property<const float
 350:./autogen/interfaces.hpp ****             template<typename T> static inline void get_power(T* obj, void* ptr) { new (ptr) Proper
 351:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_v_current_control_integral_d(T* obj) { retu
 352:./autogen/interfaces.hpp ****             template<typename T> static inline void get_v_current_control_integral_d(T* obj, void* 
ARM GAS  /tmp/ccoErako.s 			page 150


 353:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_v_current_control_integral_q(T* obj) { retu
 354:./autogen/interfaces.hpp ****             template<typename T> static inline void get_v_current_control_integral_q(T* obj, void* 
 355:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_final_v_alpha(T* obj) { return Property<con
 356:./autogen/interfaces.hpp ****             template<typename T> static inline void get_final_v_alpha(T* obj, void* ptr) { new (ptr
 357:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_final_v_beta(T* obj) { return Property<cons
 358:./autogen/interfaces.hpp ****             template<typename T> static inline void get_final_v_beta(T* obj, void* ptr) { new (ptr)
 359:./autogen/interfaces.hpp ****         };
 360:./autogen/interfaces.hpp ****         class ConfigIntf {
 361:./autogen/interfaces.hpp ****         public:
 362:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bo
 363:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (pt
 364:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pole_pairs(T* obj) { return Property<int32_
 365:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pole_pairs(T* obj, void* ptr) { new (ptr) P
 366:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calibration_current(T* obj) { return Proper
 367:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calibration_current(T* obj, void* ptr) { ne
 368:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_resistance_calib_max_voltage(T* obj) { retu
 369:./autogen/interfaces.hpp ****             template<typename T> static inline void get_resistance_calib_max_voltage(T* obj, void* 
 370:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_inductance(T* obj) { return Property<
 371:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_inductance(T* obj, void* ptr) { new (
 372:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_resistance(T* obj) { return Property<
 373:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_resistance(T* obj, void* ptr) { new (
 374:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_constant(T* obj) { return Property<f
 375:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_constant(T* obj, void* ptr) { new (p
 376:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_type(T* obj) { return Property<ODrive
 377:./autogen/interfaces.hpp ****             template<typename T> static inline void get_motor_type(T* obj, void* ptr) { new (ptr) P
 378:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_lim(T* obj) { return Property<float
 379:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_lim(T* obj, void* ptr) { new (ptr) 
 380:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_lim_margin(T* obj) { return Propert
 381:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_lim_margin(T* obj, void* ptr) { new
 382:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_lim(T* obj) { return Property<float>
 383:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_lim(T* obj, void* ptr) { new (ptr) P
 384:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inverter_temp_limit_lower(T* obj) { return 
 385:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inverter_temp_limit_lower(T* obj, void* ptr
 386:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inverter_temp_limit_upper(T* obj) { return 
 387:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inverter_temp_limit_upper(T* obj, void* ptr
 388:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_requested_current_range(T* obj) { return Pr
 389:./autogen/interfaces.hpp ****             template<typename T> static inline void get_requested_current_range(T* obj, void* ptr) 
 390:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_control_bandwidth(T* obj) { return 
 391:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_control_bandwidth(T* obj, void* ptr
 392:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_gain_min_flux(T* obj) { return Propert
 393:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_gain_min_flux(T* obj, void* ptr) { new
 394:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_min_Id(T* obj) { return Prope
 395:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_min_Id(T* obj, void* ptr) { n
 396:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_enable(T* obj) { return Prope
 397:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_enable(T* obj, void* ptr) { n
 398:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_attack_gain(T* obj) { return 
 399:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_attack_gain(T* obj, void* ptr
 400:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_decay_gain(T* obj) { return P
 401:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_decay_gain(T* obj, void* ptr)
 402:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_R_wL_FF_enable(T* obj) { return Property<bo
 403:./autogen/interfaces.hpp ****             template<typename T> static inline void get_R_wL_FF_enable(T* obj, void* ptr) { new (pt
 404:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bEMF_FF_enable(T* obj) { return Property<bo
 405:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bEMF_FF_enable(T* obj, void* ptr) { new (pt
 406:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_bus_hard_min(T* obj) { return Property<fl
 407:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_bus_hard_min(T* obj, void* ptr) { new (pt
 408:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_bus_hard_max(T* obj) { return Property<fl
 409:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_bus_hard_max(T* obj, void* ptr) { new (pt
ARM GAS  /tmp/ccoErako.s 			page 151


 410:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_leak_max(T* obj) { return Property<float>
 411:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_leak_max(T* obj, void* ptr) { new (ptr) P
 412:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dc_calib_tau(T* obj) { return Property<floa
 413:./autogen/interfaces.hpp ****             template<typename T> static inline void get_dc_calib_tau(T* obj, void* ptr) { new (ptr)
 414:./autogen/interfaces.hpp ****         };
 415:./autogen/interfaces.hpp ****         enum Error {
 416:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 417:./autogen/interfaces.hpp ****             ERROR_PHASE_RESISTANCE_OUT_OF_RANGE = 0x00000001,
 418:./autogen/interfaces.hpp ****             ERROR_PHASE_INDUCTANCE_OUT_OF_RANGE = 0x00000002,
 419:./autogen/interfaces.hpp ****             ERROR_DRV_FAULT                  = 0x00000008,
 420:./autogen/interfaces.hpp ****             ERROR_CONTROL_DEADLINE_MISSED    = 0x00000010,
 421:./autogen/interfaces.hpp ****             ERROR_MODULATION_MAGNITUDE       = 0x00000080,
 422:./autogen/interfaces.hpp ****             ERROR_CURRENT_SENSE_SATURATION   = 0x00000400,
 423:./autogen/interfaces.hpp ****             ERROR_CURRENT_LIMIT_VIOLATION    = 0x00001000,
 424:./autogen/interfaces.hpp ****             ERROR_MODULATION_IS_NAN          = 0x00010000,
 425:./autogen/interfaces.hpp ****             ERROR_MOTOR_THERMISTOR_OVER_TEMP = 0x00020000,
 426:./autogen/interfaces.hpp ****             ERROR_FET_THERMISTOR_OVER_TEMP   = 0x00040000,
 427:./autogen/interfaces.hpp ****             ERROR_TIMER_UPDATE_MISSED        = 0x00080000,
 428:./autogen/interfaces.hpp ****             ERROR_CURRENT_MEASUREMENT_UNAVAILABLE = 0x00100000,
 429:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_FAILED          = 0x00200000,
 430:./autogen/interfaces.hpp ****             ERROR_I_BUS_OUT_OF_RANGE         = 0x00400000,
 431:./autogen/interfaces.hpp ****             ERROR_BRAKE_RESISTOR_DISARMED    = 0x00800000,
 432:./autogen/interfaces.hpp ****             ERROR_SYSTEM_LEVEL               = 0x01000000,
 433:./autogen/interfaces.hpp ****             ERROR_BAD_TIMING                 = 0x02000000,
 434:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_PHASE_ESTIMATE     = 0x04000000,
 435:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_PHASE_VEL          = 0x08000000,
 436:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_TORQUE             = 0x10000000,
 437:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_COMMAND    = 0x20000000,
 438:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x40000000,
 439:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_VBUS_VOLTAGE       = 0x80000000,
 440:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_VOLTAGE_COMMAND    = 0x100000000,
 441:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_GAINS              = 0x200000000,
 442:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_INITIALIZING    = 0x400000000,
 443:./autogen/interfaces.hpp ****             ERROR_UNBALANCED_PHASES          = 0x800000000,
 444:./autogen/interfaces.hpp ****         };
 445:./autogen/interfaces.hpp ****         enum MotorType {
 446:./autogen/interfaces.hpp ****             MOTOR_TYPE_HIGH_CURRENT          = 0,
 447:./autogen/interfaces.hpp ****             MOTOR_TYPE_GIMBAL                = 2,
 448:./autogen/interfaces.hpp ****             MOTOR_TYPE_ACIM                  = 3,
 449:./autogen/interfaces.hpp ****         };
 450:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_error_time(T* obj) { return Property<float
 451:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_error_time(T* obj, void* ptr) { new (ptr) 
 452:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Mot
 453:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 454:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_armed(T* obj) { return Property<const bool>{
 455:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_armed(T* obj, void* ptr) { new (ptr) Propert
 456:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_calibrated(T* obj) { return Property<const b
 457:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_calibrated(T* obj, void* ptr) { new (ptr) Pr
 458:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phA(T* obj) { return Property<cons
 459:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phA(T* obj, void* ptr) { new (ptr)
 460:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phB(T* obj) { return Property<cons
 461:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phB(T* obj, void* ptr) { new (ptr)
 462:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phC(T* obj) { return Property<cons
 463:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phC(T* obj, void* ptr) { new (ptr)
 464:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phA(T* obj) { return Property<float>{&
 465:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phA(T* obj, void* ptr) { new (ptr) Pro
 466:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phB(T* obj) { return Property<float>{&
ARM GAS  /tmp/ccoErako.s 			page 152


 467:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phB(T* obj, void* ptr) { new (ptr) Pro
 468:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phC(T* obj) { return Property<float>{&
 469:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phC(T* obj, void* ptr) { new (ptr) Pro
 470:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_I_bus(T* obj) { return Property<const float>{&o
 471:./autogen/interfaces.hpp ****         template<typename T> static inline void get_I_bus(T* obj, void* ptr) { new (ptr) Property<c
 472:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_current_rev_gain(T* obj) { return Propert
 473:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_current_rev_gain(T* obj, void* ptr) { new
 474:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_effective_current_lim(T* obj) { return Property
 475:./autogen/interfaces.hpp ****         template<typename T> static inline void get_effective_current_lim(T* obj, void* ptr) { new 
 476:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_allowed_current(T* obj) { return Property<c
 477:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_allowed_current(T* obj, void* ptr) { new (p
 478:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_dc_calib(T* obj) { return Property<const fl
 479:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_dc_calib(T* obj, void* ptr) { new (ptr) Pro
 480:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_fet_thermistor(T* obj) { return &obj->fet_therm
 481:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_motor_thermistor(T* obj) { return &obj->motor_t
 482:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_control(T* obj) { return &obj->current_
 483:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_n_evt_current_measurement(T* obj) { return Prop
 484:./autogen/interfaces.hpp ****         template<typename T> static inline void get_n_evt_current_measurement(T* obj, void* ptr) { 
 485:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_n_evt_pwm_update(T* obj) { return Property<cons
 486:./autogen/interfaces.hpp ****         template<typename T> static inline void get_n_evt_pwm_update(T* obj, void* ptr) { new (ptr)
 487:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 488:./autogen/interfaces.hpp ****     };
 489:./autogen/interfaces.hpp ****     class OscilloscopeIntf {
 490:./autogen/interfaces.hpp ****     public:
 491:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_size(T* obj) { return Property<const uint32_t>{
 492:./autogen/interfaces.hpp ****         template<typename T> static inline void get_size(T* obj, void* ptr) { new (ptr) Property<co
 493:./autogen/interfaces.hpp ****         virtual float get_val(uint32_t index) = 0;
 494:./autogen/interfaces.hpp ****         uint32_t get_val_in_index_; // for internal use by Fibre
 495:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_val_in_index_(T* obj) { return Property<uint32_t>{
 496:./autogen/interfaces.hpp ****         template<typename T> static void get_get_val_in_index_(T* obj, void* ptr) { new (ptr) Prope
 497:./autogen/interfaces.hpp ****         float get_val_out_val_; // for internal use by Fibre
 498:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_val_out_val_(T* obj) { return Property<const float
 499:./autogen/interfaces.hpp ****         template<typename T> static void get_get_val_out_val_(T* obj, void* ptr) { new (ptr) Proper
 500:./autogen/interfaces.hpp ****     };
 501:./autogen/interfaces.hpp ****     class AcimEstimatorIntf {
 502:./autogen/interfaces.hpp ****     public:
 503:./autogen/interfaces.hpp ****         class ConfigIntf {
 504:./autogen/interfaces.hpp ****         public:
 505:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_slip_velocity(T* obj) { return Property<flo
 506:./autogen/interfaces.hpp ****             template<typename T> static inline void get_slip_velocity(T* obj, void* ptr) { new (ptr
 507:./autogen/interfaces.hpp ****         };
 508:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_rotor_flux(T* obj) { return Property<const floa
 509:./autogen/interfaces.hpp ****         template<typename T> static inline void get_rotor_flux(T* obj, void* ptr) { new (ptr) Prope
 510:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_slip_vel(T* obj) { return Property<const float>
 511:./autogen/interfaces.hpp ****         template<typename T> static inline void get_slip_vel(T* obj, void* ptr) { new (ptr) Propert
 512:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_offset(T* obj) { return Property<const fl
 513:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_offset(T* obj, void* ptr) { new (ptr) Pro
 514:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stator_phase_vel(T* obj) { return Property<cons
 515:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stator_phase_vel(T* obj, void* ptr) { new (ptr)
 516:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stator_phase(T* obj) { return Property<const fl
 517:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stator_phase(T* obj, void* ptr) { new (ptr) Pro
 518:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 519:./autogen/interfaces.hpp ****     };
 520:./autogen/interfaces.hpp ****     class ControllerIntf {
 521:./autogen/interfaces.hpp ****     public:
 522:./autogen/interfaces.hpp ****         class ConfigIntf {
 523:./autogen/interfaces.hpp ****         public:
ARM GAS  /tmp/ccoErako.s 			page 153


 524:./autogen/interfaces.hpp ****             class AnticoggingIntf {
 525:./autogen/interfaces.hpp ****             public:
 526:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_index(T* obj) { return Property<const u
 527:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_index(T* obj, void* ptr) { new (ptr) Pr
 528:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_pre_calibrated(T* obj) { return Propert
 529:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new
 530:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_anticogging(T* obj) { return Prop
 531:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_anticogging(T* obj, void* ptr) { 
 532:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_pos_threshold(T* obj) { return Pr
 533:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_pos_threshold(T* obj, void* ptr) 
 534:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_vel_threshold(T* obj) { return Pr
 535:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_vel_threshold(T* obj, void* ptr) 
 536:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_cogging_ratio(T* obj) { return Property
 537:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_cogging_ratio(T* obj, void* ptr) { new 
 538:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_anticogging_enabled(T* obj) { return Pr
 539:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_anticogging_enabled(T* obj, void* ptr) 
 540:./autogen/interfaces.hpp ****             };
 541:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gain_scheduling_width(T* obj) { return Prop
 542:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gain_scheduling_width(T* obj, void* ptr) { 
 543:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_vel_limit(T* obj) { return Property<
 544:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_vel_limit(T* obj, void* ptr) { new (
 545:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_torque_mode_vel_limit(T* obj) { retu
 546:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_torque_mode_vel_limit(T* obj, void* 
 547:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_gain_scheduling(T* obj) { return Pro
 548:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_gain_scheduling(T* obj, void* ptr) {
 549:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_overspeed_error(T* obj) { return Pro
 550:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_overspeed_error(T* obj, void* ptr) {
 551:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_control_mode(T* obj) { return Property<ODri
 552:./autogen/interfaces.hpp ****             template<typename T> static inline void get_control_mode(T* obj, void* ptr) { new (ptr)
 553:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_input_mode(T* obj) { return Property<ODrive
 554:./autogen/interfaces.hpp ****             template<typename T> static inline void get_input_mode(T* obj, void* ptr) { new (ptr) P
 555:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pos_gain(T* obj) { return Property<float>{&
 556:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pos_gain(T* obj, void* ptr) { new (ptr) Pro
 557:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_gain(T* obj) { return Property<float>{&
 558:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_gain(T* obj, void* ptr) { new (ptr) Pro
 559:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_integrator_gain(T* obj) { return Proper
 560:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_integrator_gain(T* obj, void* ptr) { ne
 561:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_integrator_limit(T* obj) { return Prope
 562:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_integrator_limit(T* obj, void* ptr) { n
 563:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit(T* obj) { return Property<float>{
 564:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit(T* obj, void* ptr) { new (ptr) Pr
 565:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit_tolerance(T* obj) { return Proper
 566:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit_tolerance(T* obj, void* ptr) { ne
 567:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_ramp_rate(T* obj) { return Property<flo
 568:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_ramp_rate(T* obj, void* ptr) { new (ptr
 569:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_ramp_rate(T* obj) { return Property<
 570:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_ramp_rate(T* obj, void* ptr) { new (
 571:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_circular_setpoints(T* obj) { return Propert
 572:./autogen/interfaces.hpp ****             template<typename T> static inline void get_circular_setpoints(T* obj, void* ptr) { new
 573:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_circular_setpoint_range(T* obj) { return Pr
 574:./autogen/interfaces.hpp ****             template<typename T> static inline void get_circular_setpoint_range(T* obj, void* ptr) 
 575:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_steps_per_circular_range(T* obj) { return P
 576:./autogen/interfaces.hpp ****             template<typename T> static inline void get_steps_per_circular_range(T* obj, void* ptr)
 577:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_homing_speed(T* obj) { return Property<floa
 578:./autogen/interfaces.hpp ****             template<typename T> static inline void get_homing_speed(T* obj, void* ptr) { new (ptr)
 579:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inertia(T* obj) { return Property<float>{&o
 580:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inertia(T* obj, void* ptr) { new (ptr) Prop
ARM GAS  /tmp/ccoErako.s 			page 154


 581:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_axis_to_mirror(T* obj) { return Property<ui
 582:./autogen/interfaces.hpp ****             template<typename T> static inline void get_axis_to_mirror(T* obj, void* ptr) { new (pt
 583:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mirror_ratio(T* obj) { return Property<floa
 584:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mirror_ratio(T* obj, void* ptr) { new (ptr)
 585:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_mirror_ratio(T* obj) { return Proper
 586:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_mirror_ratio(T* obj, void* ptr) { ne
 587:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_load_encoder_axis(T* obj) { return Property
 588:./autogen/interfaces.hpp ****             template<typename T> static inline void get_load_encoder_axis(T* obj, void* ptr) { new 
 589:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_input_filter_bandwidth(T* obj) { return Pro
 590:./autogen/interfaces.hpp ****             template<typename T> static inline void get_input_filter_bandwidth(T* obj, void* ptr) {
 591:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_anticogging(T* obj) { return &obj->anticogg
 592:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mechanical_power_bandwidth(T* obj) { return
 593:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mechanical_power_bandwidth(T* obj, void* pt
 594:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_electrical_power_bandwidth(T* obj) { return
 595:./autogen/interfaces.hpp ****             template<typename T> static inline void get_electrical_power_bandwidth(T* obj, void* pt
 596:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_spinout_mechanical_power_threshold(T* obj) 
 597:./autogen/interfaces.hpp ****             template<typename T> static inline void get_spinout_mechanical_power_threshold(T* obj, 
 598:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_spinout_electrical_power_threshold(T* obj) 
 599:./autogen/interfaces.hpp ****             template<typename T> static inline void get_spinout_electrical_power_threshold(T* obj, 
 600:./autogen/interfaces.hpp ****         };
 601:./autogen/interfaces.hpp ****         class AutotuningIntf {
 602:./autogen/interfaces.hpp ****         public:
 603:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_frequency(T* obj) { return Property<float>{
 604:./autogen/interfaces.hpp ****             template<typename T> static inline void get_frequency(T* obj, void* ptr) { new (ptr) Pr
 605:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pos_amplitude(T* obj) { return Property<flo
 606:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pos_amplitude(T* obj, void* ptr) { new (ptr
 607:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_amplitude(T* obj) { return Property<flo
 608:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_amplitude(T* obj, void* ptr) { new (ptr
 609:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_amplitude(T* obj) { return Property<
 610:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_amplitude(T* obj, void* ptr) { new (
 611:./autogen/interfaces.hpp ****         };
 612:./autogen/interfaces.hpp ****         enum Error {
 613:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 614:./autogen/interfaces.hpp ****             ERROR_OVERSPEED                  = 0x00000001,
 615:./autogen/interfaces.hpp ****             ERROR_INVALID_INPUT_MODE         = 0x00000002,
 616:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000004,
 617:./autogen/interfaces.hpp ****             ERROR_INVALID_MIRROR_AXIS        = 0x00000008,
 618:./autogen/interfaces.hpp ****             ERROR_INVALID_LOAD_ENCODER       = 0x00000010,
 619:./autogen/interfaces.hpp ****             ERROR_INVALID_ESTIMATE           = 0x00000020,
 620:./autogen/interfaces.hpp ****             ERROR_INVALID_CIRCULAR_RANGE     = 0x00000040,
 621:./autogen/interfaces.hpp ****             ERROR_SPINOUT_DETECTED           = 0x00000080,
 622:./autogen/interfaces.hpp ****         };
 623:./autogen/interfaces.hpp ****         enum ControlMode {
 624:./autogen/interfaces.hpp ****             CONTROL_MODE_VOLTAGE_CONTROL     = 0,
 625:./autogen/interfaces.hpp ****             CONTROL_MODE_TORQUE_CONTROL      = 1,
 626:./autogen/interfaces.hpp ****             CONTROL_MODE_VELOCITY_CONTROL    = 2,
 627:./autogen/interfaces.hpp ****             CONTROL_MODE_POSITION_CONTROL    = 3,
 628:./autogen/interfaces.hpp ****         };
 629:./autogen/interfaces.hpp ****         enum InputMode {
 630:./autogen/interfaces.hpp ****             INPUT_MODE_INACTIVE              = 0,
 631:./autogen/interfaces.hpp ****             INPUT_MODE_PASSTHROUGH           = 1,
 632:./autogen/interfaces.hpp ****             INPUT_MODE_VEL_RAMP              = 2,
 633:./autogen/interfaces.hpp ****             INPUT_MODE_POS_FILTER            = 3,
 634:./autogen/interfaces.hpp ****             INPUT_MODE_MIX_CHANNELS          = 4,
 635:./autogen/interfaces.hpp ****             INPUT_MODE_TRAP_TRAJ             = 5,
 636:./autogen/interfaces.hpp ****             INPUT_MODE_TORQUE_RAMP           = 6,
 637:./autogen/interfaces.hpp ****             INPUT_MODE_MIRROR                = 7,
ARM GAS  /tmp/ccoErako.s 			page 155


 638:./autogen/interfaces.hpp ****             INPUT_MODE_TUNING                = 8,
 639:./autogen/interfaces.hpp ****         };
 640:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Con
 641:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 642:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_error_time(T* obj) { return Property<float
 643:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_error_time(T* obj, void* ptr) { new (ptr) 
 644:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_pos(T* obj) { return Property<float>{obj,
 645:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_pos(T* obj, void* ptr) { new (ptr) Proper
 646:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_vel(T* obj) { return Property<float>{&obj
 647:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_vel(T* obj, void* ptr) { new (ptr) Proper
 648:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_torque(T* obj) { return Property<float>{&
 649:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_torque(T* obj, void* ptr) { new (ptr) Pro
 650:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_setpoint(T* obj) { return Property<const fl
 651:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_setpoint(T* obj, void* ptr) { new (ptr) Pro
 652:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_setpoint(T* obj) { return Property<const fl
 653:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_setpoint(T* obj, void* ptr) { new (ptr) Pro
 654:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_torque_setpoint(T* obj) { return Property<const
 655:./autogen/interfaces.hpp ****         template<typename T> static inline void get_torque_setpoint(T* obj, void* ptr) { new (ptr) 
 656:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_trajectory_done(T* obj) { return Property<const
 657:./autogen/interfaces.hpp ****         template<typename T> static inline void get_trajectory_done(T* obj, void* ptr) { new (ptr) 
 658:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_integrator_torque(T* obj) { return Property
 659:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_integrator_torque(T* obj, void* ptr) { new 
 660:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_anticogging_valid(T* obj) { return Property<boo
 661:./autogen/interfaces.hpp ****         template<typename T> static inline void get_anticogging_valid(T* obj, void* ptr) { new (ptr
 662:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_autotuning_phase(T* obj) { return Property<floa
 663:./autogen/interfaces.hpp ****         template<typename T> static inline void get_autotuning_phase(T* obj, void* ptr) { new (ptr)
 664:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 665:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_autotuning(T* obj) { return &obj->autotuning_; 
 666:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_mechanical_power(T* obj) { return Property<cons
 667:./autogen/interfaces.hpp ****         template<typename T> static inline void get_mechanical_power(T* obj, void* ptr) { new (ptr)
 668:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_electrical_power(T* obj) { return Property<cons
 669:./autogen/interfaces.hpp ****         template<typename T> static inline void get_electrical_power(T* obj, void* ptr) { new (ptr)
 670:./autogen/interfaces.hpp ****         virtual void move_incremental(float displacement, bool from_input_pos) = 0;
 671:./autogen/interfaces.hpp ****         virtual void start_anticogging_calibration() = 0;
 672:./autogen/interfaces.hpp ****         virtual float remove_anticogging_bias() = 0;
 673:./autogen/interfaces.hpp ****         virtual float get_anticogging_value(uint32_t index) = 0;
 674:./autogen/interfaces.hpp ****         float move_incremental_in_displacement_; // for internal use by Fibre
 675:./autogen/interfaces.hpp ****         template<typename T> static auto get_move_incremental_in_displacement_(T* obj) { return Pro
 676:./autogen/interfaces.hpp ****         template<typename T> static void get_move_incremental_in_displacement_(T* obj, void* ptr) {
 677:./autogen/interfaces.hpp ****         bool move_incremental_in_from_input_pos_; // for internal use by Fibre
 678:./autogen/interfaces.hpp ****         template<typename T> static auto get_move_incremental_in_from_input_pos_(T* obj) { return P
 679:./autogen/interfaces.hpp ****         template<typename T> static void get_move_incremental_in_from_input_pos_(T* obj, void* ptr)
 680:./autogen/interfaces.hpp ****         float remove_anticogging_bias_out_val_; // for internal use by Fibre
 681:./autogen/interfaces.hpp ****         template<typename T> static auto get_remove_anticogging_bias_out_val_(T* obj) { return Prop
 682:./autogen/interfaces.hpp ****         template<typename T> static void get_remove_anticogging_bias_out_val_(T* obj, void* ptr) { 
 683:./autogen/interfaces.hpp ****         uint32_t get_anticogging_value_in_index_; // for internal use by Fibre
 684:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_anticogging_value_in_index_(T* obj) { return Prope
 685:./autogen/interfaces.hpp ****         template<typename T> static void get_get_anticogging_value_in_index_(T* obj, void* ptr) { n
 686:./autogen/interfaces.hpp ****         float get_anticogging_value_out_val_; // for internal use by Fibre
 687:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_anticogging_value_out_val_(T* obj) { return Proper
 688:./autogen/interfaces.hpp ****         template<typename T> static void get_get_anticogging_value_out_val_(T* obj, void* ptr) { ne
 689:./autogen/interfaces.hpp ****     };
 690:./autogen/interfaces.hpp ****     class EncoderIntf {
 691:./autogen/interfaces.hpp ****     public:
 692:./autogen/interfaces.hpp ****         class ConfigIntf {
 693:./autogen/interfaces.hpp ****         public:
 694:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mode(T* obj) { return Property<ODriveIntf::
ARM GAS  /tmp/ccoErako.s 			page 156


 695:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mode(T* obj, void* ptr) { new (ptr) Propert
 696:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_use_index(T* obj) { return Property<bool>{o
 697:./autogen/interfaces.hpp ****             template<typename T> static inline void get_use_index(T* obj, void* ptr) { new (ptr) Pr
 698:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_index_offset(T* obj) { return Property<floa
 699:./autogen/interfaces.hpp ****             template<typename T> static inline void get_index_offset(T* obj, void* ptr) { new (ptr)
 700:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_use_index_offset(T* obj) { return Property<
 701:./autogen/interfaces.hpp ****             template<typename T> static inline void get_use_index_offset(T* obj, void* ptr) { new (
 702:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_find_idx_on_lockin_only(T* obj) { return Pr
 703:./autogen/interfaces.hpp ****             template<typename T> static inline void get_find_idx_on_lockin_only(T* obj, void* ptr) 
 704:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_abs_spi_cs_gpio_pin(T* obj) { return Proper
 705:./autogen/interfaces.hpp ****             template<typename T> static inline void get_abs_spi_cs_gpio_pin(T* obj, void* ptr) { ne
 706:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_cpr(T* obj) { return Property<int32_t>{&obj
 707:./autogen/interfaces.hpp ****             template<typename T> static inline void get_cpr(T* obj, void* ptr) { new (ptr) Property
 708:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_offset(T* obj) { return Property<int3
 709:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_offset(T* obj, void* ptr) { new (ptr)
 710:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_offset_float(T* obj) { return Propert
 711:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_offset_float(T* obj, void* ptr) { new
 712:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_direction(T* obj) { return Property<int32_t
 713:./autogen/interfaces.hpp ****             template<typename T> static inline void get_direction(T* obj, void* ptr) { new (ptr) Pr
 714:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bo
 715:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (pt
 716:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_phase_interpolation(T* obj) { return
 717:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_phase_interpolation(T* obj, void* pt
 718:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bandwidth(T* obj) { return Property<float>{
 719:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bandwidth(T* obj, void* ptr) { new (ptr) Pr
 720:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_range(T* obj) { return Property<float
 721:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_range(T* obj, void* ptr) { new (ptr) 
 722:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_scan_distance(T* obj) { return Proper
 723:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_scan_distance(T* obj, void* ptr) { ne
 724:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_scan_omega(T* obj) { return Property<
 725:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_scan_omega(T* obj, void* ptr) { new (
 726:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ignore_illegal_hall_state(T* obj) { return 
 727:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ignore_illegal_hall_state(T* obj, void* ptr
 728:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_hall_polarity(T* obj) { return Property<uin
 729:./autogen/interfaces.hpp ****             template<typename T> static inline void get_hall_polarity(T* obj, void* ptr) { new (ptr
 730:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_hall_polarity_calibrated(T* obj) { return P
 731:./autogen/interfaces.hpp ****             template<typename T> static inline void get_hall_polarity_calibrated(T* obj, void* ptr)
 732:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sincos_gpio_pin_sin(T* obj) { return Proper
 733:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sincos_gpio_pin_sin(T* obj, void* ptr) { ne
 734:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sincos_gpio_pin_cos(T* obj) { return Proper
 735:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sincos_gpio_pin_cos(T* obj, void* ptr) { ne
 736:./autogen/interfaces.hpp ****         };
 737:./autogen/interfaces.hpp ****         enum Error {
 738:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 739:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000001,
 740:./autogen/interfaces.hpp ****             ERROR_CPR_POLEPAIRS_MISMATCH     = 0x00000002,
 741:./autogen/interfaces.hpp ****             ERROR_NO_RESPONSE                = 0x00000004,
 742:./autogen/interfaces.hpp ****             ERROR_UNSUPPORTED_ENCODER_MODE   = 0x00000008,
 743:./autogen/interfaces.hpp ****             ERROR_ILLEGAL_HALL_STATE         = 0x00000010,
 744:./autogen/interfaces.hpp ****             ERROR_INDEX_NOT_FOUND_YET        = 0x00000020,
 745:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_TIMEOUT            = 0x00000040,
 746:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_COM_FAIL           = 0x00000080,
 747:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_NOT_READY          = 0x00000100,
 748:./autogen/interfaces.hpp ****             ERROR_HALL_NOT_CALIBRATED_YET    = 0x00000200,
 749:./autogen/interfaces.hpp ****         };
 750:./autogen/interfaces.hpp ****         enum Mode {
 751:./autogen/interfaces.hpp ****             MODE_INCREMENTAL                 = 0,
ARM GAS  /tmp/ccoErako.s 			page 157


 752:./autogen/interfaces.hpp ****             MODE_HALL                        = 1,
 753:./autogen/interfaces.hpp ****             MODE_SINCOS                      = 2,
 754:./autogen/interfaces.hpp ****             MODE_SPI_ABS_CUI                 = 256,
 755:./autogen/interfaces.hpp ****             MODE_SPI_ABS_AMS                 = 257,
 756:./autogen/interfaces.hpp ****             MODE_SPI_ABS_AEAT                = 258,
 757:./autogen/interfaces.hpp ****             MODE_SPI_ABS_RLS                 = 259,
 758:./autogen/interfaces.hpp ****             MODE_SPI_ABS_MA732               = 260,
 759:./autogen/interfaces.hpp ****         };
 760:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Enc
 761:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 762:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_ready(T* obj) { return Property<const bool>{
 763:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_ready(T* obj, void* ptr) { new (ptr) Propert
 764:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_index_found(T* obj) { return Property<const boo
 765:./autogen/interfaces.hpp ****         template<typename T> static inline void get_index_found(T* obj, void* ptr) { new (ptr) Prop
 766:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_shadow_count(T* obj) { return Property<const in
 767:./autogen/interfaces.hpp ****         template<typename T> static inline void get_shadow_count(T* obj, void* ptr) { new (ptr) Pro
 768:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_count_in_cpr(T* obj) { return Property<const in
 769:./autogen/interfaces.hpp ****         template<typename T> static inline void get_count_in_cpr(T* obj, void* ptr) { new (ptr) Pro
 770:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_interpolation(T* obj) { return Property<const f
 771:./autogen/interfaces.hpp ****         template<typename T> static inline void get_interpolation(T* obj, void* ptr) { new (ptr) Pr
 772:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase(T* obj) { return Property<const float>{ob
 773:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<c
 774:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_estimate(T* obj) { return Property<const fl
 775:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_estimate(T* obj, void* ptr) { new (ptr) Pro
 776:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_estimate_counts(T* obj) { return Property<c
 777:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_estimate_counts(T* obj, void* ptr) { new (p
 778:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_circular(T* obj) { return Property<const fl
 779:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_circular(T* obj, void* ptr) { new (ptr) Pro
 780:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_cpr_counts(T* obj) { return Property<const 
 781:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_cpr_counts(T* obj, void* ptr) { new (ptr) P
 782:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_delta_pos_cpr_counts(T* obj) { return Property<
 783:./autogen/interfaces.hpp ****         template<typename T> static inline void get_delta_pos_cpr_counts(T* obj, void* ptr) { new (
 784:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_hall_state(T* obj) { return Property<const uint
 785:./autogen/interfaces.hpp ****         template<typename T> static inline void get_hall_state(T* obj, void* ptr) { new (ptr) Prope
 786:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate(T* obj) { return Property<const fl
 787:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate(T* obj, void* ptr) { new (ptr) Pro
 788:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate_counts(T* obj) { return Property<c
 789:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate_counts(T* obj, void* ptr) { new (p
 790:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_calib_scan_response(T* obj) { return Property<c
 791:./autogen/interfaces.hpp ****         template<typename T> static inline void get_calib_scan_response(T* obj, void* ptr) { new (p
 792:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_abs(T* obj) { return Property<int32_t>{&obj
 793:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_abs(T* obj, void* ptr) { new (ptr) Property
 794:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_spi_error_rate(T* obj) { return Property<const 
 795:./autogen/interfaces.hpp ****         template<typename T> static inline void get_spi_error_rate(T* obj, void* ptr) { new (ptr) P
 796:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 797:./autogen/interfaces.hpp ****         virtual void set_linear_count(int32_t count) = 0;
 798:./autogen/interfaces.hpp ****         int32_t set_linear_count_in_count_; // for internal use by Fibre
 799:./autogen/interfaces.hpp ****         template<typename T> static auto get_set_linear_count_in_count_(T* obj) { return Property<i
 800:./autogen/interfaces.hpp ****         template<typename T> static void get_set_linear_count_in_count_(T* obj, void* ptr) { new (p
 801:./autogen/interfaces.hpp ****     };
 802:./autogen/interfaces.hpp ****     class SensorlessEstimatorIntf {
 803:./autogen/interfaces.hpp ****     public:
 804:./autogen/interfaces.hpp ****         class ConfigIntf {
 805:./autogen/interfaces.hpp ****         public:
 806:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_observer_gain(T* obj) { return Property<flo
 807:./autogen/interfaces.hpp ****             template<typename T> static inline void get_observer_gain(T* obj, void* ptr) { new (ptr
 808:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pll_bandwidth(T* obj) { return Property<flo
ARM GAS  /tmp/ccoErako.s 			page 158


 809:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pll_bandwidth(T* obj, void* ptr) { new (ptr
 810:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pm_flux_linkage(T* obj) { return Property<f
 811:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pm_flux_linkage(T* obj, void* ptr) { new (p
 812:./autogen/interfaces.hpp ****         };
 813:./autogen/interfaces.hpp ****         enum Error {
 814:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 815:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000001,
 816:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x00000002,
 817:./autogen/interfaces.hpp ****         };
 818:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Sen
 819:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 820:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase(T* obj) { return Property<const float>{ob
 821:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<c
 822:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pll_pos(T* obj) { return Property<const float>{
 823:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pll_pos(T* obj, void* ptr) { new (ptr) Property
 824:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_vel(T* obj) { return Property<const float
 825:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_vel(T* obj, void* ptr) { new (ptr) Proper
 826:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate(T* obj) { return Property<const fl
 827:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate(T* obj, void* ptr) { new (ptr) Pro
 828:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 829:./autogen/interfaces.hpp ****     };
 830:./autogen/interfaces.hpp ****     class TrapezoidalTrajectoryIntf {
 831:./autogen/interfaces.hpp ****     public:
 832:./autogen/interfaces.hpp ****         class ConfigIntf {
 833:./autogen/interfaces.hpp ****         public:
 834:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit(T* obj) { return Property<float>{
 835:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit(T* obj, void* ptr) { new (ptr) Pr
 836:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_accel_limit(T* obj) { return Property<float
 837:./autogen/interfaces.hpp ****             template<typename T> static inline void get_accel_limit(T* obj, void* ptr) { new (ptr) 
 838:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_decel_limit(T* obj) { return Property<float
 839:./autogen/interfaces.hpp ****             template<typename T> static inline void get_decel_limit(T* obj, void* ptr) { new (ptr) 
 840:./autogen/interfaces.hpp ****         };
 841:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 842:./autogen/interfaces.hpp ****     };
 843:./autogen/interfaces.hpp ****     class EndstopIntf {
 844:./autogen/interfaces.hpp ****     public:
 845:./autogen/interfaces.hpp ****         class ConfigIntf {
 846:./autogen/interfaces.hpp ****         public:
 847:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gpio_num(T* obj) { return Property<uint16_t
 848:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gpio_num(T* obj, void* ptr) { new (ptr) Pro
 849:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{obj
 850:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
 851:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_offset(T* obj) { return Property<float>{&ob
 852:./autogen/interfaces.hpp ****             template<typename T> static inline void get_offset(T* obj, void* ptr) { new (ptr) Prope
 853:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_is_active_high(T* obj) { return Property<bo
 854:./autogen/interfaces.hpp ****             template<typename T> static inline void get_is_active_high(T* obj, void* ptr) { new (pt
 855:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_debounce_ms(T* obj) { return Property<uint3
 856:./autogen/interfaces.hpp ****             template<typename T> static inline void get_debounce_ms(T* obj, void* ptr) { new (ptr) 
 857:./autogen/interfaces.hpp ****         };
 858:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_endstop_state(T* obj) { return Property<const b
 859:./autogen/interfaces.hpp ****         template<typename T> static inline void get_endstop_state(T* obj, void* ptr) { new (ptr) Pr
 860:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 861:./autogen/interfaces.hpp ****     };
 862:./autogen/interfaces.hpp ****     class MechanicalBrakeIntf {
 863:./autogen/interfaces.hpp ****     public:
 864:./autogen/interfaces.hpp ****         class ConfigIntf {
 865:./autogen/interfaces.hpp ****         public:
ARM GAS  /tmp/ccoErako.s 			page 159


 866:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gpio_num(T* obj) { return Property<uint16_t
 867:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gpio_num(T* obj, void* ptr) { new (ptr) Pro
 868:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_is_active_low(T* obj) { return Property<boo
 869:./autogen/interfaces.hpp ****             template<typename T> static inline void get_is_active_low(T* obj, void* ptr) { new (ptr
 870:./autogen/interfaces.hpp ****         };
 871:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 872:./autogen/interfaces.hpp ****         virtual void engage() = 0;
 873:./autogen/interfaces.hpp ****         virtual void release() = 0;
 874:./autogen/interfaces.hpp ****     };
 875:./autogen/interfaces.hpp ****     class TaskTimerIntf {
 876:./autogen/interfaces.hpp ****     public:
 877:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_start_time(T* obj) { return Property<const uint
 878:./autogen/interfaces.hpp ****         template<typename T> static inline void get_start_time(T* obj, void* ptr) { new (ptr) Prope
 879:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_end_time(T* obj) { return Property<const uint32
 880:./autogen/interfaces.hpp ****         template<typename T> static inline void get_end_time(T* obj, void* ptr) { new (ptr) Propert
 881:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_length(T* obj) { return Property<const uint32_t
 882:./autogen/interfaces.hpp ****         template<typename T> static inline void get_length(T* obj, void* ptr) { new (ptr) Property<
 883:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_length(T* obj) { return Property<uint32_t>{
 884:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_length(T* obj, void* ptr) { new (ptr) Prope
 885:./autogen/interfaces.hpp ****     };
 886:./autogen/interfaces.hpp ****     class TaskTimesIntf {
 887:./autogen/interfaces.hpp ****     public:
 888:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_sampling(T* obj) { return &obj->sampling; }
 889:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_control_loop_misc(T* obj) { return &obj->contro
 890:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_control_loop_checks(T* obj) { return &obj->cont
 891:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_calib_wait(T* obj) { return &obj->dc_calib_w
 892:./autogen/interfaces.hpp ****     };
 893:./autogen/interfaces.hpp ****     class SystemStatsIntf {
 894:./autogen/interfaces.hpp ****     public:
 895:./autogen/interfaces.hpp ****         class UsbIntf {
 896:./autogen/interfaces.hpp ****         public:
 897:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_rx_cnt(T* obj) { return Property<const uint
 898:./autogen/interfaces.hpp ****             template<typename T> static inline void get_rx_cnt(T* obj, void* ptr) { new (ptr) Prope
 899:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_tx_cnt(T* obj) { return Property<const uint
 900:./autogen/interfaces.hpp ****             template<typename T> static inline void get_tx_cnt(T* obj, void* ptr) { new (ptr) Prope
 901:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_tx_overrun_cnt(T* obj) { return Property<co
 902:./autogen/interfaces.hpp ****             template<typename T> static inline void get_tx_overrun_cnt(T* obj, void* ptr) { new (pt
 903:./autogen/interfaces.hpp ****         };
 904:./autogen/interfaces.hpp ****         class I2CIntf {
 905:./autogen/interfaces.hpp ****         public:
 906:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_addr(T* obj) { return Property<const uint8_
 907:./autogen/interfaces.hpp ****             template<typename T> static inline void get_addr(T* obj, void* ptr) { new (ptr) Propert
 908:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_addr_match_cnt(T* obj) { return Property<co
 909:./autogen/interfaces.hpp ****             template<typename T> static inline void get_addr_match_cnt(T* obj, void* ptr) { new (pt
 910:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_rx_cnt(T* obj) { return Property<const uint
 911:./autogen/interfaces.hpp ****             template<typename T> static inline void get_rx_cnt(T* obj, void* ptr) { new (ptr) Prope
 912:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_error_cnt(T* obj) { return Property<const u
 913:./autogen/interfaces.hpp ****             template<typename T> static inline void get_error_cnt(T* obj, void* ptr) { new (ptr) Pr
 914:./autogen/interfaces.hpp ****         };
 915:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uptime(T* obj) { return Property<const uint32_t
 916:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uptime(T* obj, void* ptr) { new (ptr) Property<
 917:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_min_heap_space(T* obj) { return Property<const 
 918:./autogen/interfaces.hpp ****         template<typename T> static inline void get_min_heap_space(T* obj, void* ptr) { new (ptr) P
 919:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_axis(T* obj) { return Property<
 920:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_axis(T* obj, void* ptr) { new (
 921:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_usb(T* obj) { return Property<c
 922:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_usb(T* obj, void* ptr) { new (p
ARM GAS  /tmp/ccoErako.s 			page 160


 923:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_uart(T* obj) { return Property<
 924:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_uart(T* obj, void* ptr) { new (
 925:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_can(T* obj) { return Property<c
 926:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_can(T* obj, void* ptr) { new (p
 927:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_startup(T* obj) { return Proper
 928:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_startup(T* obj, void* ptr) { ne
 929:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_analog(T* obj) { return Propert
 930:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_analog(T* obj, void* ptr) { new
 931:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_axis(T* obj) { return Property<const
 932:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_axis(T* obj, void* ptr) { new (ptr) 
 933:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_usb(T* obj) { return Property<const 
 934:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_usb(T* obj, void* ptr) { new (ptr) P
 935:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_uart(T* obj) { return Property<const
 936:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_uart(T* obj, void* ptr) { new (ptr) 
 937:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_startup(T* obj) { return Property<co
 938:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_startup(T* obj, void* ptr) { new (pt
 939:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_can(T* obj) { return Property<const 
 940:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_can(T* obj, void* ptr) { new (ptr) P
 941:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_analog(T* obj) { return Property<con
 942:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_analog(T* obj, void* ptr) { new (ptr
 943:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_axis(T* obj) { return Property<const int32
 944:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_axis(T* obj, void* ptr) { new (ptr) Proper
 945:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_usb(T* obj) { return Property<const int32_
 946:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_usb(T* obj, void* ptr) { new (ptr) Propert
 947:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_uart(T* obj) { return Property<const int32
 948:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_uart(T* obj, void* ptr) { new (ptr) Proper
 949:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_startup(T* obj) { return Property<const in
 950:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_startup(T* obj, void* ptr) { new (ptr) Pro
 951:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_can(T* obj) { return Property<const int32_
 952:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_can(T* obj, void* ptr) { new (ptr) Propert
 953:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_analog(T* obj) { return Property<const int
 954:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_analog(T* obj, void* ptr) { new (ptr) Prop
 955:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_usb(T* obj) { return &obj->usb; }
 956:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_i2c(T* obj) { return &obj->i2c; }
 957:./autogen/interfaces.hpp ****     };
 958:./autogen/interfaces.hpp ****     enum Error {
 959:./autogen/interfaces.hpp ****         ERROR_NONE                       = 0x00000000,
 960:./autogen/interfaces.hpp ****         ERROR_CONTROL_ITERATION_MISSED   = 0x00000001,
 961:./autogen/interfaces.hpp ****         ERROR_DC_BUS_UNDER_VOLTAGE       = 0x00000002,
 962:./autogen/interfaces.hpp ****         ERROR_DC_BUS_OVER_VOLTAGE        = 0x00000004,
 963:./autogen/interfaces.hpp ****         ERROR_DC_BUS_OVER_REGEN_CURRENT  = 0x00000008,
 964:./autogen/interfaces.hpp ****         ERROR_DC_BUS_OVER_CURRENT        = 0x00000010,
 965:./autogen/interfaces.hpp ****         ERROR_BRAKE_DEADTIME_VIOLATION   = 0x00000020,
 966:./autogen/interfaces.hpp ****         ERROR_BRAKE_DUTY_CYCLE_NAN       = 0x00000040,
 967:./autogen/interfaces.hpp ****         ERROR_INVALID_BRAKE_RESISTANCE   = 0x00000080,
 968:./autogen/interfaces.hpp ****     };
 969:./autogen/interfaces.hpp ****     enum GpioMode {
 970:./autogen/interfaces.hpp ****         GPIO_MODE_DIGITAL                = 0,
 971:./autogen/interfaces.hpp ****         GPIO_MODE_DIGITAL_PULL_UP        = 1,
 972:./autogen/interfaces.hpp ****         GPIO_MODE_DIGITAL_PULL_DOWN      = 2,
 973:./autogen/interfaces.hpp ****         GPIO_MODE_ANALOG_IN              = 3,
 974:./autogen/interfaces.hpp ****         GPIO_MODE_UART_A                 = 4,
 975:./autogen/interfaces.hpp ****         GPIO_MODE_UART_B                 = 5,
 976:./autogen/interfaces.hpp ****         GPIO_MODE_UART_C                 = 6,
 977:./autogen/interfaces.hpp ****         GPIO_MODE_CAN_A                  = 7,
 978:./autogen/interfaces.hpp ****         GPIO_MODE_I2C_A                  = 8,
 979:./autogen/interfaces.hpp ****         GPIO_MODE_SPI_A                  = 9,
ARM GAS  /tmp/ccoErako.s 			page 161


 980:./autogen/interfaces.hpp ****         GPIO_MODE_PWM                    = 10,
 981:./autogen/interfaces.hpp ****         GPIO_MODE_ENC0                   = 11,
 982:./autogen/interfaces.hpp ****         GPIO_MODE_ENC1                   = 12,
 983:./autogen/interfaces.hpp ****         GPIO_MODE_ENC2                   = 13,
 984:./autogen/interfaces.hpp ****         GPIO_MODE_MECH_BRAKE             = 14,
 985:./autogen/interfaces.hpp ****         GPIO_MODE_STATUS                 = 15,
 986:./autogen/interfaces.hpp ****     };
 987:./autogen/interfaces.hpp ****     enum StreamProtocolType {
 988:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_FIBRE       = 0,
 989:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_ASCII       = 1,
 990:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_STDOUT      = 2,
 991:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_ASCII_AND_STDOUT = 3,
 992:./autogen/interfaces.hpp ****     };
 993:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Error>{
 994:./autogen/interfaces.hpp ****     template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriv
 995:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_vbus_voltage(T* obj) { return Property<const float>
 996:./autogen/interfaces.hpp ****     template<typename T> static inline void get_vbus_voltage(T* obj, void* ptr) { new (ptr) Propert
 997:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_ibus(T* obj) { return Property<const float>{&obj->i
 998:./autogen/interfaces.hpp ****     template<typename T> static inline void get_ibus(T* obj, void* ptr) { new (ptr) Property<const 
 999:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_ibus_report_filter_k(T* obj) { return Property<floa
1000:./autogen/interfaces.hpp ****     template<typename T> static inline void get_ibus_report_filter_k(T* obj, void* ptr) { new (ptr)
1001:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_serial_number(T* obj) { return Property<const uint6
1002:./autogen/interfaces.hpp ****     template<typename T> static inline void get_serial_number(T* obj, void* ptr) { new (ptr) Proper
1003:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_hw_version_major(T* obj) { return Property<const ui
1004:./autogen/interfaces.hpp ****     template<typename T> static inline void get_hw_version_major(T* obj, void* ptr) { new (ptr) Pro
1005:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_hw_version_minor(T* obj) { return Property<const ui
1006:./autogen/interfaces.hpp ****     template<typename T> static inline void get_hw_version_minor(T* obj, void* ptr) { new (ptr) Pro
1007:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_hw_version_variant(T* obj) { return Property<const 
1008:./autogen/interfaces.hpp ****     template<typename T> static inline void get_hw_version_variant(T* obj, void* ptr) { new (ptr) P
1009:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_major(T* obj) { return Property<const ui
1010:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_major(T* obj, void* ptr) { new (ptr) Pro
1011:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_minor(T* obj) { return Property<const ui
1012:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_minor(T* obj, void* ptr) { new (ptr) Pro
1013:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_revision(T* obj) { return Property<const
1014:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_revision(T* obj, void* ptr) { new (ptr) 
1015:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_unreleased(T* obj) { return Property<con
1016:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_unreleased(T* obj, void* ptr) { new (ptr
1017:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_brake_resistor_armed(T* obj) { return Property<cons
1018:./autogen/interfaces.hpp ****     template<typename T> static inline void get_brake_resistor_armed(T* obj, void* ptr) { new (ptr)
1019:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_brake_resistor_saturated(T* obj) { return Property<
1020:./autogen/interfaces.hpp ****     template<typename T> static inline void get_brake_resistor_saturated(T* obj, void* ptr) { new (
1021:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_brake_resistor_current(T* obj) { return Property<co
1022:./autogen/interfaces.hpp ****     template<typename T> static inline void get_brake_resistor_current(T* obj, void* ptr) { new (pt
1023:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_n_evt_sampling(T* obj) { return Property<const uint
1024:./autogen/interfaces.hpp ****     template<typename T> static inline void get_n_evt_sampling(T* obj, void* ptr) { new (ptr) Prope
1025:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_n_evt_control_loop(T* obj) { return Property<const 
1026:./autogen/interfaces.hpp ****     template<typename T> static inline void get_n_evt_control_loop(T* obj, void* ptr) { new (ptr) P
1027:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_task_timers_armed(T* obj) { return Property<bool>{&
1028:./autogen/interfaces.hpp ****     template<typename T> static inline void get_task_timers_armed(T* obj, void* ptr) { new (ptr) Pr
1029:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_task_times(T* obj) { return &obj->task_times_; }
1030:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_system_stats(T* obj) { return &obj->system_stats_; 
1031:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_user_config_loaded(T* obj) { return Property<const 
1032:./autogen/interfaces.hpp ****     template<typename T> static inline void get_user_config_loaded(T* obj, void* ptr) { new (ptr) P
1033:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_misconfigured(T* obj) { return Property<const bool>
1034:./autogen/interfaces.hpp ****     template<typename T> static inline void get_misconfigured(T* obj, void* ptr) { new (ptr) Proper
1035:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_oscilloscope(T* obj) { return &obj->oscilloscope_; 
1036:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_can(T* obj) { return &obj->can_; }
ARM GAS  /tmp/ccoErako.s 			page 162


1037:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_test_property(T* obj) { return Property<uint32_t>{&
1038:./autogen/interfaces.hpp ****     template<typename T> static inline void get_test_property(T* obj, void* ptr) { new (ptr) Proper
1039:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_otp_valid(T* obj) { return Property<const bool>{&ob
1040:./autogen/interfaces.hpp ****     template<typename T> static inline void get_otp_valid(T* obj, void* ptr) { new (ptr) Property<c
1041:./autogen/interfaces.hpp ****     virtual int32_t test_function(int32_t delta) = 0;
1042:./autogen/interfaces.hpp ****     virtual float get_adc_voltage(uint32_t gpio) = 0;
1043:./autogen/interfaces.hpp ****     virtual bool save_configuration() = 0;
1044:./autogen/interfaces.hpp ****     virtual void erase_configuration() = 0;
1045:./autogen/interfaces.hpp ****     virtual void reboot() = 0;
1046:./autogen/interfaces.hpp ****     virtual void enter_dfu_mode() = 0;
1047:./autogen/interfaces.hpp ****     virtual uint32_t get_interrupt_status(int32_t irqn) = 0;
1048:./autogen/interfaces.hpp ****     virtual uint32_t get_dma_status(uint8_t stream_num) = 0;
1049:./autogen/interfaces.hpp ****     virtual uint32_t get_gpio_states() = 0;
1050:./autogen/interfaces.hpp ****     virtual uint64_t get_drv_fault() = 0;
1051:./autogen/interfaces.hpp ****     virtual void clear_errors() = 0;
1052:./autogen/interfaces.hpp ****     int32_t test_function_in_delta_; // for internal use by Fibre
1053:./autogen/interfaces.hpp ****     template<typename T> static auto get_test_function_in_delta_(T* obj) { return Property<int32_t>
1054:./autogen/interfaces.hpp ****     template<typename T> static void get_test_function_in_delta_(T* obj, void* ptr) { new (ptr) Pro
1055:./autogen/interfaces.hpp ****     int32_t test_function_out_cnt_; // for internal use by Fibre
1056:./autogen/interfaces.hpp ****     template<typename T> static auto get_test_function_out_cnt_(T* obj) { return Property<const int
1057:./autogen/interfaces.hpp ****     template<typename T> static void get_test_function_out_cnt_(T* obj, void* ptr) { new (ptr) Prop
1058:./autogen/interfaces.hpp ****     uint32_t get_adc_voltage_in_gpio_; // for internal use by Fibre
1059:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_adc_voltage_in_gpio_(T* obj) { return Property<uint32_
1060:./autogen/interfaces.hpp ****     template<typename T> static void get_get_adc_voltage_in_gpio_(T* obj, void* ptr) { new (ptr) Pr
1061:./autogen/interfaces.hpp ****     float get_adc_voltage_out_voltage_; // for internal use by Fibre
1062:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_adc_voltage_out_voltage_(T* obj) { return Property<con
1063:./autogen/interfaces.hpp ****     template<typename T> static void get_get_adc_voltage_out_voltage_(T* obj, void* ptr) { new (ptr
1064:./autogen/interfaces.hpp ****     bool save_configuration_out_success_; // for internal use by Fibre
1065:./autogen/interfaces.hpp ****     template<typename T> static auto get_save_configuration_out_success_(T* obj) { return Property<
1066:./autogen/interfaces.hpp ****     template<typename T> static void get_save_configuration_out_success_(T* obj, void* ptr) { new (
1067:./autogen/interfaces.hpp ****     int32_t get_interrupt_status_in_irqn_; // for internal use by Fibre
1068:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_interrupt_status_in_irqn_(T* obj) { return Property<in
1069:./autogen/interfaces.hpp ****     template<typename T> static void get_get_interrupt_status_in_irqn_(T* obj, void* ptr) { new (pt
1070:./autogen/interfaces.hpp ****     uint32_t get_interrupt_status_out_status_; // for internal use by Fibre
1071:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_interrupt_status_out_status_(T* obj) { return Property
1072:./autogen/interfaces.hpp ****     template<typename T> static void get_get_interrupt_status_out_status_(T* obj, void* ptr) { new 
1073:./autogen/interfaces.hpp ****     uint8_t get_dma_status_in_stream_num_; // for internal use by Fibre
1074:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_dma_status_in_stream_num_(T* obj) { return Property<ui
1075:./autogen/interfaces.hpp ****     template<typename T> static void get_get_dma_status_in_stream_num_(T* obj, void* ptr) { new (pt
1076:./autogen/interfaces.hpp ****     uint32_t get_dma_status_out_status_; // for internal use by Fibre
1077:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_dma_status_out_status_(T* obj) { return Property<const
1078:./autogen/interfaces.hpp ****     template<typename T> static void get_get_dma_status_out_status_(T* obj, void* ptr) { new (ptr) 
1079:./autogen/interfaces.hpp ****     uint32_t get_gpio_states_out_status_; // for internal use by Fibre
1080:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_gpio_states_out_status_(T* obj) { return Property<cons
1081:./autogen/interfaces.hpp ****     template<typename T> static void get_get_gpio_states_out_status_(T* obj, void* ptr) { new (ptr)
1082:./autogen/interfaces.hpp ****     uint64_t get_drv_fault_out_drv_fault_; // for internal use by Fibre
1083:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_drv_fault_out_drv_fault_(T* obj) { return Property<con
1084:./autogen/interfaces.hpp ****     template<typename T> static void get_get_drv_fault_out_drv_fault_(T* obj, void* ptr) { new (ptr
1085:./autogen/interfaces.hpp **** };
1086:./autogen/interfaces.hpp **** 
1087:./autogen/interfaces.hpp **** 
1088:./autogen/interfaces.hpp **** class ODrive3Intf : public ODriveIntf {
1089:./autogen/interfaces.hpp **** public:
1090:./autogen/interfaces.hpp ****     class ConfigIntf : public ODriveIntf::ConfigIntf {
1091:./autogen/interfaces.hpp ****     public:
1092:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio1_mode(T* obj) { return Property<ODriveIntf
1093:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio1_mode(T* obj, void* ptr) { new (ptr) Prope
ARM GAS  /tmp/ccoErako.s 			page 163


1094:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio2_mode(T* obj) { return Property<ODriveIntf
1095:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio2_mode(T* obj, void* ptr) { new (ptr) Prope
1096:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio3_mode(T* obj) { return Property<ODriveIntf
1097:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio3_mode(T* obj, void* ptr) { new (ptr) Prope
1098:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio4_mode(T* obj) { return Property<ODriveIntf
1099:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio4_mode(T* obj, void* ptr) { new (ptr) Prope
1100:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio5_mode(T* obj) { return Property<ODriveIntf
1101:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio5_mode(T* obj, void* ptr) { new (ptr) Prope
1102:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio6_mode(T* obj) { return Property<ODriveIntf
1103:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio6_mode(T* obj, void* ptr) { new (ptr) Prope
1104:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio7_mode(T* obj) { return Property<ODriveIntf
1105:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio7_mode(T* obj, void* ptr) { new (ptr) Prope
1106:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio8_mode(T* obj) { return Property<ODriveIntf
1107:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio8_mode(T* obj, void* ptr) { new (ptr) Prope
1108:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio9_mode(T* obj) { return Property<ODriveIntf
1109:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio9_mode(T* obj, void* ptr) { new (ptr) Prope
1110:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio10_mode(T* obj) { return Property<ODriveInt
1111:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio10_mode(T* obj, void* ptr) { new (ptr) Prop
1112:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio11_mode(T* obj) { return Property<ODriveInt
1113:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio11_mode(T* obj, void* ptr) { new (ptr) Prop
1114:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio12_mode(T* obj) { return Property<ODriveInt
1115:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio12_mode(T* obj, void* ptr) { new (ptr) Prop
1116:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio13_mode(T* obj) { return Property<ODriveInt
1117:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio13_mode(T* obj, void* ptr) { new (ptr) Prop
1118:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio14_mode(T* obj) { return Property<ODriveInt
1119:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio14_mode(T* obj, void* ptr) { new (ptr) Prop
1120:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio15_mode(T* obj) { return Property<ODriveInt
1121:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio15_mode(T* obj, void* ptr) { new (ptr) Prop
1122:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio16_mode(T* obj) { return Property<ODriveInt
1123:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio16_mode(T* obj, void* ptr) { new (ptr) Prop
1124:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio1_pwm_mapping(T* obj) { return &obj->pwm_ma
1125:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio2_pwm_mapping(T* obj) { return &obj->pwm_ma
1126:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio3_pwm_mapping(T* obj) { return &obj->pwm_ma
1127:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio4_pwm_mapping(T* obj) { return &obj->pwm_ma
1128:./autogen/interfaces.hpp ****     };
1129:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
1130:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_axis0(T* obj) { return &obj->get_axis(0); }
1131:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_axis1(T* obj) { return &obj->get_axis(1); }
1132:./autogen/interfaces.hpp **** };
1133:./autogen/interfaces.hpp **** 
1134:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1135:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator | (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIn
1136:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator & (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIn
1137:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator ^ (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIn
1138:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol& operator |= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::Ca
1139:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol& operator &= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::Ca
1140:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol& operator ^= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::Ca
1141:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator ~ (ODriveIntf::CanIntf::Protocol a) { return static_c
1142:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1143:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator | (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast
1144:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator & (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast
1145:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator ^ (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast
1146:./autogen/interfaces.hpp **** inline ODriveIntf::Error& operator |= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterp
1147:./autogen/interfaces.hpp **** inline ODriveIntf::Error& operator &= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterp
1148:./autogen/interfaces.hpp **** inline ODriveIntf::Error& operator ^= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterp
1149:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator ~ (ODriveIntf::Error a) { return static_cast<ODriveIntf::Error>(~
1150:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
ARM GAS  /tmp/ccoErako.s 			page 164


1151:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator | (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Er
1152:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator & (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Er
1153:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator ^ (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Er
1154:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error& operator |= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf:
1155:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error& operator &= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf:
1156:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error& operator ^= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf:
1157:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator ~ (ODriveIntf::CanIntf::Error a) { return static_cast<OD
1158:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1159:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator | (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf:
1160:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator & (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf:
1161:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator ^ (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf:
1162:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error& operator |= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIn
 3208              		.loc 11 1162 113 is_stmt 1 view -0
 3209              		.cfi_startproc
 3210              		@ args = 0, pretend = 0, frame = 0
 3211              		@ frame_needed = 0, uses_anonymous_args = 0
 3212              		@ link register save eliminated.
 3213              		.loc 11 1162 115 view .LVU815
 3214              		.loc 11 1162 243 is_stmt 0 view .LVU816
 3215 0000 0268     		ldr	r2, [r0]
 3216 0002 1143     		orrs	r1, r1, r2
 3217              	.LVL207:
 3218              		.loc 11 1162 243 view .LVU817
 3219 0004 0160     		str	r1, [r0]
 3220              		.loc 11 1162 316 view .LVU818
 3221 0006 7047     		bx	lr
 3222              		.cfi_endproc
 3223              	.LFE4969:
 3224              		.cantunwind
 3225              		.fnend
 3227              		.section	.text._ZN9TaskTimer4stopEm,"axG",%progbits,_ZN9TaskTimer4stopEm,comdat
 3228              		.align	1
 3229              		.weak	_ZN9TaskTimer4stopEm
 3230              		.syntax unified
 3231              		.thumb
 3232              		.thumb_func
 3234              	_ZN9TaskTimer4stopEm:
 3235              		.fnstart
 3236              	.LVL208:
 3237              	.LFB5086:
 3238              		.file 12 "MotorControl/task_timer.hpp"
   1:MotorControl/task_timer.hpp **** #ifndef __TASK_TIMER_HPP
   2:MotorControl/task_timer.hpp **** #define __TASK_TIMER_HPP
   3:MotorControl/task_timer.hpp **** 
   4:MotorControl/task_timer.hpp **** #include <stdint.h>
   5:MotorControl/task_timer.hpp **** #include <board.h>
   6:MotorControl/task_timer.hpp **** 
   7:MotorControl/task_timer.hpp **** #define MEASURE_START_TIME
   8:MotorControl/task_timer.hpp **** #define MEASURE_END_TIME
   9:MotorControl/task_timer.hpp **** #define MEASURE_LENGTH
  10:MotorControl/task_timer.hpp **** #define MEASURE_MAX_LENGTH
  11:MotorControl/task_timer.hpp **** 
  12:MotorControl/task_timer.hpp **** inline uint16_t sample_TIM13() {
  13:MotorControl/task_timer.hpp ****     //!
  14:MotorControl/task_timer.hpp ****     constexpr uint16_t clocks_per_cnt = (uint16_t)((float)TIM_1_8_CLOCK_HZ / (float)TIM_APB1_CLOCK_
  15:MotorControl/task_timer.hpp ****     return clocks_per_cnt * TIM13->CNT;  // TODO: Use a hw_config  
  16:MotorControl/task_timer.hpp **** }
ARM GAS  /tmp/ccoErako.s 			page 165


  17:MotorControl/task_timer.hpp **** 
  18:MotorControl/task_timer.hpp **** struct TaskTimer {
  19:MotorControl/task_timer.hpp ****     uint32_t start_time_ = 0;
  20:MotorControl/task_timer.hpp ****     uint32_t end_time_ = 0;
  21:MotorControl/task_timer.hpp ****     uint32_t length_ = 0;
  22:MotorControl/task_timer.hpp ****     uint32_t max_length_ = 0;
  23:MotorControl/task_timer.hpp **** 
  24:MotorControl/task_timer.hpp ****     static bool enabled;
  25:MotorControl/task_timer.hpp **** 
  26:MotorControl/task_timer.hpp ****     uint32_t start() {
  27:MotorControl/task_timer.hpp ****         return sample_TIM13();
  28:MotorControl/task_timer.hpp ****     }
  29:MotorControl/task_timer.hpp **** 
  30:MotorControl/task_timer.hpp ****     void stop(uint32_t start_time) {
 3239              		.loc 12 30 10 is_stmt 1 view -0
 3240              		.cfi_startproc
 3241              		@ args = 0, pretend = 0, frame = 8
 3242              		@ frame_needed = 0, uses_anonymous_args = 0
 3243              		@ link register save eliminated.
 3244              		.loc 12 30 10 is_stmt 0 view .LVU820
 3245 0000 82B0     		sub	sp, sp, #8
 3246              	.LCFI34:
 3247              		.cfi_def_cfa_offset 8
  31:MotorControl/task_timer.hpp ****         uint32_t end_time = sample_TIM13();
 3248              		.loc 12 31 9 is_stmt 1 view .LVU821
 3249              	.LBB1526:
 3250              	.LBI1526:
  12:MotorControl/task_timer.hpp ****     //!
 3251              		.loc 12 12 17 view .LVU822
 3252              	.LBB1527:
  14:MotorControl/task_timer.hpp ****     return clocks_per_cnt * TIM13->CNT;  // TODO: Use a hw_config  
 3253              		.loc 12 14 5 view .LVU823
 3254              	.LVL209:
  15:MotorControl/task_timer.hpp **** }
 3255              		.loc 12 15 5 view .LVU824
  15:MotorControl/task_timer.hpp **** }
 3256              		.loc 12 15 36 is_stmt 0 view .LVU825
 3257 0002 0C4B     		ldr	r3, .L99
 3258 0004 5B6A     		ldr	r3, [r3, #36]
 3259 0006 5B00     		lsls	r3, r3, #1
 3260 0008 9BB2     		uxth	r3, r3
 3261              	.LVL210:
  15:MotorControl/task_timer.hpp **** }
 3262              		.loc 12 15 36 view .LVU826
 3263              	.LBE1527:
 3264              	.LBE1526:
  32:MotorControl/task_timer.hpp ****         uint32_t length = end_time - start_time;
 3265              		.loc 12 32 9 is_stmt 1 view .LVU827
 3266              		.loc 12 32 36 is_stmt 0 view .LVU828
 3267 000a 5A1A     		subs	r2, r3, r1
 3268              		.loc 12 32 18 view .LVU829
 3269 000c 0192     		str	r2, [sp, #4]
  33:MotorControl/task_timer.hpp **** 
  34:MotorControl/task_timer.hpp ****         if (enabled) {
 3270              		.loc 12 34 9 is_stmt 1 view .LVU830
 3271 000e 0A4A     		ldr	r2, .L99+4
 3272 0010 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
ARM GAS  /tmp/ccoErako.s 			page 166


 3273 0012 1AB1     		cbz	r2, .L94
  35:MotorControl/task_timer.hpp **** #ifdef MEASURE_START_TIME
  36:MotorControl/task_timer.hpp ****             start_time_ = start_time;
 3274              		.loc 12 36 13 view .LVU831
 3275              		.loc 12 36 25 is_stmt 0 view .LVU832
 3276 0014 0160     		str	r1, [r0]
  37:MotorControl/task_timer.hpp **** #endif
  38:MotorControl/task_timer.hpp **** #ifdef MEASURE_END_TIME
  39:MotorControl/task_timer.hpp ****             end_time_ = end_time;
 3277              		.loc 12 39 13 is_stmt 1 view .LVU833
 3278              		.loc 12 39 23 is_stmt 0 view .LVU834
 3279 0016 4360     		str	r3, [r0, #4]
  40:MotorControl/task_timer.hpp **** #endif
  41:MotorControl/task_timer.hpp **** #ifdef MEASURE_LENGTH
  42:MotorControl/task_timer.hpp ****             length_ = length;
 3280              		.loc 12 42 13 is_stmt 1 view .LVU835
 3281              		.loc 12 42 21 is_stmt 0 view .LVU836
 3282 0018 019B     		ldr	r3, [sp, #4]
 3283              	.LVL211:
 3284              		.loc 12 42 21 view .LVU837
 3285 001a 8360     		str	r3, [r0, #8]
 3286              	.LVL212:
 3287              	.L94:
  43:MotorControl/task_timer.hpp **** #endif
  44:MotorControl/task_timer.hpp ****         }
  45:MotorControl/task_timer.hpp **** #ifdef MEASURE_MAX_LENGTH
  46:MotorControl/task_timer.hpp ****         max_length_ = std::max(max_length_, length);
 3288              		.loc 12 46 9 is_stmt 1 view .LVU838
 3289              		.loc 12 46 32 is_stmt 0 view .LVU839
 3290 001c 00F10C03 		add	r3, r0, #12
 3291              	.LVL213:
 3292              	.LBB1528:
 3293              	.LBI1528:
 3294              		.file 13 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Core algorithmic facilities -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Copyright (C) 2001-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // <http://www.gnu.org/licenses/>.
ARM GAS  /tmp/ccoErako.s 			page 167


  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** /*
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Copyright (c) 1994
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Hewlett-Packard Company
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Permission to use, copy, modify, distribute and sell this software
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * and its documentation for any purpose is hereby granted without fee,
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * provided that the above copyright notice appear in all copies and
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * that both that copyright notice and this permission notice appear
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * in supporting documentation.  Hewlett-Packard Company makes no
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * representations about the suitability of this software for any
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Copyright (c) 1996-1998
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Silicon Graphics Computer Systems, Inc.
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Permission to use, copy, modify, distribute and sell this software
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * and its documentation for any purpose is hereby granted without fee,
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * provided that the above copyright notice appear in all copies and
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * that both that copyright notice and this permission notice appear
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * in supporting documentation.  Silicon Graphics makes no
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * representations about the suitability of this software for any
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  */
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** /** @file bits/stl_algobase.h
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *  This is an internal header file, included by other library headers.
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *  Do not attempt to use it directly. @headername{algorithm}
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  */
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #ifndef _STL_ALGOBASE_H
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #define _STL_ALGOBASE_H 1
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/c++config.h>
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/functexcept.h>
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/cpp_type_traits.h>
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <ext/type_traits.h>
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <ext/numeric_traits.h>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_pair.h>
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator_base_types.h>
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator_base_funcs.h>
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator.h>
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/concept_check.h>
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <debug/debug.h>
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/move.h> // For std::swap
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/predefined_ops.h>
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** # include <type_traits>
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus > 201703L
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** # include <compare>
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** namespace std _GLIBCXX_VISIBILITY(default)
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** {
ARM GAS  /tmp/ccoErako.s 			page 168


  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /*
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    * A constexpr wrapper for __builtin_memcmp.
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    * @param __num The number of elements of type _Tp (not bytes).
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    */
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp, typename _Up>
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline int
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #ifdef __cpp_lib_is_constant_evaluated
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (std::is_constant_evaluated())
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  for(; __num > 0; ++__first1, ++__first2, --__num)
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    if (*__first1 != *__first2)
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      return *__first1 < *__first2 ? -1 : 1;
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return 0;
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       else
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus < 201103L
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // nutshell, we are partially implementing the resolution of DR 187,
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // when it's safe, i.e., the value_types are equal.
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _BoolType>
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __iter_swap
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _ForwardIterator1, typename _ForwardIterator2>
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static void
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  typedef typename iterator_traits<_ForwardIterator1>::value_type
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    _ValueType1;
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  _ValueType1 __tmp = *__a;
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  *__a = *__b;
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  *__b = __tmp;
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<>
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __iter_swap<true>
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _ForwardIterator1, typename _ForwardIterator2>
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static void
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  swap(*__a, *__b);
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif // C++03
ARM GAS  /tmp/ccoErako.s 			page 169


 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Swaps the contents of two iterators.
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  An iterator.
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another iterator.
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   Nothing.
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This function swaps the values pointed to by two iterators, not the
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  iterators themselves.
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2>
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline void
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator1>)
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator2>)
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus < 201103L
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator1>::value_type
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ValueType1;
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator2>::value_type
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ValueType2;
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ValueType2>)
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ValueType1>)
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator1>::reference
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ReferenceType1;
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator2>::reference
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ReferenceType2;
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	&& __are_same<_ValueType1&, _ReferenceType1>::__value
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	&& __are_same<_ValueType2&, _ReferenceType2>::__value>::
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(__a, __b);
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #else
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // _GLIBCXX_RESOLVE_LIB_DEFECTS
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // 187. iter_swap underspecified
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       swap(*__a, *__b);
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Swap the elements of two sequences.
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first1  A forward iterator.
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __last1   A forward iterator.
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first2  A forward iterator.
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   An iterator equal to @p first2+(last1-first1).
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  Swaps each element in the range @p [first1,last1) with the
ARM GAS  /tmp/ccoErako.s 			page 170


 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  corresponding element in the range @p [first2,(last1-first1)).
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  The ranges must not overlap.
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2>
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _ForwardIterator2
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		_ForwardIterator2 __first2)
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator1>)
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator2>)
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_requires_valid_range(__first1, __last1);
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       for (; __first1 != __last1; ++__first1, (void)++__first2)
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	std::iter_swap(__first1, __first2);
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __first2;
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief This does what you think it does.
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup sorting_algorithms
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  A thing of arbitrary type.
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another thing of arbitrary type.
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   The lesser of the parameters.
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This is the simple classic generic implementation.  It will work on
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  temporary expressions, since they are only evaluated once, unlike a
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  preprocessor macro.
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp>
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline const _Tp&
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     min(const _Tp& __a, const _Tp& __b)
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       //return __b < __a ? __b : __a;
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (__b < __a)
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief This does what you think it does.
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup sorting_algorithms
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  A thing of arbitrary type.
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another thing of arbitrary type.
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   The greater of the parameters.
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This is the simple classic generic implementation.  It will work on
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  temporary expressions, since they are only evaluated once, unlike a
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  preprocessor macro.
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp>
ARM GAS  /tmp/ccoErako.s 			page 171


 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline const _Tp&
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     max(const _Tp& __a, const _Tp& __b)
 3295              		.loc 13 254 5 is_stmt 1 view .LVU840
 3296              	.LBB1529:
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       //return  __a < __b ? __b : __a;
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (__a < __b)
 3297              		.loc 13 259 15 is_stmt 0 view .LVU841
 3298 0020 C168     		ldr	r1, [r0, #12]
 3299              	.LVL214:
 3300              		.loc 13 259 15 view .LVU842
 3301 0022 019A     		ldr	r2, [sp, #4]
 3302              		.loc 13 259 7 view .LVU843
 3303 0024 9142     		cmp	r1, r2
 3304 0026 03D3     		bcc	.L98
 3305              	.LVL215:
 3306              	.L95:
 3307              		.loc 13 259 7 view .LVU844
 3308              	.LBE1529:
 3309              	.LBE1528:
 3310              		.loc 12 46 31 view .LVU845
 3311 0028 1B68     		ldr	r3, [r3]
 3312              		.loc 12 46 21 view .LVU846
 3313 002a C360     		str	r3, [r0, #12]
  47:MotorControl/task_timer.hpp **** #endif
  48:MotorControl/task_timer.hpp ****     }
 3314              		.loc 12 48 5 view .LVU847
 3315 002c 02B0     		add	sp, sp, #8
 3316              	.LCFI35:
 3317              		.cfi_remember_state
 3318              		.cfi_def_cfa_offset 0
 3319              		@ sp needed
 3320 002e 7047     		bx	lr
 3321              	.LVL216:
 3322              	.L98:
 3323              	.LCFI36:
 3324              		.cfi_restore_state
 3325              	.LBB1531:
 3326              	.LBB1530:
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 3327              		.loc 13 260 9 view .LVU848
 3328 0030 01AB     		add	r3, sp, #4
 3329              	.LVL217:
 3330              		.loc 13 260 9 view .LVU849
 3331 0032 F9E7     		b	.L95
 3332              	.L100:
 3333              		.align	2
 3334              	.L99:
 3335 0034 001C0040 		.word	1073748992
 3336 0038 00000000 		.word	_ZN9TaskTimer7enabledE
 3337              	.LBE1530:
 3338              	.LBE1531:
 3339              		.cfi_endproc
 3340              	.LFE5086:
ARM GAS  /tmp/ccoErako.s 			page 172


 3341              		.cantunwind
 3342              		.fnend
 3344              		.section	.text._ZN9CANSimple12nmt_callbackERK4AxisRK13can_Message_t,"ax",%progbits
 3345              		.align	1
 3346              		.global	_ZN9CANSimple12nmt_callbackERK4AxisRK13can_Message_t
 3347              		.syntax unified
 3348              		.thumb
 3349              		.thumb_func
 3351              	_ZN9CANSimple12nmt_callbackERK4AxisRK13can_Message_t:
 3352              		.fnstart
 3353              	.LVL218:
 3354              	.LFB5201:
 166:communication/can/can_simple.cpp ****     // Not implemented
 3355              		.loc 3 166 74 is_stmt 1 view -0
 3356              		.cfi_startproc
 3357              		@ args = 0, pretend = 0, frame = 0
 3358              		@ frame_needed = 0, uses_anonymous_args = 0
 3359              		@ link register save eliminated.
 168:communication/can/can_simple.cpp **** 
 3360              		.loc 3 168 1 is_stmt 0 view .LVU851
 3361 0000 7047     		bx	lr
 3362              		.cfi_endproc
 3363              	.LFE5201:
 3364              		.cantunwind
 3365              		.fnend
 3367              		.section	.text._ZN9CANSimple14estop_callbackER4AxisRK13can_Message_t,"ax",%progbits
 3368              		.align	1
 3369              		.global	_ZN9CANSimple14estop_callbackER4AxisRK13can_Message_t
 3370              		.syntax unified
 3371              		.thumb
 3372              		.thumb_func
 3374              	_ZN9CANSimple14estop_callbackER4AxisRK13can_Message_t:
 3375              		.fnstart
 3376              	.LVL219:
 3377              	.LFB5202:
 170:communication/can/can_simple.cpp ****     axis.error_ |= Axis::ERROR_ESTOP_REQUESTED;
 3378              		.loc 3 170 70 is_stmt 1 view -0
 3379              		.cfi_startproc
 3380              		@ args = 0, pretend = 0, frame = 0
 3381              		@ frame_needed = 0, uses_anonymous_args = 0
 170:communication/can/can_simple.cpp ****     axis.error_ |= Axis::ERROR_ESTOP_REQUESTED;
 3382              		.loc 3 170 70 is_stmt 0 view .LVU853
 3383 0000 08B5     		push	{r3, lr}
 3384              	.LCFI37:
 3385              		.cfi_def_cfa_offset 8
 3386              		.cfi_offset 3, -8
 3387              		.cfi_offset 14, -4
 171:communication/can/can_simple.cpp **** }
 3388              		.loc 3 171 5 is_stmt 1 view .LVU854
 171:communication/can/can_simple.cpp **** }
 3389              		.loc 3 171 26 is_stmt 0 view .LVU855
 3390 0002 4FF48041 		mov	r1, #16384
 3391              	.LVL220:
 171:communication/can/can_simple.cpp **** }
 3392              		.loc 3 171 26 view .LVU856
 3393 0006 00F51270 		add	r0, r0, #584
 3394              	.LVL221:
ARM GAS  /tmp/ccoErako.s 			page 173


 171:communication/can/can_simple.cpp **** }
 3395              		.loc 3 171 26 view .LVU857
 3396 000a FFF7FEFF 		bl	_ZoRRN10ODriveIntf8AxisIntf5ErrorES1_
 3397              	.LVL222:
 172:communication/can/can_simple.cpp **** 
 3398              		.loc 3 172 1 view .LVU858
 3399 000e 08BD     		pop	{r3, pc}
 3400              		.cfi_endproc
 3401              	.LFE5202:
 3402              		.cantunwind
 3403              		.fnend
 3405              		.section	.text._ZN9CANSimple24set_axis_nodeid_callbackER4AxisRK13can_Message_t,"ax",%progbits
 3406              		.align	1
 3407              		.global	_ZN9CANSimple24set_axis_nodeid_callbackER4AxisRK13can_Message_t
 3408              		.syntax unified
 3409              		.thumb
 3410              		.thumb_func
 3412              	_ZN9CANSimple24set_axis_nodeid_callbackER4AxisRK13can_Message_t:
 3413              		.fnstart
 3414              	.LVL223:
 3415              	.LFB5210:
 222:communication/can/can_simple.cpp ****     axis.config_.can.node_id = can_getSignal<uint32_t>(msg, 0, 32, true);
 3416              		.loc 3 222 80 is_stmt 1 view -0
 3417              		.cfi_startproc
 3418              		@ args = 0, pretend = 0, frame = 24
 3419              		@ frame_needed = 0, uses_anonymous_args = 0
 222:communication/can/can_simple.cpp ****     axis.config_.can.node_id = can_getSignal<uint32_t>(msg, 0, 32, true);
 3420              		.loc 3 222 80 is_stmt 0 view .LVU860
 3421 0000 00B5     		push	{lr}
 3422              	.LCFI38:
 3423              		.cfi_def_cfa_offset 4
 3424              		.cfi_offset 14, -4
 3425 0002 87B0     		sub	sp, sp, #28
 3426              	.LCFI39:
 3427              		.cfi_def_cfa_offset 32
 3428 0004 8446     		mov	ip, r0
 223:communication/can/can_simple.cpp **** }
 3429              		.loc 3 223 5 is_stmt 1 view .LVU861
 3430 0006 0FC9     		ldm	r1, {r0, r1, r2, r3}
 3431              	.LVL224:
 223:communication/can/can_simple.cpp **** }
 3432              		.loc 3 223 5 is_stmt 0 view .LVU862
 3433 0008 0DF1180E 		add	lr, sp, #24
 3434 000c 0EE90F00 		stmdb	lr, {r0, r1, r2, r3}
 3435              	.LVL225:
 3436              	.LBB1538:
 3437              	.LBI1538:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 3438              		.loc 4 31 13 is_stmt 1 view .LVU863
 3439              	.LBB1539:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 3440              		.loc 4 32 14 is_stmt 0 view .LVU864
 3441 0010 0022     		movs	r2, #0
 3442 0012 0023     		movs	r3, #0
 3443 0014 CDE90023 		strd	r2, [sp]
 3444              	.LVL226:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
ARM GAS  /tmp/ccoErako.s 			page 174


 3445              		.loc 4 36 20 view .LVU865
 3446 0018 6B46     		mov	r3, sp
 3447 001a DDF80F00 		ldr	r0, [sp, #15]	@ unaligned
 3448 001e DDF81310 		ldr	r1, [sp, #19]	@ unaligned
 3449 0022 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 3450              		.loc 4 37 41 view .LVU866
 3451 0024 0023     		movs	r3, #0
  37:communication/can/can_helpers.hpp ****     } else {
 3452              		.loc 4 37 17 view .LVU867
 3453 0026 0193     		str	r3, [sp, #4]
 3454              	.LVL227:
  37:communication/can/can_helpers.hpp ****     } else {
 3455              		.loc 4 37 17 view .LVU868
 3456              	.LBE1539:
 3457              	.LBE1538:
 223:communication/can/can_simple.cpp **** }
 3458              		.loc 3 223 30 view .LVU869
 3459 0028 CCF87800 		str	r0, [ip, #120]
 224:communication/can/can_simple.cpp **** 
 3460              		.loc 3 224 1 view .LVU870
 3461 002c 07B0     		add	sp, sp, #28
 3462              	.LCFI40:
 3463              		.cfi_def_cfa_offset 4
 3464              		@ sp needed
 3465 002e 5DF804FB 		ldr	pc, [sp], #4
 3466              		.cfi_endproc
 3467              	.LFE5210:
 3468              		.cantunwind
 3469              		.fnend
 3471              		.section	.text._ZN9CANSimple33set_axis_requested_state_callbackER4AxisRK13can_Message_t,"ax",%prog
 3472              		.align	1
 3473              		.global	_ZN9CANSimple33set_axis_requested_state_callbackER4AxisRK13can_Message_t
 3474              		.syntax unified
 3475              		.thumb
 3476              		.thumb_func
 3478              	_ZN9CANSimple33set_axis_requested_state_callbackER4AxisRK13can_Message_t:
 3479              		.fnstart
 3480              	.LVL228:
 3481              	.LFB5214:
 226:communication/can/can_simple.cpp ****     axis.requested_state_ = static_cast<Axis::AxisState>(can_getSignal<int32_t>(msg, 0, 32, true));
 3482              		.loc 3 226 89 is_stmt 1 view -0
 3483              		.cfi_startproc
 3484              		@ args = 0, pretend = 0, frame = 24
 3485              		@ frame_needed = 0, uses_anonymous_args = 0
 226:communication/can/can_simple.cpp ****     axis.requested_state_ = static_cast<Axis::AxisState>(can_getSignal<int32_t>(msg, 0, 32, true));
 3486              		.loc 3 226 89 is_stmt 0 view .LVU872
 3487 0000 00B5     		push	{lr}
 3488              	.LCFI41:
 3489              		.cfi_def_cfa_offset 4
 3490              		.cfi_offset 14, -4
 3491 0002 87B0     		sub	sp, sp, #28
 3492              	.LCFI42:
 3493              		.cfi_def_cfa_offset 32
 3494 0004 8446     		mov	ip, r0
 227:communication/can/can_simple.cpp **** }
 3495              		.loc 3 227 5 is_stmt 1 view .LVU873
ARM GAS  /tmp/ccoErako.s 			page 175


 3496 0006 0FC9     		ldm	r1, {r0, r1, r2, r3}
 3497              	.LVL229:
 227:communication/can/can_simple.cpp **** }
 3498              		.loc 3 227 5 is_stmt 0 view .LVU874
 3499 0008 0DF1180E 		add	lr, sp, #24
 3500 000c 0EE90F00 		stmdb	lr, {r0, r1, r2, r3}
 3501              	.LVL230:
 3502              	.LBB1546:
 3503              	.LBI1546:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 3504              		.loc 4 31 13 is_stmt 1 view .LVU875
 3505              	.LBB1547:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 3506              		.loc 4 32 14 is_stmt 0 view .LVU876
 3507 0010 0022     		movs	r2, #0
 3508 0012 0023     		movs	r3, #0
 3509 0014 CDE90023 		strd	r2, [sp]
 3510              	.LVL231:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 3511              		.loc 4 36 20 view .LVU877
 3512 0018 6B46     		mov	r3, sp
 3513 001a DDF80F00 		ldr	r0, [sp, #15]	@ unaligned
 3514 001e DDF81310 		ldr	r1, [sp, #19]	@ unaligned
 3515 0022 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 3516              		.loc 4 37 41 view .LVU878
 3517 0024 0023     		movs	r3, #0
  37:communication/can/can_helpers.hpp ****     } else {
 3518              		.loc 4 37 17 view .LVU879
 3519 0026 0193     		str	r3, [sp, #4]
 3520              	.LVL232:
  37:communication/can/can_helpers.hpp ****     } else {
 3521              		.loc 4 37 17 view .LVU880
 3522              	.LBE1547:
 3523              	.LBE1546:
 227:communication/can/can_simple.cpp **** }
 3524              		.loc 3 227 29 view .LVU881
 3525 0028 9DF80030 		ldrb	r3, [sp]	@ zero_extendqisi2
 227:communication/can/can_simple.cpp **** }
 3526              		.loc 3 227 27 view .LVU882
 3527 002c 8CF86C32 		strb	r3, [ip, #620]
 228:communication/can/can_simple.cpp **** 
 3528              		.loc 3 228 1 view .LVU883
 3529 0030 07B0     		add	sp, sp, #28
 3530              	.LCFI43:
 3531              		.cfi_def_cfa_offset 4
 3532              		@ sp needed
 3533 0032 5DF804FB 		ldr	pc, [sp], #4
 3534              		.cfi_endproc
 3535              	.LFE5214:
 3536              		.cantunwind
 3537              		.fnend
 3539              		.section	.text._ZN9CANSimple32set_axis_startup_config_callbackER4AxisRK13can_Message_t,"ax",%progb
 3540              		.align	1
 3541              		.global	_ZN9CANSimple32set_axis_startup_config_callbackER4AxisRK13can_Message_t
 3542              		.syntax unified
 3543              		.thumb
ARM GAS  /tmp/ccoErako.s 			page 176


 3544              		.thumb_func
 3546              	_ZN9CANSimple32set_axis_startup_config_callbackER4AxisRK13can_Message_t:
 3547              		.fnstart
 3548              	.LVL233:
 3549              	.LFB5216:
 230:communication/can/can_simple.cpp ****     // Not Implemented
 3550              		.loc 3 230 88 is_stmt 1 view -0
 3551              		.cfi_startproc
 3552              		@ args = 0, pretend = 0, frame = 0
 3553              		@ frame_needed = 0, uses_anonymous_args = 0
 3554              		@ link register save eliminated.
 232:communication/can/can_simple.cpp **** 
 3555              		.loc 3 232 1 is_stmt 0 view .LVU885
 3556 0000 7047     		bx	lr
 3557              		.cfi_endproc
 3558              	.LFE5216:
 3559              		.cantunwind
 3560              		.fnend
 3562              		.section	.text._ZN9CANSimple22set_input_vel_callbackER4AxisRK13can_Message_t,"ax",%progbits
 3563              		.align	1
 3564              		.global	_ZN9CANSimple22set_input_vel_callbackER4AxisRK13can_Message_t
 3565              		.syntax unified
 3566              		.thumb
 3567              		.thumb_func
 3569              	_ZN9CANSimple22set_input_vel_callbackER4AxisRK13can_Message_t:
 3570              		.fnstart
 3571              	.LVL234:
 3572              	.LFB5222:
 281:communication/can/can_simple.cpp ****     axis.controller_.input_vel_ = can_getSignal<float>(msg, 0, 32, true);
 3573              		.loc 3 281 78 is_stmt 1 view -0
 3574              		.cfi_startproc
 3575              		@ args = 0, pretend = 0, frame = 32
 3576              		@ frame_needed = 0, uses_anonymous_args = 0
 281:communication/can/can_simple.cpp ****     axis.controller_.input_vel_ = can_getSignal<float>(msg, 0, 32, true);
 3577              		.loc 3 281 78 is_stmt 0 view .LVU887
 3578 0000 70B5     		push	{r4, r5, r6, lr}
 3579              	.LCFI44:
 3580              		.cfi_def_cfa_offset 16
 3581              		.cfi_offset 4, -16
 3582              		.cfi_offset 5, -12
 3583              		.cfi_offset 6, -8
 3584              		.cfi_offset 14, -4
 3585 0002 88B0     		sub	sp, sp, #32
 3586              	.LCFI45:
 3587              		.cfi_def_cfa_offset 48
 3588 0004 0546     		mov	r5, r0
 3589 0006 8C46     		mov	ip, r1
 282:communication/can/can_simple.cpp ****     axis.controller_.input_torque_ = can_getSignal<float>(msg, 32, 32, true);
 3590              		.loc 3 282 5 is_stmt 1 view .LVU888
 282:communication/can/can_simple.cpp ****     axis.controller_.input_torque_ = can_getSignal<float>(msg, 32, 32, true);
 3591              		.loc 3 282 10 is_stmt 0 view .LVU889
 3592 0008 D0F80041 		ldr	r4, [r0, #256]
 3593 000c 0DF1100E 		add	lr, sp, #16
 3594 0010 0FC9     		ldm	r1, {r0, r1, r2, r3}
 3595              	.LVL235:
 282:communication/can/can_simple.cpp ****     axis.controller_.input_torque_ = can_getSignal<float>(msg, 32, 32, true);
 3596              		.loc 3 282 10 view .LVU890
ARM GAS  /tmp/ccoErako.s 			page 177


 3597 0012 8EE80F00 		stm	lr, {r0, r1, r2, r3}
 3598              	.LVL236:
 3599              	.LBB1560:
 3600              	.LBI1560:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 3601              		.loc 4 31 13 is_stmt 1 view .LVU891
 3602              	.LBB1561:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 3603              		.loc 4 32 14 is_stmt 0 view .LVU892
 3604 0016 9FED147B 		vldr.64	d7, .L111	@ int
 3605 001a 8DED027B 		vstr.64	d7, [sp, #8]	@ int
 3606              	.LVL237:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 3607              		.loc 4 36 20 view .LVU893
 3608 001e 02AB     		add	r3, sp, #8
 3609 0020 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 3610 0024 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 3611 0028 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 3612              		.loc 4 37 41 view .LVU894
 3613 002a 0026     		movs	r6, #0
  37:communication/can/can_helpers.hpp ****     } else {
 3614              		.loc 4 37 17 view .LVU895
 3615 002c 0396     		str	r6, [sp, #12]
  45:communication/can/can_helpers.hpp ****     return retVal;
 3616              		.loc 4 45 16 view .LVU896
 3617 002e 0190     		str	r0, [sp, #4]
 3618              	.LVL238:
  45:communication/can/can_helpers.hpp ****     return retVal;
 3619              		.loc 4 45 16 view .LVU897
 3620              	.LBE1561:
 3621              	.LBE1560:
 282:communication/can/can_simple.cpp ****     axis.controller_.input_torque_ = can_getSignal<float>(msg, 32, 32, true);
 3622              		.loc 3 282 33 view .LVU898
 3623 0030 04F56453 		add	r3, r4, #14592
 3624 0034 9861     		str	r0, [r3, #24]	@ float
 283:communication/can/can_simple.cpp **** }
 3625              		.loc 3 283 5 is_stmt 1 view .LVU899
 283:communication/can/can_simple.cpp **** }
 3626              		.loc 3 283 10 is_stmt 0 view .LVU900
 3627 0036 D5F80041 		ldr	r4, [r5, #256]
 3628 003a 9CE80F00 		ldm	ip, {r0, r1, r2, r3}
 3629 003e 8EE80F00 		stm	lr, {r0, r1, r2, r3}
 3630              	.LVL239:
 3631              	.LBB1562:
 3632              	.LBI1562:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 3633              		.loc 4 31 13 is_stmt 1 view .LVU901
 3634              	.LBB1563:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 3635              		.loc 4 32 14 is_stmt 0 view .LVU902
 3636 0042 8DED027B 		vstr.64	d7, [sp, #8]	@ int
 3637              	.LVL240:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 3638              		.loc 4 36 20 view .LVU903
 3639 0046 02AB     		add	r3, sp, #8
 3640 0048 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
ARM GAS  /tmp/ccoErako.s 			page 178


 3641 004c DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 3642 0050 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 3643              		.loc 4 37 17 view .LVU904
 3644 0052 0291     		str	r1, [sp, #8]
 3645 0054 0396     		str	r6, [sp, #12]
  45:communication/can/can_helpers.hpp ****     return retVal;
 3646              		.loc 4 45 16 view .LVU905
 3647 0056 0191     		str	r1, [sp, #4]
 3648              	.LVL241:
  45:communication/can/can_helpers.hpp ****     return retVal;
 3649              		.loc 4 45 16 view .LVU906
 3650              	.LBE1563:
 3651              	.LBE1562:
 283:communication/can/can_simple.cpp **** }
 3652              		.loc 3 283 36 view .LVU907
 3653 0058 04F56453 		add	r3, r4, #14592
 3654 005c D961     		str	r1, [r3, #28]	@ float
 284:communication/can/can_simple.cpp **** 
 3655              		.loc 3 284 1 view .LVU908
 3656 005e 08B0     		add	sp, sp, #32
 3657              	.LCFI46:
 3658              		.cfi_def_cfa_offset 16
 3659              		@ sp needed
 3660 0060 70BD     		pop	{r4, r5, r6, pc}
 3661              	.LVL242:
 3662              	.L112:
 284:communication/can/can_simple.cpp **** 
 3663              		.loc 3 284 1 view .LVU909
 3664 0062 00BFAFF3 		.align	3
 3664      0080
 3665              	.L111:
 3666 0068 00000000 		.word	0
 3667 006c 00000000 		.word	0
 3668              		.cfi_endproc
 3669              	.LFE5222:
 3670              		.cantunwind
 3671              		.fnend
 3673              		.section	.text._ZN9CANSimple25set_input_torque_callbackER4AxisRK13can_Message_t,"ax",%progbits
 3674              		.align	1
 3675              		.global	_ZN9CANSimple25set_input_torque_callbackER4AxisRK13can_Message_t
 3676              		.syntax unified
 3677              		.thumb
 3678              		.thumb_func
 3680              	_ZN9CANSimple25set_input_torque_callbackER4AxisRK13can_Message_t:
 3681              		.fnstart
 3682              	.LVL243:
 3683              	.LFB5223:
 286:communication/can/can_simple.cpp ****     axis.controller_.input_torque_ = can_getSignal<float>(msg, 0, 32, true);
 3684              		.loc 3 286 81 is_stmt 1 view -0
 3685              		.cfi_startproc
 3686              		@ args = 0, pretend = 0, frame = 32
 3687              		@ frame_needed = 0, uses_anonymous_args = 0
 3688              		@ link register save eliminated.
 286:communication/can/can_simple.cpp ****     axis.controller_.input_torque_ = can_getSignal<float>(msg, 0, 32, true);
 3689              		.loc 3 286 81 is_stmt 0 view .LVU911
 3690 0000 10B4     		push	{r4}
ARM GAS  /tmp/ccoErako.s 			page 179


 3691              	.LCFI47:
 3692              		.cfi_def_cfa_offset 4
 3693              		.cfi_offset 4, -4
 3694 0002 89B0     		sub	sp, sp, #36
 3695              	.LCFI48:
 3696              		.cfi_def_cfa_offset 40
 287:communication/can/can_simple.cpp **** }
 3697              		.loc 3 287 5 is_stmt 1 view .LVU912
 287:communication/can/can_simple.cpp **** }
 3698              		.loc 3 287 10 is_stmt 0 view .LVU913
 3699 0004 D0F80041 		ldr	r4, [r0, #256]
 3700 0008 0FC9     		ldm	r1, {r0, r1, r2, r3}
 3701              	.LVL244:
 287:communication/can/can_simple.cpp **** }
 3702              		.loc 3 287 10 view .LVU914
 3703 000a 0DF1200C 		add	ip, sp, #32
 3704 000e 0CE90F00 		stmdb	ip, {r0, r1, r2, r3}
 3705              	.LVL245:
 3706              	.LBB1570:
 3707              	.LBI1570:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 3708              		.loc 4 31 13 is_stmt 1 view .LVU915
 3709              	.LBB1571:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 3710              		.loc 4 32 14 is_stmt 0 view .LVU916
 3711 0012 0022     		movs	r2, #0
 3712 0014 0023     		movs	r3, #0
 3713 0016 CDE90223 		strd	r2, [sp, #8]
 3714              	.LVL246:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 3715              		.loc 4 36 20 view .LVU917
 3716 001a 02AB     		add	r3, sp, #8
 3717 001c DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 3718 0020 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 3719 0024 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 3720              		.loc 4 37 41 view .LVU918
 3721 0026 0023     		movs	r3, #0
  37:communication/can/can_helpers.hpp ****     } else {
 3722              		.loc 4 37 17 view .LVU919
 3723 0028 0393     		str	r3, [sp, #12]
  45:communication/can/can_helpers.hpp ****     return retVal;
 3724              		.loc 4 45 16 view .LVU920
 3725 002a 0190     		str	r0, [sp, #4]
 3726              	.LVL247:
  45:communication/can/can_helpers.hpp ****     return retVal;
 3727              		.loc 4 45 16 view .LVU921
 3728              	.LBE1571:
 3729              	.LBE1570:
 287:communication/can/can_simple.cpp **** }
 3730              		.loc 3 287 36 view .LVU922
 3731 002c 04F56453 		add	r3, r4, #14592
 3732 0030 D861     		str	r0, [r3, #28]	@ float
 288:communication/can/can_simple.cpp **** 
 3733              		.loc 3 288 1 view .LVU923
 3734 0032 09B0     		add	sp, sp, #36
 3735              	.LCFI49:
ARM GAS  /tmp/ccoErako.s 			page 180


 3736              		.cfi_def_cfa_offset 4
 3737              		@ sp needed
 3738 0034 5DF8044B 		ldr	r4, [sp], #4
 3739              	.LCFI50:
 3740              		.cfi_restore 4
 3741              		.cfi_def_cfa_offset 0
 3742 0038 7047     		bx	lr
 3743              		.cfi_endproc
 3744              	.LFE5223:
 3745              		.cantunwind
 3746              		.fnend
 3748              		.section	.text._ZN9CANSimple29set_controller_modes_callbackER4AxisRK13can_Message_t,"ax",%progbits
 3749              		.align	1
 3750              		.global	_ZN9CANSimple29set_controller_modes_callbackER4AxisRK13can_Message_t
 3751              		.syntax unified
 3752              		.thumb
 3753              		.thumb_func
 3755              	_ZN9CANSimple29set_controller_modes_callbackER4AxisRK13can_Message_t:
 3756              		.fnstart
 3757              	.LVL248:
 3758              	.LFB5224:
 290:communication/can/can_simple.cpp ****     Controller::ControlMode const mode = static_cast<Controller::ControlMode>(can_getSignal<int32_t
 3759              		.loc 3 290 85 is_stmt 1 view -0
 3760              		.cfi_startproc
 3761              		@ args = 0, pretend = 0, frame = 24
 3762              		@ frame_needed = 0, uses_anonymous_args = 0
 290:communication/can/can_simple.cpp ****     Controller::ControlMode const mode = static_cast<Controller::ControlMode>(can_getSignal<int32_t
 3763              		.loc 3 290 85 is_stmt 0 view .LVU925
 3764 0000 30B5     		push	{r4, r5, lr}
 3765              		.save {r4, r5, lr}
 3766              	.LCFI51:
 3767              		.cfi_def_cfa_offset 12
 3768              		.cfi_offset 4, -12
 3769              		.cfi_offset 5, -8
 3770              		.cfi_offset 14, -4
 3771              		.pad #28
 3772 0002 87B0     		sub	sp, sp, #28
 3773              	.LCFI52:
 3774              		.cfi_def_cfa_offset 40
 3775 0004 0446     		mov	r4, r0
 3776 0006 8C46     		mov	ip, r1
 291:communication/can/can_simple.cpp ****     axis.controller_.config_.control_mode = static_cast<Controller::ControlMode>(mode);
 3777              		.loc 3 291 5 is_stmt 1 view .LVU926
 3778 0008 0DF1080E 		add	lr, sp, #8
 3779 000c 0FC9     		ldm	r1, {r0, r1, r2, r3}
 3780              	.LVL249:
 291:communication/can/can_simple.cpp ****     axis.controller_.config_.control_mode = static_cast<Controller::ControlMode>(mode);
 3781              		.loc 3 291 5 is_stmt 0 view .LVU927
 3782 000e 8EE80F00 		stm	lr, {r0, r1, r2, r3}
 3783              	.LVL250:
 3784              	.LBB1584:
 3785              	.LBI1584:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 3786              		.loc 4 31 13 is_stmt 1 view .LVU928
 3787              	.LBB1585:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 3788              		.loc 4 32 14 is_stmt 0 view .LVU929
ARM GAS  /tmp/ccoErako.s 			page 181


 3789 0012 9FED157B 		vldr.64	d7, .L117	@ int
 3790 0016 8DED007B 		vstr.64	d7, [sp]	@ int
 3791              	.LVL251:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 3792              		.loc 4 36 20 view .LVU930
 3793 001a 6B46     		mov	r3, sp
 3794 001c DDF80F00 		ldr	r0, [sp, #15]	@ unaligned
 3795 0020 DDF81310 		ldr	r1, [sp, #19]	@ unaligned
 3796 0024 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 3797              		.loc 4 37 41 view .LVU931
 3798 0026 0025     		movs	r5, #0
  37:communication/can/can_helpers.hpp ****     } else {
 3799              		.loc 4 37 17 view .LVU932
 3800 0028 0195     		str	r5, [sp, #4]
 3801              	.LVL252:
  37:communication/can/can_helpers.hpp ****     } else {
 3802              		.loc 4 37 17 view .LVU933
 3803              	.LBE1585:
 3804              	.LBE1584:
 291:communication/can/can_simple.cpp ****     axis.controller_.config_.control_mode = static_cast<Controller::ControlMode>(mode);
 3805              		.loc 3 291 119 view .LVU934
 3806 002a 9DF80020 		ldrb	r2, [sp]	@ zero_extendqisi2
 3807              	.LVL253:
 292:communication/can/can_simple.cpp ****     axis.controller_.config_.input_mode = static_cast<Controller::InputMode>(can_getSignal<int32_t>
 3808              		.loc 3 292 5 is_stmt 1 view .LVU935
 292:communication/can/can_simple.cpp ****     axis.controller_.config_.input_mode = static_cast<Controller::InputMode>(can_getSignal<int32_t>
 3809              		.loc 3 292 10 is_stmt 0 view .LVU936
 3810 002e D4F80031 		ldr	r3, [r4, #256]
 292:communication/can/can_simple.cpp ****     axis.controller_.config_.input_mode = static_cast<Controller::InputMode>(can_getSignal<int32_t>
 3811              		.loc 3 292 43 view .LVU937
 3812 0032 1A76     		strb	r2, [r3, #24]
 293:communication/can/can_simple.cpp ****     axis.controller_.control_mode_updated();
 3813              		.loc 3 293 5 is_stmt 1 view .LVU938
 3814 0034 9CE80F00 		ldm	ip, {r0, r1, r2, r3}
 3815              	.LVL254:
 293:communication/can/can_simple.cpp ****     axis.controller_.control_mode_updated();
 3816              		.loc 3 293 5 is_stmt 0 view .LVU939
 3817 0038 8EE80F00 		stm	lr, {r0, r1, r2, r3}
 3818              	.LVL255:
 3819              	.LBB1586:
 3820              	.LBI1586:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 3821              		.loc 4 31 13 is_stmt 1 view .LVU940
 3822              	.LBB1587:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 3823              		.loc 4 32 14 is_stmt 0 view .LVU941
 3824 003c 8DED007B 		vstr.64	d7, [sp]	@ int
 3825              	.LVL256:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 3826              		.loc 4 36 20 view .LVU942
 3827 0040 6B46     		mov	r3, sp
 3828 0042 DDF80F00 		ldr	r0, [sp, #15]	@ unaligned
 3829 0046 DDF81310 		ldr	r1, [sp, #19]	@ unaligned
 3830 004a 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 3831              		.loc 4 37 17 view .LVU943
ARM GAS  /tmp/ccoErako.s 			page 182


 3832 004c 0091     		str	r1, [sp]
 3833 004e 0195     		str	r5, [sp, #4]
 3834              	.LVL257:
  37:communication/can/can_helpers.hpp ****     } else {
 3835              		.loc 4 37 17 view .LVU944
 3836              	.LBE1587:
 3837              	.LBE1586:
 293:communication/can/can_simple.cpp ****     axis.controller_.control_mode_updated();
 3838              		.loc 3 293 10 view .LVU945
 3839 0050 D4F80021 		ldr	r2, [r4, #256]
 293:communication/can/can_simple.cpp ****     axis.controller_.control_mode_updated();
 3840              		.loc 3 293 41 view .LVU946
 3841 0054 5176     		strb	r1, [r2, #25]
 294:communication/can/can_simple.cpp **** }
 3842              		.loc 3 294 5 is_stmt 1 view .LVU947
 294:communication/can/can_simple.cpp **** }
 3843              		.loc 3 294 42 is_stmt 0 view .LVU948
 3844 0056 D4F80001 		ldr	r0, [r4, #256]
 3845 005a FFF7FEFF 		bl	_ZN10Controller20control_mode_updatedEv
 3846              	.LVL258:
 295:communication/can/can_simple.cpp **** 
 3847              		.loc 3 295 1 view .LVU949
 3848 005e 07B0     		add	sp, sp, #28
 3849              	.LCFI53:
 3850              		.cfi_def_cfa_offset 12
 3851              		@ sp needed
 3852 0060 30BD     		pop	{r4, r5, pc}
 3853              	.LVL259:
 3854              	.L118:
 295:communication/can/can_simple.cpp **** 
 3855              		.loc 3 295 1 view .LVU950
 3856 0062 00BFAFF3 		.align	3
 3856      0080
 3857              	.L117:
 3858 0068 00000000 		.word	0
 3859 006c 00000000 		.word	0
 3860              		.cfi_endproc
 3861              	.LFE5224:
 3862              		.fnend
 3864              		.section	.text._ZN9CANSimple19set_limits_callbackER4AxisRK13can_Message_t,"ax",%progbits
 3865              		.align	1
 3866              		.global	_ZN9CANSimple19set_limits_callbackER4AxisRK13can_Message_t
 3867              		.syntax unified
 3868              		.thumb
 3869              		.thumb_func
 3871              	_ZN9CANSimple19set_limits_callbackER4AxisRK13can_Message_t:
 3872              		.fnstart
 3873              	.LVL260:
 3874              	.LFB5225:
 297:communication/can/can_simple.cpp ****     axis.controller_.config_.vel_limit = can_getSignal<float>(msg, 0, 32, true);
 3875              		.loc 3 297 75 is_stmt 1 view -0
 3876              		.cfi_startproc
 3877              		@ args = 0, pretend = 0, frame = 32
 3878              		@ frame_needed = 0, uses_anonymous_args = 0
 297:communication/can/can_simple.cpp ****     axis.controller_.config_.vel_limit = can_getSignal<float>(msg, 0, 32, true);
 3879              		.loc 3 297 75 is_stmt 0 view .LVU952
 3880 0000 30B5     		push	{r4, r5, lr}
ARM GAS  /tmp/ccoErako.s 			page 183


 3881              	.LCFI54:
 3882              		.cfi_def_cfa_offset 12
 3883              		.cfi_offset 4, -12
 3884              		.cfi_offset 5, -8
 3885              		.cfi_offset 14, -4
 3886 0002 89B0     		sub	sp, sp, #36
 3887              	.LCFI55:
 3888              		.cfi_def_cfa_offset 48
 3889 0004 0446     		mov	r4, r0
 3890 0006 8C46     		mov	ip, r1
 298:communication/can/can_simple.cpp ****     axis.motor_.config_.current_lim = can_getSignal<float>(msg, 32, 32, true);
 3891              		.loc 3 298 5 is_stmt 1 view .LVU953
 3892 0008 0DF1100E 		add	lr, sp, #16
 3893 000c 0FC9     		ldm	r1, {r0, r1, r2, r3}
 3894              	.LVL261:
 298:communication/can/can_simple.cpp ****     axis.motor_.config_.current_lim = can_getSignal<float>(msg, 32, 32, true);
 3895              		.loc 3 298 5 is_stmt 0 view .LVU954
 3896 000e 8EE80F00 		stm	lr, {r0, r1, r2, r3}
 3897              	.LVL262:
 3898              	.LBB1600:
 3899              	.LBI1600:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 3900              		.loc 4 31 13 is_stmt 1 view .LVU955
 3901              	.LBB1601:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 3902              		.loc 4 32 14 is_stmt 0 view .LVU956
 3903 0012 9FED137B 		vldr.64	d7, .L121	@ int
 3904 0016 8DED027B 		vstr.64	d7, [sp, #8]	@ int
 3905              	.LVL263:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 3906              		.loc 4 36 20 view .LVU957
 3907 001a 02AB     		add	r3, sp, #8
 3908 001c DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 3909 0020 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 3910 0024 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 3911              		.loc 4 37 41 view .LVU958
 3912 0026 0025     		movs	r5, #0
  37:communication/can/can_helpers.hpp ****     } else {
 3913              		.loc 4 37 17 view .LVU959
 3914 0028 0395     		str	r5, [sp, #12]
  45:communication/can/can_helpers.hpp ****     return retVal;
 3915              		.loc 4 45 16 view .LVU960
 3916 002a 0190     		str	r0, [sp, #4]
 3917              	.LVL264:
  45:communication/can/can_helpers.hpp ****     return retVal;
 3918              		.loc 4 45 16 view .LVU961
 3919              	.LBE1601:
 3920              	.LBE1600:
 298:communication/can/can_simple.cpp ****     axis.motor_.config_.current_lim = can_getSignal<float>(msg, 32, 32, true);
 3921              		.loc 3 298 40 view .LVU962
 3922 002c D4F80021 		ldr	r2, [r4, #256]
 3923 0030 9062     		str	r0, [r2, #40]	@ float
 299:communication/can/can_simple.cpp **** }
 3924              		.loc 3 299 5 is_stmt 1 view .LVU963
 299:communication/can/can_simple.cpp **** }
 3925              		.loc 3 299 10 is_stmt 0 view .LVU964
ARM GAS  /tmp/ccoErako.s 			page 184


 3926 0032 D4F85841 		ldr	r4, [r4, #344]
 3927              	.LVL265:
 299:communication/can/can_simple.cpp **** }
 3928              		.loc 3 299 10 view .LVU965
 3929 0036 9CE80F00 		ldm	ip, {r0, r1, r2, r3}
 3930 003a 8EE80F00 		stm	lr, {r0, r1, r2, r3}
 3931              	.LVL266:
 3932              	.LBB1602:
 3933              	.LBI1602:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 3934              		.loc 4 31 13 is_stmt 1 view .LVU966
 3935              	.LBB1603:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 3936              		.loc 4 32 14 is_stmt 0 view .LVU967
 3937 003e 8DED027B 		vstr.64	d7, [sp, #8]	@ int
 3938              	.LVL267:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 3939              		.loc 4 36 20 view .LVU968
 3940 0042 02AB     		add	r3, sp, #8
 3941 0044 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 3942 0048 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 3943 004c 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 3944              		.loc 4 37 17 view .LVU969
 3945 004e 0291     		str	r1, [sp, #8]
 3946 0050 0395     		str	r5, [sp, #12]
  45:communication/can/can_helpers.hpp ****     return retVal;
 3947              		.loc 4 45 16 view .LVU970
 3948 0052 0191     		str	r1, [sp, #4]
 3949              	.LVL268:
  45:communication/can/can_helpers.hpp ****     return retVal;
 3950              		.loc 4 45 16 view .LVU971
 3951              	.LBE1603:
 3952              	.LBE1602:
 299:communication/can/can_simple.cpp **** }
 3953              		.loc 3 299 37 view .LVU972
 3954 0054 E163     		str	r1, [r4, #60]	@ float
 300:communication/can/can_simple.cpp **** 
 3955              		.loc 3 300 1 view .LVU973
 3956 0056 09B0     		add	sp, sp, #36
 3957              	.LCFI56:
 3958              		.cfi_def_cfa_offset 12
 3959              		@ sp needed
 3960 0058 30BD     		pop	{r4, r5, pc}
 3961              	.L122:
 3962 005a 00BFAFF3 		.align	3
 3962      0080
 3963              	.L121:
 3964 0060 00000000 		.word	0
 3965 0064 00000000 		.word	0
 3966              		.cfi_endproc
 3967              	.LFE5225:
 3968              		.cantunwind
 3969              		.fnend
 3971              		.section	.text._ZN9CANSimple26start_anticogging_callbackERK4AxisRK13can_Message_t,"ax",%progbits
 3972              		.align	1
 3973              		.global	_ZN9CANSimple26start_anticogging_callbackERK4AxisRK13can_Message_t
ARM GAS  /tmp/ccoErako.s 			page 185


 3974              		.syntax unified
 3975              		.thumb
 3976              		.thumb_func
 3978              	_ZN9CANSimple26start_anticogging_callbackERK4AxisRK13can_Message_t:
 3979              		.fnstart
 3980              	.LVL269:
 3981              	.LFB5226:
 302:communication/can/can_simple.cpp ****     axis.controller_.start_anticogging_calibration();
 3982              		.loc 3 302 88 is_stmt 1 view -0
 3983              		.cfi_startproc
 3984              		@ args = 0, pretend = 0, frame = 0
 3985              		@ frame_needed = 0, uses_anonymous_args = 0
 302:communication/can/can_simple.cpp ****     axis.controller_.start_anticogging_calibration();
 3986              		.loc 3 302 88 is_stmt 0 view .LVU975
 3987 0000 08B5     		push	{r3, lr}
 3988              		.save {r3, lr}
 3989              	.LCFI57:
 3990              		.cfi_def_cfa_offset 8
 3991              		.cfi_offset 3, -8
 3992              		.cfi_offset 14, -4
 303:communication/can/can_simple.cpp **** }
 3993              		.loc 3 303 5 is_stmt 1 view .LVU976
 303:communication/can/can_simple.cpp **** }
 3994              		.loc 3 303 10 is_stmt 0 view .LVU977
 3995 0002 D0F80001 		ldr	r0, [r0, #256]
 3996              	.LVL270:
 303:communication/can/can_simple.cpp **** }
 3997              		.loc 3 303 52 view .LVU978
 3998 0006 0368     		ldr	r3, [r0]
 3999 0008 5B68     		ldr	r3, [r3, #4]
 303:communication/can/can_simple.cpp **** }
 4000              		.loc 3 303 51 view .LVU979
 4001 000a 9847     		blx	r3
 4002              	.LVL271:
 304:communication/can/can_simple.cpp **** 
 4003              		.loc 3 304 1 view .LVU980
 4004 000c 08BD     		pop	{r3, pc}
 4005              		.cfi_endproc
 4006              	.LFE5226:
 4007              		.fnend
 4009              		.section	.text._ZN9CANSimple27set_traj_vel_limit_callbackER4AxisRK13can_Message_t,"ax",%progbits
 4010              		.align	1
 4011              		.global	_ZN9CANSimple27set_traj_vel_limit_callbackER4AxisRK13can_Message_t
 4012              		.syntax unified
 4013              		.thumb
 4014              		.thumb_func
 4016              	_ZN9CANSimple27set_traj_vel_limit_callbackER4AxisRK13can_Message_t:
 4017              		.fnstart
 4018              	.LVL272:
 4019              	.LFB5227:
 306:communication/can/can_simple.cpp ****     axis.trap_traj_.config_.vel_limit = can_getSignal<float>(msg, 0, 32, true);
 4020              		.loc 3 306 83 is_stmt 1 view -0
 4021              		.cfi_startproc
 4022              		@ args = 0, pretend = 0, frame = 32
 4023              		@ frame_needed = 0, uses_anonymous_args = 0
 4024              		@ link register save eliminated.
 306:communication/can/can_simple.cpp ****     axis.trap_traj_.config_.vel_limit = can_getSignal<float>(msg, 0, 32, true);
ARM GAS  /tmp/ccoErako.s 			page 186


 4025              		.loc 3 306 83 is_stmt 0 view .LVU982
 4026 0000 10B4     		push	{r4}
 4027              	.LCFI58:
 4028              		.cfi_def_cfa_offset 4
 4029              		.cfi_offset 4, -4
 4030 0002 89B0     		sub	sp, sp, #36
 4031              	.LCFI59:
 4032              		.cfi_def_cfa_offset 40
 307:communication/can/can_simple.cpp **** }
 4033              		.loc 3 307 5 is_stmt 1 view .LVU983
 307:communication/can/can_simple.cpp **** }
 4034              		.loc 3 307 10 is_stmt 0 view .LVU984
 4035 0004 D0F85C41 		ldr	r4, [r0, #348]
 4036 0008 0FC9     		ldm	r1, {r0, r1, r2, r3}
 4037              	.LVL273:
 307:communication/can/can_simple.cpp **** }
 4038              		.loc 3 307 10 view .LVU985
 4039 000a 0DF1200C 		add	ip, sp, #32
 4040 000e 0CE90F00 		stmdb	ip, {r0, r1, r2, r3}
 4041              	.LVL274:
 4042              	.LBB1610:
 4043              	.LBI1610:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 4044              		.loc 4 31 13 is_stmt 1 view .LVU986
 4045              	.LBB1611:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 4046              		.loc 4 32 14 is_stmt 0 view .LVU987
 4047 0012 0022     		movs	r2, #0
 4048 0014 0023     		movs	r3, #0
 4049 0016 CDE90223 		strd	r2, [sp, #8]
 4050              	.LVL275:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 4051              		.loc 4 36 20 view .LVU988
 4052 001a 02AB     		add	r3, sp, #8
 4053 001c DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 4054 0020 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 4055 0024 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 4056              		.loc 4 37 17 view .LVU989
 4057 0026 0392     		str	r2, [sp, #12]
  45:communication/can/can_helpers.hpp ****     return retVal;
 4058              		.loc 4 45 16 view .LVU990
 4059 0028 0190     		str	r0, [sp, #4]
 4060              	.LVL276:
  45:communication/can/can_helpers.hpp ****     return retVal;
 4061              		.loc 4 45 16 view .LVU991
 4062              	.LBE1611:
 4063              	.LBE1610:
 307:communication/can/can_simple.cpp **** }
 4064              		.loc 3 307 39 view .LVU992
 4065 002a 6060     		str	r0, [r4, #4]	@ float
 308:communication/can/can_simple.cpp **** 
 4066              		.loc 3 308 1 view .LVU993
 4067 002c 09B0     		add	sp, sp, #36
 4068              	.LCFI60:
 4069              		.cfi_def_cfa_offset 4
 4070              		@ sp needed
ARM GAS  /tmp/ccoErako.s 			page 187


 4071 002e 5DF8044B 		ldr	r4, [sp], #4
 4072              	.LCFI61:
 4073              		.cfi_restore 4
 4074              		.cfi_def_cfa_offset 0
 4075 0032 7047     		bx	lr
 4076              		.cfi_endproc
 4077              	.LFE5227:
 4078              		.cantunwind
 4079              		.fnend
 4081              		.section	.text._ZN9CANSimple30set_traj_accel_limits_callbackER4AxisRK13can_Message_t,"ax",%progbit
 4082              		.align	1
 4083              		.global	_ZN9CANSimple30set_traj_accel_limits_callbackER4AxisRK13can_Message_t
 4084              		.syntax unified
 4085              		.thumb
 4086              		.thumb_func
 4088              	_ZN9CANSimple30set_traj_accel_limits_callbackER4AxisRK13can_Message_t:
 4089              		.fnstart
 4090              	.LVL277:
 4091              	.LFB5228:
 310:communication/can/can_simple.cpp ****     axis.trap_traj_.config_.accel_limit = can_getSignal<float>(msg, 0, 32, true);
 4092              		.loc 3 310 86 is_stmt 1 view -0
 4093              		.cfi_startproc
 4094              		@ args = 0, pretend = 0, frame = 32
 4095              		@ frame_needed = 0, uses_anonymous_args = 0
 310:communication/can/can_simple.cpp ****     axis.trap_traj_.config_.accel_limit = can_getSignal<float>(msg, 0, 32, true);
 4096              		.loc 3 310 86 is_stmt 0 view .LVU995
 4097 0000 30B5     		push	{r4, r5, lr}
 4098              	.LCFI62:
 4099              		.cfi_def_cfa_offset 12
 4100              		.cfi_offset 4, -12
 4101              		.cfi_offset 5, -8
 4102              		.cfi_offset 14, -4
 4103 0002 89B0     		sub	sp, sp, #36
 4104              	.LCFI63:
 4105              		.cfi_def_cfa_offset 48
 4106 0004 0446     		mov	r4, r0
 4107 0006 8C46     		mov	ip, r1
 311:communication/can/can_simple.cpp ****     axis.trap_traj_.config_.decel_limit = can_getSignal<float>(msg, 32, 32, true);
 4108              		.loc 3 311 5 is_stmt 1 view .LVU996
 4109 0008 0DF1100E 		add	lr, sp, #16
 4110 000c 0FC9     		ldm	r1, {r0, r1, r2, r3}
 4111              	.LVL278:
 311:communication/can/can_simple.cpp ****     axis.trap_traj_.config_.decel_limit = can_getSignal<float>(msg, 32, 32, true);
 4112              		.loc 3 311 5 is_stmt 0 view .LVU997
 4113 000e 8EE80F00 		stm	lr, {r0, r1, r2, r3}
 4114              	.LVL279:
 4115              	.LBB1624:
 4116              	.LBI1624:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 4117              		.loc 4 31 13 is_stmt 1 view .LVU998
 4118              	.LBB1625:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 4119              		.loc 4 32 14 is_stmt 0 view .LVU999
 4120 0012 9FED137B 		vldr.64	d7, .L129	@ int
 4121 0016 8DED027B 		vstr.64	d7, [sp, #8]	@ int
 4122              	.LVL280:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
ARM GAS  /tmp/ccoErako.s 			page 188


 4123              		.loc 4 36 20 view .LVU1000
 4124 001a 02AB     		add	r3, sp, #8
 4125 001c DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 4126 0020 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 4127 0024 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 4128              		.loc 4 37 41 view .LVU1001
 4129 0026 0025     		movs	r5, #0
  37:communication/can/can_helpers.hpp ****     } else {
 4130              		.loc 4 37 17 view .LVU1002
 4131 0028 0395     		str	r5, [sp, #12]
  45:communication/can/can_helpers.hpp ****     return retVal;
 4132              		.loc 4 45 16 view .LVU1003
 4133 002a 0190     		str	r0, [sp, #4]
 4134              	.LVL281:
  45:communication/can/can_helpers.hpp ****     return retVal;
 4135              		.loc 4 45 16 view .LVU1004
 4136              	.LBE1625:
 4137              	.LBE1624:
 311:communication/can/can_simple.cpp ****     axis.trap_traj_.config_.decel_limit = can_getSignal<float>(msg, 32, 32, true);
 4138              		.loc 3 311 41 view .LVU1005
 4139 002c D4F85C21 		ldr	r2, [r4, #348]
 4140 0030 9060     		str	r0, [r2, #8]	@ float
 312:communication/can/can_simple.cpp **** }
 4141              		.loc 3 312 5 is_stmt 1 view .LVU1006
 312:communication/can/can_simple.cpp **** }
 4142              		.loc 3 312 10 is_stmt 0 view .LVU1007
 4143 0032 D4F85C41 		ldr	r4, [r4, #348]
 4144              	.LVL282:
 312:communication/can/can_simple.cpp **** }
 4145              		.loc 3 312 10 view .LVU1008
 4146 0036 9CE80F00 		ldm	ip, {r0, r1, r2, r3}
 4147 003a 8EE80F00 		stm	lr, {r0, r1, r2, r3}
 4148              	.LVL283:
 4149              	.LBB1626:
 4150              	.LBI1626:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 4151              		.loc 4 31 13 is_stmt 1 view .LVU1009
 4152              	.LBB1627:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 4153              		.loc 4 32 14 is_stmt 0 view .LVU1010
 4154 003e 8DED027B 		vstr.64	d7, [sp, #8]	@ int
 4155              	.LVL284:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 4156              		.loc 4 36 20 view .LVU1011
 4157 0042 02AB     		add	r3, sp, #8
 4158 0044 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 4159 0048 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 4160 004c 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 4161              		.loc 4 37 17 view .LVU1012
 4162 004e 0291     		str	r1, [sp, #8]
 4163 0050 0395     		str	r5, [sp, #12]
  45:communication/can/can_helpers.hpp ****     return retVal;
 4164              		.loc 4 45 16 view .LVU1013
 4165 0052 0191     		str	r1, [sp, #4]
 4166              	.LVL285:
ARM GAS  /tmp/ccoErako.s 			page 189


  45:communication/can/can_helpers.hpp ****     return retVal;
 4167              		.loc 4 45 16 view .LVU1014
 4168              	.LBE1627:
 4169              	.LBE1626:
 312:communication/can/can_simple.cpp **** }
 4170              		.loc 3 312 41 view .LVU1015
 4171 0054 E160     		str	r1, [r4, #12]	@ float
 313:communication/can/can_simple.cpp **** 
 4172              		.loc 3 313 1 view .LVU1016
 4173 0056 09B0     		add	sp, sp, #36
 4174              	.LCFI64:
 4175              		.cfi_def_cfa_offset 12
 4176              		@ sp needed
 4177 0058 30BD     		pop	{r4, r5, pc}
 4178              	.L130:
 4179 005a 00BFAFF3 		.align	3
 4179      0080
 4180              	.L129:
 4181 0060 00000000 		.word	0
 4182 0064 00000000 		.word	0
 4183              		.cfi_endproc
 4184              	.LFE5228:
 4185              		.cantunwind
 4186              		.fnend
 4188              		.section	.text._ZN9CANSimple25set_traj_inertia_callbackER4AxisRK13can_Message_t,"ax",%progbits
 4189              		.align	1
 4190              		.global	_ZN9CANSimple25set_traj_inertia_callbackER4AxisRK13can_Message_t
 4191              		.syntax unified
 4192              		.thumb
 4193              		.thumb_func
 4195              	_ZN9CANSimple25set_traj_inertia_callbackER4AxisRK13can_Message_t:
 4196              		.fnstart
 4197              	.LVL286:
 4198              	.LFB5229:
 315:communication/can/can_simple.cpp ****     axis.controller_.config_.inertia = can_getSignal<float>(msg, 0, 32, true);
 4199              		.loc 3 315 81 is_stmt 1 view -0
 4200              		.cfi_startproc
 4201              		@ args = 0, pretend = 0, frame = 32
 4202              		@ frame_needed = 0, uses_anonymous_args = 0
 4203              		@ link register save eliminated.
 315:communication/can/can_simple.cpp ****     axis.controller_.config_.inertia = can_getSignal<float>(msg, 0, 32, true);
 4204              		.loc 3 315 81 is_stmt 0 view .LVU1018
 4205 0000 10B4     		push	{r4}
 4206              	.LCFI65:
 4207              		.cfi_def_cfa_offset 4
 4208              		.cfi_offset 4, -4
 4209 0002 89B0     		sub	sp, sp, #36
 4210              	.LCFI66:
 4211              		.cfi_def_cfa_offset 40
 316:communication/can/can_simple.cpp **** }
 4212              		.loc 3 316 5 is_stmt 1 view .LVU1019
 316:communication/can/can_simple.cpp **** }
 4213              		.loc 3 316 10 is_stmt 0 view .LVU1020
 4214 0004 D0F80041 		ldr	r4, [r0, #256]
 4215 0008 0FC9     		ldm	r1, {r0, r1, r2, r3}
 4216              	.LVL287:
 316:communication/can/can_simple.cpp **** }
ARM GAS  /tmp/ccoErako.s 			page 190


 4217              		.loc 3 316 10 view .LVU1021
 4218 000a 0DF1200C 		add	ip, sp, #32
 4219 000e 0CE90F00 		stmdb	ip, {r0, r1, r2, r3}
 4220              	.LVL288:
 4221              	.LBB1634:
 4222              	.LBI1634:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 4223              		.loc 4 31 13 is_stmt 1 view .LVU1022
 4224              	.LBB1635:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 4225              		.loc 4 32 14 is_stmt 0 view .LVU1023
 4226 0012 0022     		movs	r2, #0
 4227 0014 0023     		movs	r3, #0
 4228 0016 CDE90223 		strd	r2, [sp, #8]
 4229              	.LVL289:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 4230              		.loc 4 36 20 view .LVU1024
 4231 001a 02AB     		add	r3, sp, #8
 4232 001c DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 4233 0020 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 4234 0024 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 4235              		.loc 4 37 17 view .LVU1025
 4236 0026 0392     		str	r2, [sp, #12]
  45:communication/can/can_helpers.hpp ****     return retVal;
 4237              		.loc 4 45 16 view .LVU1026
 4238 0028 0190     		str	r0, [sp, #4]
 4239              	.LVL290:
  45:communication/can/can_helpers.hpp ****     return retVal;
 4240              		.loc 4 45 16 view .LVU1027
 4241              	.LBE1635:
 4242              	.LBE1634:
 316:communication/can/can_simple.cpp **** }
 4243              		.loc 3 316 38 view .LVU1028
 4244 002a A064     		str	r0, [r4, #72]	@ float
 317:communication/can/can_simple.cpp **** 
 4245              		.loc 3 317 1 view .LVU1029
 4246 002c 09B0     		add	sp, sp, #36
 4247              	.LCFI67:
 4248              		.cfi_def_cfa_offset 4
 4249              		@ sp needed
 4250 002e 5DF8044B 		ldr	r4, [sp], #4
 4251              	.LCFI68:
 4252              		.cfi_restore 4
 4253              		.cfi_def_cfa_offset 0
 4254 0032 7047     		bx	lr
 4255              		.cfi_endproc
 4256              	.LFE5229:
 4257              		.cantunwind
 4258              		.fnend
 4260              		.section	.text._ZN9CANSimple25set_linear_count_callbackER4AxisRK13can_Message_t,"ax",%progbits
 4261              		.align	1
 4262              		.global	_ZN9CANSimple25set_linear_count_callbackER4AxisRK13can_Message_t
 4263              		.syntax unified
 4264              		.thumb
 4265              		.thumb_func
 4267              	_ZN9CANSimple25set_linear_count_callbackER4AxisRK13can_Message_t:
ARM GAS  /tmp/ccoErako.s 			page 191


 4268              		.fnstart
 4269              	.LVL291:
 4270              	.LFB5230:
 319:communication/can/can_simple.cpp ****     axis.encoder_.set_linear_count(can_getSignal<int32_t>(msg, 0, 32, true));
 4271              		.loc 3 319 81 is_stmt 1 view -0
 4272              		.cfi_startproc
 4273              		@ args = 0, pretend = 0, frame = 24
 4274              		@ frame_needed = 0, uses_anonymous_args = 0
 319:communication/can/can_simple.cpp ****     axis.encoder_.set_linear_count(can_getSignal<int32_t>(msg, 0, 32, true));
 4275              		.loc 3 319 81 is_stmt 0 view .LVU1031
 4276 0000 30B5     		push	{r4, r5, lr}
 4277              		.save {r4, r5, lr}
 4278              	.LCFI69:
 4279              		.cfi_def_cfa_offset 12
 4280              		.cfi_offset 4, -12
 4281              		.cfi_offset 5, -8
 4282              		.cfi_offset 14, -4
 4283              		.pad #28
 4284 0002 87B0     		sub	sp, sp, #28
 4285              	.LCFI70:
 4286              		.cfi_def_cfa_offset 40
 320:communication/can/can_simple.cpp **** }
 4287              		.loc 3 320 5 is_stmt 1 view .LVU1032
 320:communication/can/can_simple.cpp **** }
 4288              		.loc 3 320 10 is_stmt 0 view .LVU1033
 4289 0004 D0F8AC40 		ldr	r4, [r0, #172]
 320:communication/can/can_simple.cpp **** }
 4290              		.loc 3 320 76 view .LVU1034
 4291 0008 2368     		ldr	r3, [r4]
 4292 000a 1D68     		ldr	r5, [r3]
 4293 000c 0FC9     		ldm	r1, {r0, r1, r2, r3}
 4294              	.LVL292:
 320:communication/can/can_simple.cpp **** }
 4295              		.loc 3 320 76 view .LVU1035
 4296 000e 0DF1180C 		add	ip, sp, #24
 4297 0012 0CE90F00 		stmdb	ip, {r0, r1, r2, r3}
 4298              	.LVL293:
 4299              	.LBB1642:
 4300              	.LBI1642:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 4301              		.loc 4 31 13 is_stmt 1 view .LVU1036
 4302              	.LBB1643:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 4303              		.loc 4 32 14 is_stmt 0 view .LVU1037
 4304 0016 0022     		movs	r2, #0
 4305 0018 0023     		movs	r3, #0
 4306 001a CDE90023 		strd	r2, [sp]
 4307              	.LVL294:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 4308              		.loc 4 36 20 view .LVU1038
 4309 001e 6B46     		mov	r3, sp
 4310 0020 DDF80F00 		ldr	r0, [sp, #15]	@ unaligned
 4311 0024 DDF81310 		ldr	r1, [sp, #19]	@ unaligned
 4312 0028 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 4313              		.loc 4 37 41 view .LVU1039
 4314 002a 0023     		movs	r3, #0
ARM GAS  /tmp/ccoErako.s 			page 192


  37:communication/can/can_helpers.hpp ****     } else {
 4315              		.loc 4 37 17 view .LVU1040
 4316 002c 0193     		str	r3, [sp, #4]
 4317              	.LVL295:
  37:communication/can/can_helpers.hpp ****     } else {
 4318              		.loc 4 37 17 view .LVU1041
 4319              	.LBE1643:
 4320              	.LBE1642:
 320:communication/can/can_simple.cpp **** }
 4321              		.loc 3 320 35 view .LVU1042
 4322 002e 0146     		mov	r1, r0
 4323 0030 2046     		mov	r0, r4
 4324 0032 A847     		blx	r5
 4325              	.LVL296:
 321:communication/can/can_simple.cpp **** 
 4326              		.loc 3 321 1 view .LVU1043
 4327 0034 07B0     		add	sp, sp, #28
 4328              	.LCFI71:
 4329              		.cfi_def_cfa_offset 12
 4330              		@ sp needed
 4331 0036 30BD     		pop	{r4, r5, pc}
 4332              		.cfi_endproc
 4333              	.LFE5230:
 4334              		.fnend
 4336              		.section	.text._ZN9CANSimple21set_pos_gain_callbackER4AxisRK13can_Message_t,"ax",%progbits
 4337              		.align	1
 4338              		.global	_ZN9CANSimple21set_pos_gain_callbackER4AxisRK13can_Message_t
 4339              		.syntax unified
 4340              		.thumb
 4341              		.thumb_func
 4343              	_ZN9CANSimple21set_pos_gain_callbackER4AxisRK13can_Message_t:
 4344              		.fnstart
 4345              	.LVL297:
 4346              	.LFB5231:
 323:communication/can/can_simple.cpp ****     axis.controller_.config_.pos_gain = can_getSignal<float>(msg, 0, 32, true);
 4347              		.loc 3 323 77 is_stmt 1 view -0
 4348              		.cfi_startproc
 4349              		@ args = 0, pretend = 0, frame = 32
 4350              		@ frame_needed = 0, uses_anonymous_args = 0
 4351              		@ link register save eliminated.
 323:communication/can/can_simple.cpp ****     axis.controller_.config_.pos_gain = can_getSignal<float>(msg, 0, 32, true);
 4352              		.loc 3 323 77 is_stmt 0 view .LVU1045
 4353 0000 10B4     		push	{r4}
 4354              	.LCFI72:
 4355              		.cfi_def_cfa_offset 4
 4356              		.cfi_offset 4, -4
 4357 0002 89B0     		sub	sp, sp, #36
 4358              	.LCFI73:
 4359              		.cfi_def_cfa_offset 40
 324:communication/can/can_simple.cpp **** }
 4360              		.loc 3 324 5 is_stmt 1 view .LVU1046
 324:communication/can/can_simple.cpp **** }
 4361              		.loc 3 324 10 is_stmt 0 view .LVU1047
 4362 0004 D0F80041 		ldr	r4, [r0, #256]
 4363 0008 0FC9     		ldm	r1, {r0, r1, r2, r3}
 4364              	.LVL298:
 324:communication/can/can_simple.cpp **** }
ARM GAS  /tmp/ccoErako.s 			page 193


 4365              		.loc 3 324 10 view .LVU1048
 4366 000a 0DF1200C 		add	ip, sp, #32
 4367 000e 0CE90F00 		stmdb	ip, {r0, r1, r2, r3}
 4368              	.LVL299:
 4369              	.LBB1650:
 4370              	.LBI1650:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 4371              		.loc 4 31 13 is_stmt 1 view .LVU1049
 4372              	.LBB1651:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 4373              		.loc 4 32 14 is_stmt 0 view .LVU1050
 4374 0012 0022     		movs	r2, #0
 4375 0014 0023     		movs	r3, #0
 4376 0016 CDE90223 		strd	r2, [sp, #8]
 4377              	.LVL300:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 4378              		.loc 4 36 20 view .LVU1051
 4379 001a 02AB     		add	r3, sp, #8
 4380 001c DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 4381 0020 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 4382 0024 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 4383              		.loc 4 37 17 view .LVU1052
 4384 0026 0392     		str	r2, [sp, #12]
  45:communication/can/can_helpers.hpp ****     return retVal;
 4385              		.loc 4 45 16 view .LVU1053
 4386 0028 0190     		str	r0, [sp, #4]
 4387              	.LVL301:
  45:communication/can/can_helpers.hpp ****     return retVal;
 4388              		.loc 4 45 16 view .LVU1054
 4389              	.LBE1651:
 4390              	.LBE1650:
 324:communication/can/can_simple.cpp **** }
 4391              		.loc 3 324 39 view .LVU1055
 4392 002a E061     		str	r0, [r4, #28]	@ float
 325:communication/can/can_simple.cpp **** 
 4393              		.loc 3 325 1 view .LVU1056
 4394 002c 09B0     		add	sp, sp, #36
 4395              	.LCFI74:
 4396              		.cfi_def_cfa_offset 4
 4397              		@ sp needed
 4398 002e 5DF8044B 		ldr	r4, [sp], #4
 4399              	.LCFI75:
 4400              		.cfi_restore 4
 4401              		.cfi_def_cfa_offset 0
 4402 0032 7047     		bx	lr
 4403              		.cfi_endproc
 4404              	.LFE5231:
 4405              		.cantunwind
 4406              		.fnend
 4408              		.section	.text._ZN9CANSimple22set_vel_gains_callbackER4AxisRK13can_Message_t,"ax",%progbits
 4409              		.align	1
 4410              		.global	_ZN9CANSimple22set_vel_gains_callbackER4AxisRK13can_Message_t
 4411              		.syntax unified
 4412              		.thumb
 4413              		.thumb_func
 4415              	_ZN9CANSimple22set_vel_gains_callbackER4AxisRK13can_Message_t:
ARM GAS  /tmp/ccoErako.s 			page 194


 4416              		.fnstart
 4417              	.LVL302:
 4418              	.LFB5232:
 327:communication/can/can_simple.cpp ****     axis.controller_.config_.vel_gain = can_getSignal<float>(msg, 0, 32, true);
 4419              		.loc 3 327 78 is_stmt 1 view -0
 4420              		.cfi_startproc
 4421              		@ args = 0, pretend = 0, frame = 32
 4422              		@ frame_needed = 0, uses_anonymous_args = 0
 327:communication/can/can_simple.cpp ****     axis.controller_.config_.vel_gain = can_getSignal<float>(msg, 0, 32, true);
 4423              		.loc 3 327 78 is_stmt 0 view .LVU1058
 4424 0000 30B5     		push	{r4, r5, lr}
 4425              	.LCFI76:
 4426              		.cfi_def_cfa_offset 12
 4427              		.cfi_offset 4, -12
 4428              		.cfi_offset 5, -8
 4429              		.cfi_offset 14, -4
 4430 0002 89B0     		sub	sp, sp, #36
 4431              	.LCFI77:
 4432              		.cfi_def_cfa_offset 48
 4433 0004 0446     		mov	r4, r0
 4434 0006 8C46     		mov	ip, r1
 328:communication/can/can_simple.cpp ****     axis.controller_.config_.vel_integrator_gain = can_getSignal<float>(msg, 32, 32, true);
 4435              		.loc 3 328 5 is_stmt 1 view .LVU1059
 4436 0008 0DF1100E 		add	lr, sp, #16
 4437 000c 0FC9     		ldm	r1, {r0, r1, r2, r3}
 4438              	.LVL303:
 328:communication/can/can_simple.cpp ****     axis.controller_.config_.vel_integrator_gain = can_getSignal<float>(msg, 32, 32, true);
 4439              		.loc 3 328 5 is_stmt 0 view .LVU1060
 4440 000e 8EE80F00 		stm	lr, {r0, r1, r2, r3}
 4441              	.LVL304:
 4442              	.LBB1664:
 4443              	.LBI1664:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 4444              		.loc 4 31 13 is_stmt 1 view .LVU1061
 4445              	.LBB1665:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 4446              		.loc 4 32 14 is_stmt 0 view .LVU1062
 4447 0012 9FED137B 		vldr.64	d7, .L139	@ int
 4448 0016 8DED027B 		vstr.64	d7, [sp, #8]	@ int
 4449              	.LVL305:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 4450              		.loc 4 36 20 view .LVU1063
 4451 001a 02AB     		add	r3, sp, #8
 4452 001c DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 4453 0020 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 4454 0024 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 4455              		.loc 4 37 41 view .LVU1064
 4456 0026 0025     		movs	r5, #0
  37:communication/can/can_helpers.hpp ****     } else {
 4457              		.loc 4 37 17 view .LVU1065
 4458 0028 0395     		str	r5, [sp, #12]
  45:communication/can/can_helpers.hpp ****     return retVal;
 4459              		.loc 4 45 16 view .LVU1066
 4460 002a 0190     		str	r0, [sp, #4]
 4461              	.LVL306:
  45:communication/can/can_helpers.hpp ****     return retVal;
ARM GAS  /tmp/ccoErako.s 			page 195


 4462              		.loc 4 45 16 view .LVU1067
 4463              	.LBE1665:
 4464              	.LBE1664:
 328:communication/can/can_simple.cpp ****     axis.controller_.config_.vel_integrator_gain = can_getSignal<float>(msg, 32, 32, true);
 4465              		.loc 3 328 39 view .LVU1068
 4466 002c D4F80021 		ldr	r2, [r4, #256]
 4467 0030 1062     		str	r0, [r2, #32]	@ float
 329:communication/can/can_simple.cpp **** }
 4468              		.loc 3 329 5 is_stmt 1 view .LVU1069
 329:communication/can/can_simple.cpp **** }
 4469              		.loc 3 329 10 is_stmt 0 view .LVU1070
 4470 0032 D4F80041 		ldr	r4, [r4, #256]
 4471              	.LVL307:
 329:communication/can/can_simple.cpp **** }
 4472              		.loc 3 329 10 view .LVU1071
 4473 0036 9CE80F00 		ldm	ip, {r0, r1, r2, r3}
 4474 003a 8EE80F00 		stm	lr, {r0, r1, r2, r3}
 4475              	.LVL308:
 4476              	.LBB1666:
 4477              	.LBI1666:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 4478              		.loc 4 31 13 is_stmt 1 view .LVU1072
 4479              	.LBB1667:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 4480              		.loc 4 32 14 is_stmt 0 view .LVU1073
 4481 003e 8DED027B 		vstr.64	d7, [sp, #8]	@ int
 4482              	.LVL309:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 4483              		.loc 4 36 20 view .LVU1074
 4484 0042 02AB     		add	r3, sp, #8
 4485 0044 DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 4486 0048 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 4487 004c 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 4488              		.loc 4 37 17 view .LVU1075
 4489 004e 0291     		str	r1, [sp, #8]
 4490 0050 0395     		str	r5, [sp, #12]
  45:communication/can/can_helpers.hpp ****     return retVal;
 4491              		.loc 4 45 16 view .LVU1076
 4492 0052 0191     		str	r1, [sp, #4]
 4493              	.LVL310:
  45:communication/can/can_helpers.hpp ****     return retVal;
 4494              		.loc 4 45 16 view .LVU1077
 4495              	.LBE1667:
 4496              	.LBE1666:
 329:communication/can/can_simple.cpp **** }
 4497              		.loc 3 329 50 view .LVU1078
 4498 0054 6162     		str	r1, [r4, #36]	@ float
 330:communication/can/can_simple.cpp **** 
 4499              		.loc 3 330 1 view .LVU1079
 4500 0056 09B0     		add	sp, sp, #36
 4501              	.LCFI78:
 4502              		.cfi_def_cfa_offset 12
 4503              		@ sp needed
 4504 0058 30BD     		pop	{r4, r5, pc}
 4505              	.L140:
 4506 005a 00BFAFF3 		.align	3
ARM GAS  /tmp/ccoErako.s 			page 196


 4506      0080
 4507              	.L139:
 4508 0060 00000000 		.word	0
 4509 0064 00000000 		.word	0
 4510              		.cfi_endproc
 4511              	.LFE5232:
 4512              		.cantunwind
 4513              		.fnend
 4515              		.section	.text._ZN9CANSimple24get_adc_voltage_callbackERK4AxisRK13can_Message_t,"ax",%progbits
 4516              		.align	1
 4517              		.global	_ZN9CANSimple24get_adc_voltage_callbackERK4AxisRK13can_Message_t
 4518              		.syntax unified
 4519              		.thumb
 4520              		.thumb_func
 4522              	_ZN9CANSimple24get_adc_voltage_callbackERK4AxisRK13can_Message_t:
 4523              		.fnstart
 4524              	.LVL311:
 4525              	.LFB5242:
 368:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 4526              		.loc 3 368 86 is_stmt 1 view -0
 4527              		.cfi_startproc
 4528              		@ args = 0, pretend = 0, frame = 56
 4529              		@ frame_needed = 0, uses_anonymous_args = 0
 368:communication/can/can_simple.cpp ****     can_Message_t txmsg;
 4530              		.loc 3 368 86 is_stmt 0 view .LVU1081
 4531 0000 30B5     		push	{r4, r5, lr}
 4532              		.save {r4, r5, lr}
 4533              	.LCFI79:
 4534              		.cfi_def_cfa_offset 12
 4535              		.cfi_offset 4, -12
 4536              		.cfi_offset 5, -8
 4537              		.cfi_offset 14, -4
 4538              		.pad #60
 4539 0002 8FB0     		sub	sp, sp, #60
 4540              	.LCFI80:
 4541              		.cfi_def_cfa_offset 72
 4542 0004 0446     		mov	r4, r0
 4543 0006 8C46     		mov	ip, r1
 4544 0008 9646     		mov	lr, r2
 369:communication/can/can_simple.cpp **** 
 4545              		.loc 3 369 5 is_stmt 1 view .LVU1082
 369:communication/can/can_simple.cpp **** 
 4546              		.loc 3 369 19 is_stmt 0 view .LVU1083
 4547 000a 2B4B     		ldr	r3, .L146
 4548 000c 08AD     		add	r5, sp, #32
 4549 000e 0FCB     		ldm	r3, {r0, r1, r2, r3}
 4550              	.LVL312:
 369:communication/can/can_simple.cpp **** 
 4551              		.loc 3 369 19 view .LVU1084
 4552 0010 85E80F00 		stm	r5, {r0, r1, r2, r3}
 371:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_ADC_VOLTAGE;
 4553              		.loc 3 371 5 is_stmt 1 view .LVU1085
 371:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_ADC_VOLTAGE;
 4554              		.loc 3 371 33 is_stmt 0 view .LVU1086
 4555 0014 DCF87830 		ldr	r3, [ip, #120]
 371:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_ADC_VOLTAGE;
 4556              		.loc 3 371 41 view .LVU1087
ARM GAS  /tmp/ccoErako.s 			page 197


 4557 0018 5B01     		lsls	r3, r3, #5
 371:communication/can/can_simple.cpp ****     txmsg.id += MSG_GET_ADC_VOLTAGE;
 4558              		.loc 3 371 14 view .LVU1088
 4559 001a 0893     		str	r3, [sp, #32]
 372:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 4560              		.loc 3 372 5 is_stmt 1 view .LVU1089
 372:communication/can/can_simple.cpp ****     txmsg.isExt = axis.config_.can.is_extended;
 4561              		.loc 3 372 14 is_stmt 0 view .LVU1090
 4562 001c 1C33     		adds	r3, r3, #28
 4563 001e 0893     		str	r3, [sp, #32]
 373:communication/can/can_simple.cpp ****     txmsg.len = 8;
 4564              		.loc 3 373 5 is_stmt 1 view .LVU1091
 373:communication/can/can_simple.cpp ****     txmsg.len = 8;
 4565              		.loc 3 373 36 is_stmt 0 view .LVU1092
 4566 0020 9CF87C30 		ldrb	r3, [ip, #124]	@ zero_extendqisi2
 373:communication/can/can_simple.cpp ****     txmsg.len = 8;
 4567              		.loc 3 373 17 view .LVU1093
 4568 0024 8DF82430 		strb	r3, [sp, #36]
 374:communication/can/can_simple.cpp **** 
 4569              		.loc 3 374 5 is_stmt 1 view .LVU1094
 376:communication/can/can_simple.cpp ****     if (gpio_num < GPIO_COUNT) {
 4570              		.loc 3 376 5 view .LVU1095
 4571 0028 0DF1100C 		add	ip, sp, #16
 4572              	.LVL313:
 376:communication/can/can_simple.cpp ****     if (gpio_num < GPIO_COUNT) {
 4573              		.loc 3 376 5 is_stmt 0 view .LVU1096
 4574 002c 9EE80F00 		ldm	lr, {r0, r1, r2, r3}
 4575 0030 8CE80F00 		stm	ip, {r0, r1, r2, r3}
 4576              	.LVL314:
 4577              	.LBB1687:
 4578              	.LBI1687:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 4579              		.loc 4 31 13 is_stmt 1 view .LVU1097
 4580              	.LBB1688:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 4581              		.loc 4 32 14 is_stmt 0 view .LVU1098
 4582 0034 0022     		movs	r2, #0
 4583 0036 0023     		movs	r3, #0
 4584 0038 CDE90223 		strd	r2, [sp, #8]
 4585              	.LVL315:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 4586              		.loc 4 36 20 view .LVU1099
 4587 003c 02AB     		add	r3, sp, #8
 4588 003e DDF81700 		ldr	r0, [sp, #23]	@ unaligned
 4589 0042 DDF81B10 		ldr	r1, [sp, #27]	@ unaligned
 4590 0046 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 4591              		.loc 4 37 41 view .LVU1100
 4592 0048 9DF80830 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
  37:communication/can/can_helpers.hpp ****     } else {
 4593              		.loc 4 37 17 view .LVU1101
 4594 004c 0293     		str	r3, [sp, #8]
 4595 004e 0023     		movs	r3, #0
 4596 0050 0393     		str	r3, [sp, #12]
 4597 0052 9DF80810 		ldrb	r1, [sp, #8]	@ zero_extendqisi2
 4598              	.LVL316:
  37:communication/can/can_helpers.hpp ****     } else {
ARM GAS  /tmp/ccoErako.s 			page 198


 4599              		.loc 4 37 17 view .LVU1102
 4600              	.LBE1688:
 4601              	.LBE1687:
 377:communication/can/can_simple.cpp ****         auto voltage = get_adc_voltage(get_gpio(gpio_num));
 4602              		.loc 3 377 5 is_stmt 1 view .LVU1103
 4603              	.LBB1689:
 4604 0056 1029     		cmp	r1, #16
 4605 0058 02D9     		bls	.L145
 382:communication/can/can_simple.cpp ****     }
 4606              		.loc 3 382 16 is_stmt 0 view .LVU1104
 4607 005a 0020     		movs	r0, #0
 4608              	.LVL317:
 4609              	.L142:
 382:communication/can/can_simple.cpp ****     }
 4610              		.loc 3 382 16 view .LVU1105
 4611              	.LBE1689:
 384:communication/can/can_simple.cpp **** 
 4612              		.loc 3 384 1 discriminator 1 view .LVU1106
 4613 005c 0FB0     		add	sp, sp, #60
 4614              	.LCFI81:
 4615              		.cfi_remember_state
 4616              		.cfi_def_cfa_offset 12
 4617              		@ sp needed
 4618 005e 30BD     		pop	{r4, r5, pc}
 4619              	.LVL318:
 4620              	.L145:
 4621              	.LCFI82:
 4622              		.cfi_restore_state
 4623              	.LBB1694:
 4624              	.LBB1690:
 378:communication/can/can_simple.cpp ****         can_setSignal<float>(txmsg, voltage, 0, 32, true);
 4625              		.loc 3 378 9 is_stmt 1 view .LVU1107
 378:communication/can/can_simple.cpp ****         can_setSignal<float>(txmsg, voltage, 0, 32, true);
 4626              		.loc 3 378 39 is_stmt 0 view .LVU1108
 4627 0060 0CAD     		add	r5, sp, #48
 4628 0062 2846     		mov	r0, r5
 4629 0064 FFF7FEFF 		bl	_ZL8get_gpioj
 4630              	.LVL319:
 378:communication/can/can_simple.cpp ****         can_setSignal<float>(txmsg, voltage, 0, 32, true);
 4631              		.loc 3 378 39 view .LVU1109
 4632 0068 95E80300 		ldm	r5, {r0, r1}
 4633 006c FFF7FEFF 		bl	get_adc_voltage
 4634              	.LVL320:
 4635 0070 8DED010A 		vstr.32	s0, [sp, #4]
 4636              	.LVL321:
 379:communication/can/can_simple.cpp ****         return canbus_->send_message(txmsg);
 4637              		.loc 3 379 9 is_stmt 1 view .LVU1110
 4638              	.LBB1691:
 4639              	.LBI1691:
  50:communication/can/can_helpers.hpp ****     uint64_t valAsBits = 0;
 4640              		.loc 4 50 16 view .LVU1111
 4641              	.LBB1692:
  51:communication/can/can_helpers.hpp ****     std::memcpy(&valAsBits, &val, sizeof(val));
 4642              		.loc 4 51 14 is_stmt 0 view .LVU1112
 4643 0074 0020     		movs	r0, #0
 4644 0076 0021     		movs	r1, #0
 4645 0078 CDE90201 		strd	r0, [sp, #8]
ARM GAS  /tmp/ccoErako.s 			page 199


  52:communication/can/can_helpers.hpp **** 
 4646              		.loc 4 52 16 view .LVU1113
 4647 007c 019B     		ldr	r3, [sp, #4]
 4648 007e 0293     		str	r3, [sp, #8]
 4649              	.LVL322:
 4650              	.LBB1693:
  57:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
 4651              		.loc 4 57 18 view .LVU1114
 4652 0080 CDE90401 		strd	r0, [sp, #16]
  58:communication/can/can_helpers.hpp **** 
 4653              		.loc 4 58 20 view .LVU1115
 4654 0084 04AA     		add	r2, sp, #16
 4655 0086 DDF82700 		ldr	r0, [sp, #39]	@ unaligned
 4656 008a DDF82B10 		ldr	r1, [sp, #43]	@ unaligned
 4657 008e 03C2     		stmia	r2!, {r0, r1}
  60:communication/can/can_helpers.hpp ****         data |= valAsBits << startBit;
 4658              		.loc 4 60 14 view .LVU1116
 4659 0090 0022     		movs	r2, #0
 4660 0092 0492     		str	r2, [sp, #16]
  61:communication/can/can_helpers.hpp **** 
 4661              		.loc 4 61 27 view .LVU1117
 4662 0094 0399     		ldr	r1, [sp, #12]
  61:communication/can/can_helpers.hpp **** 
 4663              		.loc 4 61 14 view .LVU1118
 4664 0096 059A     		ldr	r2, [sp, #20]
 4665 0098 0A43     		orrs	r2, r2, r1
 4666 009a 0493     		str	r3, [sp, #16]
 4667 009c 0592     		str	r2, [sp, #20]
 4668              		.loc 4 63 20 view .LVU1119
 4669 009e 04AB     		add	r3, sp, #16
 4670 00a0 03CB     		ldmia	r3!, {r0, r1}
 4671 00a2 CDF82700 		str	r0, [sp, #39]	@ unaligned
 4672 00a6 CDF82B10 		str	r1, [sp, #43]	@ unaligned
 4673              	.LVL323:
 4674              		.loc 4 63 20 view .LVU1120
 4675              	.LBE1693:
 4676              	.LBE1692:
 4677              	.LBE1691:
 380:communication/can/can_simple.cpp ****     } else {
 4678              		.loc 3 380 9 is_stmt 1 view .LVU1121
 380:communication/can/can_simple.cpp ****     } else {
 4679              		.loc 3 380 16 is_stmt 0 view .LVU1122
 4680 00aa 2068     		ldr	r0, [r4]
 380:communication/can/can_simple.cpp ****     } else {
 4681              		.loc 3 380 43 view .LVU1123
 4682 00ac 0368     		ldr	r3, [r0]
 4683 00ae 1B68     		ldr	r3, [r3]
 380:communication/can/can_simple.cpp ****     } else {
 4684              		.loc 3 380 37 view .LVU1124
 4685 00b0 08A9     		add	r1, sp, #32
 4686 00b2 9847     		blx	r3
 4687              	.LVL324:
 380:communication/can/can_simple.cpp ****     } else {
 4688              		.loc 3 380 37 view .LVU1125
 4689 00b4 D2E7     		b	.L142
 4690              	.L147:
 4691 00b6 00BF     		.align	2
ARM GAS  /tmp/ccoErako.s 			page 200


 4692              	.L146:
 4693 00b8 00000000 		.word	.LANCHOR0
 4694              	.LBE1690:
 4695              	.LBE1694:
 4696              		.cfi_endproc
 4697              	.LFE5242:
 4698              		.fnend
 4700              		.section	.text._ZSt9__reverseIPhEvT_S1_St26random_access_iterator_tag,"axG",%progbits,_ZSt9__rever
 4701              		.align	1
 4702              		.weak	_ZSt9__reverseIPhEvT_S1_St26random_access_iterator_tag
 4703              		.syntax unified
 4704              		.thumb
 4705              		.thumb_func
 4707              	_ZSt9__reverseIPhEvT_S1_St26random_access_iterator_tag:
 4708              		.fnstart
 4709              	.LVL325:
 4710              	.LFB5974:
 4711              		.file 14 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // Algorithm implementation -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // Copyright (C) 2001-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** /*
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  *
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * Copyright (c) 1994
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * Hewlett-Packard Company
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  *
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * Permission to use, copy, modify, distribute and sell this software
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * and its documentation for any purpose is hereby granted without fee,
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * provided that the above copyright notice appear in all copies and
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * that both that copyright notice and this permission notice appear
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * in supporting documentation.  Hewlett-Packard Company makes no
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * representations about the suitability of this software for any
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  *
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  *
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * Copyright (c) 1996
ARM GAS  /tmp/ccoErako.s 			page 201


  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * Silicon Graphics Computer Systems, Inc.
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  *
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * Permission to use, copy, modify, distribute and sell this software
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * and its documentation for any purpose is hereby granted without fee,
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * provided that the above copyright notice appear in all copies and
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * that both that copyright notice and this permission notice appear
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * in supporting documentation.  Silicon Graphics makes no
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * representations about the suitability of this software for any
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  */
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** /** @file bits/stl_algo.h
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  *  This is an internal header file, included by other library headers.
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  *  Do not attempt to use it directly. @headername{algorithm}
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  */
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #ifndef _STL_ALGO_H
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #define _STL_ALGO_H 1
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #include <cstdlib>	     // for rand
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #include <bits/algorithmfwd.h>
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #include <bits/stl_heap.h>
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #include <bits/stl_tempbuf.h>  // for _Temporary_buffer
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #include <bits/predefined_ops.h>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #if __cplusplus >= 201103L
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #include <bits/uniform_int_dist.h>
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #endif
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // See concept_check.h for the __glibcxx_*_requires macros.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** namespace std _GLIBCXX_VISIBILITY(default)
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** {
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// Swaps the median value of *__a, *__b and *__c under __comp to *__result
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _Iterator, typename _Compare>
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   _Iterator __c, _Compare __comp)
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__comp(__a, __b))
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__comp(__b, __c))
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::iter_swap(__result, __b);
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else if (__comp(__a, __c))
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::iter_swap(__result, __c);
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::iter_swap(__result, __a);
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else if (__comp(__a, __c))
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::iter_swap(__result, __a);
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else if (__comp(__b, __c))
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::iter_swap(__result, __c);
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::iter_swap(__result, __b);
ARM GAS  /tmp/ccoErako.s 			page 202


  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// Provided for stable_partition to use.
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Predicate>
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _InputIterator
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __find_if_not(_InputIterator __first, _InputIterator __last,
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _Predicate __pred)
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__find_if(__first, __last,
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			    __gnu_cxx::__ops::__negate(__pred),
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			    std::__iterator_category(__first));
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// Like find_if_not(), but uses and updates a count of the
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// remaining range length instead of comparing against an end
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// iterator.
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Predicate, typename _Distance>
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _InputIterator
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (; __len; --__len,  (void) ++__first)
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__pred(__first))
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  break;
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __first;
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // set_difference
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // set_intersection
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // set_symmetric_difference
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // set_union
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // for_each
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // find
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // find_if
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // find_first_of
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // adjacent_find
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // count
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // count_if
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // search
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2,
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator1
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _BinaryPredicate  __predicate)
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // Test for empty ranges
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first1 == __last1 || __first2 == __last2)
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __first1;
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // Test for a pattern of length 1.
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator2 __p1(__first2);
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (++__p1 == __last2)
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return std::__find_if(__first1, __last1,
ARM GAS  /tmp/ccoErako.s 			page 203


 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // General case.
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator1 __current = __first1;
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (;;)
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __first1 =
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::__find_if(__first1, __last1,
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__first1 == __last1)
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __last1;
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _ForwardIterator2 __p = __p1;
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __current = __first1;
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (++__current == __last1)
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __last1;
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  while (__predicate(__current, __p))
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (++__p == __last2)
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		return __first1;
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (++__current == __last1)
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		return __last1;
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first1;
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __first1;
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // search_n
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is an helper function for search_n overloaded for forward iterators.
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Integer,
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _UnaryPredicate>
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _Integer __count, _UnaryPredicate __unary_pred,
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   std::forward_iterator_tag)
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __first = std::__find_if(__first, __last, __unary_pred);
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__first != __last)
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  typename iterator_traits<_ForwardIterator>::difference_type
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __n = __count;
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _ForwardIterator __i = __first;
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__i;
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  while (__i != __last && __n != 1 && __unary_pred(__i))
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__i;
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      --__n;
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__n == 1)
ARM GAS  /tmp/ccoErako.s 			page 204


 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __first;
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__i == __last)
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __last;
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __first = std::__find_if(++__i, __last, __unary_pred);
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __last;
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is an helper function for search_n overloaded for random access
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  iterators.
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIter, typename _Integer,
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _UnaryPredicate>
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _RandomAccessIter
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _Integer __count, _UnaryPredicate __unary_pred,
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   std::random_access_iterator_tag)
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_DistanceType;
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _DistanceType __tailSize = __last - __first;
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _DistanceType __remainder = __count;
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__remainder <= __tailSize) // the main loop...
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __first += __remainder;
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __tailSize -= __remainder;
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  // __first here is always pointing to one past the last element of
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  // next possible match.
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _RandomAccessIter __backTrack = __first; 
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  while (__unary_pred(--__backTrack))
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (--__remainder == 0)
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		return (__first - __count); // Success
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __remainder = __count + 1 - (__first - __backTrack);
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __last; // Failure
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Integer,
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _UnaryPredicate>
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __search_n(_ForwardIterator __first, _ForwardIterator __last,
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _Integer __count,
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _UnaryPredicate __unary_pred)
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__count <= 0)
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __first;
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__count == 1)
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return std::__find_if(__first, __last, __unary_pred);
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
ARM GAS  /tmp/ccoErako.s 			page 205


 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__search_n_aux(__first, __last, __count, __unary_pred,
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				 std::__iterator_category(__first));
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // find_end for forward iterators.
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2,
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator1
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       forward_iterator_tag, forward_iterator_tag,
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _BinaryPredicate __comp)
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first2 == __last2)
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __last1;
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator1 __result = __last1;
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (1)
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _ForwardIterator1 __new_result
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    = std::__search(__first1, __last1, __first2, __last2, __comp);
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__new_result == __last1)
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __result;
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __result = __new_result;
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __first1 = __new_result;
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__first1;
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // find_end for bidirectional iterators (much faster).
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _BidirectionalIterator1
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __find_end(_BidirectionalIterator1 __first1,
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _BidirectionalIterator1 __last1,
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _BidirectionalIterator2 __first2,
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _BidirectionalIterator2 __last2,
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       bidirectional_iterator_tag, bidirectional_iterator_tag,
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _BinaryPredicate __comp)
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BidirectionalIteratorConcept<
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _BidirectionalIterator1>)
 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BidirectionalIteratorConcept<
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _BidirectionalIterator2>)
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _RevIterator1 __rlast1(__first1);
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _RevIterator2 __rlast2(__first2);
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
ARM GAS  /tmp/ccoErako.s 			page 206


 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					      _RevIterator2(__last2), __rlast2,
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					      __comp);
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__rresult == __rlast1)
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __last1;
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _BidirectionalIterator1 __result = __rresult.base();
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::advance(__result, -std::distance(__first2, __last2));
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  return __result;
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Find last matching subsequence in a sequence.
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first1  Start of range to search.
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last1   End of range to search.
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first2  Start of sequence to match.
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last2   End of sequence to match.
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   The last iterator @c i in the range
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__first1,__last1-(__last2-__first2)) such that @c *(i+N) ==
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p *(__first2+N) for each @c N in the range @p
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Searches the range @p [__first1,__last1) for a sub-sequence that
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  compares equal value-by-value with the sequence given by @p
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first2,__last2) and returns an iterator to the __first
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  element of the sub-sequence, or @p __last1 if the sub-sequence
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  is not found.  The sub-sequence will be the last such
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  subsequence contained in [__first1,__last1).
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Because the sub-sequence must lie completely within the range @p
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first1,__last1) it must start at a position less than @p
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  __last1-(__last2-__first2) where @p __last2-__first2 is the
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  length of the sub-sequence.  This means that the returned
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  iterator @c i will be in the range @p
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first1,__last1-(__last2-__first2))
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2>
 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator1
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_EqualOpConcept<
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator1>::value_type,
 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator2>::value_type>)
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first1, __last1);
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first2, __last2);
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__find_end(__first1, __last1, __first2, __last2,
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     std::__iterator_category(__first1),
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     std::__iterator_category(__first2),
ARM GAS  /tmp/ccoErako.s 			page 207


 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     __gnu_cxx::__ops::__iter_equal_to_iter());
 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Find last matching subsequence in a sequence using a predicate.
 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first1  Start of range to search.
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last1   End of range to search.
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first2  Start of sequence to match.
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last2   End of sequence to match.
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp    The predicate to use.
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return The last iterator @c i in the range @p
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first1,__last1-(__last2-__first2)) such that @c
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  predicate(*(i+N), @p (__first2+N)) is true for each @c N in the
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  range @p [0,__last2-__first2), or @p __last1 if no such iterator
 397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  exists.
 398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Searches the range @p [__first1,__last1) for a sub-sequence that
 400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  compares equal value-by-value with the sequence given by @p
 401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first2,__last2) using comp as a predicate and returns an
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  iterator to the first element of the sub-sequence, or @p __last1
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  if the sub-sequence is not found.  The sub-sequence will be the
 404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  last such subsequence contained in [__first,__last1).
 405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Because the sub-sequence must lie completely within the range @p
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first1,__last1) it must start at a position less than @p
 408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  __last1-(__last2-__first2) where @p __last2-__first2 is the
 409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  length of the sub-sequence.  This means that the returned
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  iterator @c i will be in the range @p
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first1,__last1-(__last2-__first2))
 412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2,
 414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator1
 417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
 419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _BinaryPredicate __comp)
 420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
 423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
 424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
 425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator1>::value_type,
 426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator2>::value_type>)
 427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first1, __last1);
 428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first2, __last2);
 429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__find_end(__first1, __last1, __first2, __last2,
 431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     std::__iterator_category(__first1),
 432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     std::__iterator_category(__first2),
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     __gnu_cxx::__ops::__iter_comp_iter(__comp));
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #if __cplusplus >= 201103L
 437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Checks that a predicate is true for all the elements
ARM GAS  /tmp/ccoErako.s 			page 208


 439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          of a sequence.
 440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
 441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
 442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    An input iterator.
 443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate.
 444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  True if the check is true, false otherwise.
 445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Returns true if @p __pred is true for each element in the range
 447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__first,__last), and false otherwise.
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Predicate>
 450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
 453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     { return __last == std::find_if_not(__first, __last, __pred); }
 454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Checks that a predicate is false for all the elements
 457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          of a sequence.
 458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
 459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
 460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    An input iterator.
 461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate.
 462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  True if the check is true, false otherwise.
 463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Returns true if @p __pred is false for each element in the range
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__first,__last), and false otherwise.
 466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Predicate>
 468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
 470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
 471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     { return __last == _GLIBCXX_STD_A::find_if(__first, __last, __pred); }
 472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Checks that a predicate is true for at least one element
 475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          of a sequence.
 476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
 477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
 478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    An input iterator.
 479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate.
 480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  True if the check is true, false otherwise.
 481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Returns true if an element exists in the range @p
 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first,__last) such that @p __pred is true, and false
 484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  otherwise.
 485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Predicate>
 487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
 489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
 490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     { return !std::none_of(__first, __last, __pred); }
 491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Find the first element in a sequence for which a
 494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          predicate is false.
 495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
ARM GAS  /tmp/ccoErako.s 			page 209


 496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  An input iterator.
 497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   An input iterator.
 498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred   A predicate.
 499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   The first iterator @c i in the range @p [__first,__last)
 500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  such that @p __pred(*i) is false, or @p __last if no such iterator exists.
 501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Predicate>
 503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _InputIterator
 505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     find_if_not(_InputIterator __first, _InputIterator __last,
 506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		_Predicate __pred)
 507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
 510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
 511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      typename iterator_traits<_InputIterator>::value_type>)
 512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__find_if_not(__first, __last,
 514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__gnu_cxx::__ops::__pred_iter(__pred));
 515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Checks whether the sequence is partitioned.
 519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  An input iterator.
 521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   An input iterator.
 522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred   A predicate.
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  True if the range @p [__first,__last) is partioned by @p __pred,
 524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  i.e. if all elements that satisfy @p __pred appear before those that
 525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  do not.
 526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Predicate>
 528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
 530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     is_partitioned(_InputIterator __first, _InputIterator __last,
 531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _Predicate __pred)
 532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __first = std::find_if_not(__first, __last, __pred);
 534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
 535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return true;
 536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       ++__first;
 537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::none_of(__first, __last, __pred);
 538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Find the partition point of a partitioned range.
 542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
 544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
 545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate.
 546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  An iterator @p mid such that @p all_of(__first, mid, __pred)
 547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *           and @p none_of(mid, __last, __pred) are both true.
 548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Predicate>
 550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
 552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     partition_point(_ForwardIterator __first, _ForwardIterator __last,
ARM GAS  /tmp/ccoErako.s 			page 210


 553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		    _Predicate __pred)
 554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
 557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
 558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      typename iterator_traits<_ForwardIterator>::value_type>)
 559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // A specific debug-mode test will be necessary...
 561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_ForwardIterator>::difference_type
 564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_DistanceType;
 565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _DistanceType __len = std::distance(__first, __last);
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__len > 0)
 569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _DistanceType __half = __len >> 1;
 571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _ForwardIterator __middle = __first;
 572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::advance(__middle, __half);
 573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__pred(*__middle))
 574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
 575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __first = __middle;
 576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__first;
 577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __len = __len - __half - 1;
 578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
 579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
 580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __len = __half;
 581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __first;
 583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #endif
 585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator,
 587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Predicate>
 588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
 590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __remove_copy_if(_InputIterator __first, _InputIterator __last,
 591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _OutputIterator __result, _Predicate __pred)
 592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (; __first != __last; ++__first)
 594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__pred(__first))
 595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
 596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    *__result = *__first;
 597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__result;
 598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
 599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __result;
 600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copy a sequence, removing elements of a given value.
 604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
 606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    An input iterator.
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result  An output iterator.
 608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __value   The value to be removed.
 609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   An iterator designating the end of the resulting sequence.
ARM GAS  /tmp/ccoErako.s 			page 211


 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Copies each element in the range @p [__first,__last) not equal
 612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  to @p __value to the range beginning at @p __result.
 613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  remove_copy() is stable, so the relative order of elements that
 614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  are copied is unchanged.
 615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator, typename _Tp>
 617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _OutputIterator
 619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     remove_copy(_InputIterator __first, _InputIterator __last,
 620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		_OutputIterator __result, const _Tp& __value)
 621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
 624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
 625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_EqualOpConcept<
 627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
 628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__remove_copy_if(__first, __last, __result,
 631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	__gnu_cxx::__ops::__iter_equals_val(__value));
 632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copy a sequence, removing elements for which a predicate is true.
 636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
 638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    An input iterator.
 639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result  An output iterator.
 640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate.
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   An iterator designating the end of the resulting sequence.
 642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Copies each element in the range @p [__first,__last) for which
 644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p __pred returns false to the range beginning at @p __result.
 645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  remove_copy_if() is stable, so the relative order of elements that are
 647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  copied is unchanged.
 648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator,
 650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Predicate>
 651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _OutputIterator
 653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     remove_copy_if(_InputIterator __first, _InputIterator __last,
 654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _OutputIterator __result, _Predicate __pred)
 655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
 658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
 659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
 661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__remove_copy_if(__first, __last, __result,
 665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				   __gnu_cxx::__ops::__pred_iter(__pred));
 666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
ARM GAS  /tmp/ccoErako.s 			page 212


 667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #if __cplusplus >= 201103L
 669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copy the elements of a sequence for which a predicate is true.
 671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
 673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    An input iterator.
 674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result  An output iterator.
 675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate.
 676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   An iterator designating the end of the resulting sequence.
 677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Copies each element in the range @p [__first,__last) for which
 679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p __pred returns true to the range beginning at @p __result.
 680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  copy_if() is stable, so the relative order of elements that are
 682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  copied is unchanged.
 683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator,
 685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Predicate>
 686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
 688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     copy_if(_InputIterator __first, _InputIterator __last,
 689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    _OutputIterator __result, _Predicate __pred)
 690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
 693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
 694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
 696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (; __first != __last; ++__first)
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (__pred(*__first))
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
 702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    *__result = *__first;
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__result;
 704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
 705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __result;
 706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Size, typename _OutputIterator>
 709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
 711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result)
 712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__n > 0)
 714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  while (true)
 716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
 717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      *__result = *__first;
 718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__result;
 719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (--__n > 0)
 720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		++__first;
 721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      else
 722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		break;
 723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
ARM GAS  /tmp/ccoErako.s 			page 213


 724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __result;
 726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  
 728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _CharT, typename _Size>
 729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __enable_if_t<__is_char<_CharT>::__value, _CharT*>
 730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>,
 731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _Size, _CharT*);
 732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Size, typename _OutputIterator>
 734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
 736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __copy_n(_InputIterator __first, _Size __n,
 737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _OutputIterator __result, input_iterator_tag)
 738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__niter_wrap(__result,
 740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			       __copy_n_a(__first, __n,
 741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					  std::__niter_base(__result)));
 742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Size,
 745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _OutputIterator>
 746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _OutputIterator
 748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __copy_n(_RandomAccessIterator __first, _Size __n,
 749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _OutputIterator __result, random_access_iterator_tag)
 750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     { return std::copy(__first, __first + __n, __result); }
 751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copies the range [first,first+n) into [result,result+n).
 754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  An input iterator.
 756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __n      The number of elements to copy.
 757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result An output iterator.
 758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  result+n.
 759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This inline function will boil down to a call to @c memmove whenever
 761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  possible.  Failing that, if random access iterators are passed, then the
 762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  loop count will be known (and therefore a candidate for compiler
 763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  optimizations such as unrolling).
 764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Size, typename _OutputIterator>
 766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _OutputIterator
 768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
 769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
 772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
 773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       const auto __n2 = std::__size_to_integer(__n);
 776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__n2 <= 0)
 777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __result;
 778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_can_increment(__first, __n2);
 780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_can_increment(__result, __n2);
ARM GAS  /tmp/ccoErako.s 			page 214


 781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__copy_n(__first, __n2, __result,
 783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   std::__iterator_category(__first));
 784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copy the elements of a sequence to separate output sequences
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *         depending on the truth value of a predicate.
 789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    An input iterator.
 792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __out_true   An output iterator.
 793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __out_false  An output iterator.
 794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate.
 795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   A pair designating the ends of the resulting sequences.
 796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Copies each element in the range @p [__first,__last) for which
 798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p __pred returns true to the range beginning at @p out_true
 799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  and each element for which @p __pred returns false to @p __out_false.
 800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator1,
 802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _OutputIterator2, typename _Predicate>
 803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     pair<_OutputIterator1, _OutputIterator2>
 805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     partition_copy(_InputIterator __first, _InputIterator __last,
 806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _OutputIterator1 __out_true, _OutputIterator2 __out_false,
 807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _Predicate __pred)
 808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
 811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator1,
 812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator2,
 814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       
 819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (; __first != __last; ++__first)
 820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (__pred(*__first))
 821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
 822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    *__out_true = *__first;
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__out_true;
 824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
 825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	else
 826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
 827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    *__out_false = *__first;
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__out_false;
 829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
 830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
 832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #endif // C++11
 834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Predicate>
 836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
ARM GAS  /tmp/ccoErako.s 			page 215


 838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __remove_if(_ForwardIterator __first, _ForwardIterator __last,
 839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		_Predicate __pred)
 840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __first = std::__find_if(__first, __last, __pred);
 842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
 843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __first;
 844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __result = __first;
 845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       ++__first;
 846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (; __first != __last; ++__first)
 847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__pred(__first))
 848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
 849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    *__result = _GLIBCXX_MOVE(*__first);
 850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__result;
 851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
 852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __result;
 853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Remove elements from a sequence.
 857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  An input iterator.
 859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   An input iterator.
 860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __value  The value to be removed.
 861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   An iterator designating the end of the resulting sequence.
 862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  All elements equal to @p __value are removed from the range
 864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__first,__last).
 865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  remove() is stable, so the relative order of elements that are
 867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  not removed is unchanged.
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Elements between the end of the resulting sequence and @p __last
 870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  are still present, but their value is unspecified.
 871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Tp>
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
 875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     remove(_ForwardIterator __first, _ForwardIterator __last,
 876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   const _Tp& __value)
 877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _ForwardIterator>)
 881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_EqualOpConcept<
 882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
 883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__remove_if(__first, __last,
 886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		__gnu_cxx::__ops::__iter_equals_val(__value));
 887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Remove elements from a sequence using a predicate.
 891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  A forward iterator.
 893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   A forward iterator.
 894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred   A predicate.
ARM GAS  /tmp/ccoErako.s 			page 216


 895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   An iterator designating the end of the resulting sequence.
 896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  All elements for which @p __pred returns true are removed from the range
 898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__first,__last).
 899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  remove_if() is stable, so the relative order of elements that are
 901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  not removed is unchanged.
 902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Elements between the end of the resulting sequence and @p __last
 904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  are still present, but their value is unspecified.
 905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Predicate>
 907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
 909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     remove_if(_ForwardIterator __first, _ForwardIterator __last,
 910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      _Predicate __pred)
 911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _ForwardIterator>)
 915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator>::value_type>)
 917:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 918:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 919:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__remove_if(__first, __last,
 920:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			      __gnu_cxx::__ops::__pred_iter(__pred));
 921:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 922:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 923:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _BinaryPredicate>
 924:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 925:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
 926:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
 927:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		    _BinaryPredicate __binary_pred)
 928:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 929:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
 930:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __last;
 931:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __next = __first;
 932:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (++__next != __last)
 933:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 934:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__binary_pred(__first, __next))
 935:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __first;
 936:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __first = __next;
 937:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 938:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __last;
 939:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 940:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 941:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _BinaryPredicate>
 942:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 943:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
 944:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __unique(_ForwardIterator __first, _ForwardIterator __last,
 945:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _BinaryPredicate __binary_pred)
 946:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 947:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // Skip the beginning, if already unique.
 948:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __first = std::__adjacent_find(__first, __last, __binary_pred);
 949:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
 950:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __last;
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
ARM GAS  /tmp/ccoErako.s 			page 217


 952:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // Do the real copy work.
 953:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __dest = __first;
 954:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       ++__first;
 955:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (++__first != __last)
 956:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__binary_pred(__dest, __first))
 957:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  *++__dest = _GLIBCXX_MOVE(*__first);
 958:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return ++__dest;
 959:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 960:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 961:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 962:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Remove consecutive duplicate values from a sequence.
 963:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  A forward iterator.
 965:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   A forward iterator.
 966:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  An iterator designating the end of the resulting sequence.
 967:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 968:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Removes all but the first element from each group of consecutive
 969:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  values that compare equal.
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  unique() is stable, so the relative order of elements that are
 971:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  not removed is unchanged.
 972:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Elements between the end of the resulting sequence and @p __last
 973:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  are still present, but their value is unspecified.
 974:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 975:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator>
 976:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 977:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
 978:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     unique(_ForwardIterator __first, _ForwardIterator __last)
 979:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 980:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 981:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 982:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _ForwardIterator>)
 983:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_EqualityComparableConcept<
 984:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     typename iterator_traits<_ForwardIterator>::value_type>)
 985:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 986:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 987:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__unique(__first, __last,
 988:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   __gnu_cxx::__ops::__iter_equal_to_iter());
 989:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 990:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 991:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 992:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Remove consecutive values from a sequence using a predicate.
 993:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 994:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first        A forward iterator.
 995:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last         A forward iterator.
 996:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __binary_pred  A binary predicate.
 997:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  An iterator designating the end of the resulting sequence.
 998:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 999:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Removes all but the first element from each group of consecutive
1000:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  values for which @p __binary_pred returns true.
1001:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  unique() is stable, so the relative order of elements that are
1002:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  not removed is unchanged.
1003:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Elements between the end of the resulting sequence and @p __last
1004:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  are still present, but their value is unspecified.
1005:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1006:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _BinaryPredicate>
1007:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1008:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
ARM GAS  /tmp/ccoErako.s 			page 218


1009:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     unique(_ForwardIterator __first, _ForwardIterator __last,
1010:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   _BinaryPredicate __binary_pred)
1011:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1012:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
1013:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
1014:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _ForwardIterator>)
1015:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
1016:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		typename iterator_traits<_ForwardIterator>::value_type,
1017:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		typename iterator_traits<_ForwardIterator>::value_type>)
1018:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
1019:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1020:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__unique(__first, __last,
1021:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
1022:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1023:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1024:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1025:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is an uglified
1026:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
1027:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *              _BinaryPredicate)
1028:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  overloaded for forward iterators and output iterator as result.
1029:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1030:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _OutputIterator,
1031:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
1032:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1033:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
1034:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
1035:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _OutputIterator __result, _BinaryPredicate __binary_pred,
1036:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  forward_iterator_tag, output_iterator_tag)
1037:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1038:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements -- iterators already checked
1039:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
1040:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  typename iterator_traits<_ForwardIterator>::value_type,
1041:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  typename iterator_traits<_ForwardIterator>::value_type>)
1042:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1043:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __next = __first;
1044:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       *__result = *__first;
1045:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (++__next != __last)
1046:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__binary_pred(__first, __next))
1047:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
1048:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __first = __next;
1049:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    *++__result = *__first;
1050:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
1051:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return ++__result;
1052:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1053:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1055:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is an uglified
1056:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
1057:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *              _BinaryPredicate)
1058:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  overloaded for input iterators and output iterator as result.
1059:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1060:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator,
1061:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
1062:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1063:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
1064:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __unique_copy(_InputIterator __first, _InputIterator __last,
1065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _OutputIterator __result, _BinaryPredicate __binary_pred,
ARM GAS  /tmp/ccoErako.s 			page 219


1066:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  input_iterator_tag, output_iterator_tag)
1067:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements -- iterators already checked
1069:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
1070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  typename iterator_traits<_InputIterator>::value_type,
1071:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  typename iterator_traits<_InputIterator>::value_type>)
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1073:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typename iterator_traits<_InputIterator>::value_type __value = *__first;
1074:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
1075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	__rebound_pred
1076:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	= __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
1077:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       *__result = __value;
1078:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (++__first != __last)
1079:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__rebound_pred(__first, __value))
1080:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
1081:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __value = *__first;
1082:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    *++__result = __value;
1083:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
1084:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return ++__result;
1085:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1086:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1087:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1088:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is an uglified
1089:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
1090:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *              _BinaryPredicate)
1091:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  overloaded for input iterators and forward iterator as result.
1092:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1093:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _ForwardIterator,
1094:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
1095:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1096:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
1097:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __unique_copy(_InputIterator __first, _InputIterator __last,
1098:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _ForwardIterator __result, _BinaryPredicate __binary_pred,
1099:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  input_iterator_tag, forward_iterator_tag)
1100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements -- iterators already checked
1102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
1103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  typename iterator_traits<_ForwardIterator>::value_type,
1104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  typename iterator_traits<_InputIterator>::value_type>)
1105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       *__result = *__first;
1106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (++__first != __last)
1107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__binary_pred(__result, __first))
1108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  *++__result = *__first;
1109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return ++__result;
1110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is an uglified reverse(_BidirectionalIterator,
1114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *                              _BidirectionalIterator)
1115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  overloaded for bidirectional iterators.
1116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator>
1118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
1120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
1121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      bidirectional_iterator_tag)
1122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
ARM GAS  /tmp/ccoErako.s 			page 220


1123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (true)
1124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (__first == __last || __first == --__last)
1125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  return;
1126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	else
1127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
1128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::iter_swap(__first, __last);
1129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__first;
1130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
1131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is an uglified reverse(_BidirectionalIterator,
1135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *                              _BidirectionalIterator)
1136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  overloaded for random access iterators.
1137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator>
1139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
1141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
 4712              		.loc 14 1141 5 is_stmt 1 view -0
 4713              		.cfi_startproc
 4714              		@ args = 0, pretend = 0, frame = 0
 4715              		@ frame_needed = 0, uses_anonymous_args = 0
 4716              		@ link register save eliminated.
1142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      random_access_iterator_tag)
1143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
 4717              		.loc 14 1144 7 is_stmt 0 view .LVU1127
 4718 0000 8842     		cmp	r0, r1
 4719 0002 09D0     		beq	.L148
1145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return;
1146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       --__last;
 4720              		.loc 14 1146 7 view .LVU1128
 4721 0004 0139     		subs	r1, r1, #1
 4722              	.LVL326:
 4723              		.loc 14 1146 7 view .LVU1129
 4724 0006 05E0     		b	.L150
 4725              	.L151:
 4726              	.LVL327:
 4727              	.LBB1695:
 4728              	.LBI1695:
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 4729              		.loc 13 152 5 is_stmt 1 view .LVU1130
 4730              	.LBB1696:
 4731              	.LBI1696:
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief  Forward an rvalue.
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @return The parameter cast to the specified type.
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  This function is used to implement "perfect forwarding".
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     constexpr _Tp&&
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     {
ARM GAS  /tmp/ccoErako.s 			page 221


  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****       static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 		    " substituting _Tp is an lvalue reference type");
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****       return static_cast<_Tp&&>(__t);
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     }
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief  Convert a value to an rvalue.
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @param  __t  A thing of arbitrary type.
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @return The parameter cast to an rvalue-reference to allow moving it.
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   */
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     constexpr typename std::remove_reference<_Tp>::type&&
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     move(_Tp&& __t) noexcept
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     struct __move_if_noexcept_cond
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****                     is_copy_constructible<_Tp>>::type { };
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief  Conditionally convert a value to an rvalue.
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @param  __x  A thing of arbitrary type.
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @return The parameter, possibly cast to an rvalue-reference.
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  Same as std::move unless the type's move constructor could throw and the
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  type is copyable, in which case an lvalue-reference is returned instead.
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     constexpr typename
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     move_if_noexcept(_Tp& __x) noexcept
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return std::move(__x); }
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   // declval, from type_traits.
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #if __cplusplus > 201402L
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   // _GLIBCXX_RESOLVE_LIB_DEFECTS
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   // 2296. std::addressof should be constexpr
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** # define __cpp_lib_addressof_constexpr 201603
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #endif
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief Returns the actual address of the object or function
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *         referenced by r, even in the presence of an overloaded
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *         operator&.
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @param  __r  Reference to an object or function.
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @return   The actual address.
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   */
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     inline _GLIBCXX17_CONSTEXPR _Tp*
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     addressof(_Tp& __r) noexcept
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return std::__addressof(__r); }
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   // _GLIBCXX_RESOLVE_LIB_DEFECTS
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   // 2598. addressof works on temporaries
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
ARM GAS  /tmp/ccoErako.s 			page 222


 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     const _Tp* addressof(const _Tp&&) = delete;
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   // C++11 version of std::exchange for internal use.
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template <typename _Tp, typename _Up = _Tp>
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     _GLIBCXX20_CONSTEXPR
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     inline _Tp
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     __exchange(_Tp& __obj, _Up&& __new_val)
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     {
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****       _Tp __old_val = std::move(__obj);
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****       __obj = std::forward<_Up>(__new_val);
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****       return __old_val;
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     }
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /// @} group utilities
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #define _GLIBCXX_MOVE(__val) std::move(__val)
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #define _GLIBCXX_FORWARD(_Tp, __val) std::forward<_Tp>(__val)
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #else
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #define _GLIBCXX_MOVE(__val) (__val)
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #define _GLIBCXX_FORWARD(_Tp, __val) (__val)
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #endif
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @addtogroup utilities
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @{
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief Swaps two values.
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @param  __a  A thing of arbitrary type.
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @param  __b  Another thing of arbitrary type.
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @return   Nothing.
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   */
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     _GLIBCXX20_CONSTEXPR
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     inline
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #if __cplusplus >= 201103L
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 			      is_move_constructible<_Tp>,
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 			      is_move_assignable<_Tp>>::value>::type
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #else
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     void
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #endif
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     swap(_Tp& __a, _Tp& __b)
 4732              		.loc 7 189 5 view .LVU1131
 4733              	.LBB1697:
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     _GLIBCXX_NOEXCEPT_IF(__and_<is_nothrow_move_constructible<_Tp>,
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 				is_nothrow_move_assignable<_Tp>>::value)
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     {
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #if __cplusplus < 201103L
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****       // concept requirements
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****       __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #endif
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****       _Tp __tmp = _GLIBCXX_MOVE(__a);
 4734              		.loc 7 197 11 is_stmt 0 view .LVU1132
 4735 0008 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 4736              	.LVL328:
ARM GAS  /tmp/ccoErako.s 			page 223


 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****       __a = _GLIBCXX_MOVE(__b);
 4737              		.loc 7 198 11 view .LVU1133
 4738 000a 0A78     		ldrb	r2, [r1]	@ zero_extendqisi2
 4739 000c 00F8012B 		strb	r2, [r0], #1
 4740              	.LVL329:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****       __b = _GLIBCXX_MOVE(__tmp);
 4741              		.loc 7 199 11 view .LVU1134
 4742 0010 01F80139 		strb	r3, [r1], #-1
 4743              	.LVL330:
 4744              	.L150:
 4745              		.loc 7 199 11 view .LVU1135
 4746              	.LBE1697:
 4747              	.LBE1696:
 4748              	.LBE1695:
1147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__first < __last)
 4749              		.loc 14 1147 22 is_stmt 1 view .LVU1136
 4750 0014 8842     		cmp	r0, r1
 4751 0016 F7D3     		bcc	.L151
 4752              	.L148:
1148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::iter_swap(__first, __last);
1150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first;
1151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  --__last;
1152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 4753              		.loc 14 1153 5 is_stmt 0 view .LVU1137
 4754 0018 7047     		bx	lr
 4755              		.cfi_endproc
 4756              	.LFE5974:
 4757              		.cantunwind
 4758              		.fnend
 4760              		.section	.text._Z13can_getSignalIsEf13can_Message_thhbff,"axG",%progbits,_Z13can_getSignalIsEf13ca
 4761              		.align	1
 4762              		.weak	_Z13can_getSignalIsEf13can_Message_thhbff
 4763              		.syntax unified
 4764              		.thumb
 4765              		.thumb_func
 4767              	_Z13can_getSignalIsEf13can_Message_thhbff:
 4768              		.fnstart
 4769              	.LVL331:
 4770              	.LFB5692:
  64:communication/can/can_helpers.hpp ****     } else {
  65:communication/can/can_helpers.hpp ****         uint64_t data = 0;
  66:communication/can/can_helpers.hpp ****         std::reverse(std::begin(msg.buf), std::end(msg.buf));
  67:communication/can/can_helpers.hpp ****         std::memcpy(&data, msg.buf, sizeof(data));
  68:communication/can/can_helpers.hpp **** 
  69:communication/can/can_helpers.hpp ****         data &= ~(mask << (64 - startBit - length));
  70:communication/can/can_helpers.hpp ****         data |= valAsBits << (64 - startBit - length);
  71:communication/can/can_helpers.hpp **** 
  72:communication/can/can_helpers.hpp ****         std::memcpy(msg.buf, &data, sizeof(data));
  73:communication/can/can_helpers.hpp ****         std::reverse(std::begin(msg.buf), std::end(msg.buf));
  74:communication/can/can_helpers.hpp ****     }
  75:communication/can/can_helpers.hpp **** }
  76:communication/can/can_helpers.hpp **** 
  77:communication/can/can_helpers.hpp **** template<typename T>
  78:communication/can/can_helpers.hpp **** void can_setSignal(can_Message_t& msg, const T& val, const uint8_t startBit, const uint8_t length, 
  79:communication/can/can_helpers.hpp ****     T scaledVal = static_cast<T>((val - offset) / factor);
ARM GAS  /tmp/ccoErako.s 			page 224


  80:communication/can/can_helpers.hpp ****     can_setSignal<T>(msg, scaledVal, startBit, length, isIntel);
  81:communication/can/can_helpers.hpp **** }
  82:communication/can/can_helpers.hpp **** 
  83:communication/can/can_helpers.hpp **** template<typename T>
  84:communication/can/can_helpers.hpp **** float can_getSignal(can_Message_t msg, const uint8_t startBit, const uint8_t length, const bool isI
 4771              		.loc 4 84 7 is_stmt 1 view -0
 4772              		.cfi_startproc
 4773              		@ args = 12, pretend = 0, frame = 40
 4774              		@ frame_needed = 0, uses_anonymous_args = 0
 4775              		.loc 4 84 7 is_stmt 0 view .LVU1139
 4776 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 4777              	.LCFI83:
 4778              		.cfi_def_cfa_offset 20
 4779              		.cfi_offset 4, -20
 4780              		.cfi_offset 5, -16
 4781              		.cfi_offset 6, -12
 4782              		.cfi_offset 7, -8
 4783              		.cfi_offset 14, -4
 4784 0002 2DED028B 		vpush.64	{d8}
 4785              	.LCFI84:
 4786              		.cfi_def_cfa_offset 28
 4787              		.cfi_offset 80, -28
 4788              		.cfi_offset 81, -24
 4789 0006 8BB0     		sub	sp, sp, #44
 4790              	.LCFI85:
 4791              		.cfi_def_cfa_offset 72
 4792 0008 EC46     		mov	ip, sp
 4793 000a 8CE80F00 		stm	ip, {r0, r1, r2, r3}
 4794 000e 9DF84850 		ldrb	r5, [sp, #72]	@ zero_extendqisi2
 4795 0012 9DF84C70 		ldrb	r7, [sp, #76]	@ zero_extendqisi2
 4796 0016 9DF850E0 		ldrb	lr, [sp, #80]	@ zero_extendqisi2
 4797 001a F0EE408A 		vmov.f32	s17, s0
 4798 001e B0EE608A 		vmov.f32	s16, s1
 4799 0022 9CE80F00 		ldm	ip, {r0, r1, r2, r3}
 4800 0026 0AAC     		add	r4, sp, #40
 4801 0028 04E90F00 		stmdb	r4, {r0, r1, r2, r3}
 4802              	.LVL332:
 4803              	.LBB1704:
 4804              	.LBI1704:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 4805              		.loc 4 31 13 is_stmt 1 view .LVU1140
 4806              	.LBB1705:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 4807              		.loc 4 32 14 is_stmt 0 view .LVU1141
 4808 002c 0022     		movs	r2, #0
 4809 002e 0023     		movs	r3, #0
 4810 0030 CDE90423 		strd	r2, [sp, #16]
  33:communication/can/can_helpers.hpp **** 
 4811              		.loc 4 33 33 view .LVU1142
 4812 0034 3F2F     		cmp	r7, #63
 4813 0036 36D8     		bhi	.L156
  33:communication/can/can_helpers.hpp **** 
 4814              		.loc 4 33 41 view .LVU1143
 4815 0038 0124     		movs	r4, #1
 4816 003a A7F12006 		sub	r6, r7, #32
 4817 003e C7F12003 		rsb	r3, r7, #32
 4818 0042 04FA06F6 		lsl	r6, r4, r6
ARM GAS  /tmp/ccoErako.s 			page 225


 4819 0046 24FA03F3 		lsr	r3, r4, r3
 4820 004a 1E43     		orrs	r6, r6, r3
 4821 004c BC40     		lsls	r4, r4, r7
  33:communication/can/can_helpers.hpp **** 
 4822              		.loc 4 33 33 view .LVU1144
 4823 004e 013C     		subs	r4, r4, #1
 4824 0050 46F1FF36 		adc	r6, r6, #-1
 4825              	.L153:
 4826              	.LVL333:
  35:communication/can/can_helpers.hpp ****         std::memcpy(&tempVal, msg.buf, sizeof(tempVal));
 4827              		.loc 4 35 5 view .LVU1145
 4828 0054 BEF1000F 		cmp	lr, #0
 4829 0058 29D0     		beq	.L154
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 4830              		.loc 4 36 20 view .LVU1146
 4831 005a 04AB     		add	r3, sp, #16
 4832 005c DDF81F00 		ldr	r0, [sp, #31]	@ unaligned
 4833 0060 DDF82310 		ldr	r1, [sp, #35]	@ unaligned
 4834 0064 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 4835              		.loc 4 37 28 view .LVU1147
 4836 0066 0A46     		mov	r2, r1
 4837 0068 C5F12000 		rsb	r0, r5, #32
 4838 006c A5F12001 		sub	r1, r5, #32
 4839 0070 049B     		ldr	r3, [sp, #16]
 4840 0072 EB40     		lsrs	r3, r3, r5
 4841 0074 02FA00F0 		lsl	r0, r2, r0
 4842 0078 0343     		orrs	r3, r3, r0
 4843 007a 22FA01F1 		lsr	r1, r2, r1
 4844 007e 0B43     		orrs	r3, r3, r1
 4845 0080 EA40     		lsrs	r2, r2, r5
  37:communication/can/can_helpers.hpp ****     } else {
 4846              		.loc 4 37 41 view .LVU1148
 4847 0082 2340     		ands	r3, r3, r4
 4848 0084 1640     		ands	r6, r6, r2
 4849              	.LVL334:
  37:communication/can/can_helpers.hpp ****     } else {
 4850              		.loc 4 37 17 view .LVU1149
 4851 0086 0493     		str	r3, [sp, #16]
 4852 0088 0596     		str	r6, [sp, #20]
 4853              	.LVL335:
 4854              	.L155:
  45:communication/can/can_helpers.hpp ****     return retVal;
 4855              		.loc 4 45 16 view .LVU1150
 4856 008a BDF91030 		ldrsh	r3, [sp, #16]
 4857 008e 00EE103A 		vmov	s0, r3	@ int
 4858              	.LVL336:
  45:communication/can/can_helpers.hpp ****     return retVal;
 4859              		.loc 4 45 16 view .LVU1151
 4860              	.LBE1705:
 4861              	.LBE1704:
  85:communication/can/can_helpers.hpp ****     T retVal = can_getSignal<T>(msg, startBit, length, isIntel);
  86:communication/can/can_helpers.hpp ****     return (retVal * factor) + offset;
 4862              		.loc 4 86 20 view .LVU1152
 4863 0092 F8EEC07A 		vcvt.f32.s32	s15, s0
 4864 0096 27EEA80A 		vmul.f32	s0, s15, s17
 4865              	.LVL337:
ARM GAS  /tmp/ccoErako.s 			page 226


  87:communication/can/can_helpers.hpp **** }
 4866              		.loc 4 87 1 view .LVU1153
 4867 009a 30EE080A 		vadd.f32	s0, s0, s16
 4868 009e 0BB0     		add	sp, sp, #44
 4869              	.LCFI86:
 4870              		.cfi_remember_state
 4871              		.cfi_def_cfa_offset 28
 4872              		@ sp needed
 4873 00a0 BDEC028B 		vldm	sp!, {d8}
 4874              	.LCFI87:
 4875              		.cfi_restore 80
 4876              		.cfi_restore 81
 4877              		.cfi_def_cfa_offset 20
 4878              	.LVL338:
 4879              		.loc 4 87 1 view .LVU1154
 4880 00a4 F0BD     		pop	{r4, r5, r6, r7, pc}
 4881              	.LVL339:
 4882              	.L156:
 4883              	.LCFI88:
 4884              		.cfi_restore_state
 4885              	.LBB1710:
 4886              	.LBB1709:
  33:communication/can/can_helpers.hpp **** 
 4887              		.loc 4 33 33 view .LVU1155
 4888 00a6 4FF0FF34 		mov	r4, #-1
 4889 00aa 2646     		mov	r6, r4
 4890 00ac D2E7     		b	.L153
 4891              	.LVL340:
 4892              	.L154:
 4893              	.LBB1706:
 4894              	.LBI1706:
 4895              		.file 15 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // <range_access.h> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // Copyright (C) 2010-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** /** @file bits/range_access.h
ARM GAS  /tmp/ccoErako.s 			page 227


  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****  *  This is an internal header file, included by other library headers.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****  *  Do not attempt to use it directly. @headername{iterator}
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****  */
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** #ifndef _GLIBCXX_RANGE_ACCESS_H
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** #define _GLIBCXX_RANGE_ACCESS_H 1
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** #pragma GCC system_header
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** #if __cplusplus >= 201103L
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** #include <initializer_list>
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** #include <bits/iterator_concepts.h>
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** #include <ext/numeric_traits.h>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** namespace std _GLIBCXX_VISIBILITY(default)
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** {
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   /**
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @brief  Return an iterator pointing to the first element of
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *          the container.
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @param  __cont  Container.
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    */
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   template<typename _Container>
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     inline _GLIBCXX17_CONSTEXPR auto
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     begin(_Container& __cont) -> decltype(__cont.begin())
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     { return __cont.begin(); }
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   /**
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @brief  Return an iterator pointing to the first element of
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *          the const container.
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @param  __cont  Container.
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    */
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   template<typename _Container>
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     inline _GLIBCXX17_CONSTEXPR auto
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     begin(const _Container& __cont) -> decltype(__cont.begin())
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     { return __cont.begin(); }
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   /**
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @brief  Return an iterator pointing to one past the last element of
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *          the container.
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @param  __cont  Container.
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    */
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   template<typename _Container>
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     inline _GLIBCXX17_CONSTEXPR auto
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     end(_Container& __cont) -> decltype(__cont.end())
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     { return __cont.end(); }
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   /**
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @brief  Return an iterator pointing to one past the last element of
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *          the const container.
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @param  __cont  Container.
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    */
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   template<typename _Container>
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     inline _GLIBCXX17_CONSTEXPR auto
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     end(const _Container& __cont) -> decltype(__cont.end())
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     { return __cont.end(); }
ARM GAS  /tmp/ccoErako.s 			page 228


  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   /**
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @brief  Return an iterator pointing to the first element of the array.
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @param  __arr  Array.
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    */
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   template<typename _Tp, size_t _Nm>
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     inline _GLIBCXX14_CONSTEXPR _Tp*
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     begin(_Tp (&__arr)[_Nm]) noexcept
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     { return __arr; }
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   /**
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @brief  Return an iterator pointing to one past the last element
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *          of the array.
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @param  __arr  Array.
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    */
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   template<typename _Tp, size_t _Nm>
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     inline _GLIBCXX14_CONSTEXPR _Tp*
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     end(_Tp (&__arr)[_Nm]) noexcept
 4896              		.loc 15 100 5 is_stmt 1 view .LVU1156
 4897              		.loc 15 100 5 is_stmt 0 view .LVU1157
 4898              	.LBE1706:
 4899              	.LBB1707:
 4900              	.LBI1707:
1154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Reverse a sequence.
1157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
1158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  A bidirectional iterator.
1159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   A bidirectional iterator.
1160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   reverse() returns no value.
1161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
1162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Reverses the order of the elements in the range @p [__first,__last),
1163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  so that the first element becomes the last etc.
1164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  For every @c i such that @p 0<=i<=(__last-__first)/2), @p reverse()
1165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  swaps @p *(__first+i) and @p *(__last-(i+1))
1166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator>
1168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline void
1170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
 4901              		.loc 14 1170 5 is_stmt 1 view .LVU1158
 4902              	.LBB1708:
1171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
1173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
1174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _BidirectionalIterator>)
1175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
1176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__reverse(__first, __last, std::__iterator_category(__first));
 4903              		.loc 14 1176 21 is_stmt 0 view .LVU1159
 4904 00ae 4FF00002 		mov	r2, #0
 4905 00b2 0DF12701 		add	r1, sp, #39
 4906              	.LVL341:
 4907              		.loc 14 1176 21 view .LVU1160
 4908 00b6 0DF11F00 		add	r0, sp, #31
 4909              	.LVL342:
 4910              		.loc 14 1176 21 view .LVU1161
 4911 00ba FFF7FEFF 		bl	_ZSt9__reverseIPhEvT_S1_St26random_access_iterator_tag
ARM GAS  /tmp/ccoErako.s 			page 229


 4912              	.LVL343:
 4913              		.loc 14 1176 21 view .LVU1162
 4914              	.LBE1708:
 4915              	.LBE1707:
  40:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> (64 - startBit - length)) & mask;
 4916              		.loc 4 40 20 view .LVU1163
 4917 00be 04AB     		add	r3, sp, #16
 4918 00c0 DDF81F00 		ldr	r0, [sp, #31]	@ unaligned
 4919 00c4 DDF82310 		ldr	r1, [sp, #35]	@ unaligned
 4920 00c8 03C3     		stmia	r3!, {r0, r1}
  41:communication/can/can_helpers.hpp ****     }
 4921              		.loc 4 41 35 view .LVU1164
 4922 00ca C5F14005 		rsb	r5, r5, #64
 4923              	.LVL344:
  41:communication/can/can_helpers.hpp ****     }
 4924              		.loc 4 41 46 view .LVU1165
 4925 00ce ED1B     		subs	r5, r5, r7
  41:communication/can/can_helpers.hpp ****     }
 4926              		.loc 4 41 28 view .LVU1166
 4927 00d0 0A46     		mov	r2, r1
 4928 00d2 C5F12000 		rsb	r0, r5, #32
 4929 00d6 A5F12001 		sub	r1, r5, #32
 4930 00da 049B     		ldr	r3, [sp, #16]
 4931 00dc EB40     		lsrs	r3, r3, r5
 4932 00de 02FA00F0 		lsl	r0, r2, r0
 4933 00e2 0343     		orrs	r3, r3, r0
 4934 00e4 22FA01F1 		lsr	r1, r2, r1
 4935 00e8 0B43     		orrs	r3, r3, r1
 4936 00ea 22FA05F5 		lsr	r5, r2, r5
  41:communication/can/can_helpers.hpp ****     }
 4937              		.loc 4 41 57 view .LVU1167
 4938 00ee 2340     		ands	r3, r3, r4
 4939 00f0 2E40     		ands	r6, r6, r5
 4940              	.LVL345:
  41:communication/can/can_helpers.hpp ****     }
 4941              		.loc 4 41 17 view .LVU1168
 4942 00f2 0493     		str	r3, [sp, #16]
 4943 00f4 0596     		str	r6, [sp, #20]
 4944 00f6 C8E7     		b	.L155
 4945              	.LBE1709:
 4946              	.LBE1710:
 4947              		.cfi_endproc
 4948              	.LFE5692:
 4949              		.cantunwind
 4950              		.fnend
 4952              		.section	.text._ZN9CANSimple22set_input_pos_callbackER4AxisRK13can_Message_t,"ax",%progbits
 4953              		.align	1
 4954              		.global	_ZN9CANSimple22set_input_pos_callbackER4AxisRK13can_Message_t
 4955              		.syntax unified
 4956              		.thumb
 4957              		.thumb_func
 4959              	_ZN9CANSimple22set_input_pos_callbackER4AxisRK13can_Message_t:
 4960              		.fnstart
 4961              	.LVL346:
 4962              	.LFB5220:
 274:communication/can/can_simple.cpp ****     axis.controller_.set_input_pos_and_steps(can_getSignal<float>(msg, 0, 32, true));
 4963              		.loc 3 274 78 is_stmt 1 view -0
ARM GAS  /tmp/ccoErako.s 			page 230


 4964              		.cfi_startproc
 4965              		@ args = 0, pretend = 0, frame = 32
 4966              		@ frame_needed = 0, uses_anonymous_args = 0
 274:communication/can/can_simple.cpp ****     axis.controller_.set_input_pos_and_steps(can_getSignal<float>(msg, 0, 32, true));
 4967              		.loc 3 274 78 is_stmt 0 view .LVU1170
 4968 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 4969              		.save {r4, r5, r6, r7, r8, lr}
 4970              	.LCFI89:
 4971              		.cfi_def_cfa_offset 24
 4972              		.cfi_offset 4, -24
 4973              		.cfi_offset 5, -20
 4974              		.cfi_offset 6, -16
 4975              		.cfi_offset 7, -12
 4976              		.cfi_offset 8, -8
 4977              		.cfi_offset 14, -4
 4978 0004 2DED028B 		vpush.64	{d8}
 4979              		.vsave {d8}
 4980              	.LCFI90:
 4981              		.cfi_def_cfa_offset 32
 4982              		.cfi_offset 80, -32
 4983              		.cfi_offset 81, -28
 4984              		.pad #48
 4985 0008 8CB0     		sub	sp, sp, #48
 4986              	.LCFI91:
 4987              		.cfi_def_cfa_offset 80
 4988 000a 0546     		mov	r5, r0
 4989 000c 0C46     		mov	r4, r1
 275:communication/can/can_simple.cpp ****     axis.controller_.input_vel_ = can_getSignal<int16_t>(msg, 32, 16, true, 0.001f, 0);
 4990              		.loc 3 275 5 is_stmt 1 view .LVU1171
 4991 000e 0FC9     		ldm	r1, {r0, r1, r2, r3}
 4992              	.LVL347:
 275:communication/can/can_simple.cpp ****     axis.controller_.input_vel_ = can_getSignal<int16_t>(msg, 32, 16, true, 0.001f, 0);
 4993              		.loc 3 275 5 is_stmt 0 view .LVU1172
 4994 0010 0CAE     		add	r6, sp, #48
 4995 0012 06E90F00 		stmdb	r6, {r0, r1, r2, r3}
 4996              	.LVL348:
 4997              	.LBB1719:
 4998              	.LBI1719:
  31:communication/can/can_helpers.hpp ****     uint64_t tempVal = 0;
 4999              		.loc 4 31 13 is_stmt 1 view .LVU1173
 5000              	.LBB1720:
  32:communication/can/can_helpers.hpp ****     uint64_t mask = length < 64 ? (1ULL << length) - 1ULL : -1ULL;
 5001              		.loc 4 32 14 is_stmt 0 view .LVU1174
 5002 0016 0022     		movs	r2, #0
 5003 0018 0023     		movs	r3, #0
 5004 001a CDE90623 		strd	r2, [sp, #24]
 5005              	.LVL349:
  36:communication/can/can_helpers.hpp ****         tempVal = (tempVal >> startBit) & mask;
 5006              		.loc 4 36 20 view .LVU1175
 5007 001e 06AB     		add	r3, sp, #24
 5008 0020 DDF82700 		ldr	r0, [sp, #39]	@ unaligned
 5009 0024 DDF82B10 		ldr	r1, [sp, #43]	@ unaligned
 5010 0028 03C3     		stmia	r3!, {r0, r1}
  37:communication/can/can_helpers.hpp ****     } else {
 5011              		.loc 4 37 41 view .LVU1176
 5012 002a 0023     		movs	r3, #0
  37:communication/can/can_helpers.hpp ****     } else {
ARM GAS  /tmp/ccoErako.s 			page 231


 5013              		.loc 4 37 17 view .LVU1177
 5014 002c 0793     		str	r3, [sp, #28]
  45:communication/can/can_helpers.hpp ****     return retVal;
 5015              		.loc 4 45 16 view .LVU1178
 5016 002e 0590     		str	r0, [sp, #20]
 5017              	.LVL350:
  45:communication/can/can_helpers.hpp ****     return retVal;
 5018              		.loc 4 45 16 view .LVU1179
 5019              	.LBE1720:
 5020              	.LBE1719:
 275:communication/can/can_simple.cpp ****     axis.controller_.input_vel_ = can_getSignal<int16_t>(msg, 32, 16, true, 0.001f, 0);
 5021              		.loc 3 275 45 view .LVU1180
 5022 0030 9DED060A 		vldr.32	s0, [sp, #24]
 5023 0034 D5F80001 		ldr	r0, [r5, #256]
 5024 0038 FFF7FEFF 		bl	_ZN10Controller23set_input_pos_and_stepsEf
 5025              	.LVL351:
 276:communication/can/can_simple.cpp ****     axis.controller_.input_torque_ = can_getSignal<int16_t>(msg, 48, 16, true, 0.001f, 0);
 5026              		.loc 3 276 5 is_stmt 1 view .LVU1181
 276:communication/can/can_simple.cpp ****     axis.controller_.input_torque_ = can_getSignal<int16_t>(msg, 48, 16, true, 0.001f, 0);
 5027              		.loc 3 276 10 is_stmt 0 view .LVU1182
 5028 003c D5F80061 		ldr	r6, [r5, #256]
 276:communication/can/can_simple.cpp ****     axis.controller_.input_torque_ = can_getSignal<int16_t>(msg, 48, 16, true, 0.001f, 0);
 5029              		.loc 3 276 57 view .LVU1183
 5030 0040 DFED1A8A 		vldr.32	s17, .L160
 5031 0044 9FED1A8A 		vldr.32	s16, .L160+4
 5032 0048 0127     		movs	r7, #1
 5033 004a 0297     		str	r7, [sp, #8]
 5034 004c 4FF01008 		mov	r8, #16
 5035 0050 CDF80480 		str	r8, [sp, #4]
 5036 0054 2023     		movs	r3, #32
 5037 0056 0093     		str	r3, [sp]
 5038 0058 F0EE680A 		vmov.f32	s1, s17
 5039 005c B0EE480A 		vmov.f32	s0, s16
 5040 0060 94E80F00 		ldm	r4, {r0, r1, r2, r3}
 5041 0064 FFF7FEFF 		bl	_Z13can_getSignalIsEf13can_Message_thhbff
 5042              	.LVL352:
 276:communication/can/can_simple.cpp ****     axis.controller_.input_torque_ = can_getSignal<int16_t>(msg, 48, 16, true, 0.001f, 0);
 5043              		.loc 3 276 33 view .LVU1184
 5044 0068 06F56453 		add	r3, r6, #14592
 5045 006c 83ED060A 		vstr.32	s0, [r3, #24]
 277:communication/can/can_simple.cpp ****     axis.controller_.input_pos_updated();
 5046              		.loc 3 277 5 is_stmt 1 view .LVU1185
 277:communication/can/can_simple.cpp ****     axis.controller_.input_pos_updated();
 5047              		.loc 3 277 10 is_stmt 0 view .LVU1186
 5048 0070 D5F80061 		ldr	r6, [r5, #256]
 277:communication/can/can_simple.cpp ****     axis.controller_.input_pos_updated();
 5049              		.loc 3 277 60 view .LVU1187
 5050 0074 0297     		str	r7, [sp, #8]
 5051 0076 CDF80480 		str	r8, [sp, #4]
 5052 007a 3023     		movs	r3, #48
 5053 007c 0093     		str	r3, [sp]
 5054 007e F0EE680A 		vmov.f32	s1, s17
 5055 0082 B0EE480A 		vmov.f32	s0, s16
 5056 0086 94E80F00 		ldm	r4, {r0, r1, r2, r3}
 5057 008a FFF7FEFF 		bl	_Z13can_getSignalIsEf13can_Message_thhbff
 5058              	.LVL353:
 277:communication/can/can_simple.cpp ****     axis.controller_.input_pos_updated();
ARM GAS  /tmp/ccoErako.s 			page 232


 5059              		.loc 3 277 36 view .LVU1188
 5060 008e 06F56453 		add	r3, r6, #14592
 5061 0092 83ED070A 		vstr.32	s0, [r3, #28]
 278:communication/can/can_simple.cpp **** }
 5062              		.loc 3 278 5 is_stmt 1 view .LVU1189
 278:communication/can/can_simple.cpp **** }
 5063              		.loc 3 278 10 is_stmt 0 view .LVU1190
 5064 0096 D5F80031 		ldr	r3, [r5, #256]
 5065              	.LVL354:
 5066              	.LBB1721:
 5067              	.LBI1721:
 5068              		.file 16 "MotorControl/controller.hpp"
   1:MotorControl/controller.hpp **** #ifndef __CONTROLLER_HPP
   2:MotorControl/controller.hpp **** #define __CONTROLLER_HPP
   3:MotorControl/controller.hpp **** 
   4:MotorControl/controller.hpp **** class Controller : public ODriveIntf::ControllerIntf {
   5:MotorControl/controller.hpp **** public:
   6:MotorControl/controller.hpp ****     struct Anticogging_t {
   7:MotorControl/controller.hpp ****         uint32_t index = 0;
   8:MotorControl/controller.hpp ****         float cogging_map[3600];
   9:MotorControl/controller.hpp ****         bool pre_calibrated = false;
  10:MotorControl/controller.hpp ****         bool calib_anticogging = false;
  11:MotorControl/controller.hpp ****         float calib_pos_threshold = 1.0f;
  12:MotorControl/controller.hpp ****         float calib_vel_threshold = 1.0f;
  13:MotorControl/controller.hpp ****         float cogging_ratio = 1.0f;
  14:MotorControl/controller.hpp ****         bool anticogging_enabled = true;
  15:MotorControl/controller.hpp ****     };
  16:MotorControl/controller.hpp **** 
  17:MotorControl/controller.hpp ****     struct Autotuning_t {
  18:MotorControl/controller.hpp ****         float frequency = 0.0f;
  19:MotorControl/controller.hpp ****         float pos_amplitude = 0.0f;
  20:MotorControl/controller.hpp ****         float vel_amplitude = 0.0f;
  21:MotorControl/controller.hpp ****         float torque_amplitude = 0.0f;
  22:MotorControl/controller.hpp ****     };
  23:MotorControl/controller.hpp **** 
  24:MotorControl/controller.hpp ****     struct Config_t {
  25:MotorControl/controller.hpp ****         ControlMode control_mode = CONTROL_MODE_POSITION_CONTROL;  //see: ControlMode_t
  26:MotorControl/controller.hpp ****         InputMode input_mode = INPUT_MODE_PASSTHROUGH;             //see: InputMode_t
  27:MotorControl/controller.hpp ****         float pos_gain = 20.0f;                  // [(turn/s) / turn]
  28:MotorControl/controller.hpp ****         float vel_gain = 1.0f / 6.0f;            // [Nm/(turn/s)]
  29:MotorControl/controller.hpp ****         // float vel_gain = 0.2f / 200.0f,       // [Nm/(rad/s)] <sensorless example>
  30:MotorControl/controller.hpp ****         float vel_integrator_gain = 2.0f / 6.0f; // [Nm/(turn/s * s)]
  31:MotorControl/controller.hpp ****         float vel_limit = 2.0f;                  // [turn/s] Infinity to disable.
  32:MotorControl/controller.hpp ****         float vel_limit_tolerance = 1.2f;        // ratio to vel_lim. Infinity to disable.
  33:MotorControl/controller.hpp ****         float vel_integrator_limit = INFINITY;   // Vel. integrator clamping value. Infinity to dis
  34:MotorControl/controller.hpp ****         float vel_ramp_rate = 1.0f;              // [(turn/s) / s]
  35:MotorControl/controller.hpp ****         float torque_ramp_rate = 0.01f;          // Nm / sec
  36:MotorControl/controller.hpp ****         bool circular_setpoints = false;
  37:MotorControl/controller.hpp ****         float circular_setpoint_range = 1.0f;    // Circular range when circular_setpoints is true.
  38:MotorControl/controller.hpp ****         uint32_t steps_per_circular_range = 1024;
  39:MotorControl/controller.hpp ****         float inertia = 0.0f;                    // [Nm/(turn/s^2)]
  40:MotorControl/controller.hpp ****         float input_filter_bandwidth = 2.0f;     // [1/s]
  41:MotorControl/controller.hpp ****         float homing_speed = 0.25f;              // [turn/s]
  42:MotorControl/controller.hpp ****         Anticogging_t anticogging;
  43:MotorControl/controller.hpp ****         float gain_scheduling_width = 10.0f;
  44:MotorControl/controller.hpp ****         bool enable_gain_scheduling = false;
  45:MotorControl/controller.hpp ****         bool enable_vel_limit = true;
ARM GAS  /tmp/ccoErako.s 			page 233


  46:MotorControl/controller.hpp ****         bool enable_overspeed_error = true;
  47:MotorControl/controller.hpp ****         bool enable_torque_mode_vel_limit = true;  // enable velocity limit in current control mode
  48:MotorControl/controller.hpp ****         uint8_t axis_to_mirror = -1;
  49:MotorControl/controller.hpp ****         float mirror_ratio = 1.0f;
  50:MotorControl/controller.hpp ****         float torque_mirror_ratio = 0.0f;
  51:MotorControl/controller.hpp ****         uint8_t load_encoder_axis = -1;  // default depends on Axis number and is set in load_confi
  52:MotorControl/controller.hpp ****         float mechanical_power_bandwidth = 20.0f; // [rad/s] filter cutoff for mechanical power for
  53:MotorControl/controller.hpp ****         float electrical_power_bandwidth = 20.0f; // [rad/s] filter cutoff for electrical power for
  54:MotorControl/controller.hpp ****         float spinout_electrical_power_threshold = 10.0f; // [W] electrical power threshold for spi
  55:MotorControl/controller.hpp ****         float spinout_mechanical_power_threshold = -10.0f; // [W] mechanical power threshold for sp
  56:MotorControl/controller.hpp **** 
  57:MotorControl/controller.hpp ****         // custom setters
  58:MotorControl/controller.hpp ****         Controller* parent;
  59:MotorControl/controller.hpp ****         void set_input_filter_bandwidth(float value) { input_filter_bandwidth = value; parent->upda
  60:MotorControl/controller.hpp ****         void set_steps_per_circular_range(uint32_t value) { steps_per_circular_range = value > 0 ? 
  61:MotorControl/controller.hpp ****         void set_control_mode(ControlMode value) { control_mode = value; parent->control_mode_updat
  62:MotorControl/controller.hpp ****     };
  63:MotorControl/controller.hpp **** 
  64:MotorControl/controller.hpp ****     
  65:MotorControl/controller.hpp ****     bool apply_config();
  66:MotorControl/controller.hpp **** 
  67:MotorControl/controller.hpp ****     void reset();
  68:MotorControl/controller.hpp ****     void set_error(Error error);
  69:MotorControl/controller.hpp **** 
  70:MotorControl/controller.hpp ****     constexpr void input_pos_updated() {
 5069              		.loc 16 70 20 is_stmt 1 view .LVU1191
 5070              	.LBB1722:
  71:MotorControl/controller.hpp ****         input_pos_updated_ = true;
 5071              		.loc 16 71 9 view .LVU1192
 5072              		.loc 16 71 28 is_stmt 0 view .LVU1193
 5073 009a 03F54053 		add	r3, r3, #12288
 5074              	.LVL355:
 5075              		.loc 16 71 28 view .LVU1194
 5076 009e 83F83C79 		strb	r7, [r3, #2364]
 5077              	.LVL356:
 5078              		.loc 16 71 28 view .LVU1195
 5079              	.LBE1722:
 5080              	.LBE1721:
 279:communication/can/can_simple.cpp **** 
 5081              		.loc 3 279 1 view .LVU1196
 5082 00a2 0CB0     		add	sp, sp, #48
 5083              	.LCFI92:
 5084              		.cfi_def_cfa_offset 32
 5085              		@ sp needed
 5086 00a4 BDEC028B 		vldm	sp!, {d8}
 5087              	.LCFI93:
 5088              		.cfi_restore 80
 5089              		.cfi_restore 81
 5090              		.cfi_def_cfa_offset 24
 5091 00a8 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 5092              	.LVL357:
 5093              	.L161:
 279:communication/can/can_simple.cpp **** 
 5094              		.loc 3 279 1 view .LVU1197
 5095              		.align	2
 5096              	.L160:
 5097 00ac 00000000 		.word	0
ARM GAS  /tmp/ccoErako.s 			page 234


 5098 00b0 6F12833A 		.word	981668463
 5099              		.cfi_endproc
 5100              	.LFE5220:
 5101              		.fnend
 5103              		.section	.text._ZSt28__variant_construct_by_indexILj1ESt7variantIJtmEEJmEEvRT0_DpOT1_,"axG",%progb
 5104              		.align	1
 5105              		.weak	_ZSt28__variant_construct_by_indexILj1ESt7variantIJtmEEJmEEvRT0_DpOT1_
 5106              		.syntax unified
 5107              		.thumb
 5108              		.thumb_func
 5110              	_ZSt28__variant_construct_by_indexILj1ESt7variantIJtmEEJmEEvRT0_DpOT1_:
 5111              		.fnstart
 5112              	.LVL358:
 5113              	.LFB6131:
1068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 5114              		.loc 1 1068 10 is_stmt 1 view -0
 5115              		.cfi_startproc
 5116              		@ args = 0, pretend = 0, frame = 0
 5117              		@ frame_needed = 0, uses_anonymous_args = 0
 5118              		@ link register save eliminated.
1070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       auto&& __storage = __detail::__variant::__get<_Np>(__v);
 5119              		.loc 1 1070 20 is_stmt 0 view .LVU1199
 5120 0000 0123     		movs	r3, #1
 5121 0002 0371     		strb	r3, [r0, #4]
 5122              	.LVL359:
 5123              	.LBB1723:
 5124              	.LBI1723:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 5125              		.loc 1 276 5 is_stmt 1 view .LVU1200
 5126              	.LBB1724:
 5127              	.LBB1725:
 5128              	.LBI1725:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 5129              		.loc 1 267 5 view .LVU1201
 5130              	.LBB1726:
 5131              	.LBB1727:
 5132              	.LBI1727:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 5133              		.loc 1 262 5 view .LVU1202
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 5134              		.loc 1 262 5 is_stmt 0 view .LVU1203
 5135              	.LBE1727:
 5136              	.LBE1726:
 5137              	.LBE1725:
 5138              	.LBE1724:
 5139              	.LBE1723:
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         remove_reference_t<decltype(__storage)>
 5140              		.loc 1 1072 7 view .LVU1204
 5141 0004 0B68     		ldr	r3, [r1]
 5142              	.LVL360:
 5143              		.loc 9 175 3 is_stmt 1 view .LVU1205
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         remove_reference_t<decltype(__storage)>
 5144              		.loc 1 1072 7 is_stmt 0 view .LVU1206
 5145 0006 0360     		str	r3, [r0]
1075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 5146              		.loc 1 1075 5 view .LVU1207
 5147 0008 7047     		bx	lr
ARM GAS  /tmp/ccoErako.s 			page 235


 5148              		.cfi_endproc
 5149              	.LFE6131:
 5150              		.cantunwind
 5151              		.fnend
 5153              		.section	.text._ZSt28__variant_construct_by_indexILj0ESt7variantIJtmEEJtEEvRT0_DpOT1_,"axG",%progb
 5154              		.align	1
 5155              		.weak	_ZSt28__variant_construct_by_indexILj0ESt7variantIJtmEEJtEEvRT0_DpOT1_
 5156              		.syntax unified
 5157              		.thumb
 5158              		.thumb_func
 5160              	_ZSt28__variant_construct_by_indexILj0ESt7variantIJtmEEJtEEvRT0_DpOT1_:
 5161              		.fnstart
 5162              	.LVL361:
 5163              	.LFB6134:
1068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 5164              		.loc 1 1068 10 is_stmt 1 view -0
 5165              		.cfi_startproc
 5166              		@ args = 0, pretend = 0, frame = 0
 5167              		@ frame_needed = 0, uses_anonymous_args = 0
 5168              		@ link register save eliminated.
1070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       auto&& __storage = __detail::__variant::__get<_Np>(__v);
 5169              		.loc 1 1070 20 is_stmt 0 view .LVU1209
 5170 0000 0023     		movs	r3, #0
 5171 0002 0371     		strb	r3, [r0, #4]
 5172              	.LVL362:
 5173              	.LBB1728:
 5174              	.LBI1728:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 5175              		.loc 1 276 5 is_stmt 1 view .LVU1210
 5176              	.LBB1729:
 5177              	.LBB1730:
 5178              	.LBI1730:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 5179              		.loc 1 262 5 view .LVU1211
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 5180              		.loc 1 262 5 is_stmt 0 view .LVU1212
 5181              	.LBE1730:
 5182              	.LBE1729:
 5183              	.LBE1728:
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         remove_reference_t<decltype(__storage)>
 5184              		.loc 1 1072 7 view .LVU1213
 5185 0004 0B88     		ldrh	r3, [r1]
 5186              	.LVL363:
 5187              		.loc 9 175 3 is_stmt 1 view .LVU1214
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         remove_reference_t<decltype(__storage)>
 5188              		.loc 1 1072 7 is_stmt 0 view .LVU1215
 5189 0006 0380     		strh	r3, [r0]	@ movhi
1075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 5190              		.loc 1 1075 5 view .LVU1216
 5191 0008 7047     		bx	lr
 5192              		.cfi_endproc
 5193              	.LFE6134:
 5194              		.cantunwind
 5195              		.fnend
 5197              		.section	.text._ZN9CANSimple18renew_subscriptionEj,"ax",%progbits
 5198              		.align	1
 5199              		.global	_ZN9CANSimple18renew_subscriptionEj
ARM GAS  /tmp/ccoErako.s 			page 236


 5200              		.syntax unified
 5201              		.thumb
 5202              		.thumb_func
 5204              	_ZN9CANSimple18renew_subscriptionEj:
 5205              		.fnstart
 5206              	.LVL364:
 5207              	.LFB5159:
  17:communication/can/can_simple.cpp ****     Axis& axis = axes[i];
 5208              		.loc 3 17 46 is_stmt 1 view -0
 5209              		.cfi_startproc
 5210              		@ args = 0, pretend = 0, frame = 24
 5211              		@ frame_needed = 0, uses_anonymous_args = 0
  17:communication/can/can_simple.cpp ****     Axis& axis = axes[i];
 5212              		.loc 3 17 46 is_stmt 0 view .LVU1218
 5213 0000 70B5     		push	{r4, r5, r6, lr}
 5214              		.save {r4, r5, r6, lr}
 5215              	.LCFI94:
 5216              		.cfi_def_cfa_offset 16
 5217              		.cfi_offset 4, -16
 5218              		.cfi_offset 5, -12
 5219              		.cfi_offset 6, -8
 5220              		.cfi_offset 14, -4
 5221              		.pad #32
 5222 0002 88B0     		sub	sp, sp, #32
 5223              	.LCFI95:
 5224              		.cfi_def_cfa_offset 48
 5225 0004 0546     		mov	r5, r0
 5226 0006 0C46     		mov	r4, r1
  18:communication/can/can_simple.cpp **** 
 5227              		.loc 3 18 5 is_stmt 1 view .LVU1219
 5228              	.LVL365:
 5229              	.LBB1801:
 5230              	.LBI1801:
 5231              		.file 17 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // <array> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // Copyright (C) 2007-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // <http://www.gnu.org/licenses/>.
ARM GAS  /tmp/ccoErako.s 			page 237


  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** /** @file include/array
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****  *  This is a Standard C++ Library header.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****  */
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #ifndef _GLIBCXX_ARRAY
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #define _GLIBCXX_ARRAY 1
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #pragma GCC system_header
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #if __cplusplus < 201103L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** # include <bits/c++0x_warning.h>
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #else
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <utility>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <bits/functexcept.h>
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <bits/stl_algobase.h>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <bits/range_access.h>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** namespace std _GLIBCXX_VISIBILITY(default)
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** {
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   template<typename _Tp, std::size_t _Nm>
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     struct __array_traits
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     {
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef _Tp _Type[_Nm];
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef __is_swappable<_Tp> _Is_swappable;
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       static constexpr _Tp&
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _S_ref(const _Type& __t, std::size_t __n) noexcept
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       static constexpr _Tp*
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _S_ptr(const _Type& __t) noexcept
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp*>(__t); }
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     };
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****  template<typename _Tp>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    struct __array_traits<_Tp, 0>
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    {
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      struct _Type { };
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      typedef true_type _Is_swappable;
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      typedef true_type _Is_nothrow_swappable;
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      static constexpr _Tp&
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      _S_ref(const _Type&, std::size_t) noexcept
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      { return *static_cast<_Tp*>(nullptr); }
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      static constexpr _Tp*
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      _S_ptr(const _Type&) noexcept
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      { return nullptr; }
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    };
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   /**
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @brief A standard container for storing a fixed size sequence of elements.
ARM GAS  /tmp/ccoErako.s 			page 238


  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @ingroup sequences
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  Meets the requirements of a <a href="tables.html#65">container</a>, a
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  <a href="tables.html#66">reversible container</a>, and a
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  <a href="tables.html#67">sequence</a>.
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  Sets support random access iterators.
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @tparam  Tp  Type of element. Required to be a complete type.
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @tparam  Nm  Number of elements.
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   */
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   template<typename _Tp, std::size_t _Nm>
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     struct array
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     {
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef _Tp 	    			      value_type;
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef value_type*			      pointer;
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef const value_type*                       const_pointer;
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef value_type&                   	      reference;
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef const value_type&             	      const_reference;
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef value_type*          		      iterator;
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef const value_type*			      const_iterator;
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::size_t                    	      size_type;
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::ptrdiff_t                   	      difference_type;
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::reverse_iterator<iterator>	      reverse_iterator;
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::reverse_iterator<const_iterator>   const_reverse_iterator;
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Support for zero-sized arrays mandatory.
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef _GLIBCXX_STD_C::__array_traits<_Tp, _Nm> _AT_Type;
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typename _AT_Type::_Type                         _M_elems;
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // No explicit construct/copy/destroy for aggregate type.
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // DR 776.
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX20_CONSTEXPR void
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       fill(const value_type& __u)
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { std::fill_n(begin(), size(), __u); }
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX20_CONSTEXPR void
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       swap(array& __other)
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       noexcept(_AT_Type::_Is_nothrow_swappable::value)
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { std::swap_ranges(begin(), end(), __other.begin()); }
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Iterators.
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR iterator
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       begin() noexcept
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return iterator(data()); }
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       begin() const noexcept
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data()); }
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR iterator
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       end() noexcept
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return iterator(data() + _Nm); }
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
ARM GAS  /tmp/ccoErako.s 			page 239


 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       end() const noexcept
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data() + _Nm); }
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reverse_iterator
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rbegin() noexcept
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return reverse_iterator(end()); }
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rbegin() const noexcept
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(end()); }
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reverse_iterator
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rend() noexcept
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return reverse_iterator(begin()); }
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rend() const noexcept
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(begin()); }
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       cbegin() const noexcept
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data()); }
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       cend() const noexcept
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data() + _Nm); }
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       crbegin() const noexcept
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(end()); }
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       crend() const noexcept
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(begin()); }
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Capacity.
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       constexpr size_type
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       size() const noexcept { return _Nm; }
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       constexpr size_type
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       max_size() const noexcept { return _Nm; }
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX_NODISCARD constexpr bool
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       empty() const noexcept { return size() == 0; }
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Element access.
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reference
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       operator[](size_type __n) noexcept
 5232              		.loc 17 185 7 view .LVU1220
 5233              	.LBB1802:
 5234              	.LBI1802:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 5235              		.loc 17 55 7 view .LVU1221
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 5236              		.loc 17 55 7 is_stmt 0 view .LVU1222
 5237              	.LBE1802:
 5238              	.LBE1801:
ARM GAS  /tmp/ccoErako.s 			page 240


  21:communication/can/can_simple.cpp ****     extended_node_ids_[i] = axis.config_.can.is_extended;
 5239              		.loc 3 21 5 is_stmt 1 view .LVU1223
  21:communication/can/can_simple.cpp ****     extended_node_ids_[i] = axis.config_.can.is_extended;
 5240              		.loc 3 21 37 is_stmt 0 view .LVU1224
 5241 0008 394B     		ldr	r3, .L181
 5242 000a 4FF42C72 		mov	r2, #688
 5243 000e 02FB0133 		mla	r3, r2, r1, r3
 5244              	.LVL366:
  21:communication/can/can_simple.cpp ****     extended_node_ids_[i] = axis.config_.can.is_extended;
 5245              		.loc 3 21 37 view .LVU1225
 5246 0012 996F     		ldr	r1, [r3, #120]
 5247              	.LVL367:
  21:communication/can/can_simple.cpp ****     extended_node_ids_[i] = axis.config_.can.is_extended;
 5248              		.loc 3 21 18 view .LVU1226
 5249 0014 A21C     		adds	r2, r4, #2
 5250 0016 00EB8202 		add	r2, r0, r2, lsl #2
 5251 001a 5160     		str	r1, [r2, #4]
  22:communication/can/can_simple.cpp **** 
 5252              		.loc 3 22 5 is_stmt 1 view .LVU1227
  22:communication/can/can_simple.cpp **** 
 5253              		.loc 3 22 46 is_stmt 0 view .LVU1228
 5254 001c 93F87C20 		ldrb	r2, [r3, #124]	@ zero_extendqisi2
  22:communication/can/can_simple.cpp **** 
 5255              		.loc 3 22 27 view .LVU1229
 5256 0020 0319     		adds	r3, r0, r4
 5257              	.LVL368:
  22:communication/can/can_simple.cpp **** 
 5258              		.loc 3 22 27 view .LVU1230
 5259 0022 1A75     		strb	r2, [r3, #20]
  24:communication/can/can_simple.cpp ****         .id = {},
 5260              		.loc 3 24 5 is_stmt 1 view .LVU1231
  24:communication/can/can_simple.cpp ****         .id = {},
 5261              		.loc 3 24 22 is_stmt 0 view .LVU1232
 5262 0024 0023     		movs	r3, #0
 5263 0026 0393     		str	r3, [sp, #12]
 5264 0028 0493     		str	r3, [sp, #16]
 5265 002a 0593     		str	r3, [sp, #20]
 5266 002c 6FF01F03 		mvn	r3, #31
 5267 0030 0593     		str	r3, [sp, #20]
  27:communication/can/can_simple.cpp ****         filter.id = (uint32_t)(axis.config_.can.node_id << NUM_CMD_ID_BITS);
 5268              		.loc 3 27 5 is_stmt 1 view .LVU1233
 5269 0032 002A     		cmp	r2, #0
 5270 0034 35D0     		beq	.L165
  28:communication/can/can_simple.cpp ****     } else {
 5271              		.loc 3 28 9 view .LVU1234
  28:communication/can/can_simple.cpp ****     } else {
 5272              		.loc 3 28 49 is_stmt 0 view .LVU1235
 5273 0036 2E4B     		ldr	r3, .L181
 5274 0038 4FF42C72 		mov	r2, #688
 5275 003c 02FB0433 		mla	r3, r2, r4, r3
 5276              	.LVL369:
  28:communication/can/can_simple.cpp ****     } else {
 5277              		.loc 3 28 49 view .LVU1236
 5278 0040 9B6F     		ldr	r3, [r3, #120]
 5279              	.LVL370:
  28:communication/can/can_simple.cpp ****     } else {
 5280              		.loc 3 28 57 view .LVU1237
ARM GAS  /tmp/ccoErako.s 			page 241


 5281 0042 5B01     		lsls	r3, r3, #5
  28:communication/can/can_simple.cpp ****     } else {
 5282              		.loc 3 28 21 view .LVU1238
 5283 0044 0693     		str	r3, [sp, #24]
 5284              	.LVL371:
 5285              	.LBB1803:
 5286              	.LBI1803:
1430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
 5287              		.loc 1 1430 2 is_stmt 1 view .LVU1239
 5288              	.LBB1804:
 5289              	.LBB1805:
 5290              	.LBB1806:
 5291              	.LBI1806:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 5292              		.loc 1 1571 24 view .LVU1240
 5293              	.LBB1807:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 5294              		.loc 1 1575 17 is_stmt 0 view .LVU1241
 5295 0046 9DF81030 		ldrb	r3, [sp, #16]	@ zero_extendqisi2
 5296              	.LVL372:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 5297              		.loc 1 1575 17 view .LVU1242
 5298              	.LBE1807:
 5299              	.LBE1806:
1435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
 5300              		.loc 1 1435 4 view .LVU1243
 5301 004a 012B     		cmp	r3, #1
 5302 004c 1FD0     		beq	.L177
 5303              	.LVL373:
 5304              	.LBB1808:
 5305              	.LBB1809:
 5306              	.LBI1809:
1472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 5307              		.loc 1 1472 2 is_stmt 1 view .LVU1244
 5308              	.LBB1810:
 5309              	.LBB1811:
 5310              	.LBI1811:
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_index = static_cast<__index_type>(variant_npos); }
 5311              		.loc 1 451 12 view .LVU1245
 5312              	.LBB1812:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 5313              		.loc 1 452 18 is_stmt 0 view .LVU1246
 5314 004e FF23     		movs	r3, #255
 5315 0050 8DF81030 		strb	r3, [sp, #16]
 5316              	.LVL374:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 5317              		.loc 1 452 18 view .LVU1247
 5318              	.LBE1812:
 5319              	.LBE1811:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 5320              		.loc 1 1482 41 view .LVU1248
 5321 0054 06A9     		add	r1, sp, #24
 5322              	.LVL375:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 5323              		.loc 1 1482 41 view .LVU1249
 5324 0056 03A8     		add	r0, sp, #12
 5325              	.LVL376:
ARM GAS  /tmp/ccoErako.s 			page 242


1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 5326              		.loc 1 1482 41 view .LVU1250
 5327 0058 FFF7FEFF 		bl	_ZSt28__variant_construct_by_indexILj1ESt7variantIJtmEEJmEEvRT0_DpOT1_
 5328              	.LVL377:
 5329              	.LBB1813:
 5330              	.LBI1813:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 5331              		.loc 1 1661 5 is_stmt 1 view .LVU1251
 5332              	.LBB1814:
 5333              	.LBB1815:
 5334              	.LBI1815:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 5335              		.loc 1 1571 24 view .LVU1252
 5336              	.LBB1816:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 5337              		.loc 1 1575 17 is_stmt 0 view .LVU1253
 5338 005c 9DF81030 		ldrb	r3, [sp, #16]	@ zero_extendqisi2
 5339              	.LVL378:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 5340              		.loc 1 1575 17 view .LVU1254
 5341              	.LBE1816:
 5342              	.LBE1815:
 5343              		.loc 1 1665 7 view .LVU1255
 5344 0060 012B     		cmp	r3, #1
 5345 0062 1BD1     		bne	.L178
 5346              	.LVL379:
 5347              	.L170:
 5348              		.loc 1 1665 7 view .LVU1256
 5349              	.LBE1814:
 5350              	.LBE1813:
 5351              	.LBE1810:
 5352              	.LBE1809:
 5353              	.LBE1808:
 5354              	.LBE1805:
 5355              	.LBE1804:
 5356              	.LBE1803:
  33:communication/can/can_simple.cpp ****         canbus_->unsubscribe(subscription_handles_[i]);
 5357              		.loc 3 33 5 is_stmt 1 view .LVU1257
  33:communication/can/can_simple.cpp ****         canbus_->unsubscribe(subscription_handles_[i]);
 5358              		.loc 3 33 32 is_stmt 0 view .LVU1258
 5359 0064 05EB8403 		add	r3, r5, r4, lsl #2
 5360 0068 5968     		ldr	r1, [r3, #4]
  33:communication/can/can_simple.cpp ****         canbus_->unsubscribe(subscription_handles_[i]);
 5361              		.loc 3 33 5 view .LVU1259
 5362 006a 19B1     		cbz	r1, .L175
  34:communication/can/can_simple.cpp ****     }
 5363              		.loc 3 34 9 is_stmt 1 view .LVU1260
 5364 006c 2868     		ldr	r0, [r5]
  34:communication/can/can_simple.cpp ****     }
 5365              		.loc 3 34 54 is_stmt 0 view .LVU1261
 5366 006e 0368     		ldr	r3, [r0]
 5367 0070 9B68     		ldr	r3, [r3, #8]
 5368              	.LEHB0:
  34:communication/can/can_simple.cpp ****     }
 5369              		.loc 3 34 29 view .LVU1262
 5370 0072 9847     		blx	r3
 5371              	.LVL380:
ARM GAS  /tmp/ccoErako.s 			page 243


 5372              	.L175:
  37:communication/can/can_simple.cpp ****         filter, [](void* ctx, const can_Message_t& msg) {
 5373              		.loc 3 37 5 is_stmt 1 view .LVU1263
  37:communication/can/can_simple.cpp ****         filter, [](void* ctx, const can_Message_t& msg) {
 5374              		.loc 3 37 12 is_stmt 0 view .LVU1264
 5375 0074 2868     		ldr	r0, [r5]
  41:communication/can/can_simple.cpp **** }
 5376              		.loc 3 41 40 view .LVU1265
 5377 0076 0368     		ldr	r3, [r0]
 5378 0078 5E68     		ldr	r6, [r3, #4]
  37:communication/can/can_simple.cpp ****         filter, [](void* ctx, const can_Message_t& msg) {
 5379              		.loc 3 37 30 view .LVU1266
 5380 007a 05EB8404 		add	r4, r5, r4, lsl #2
 5381              	.LVL381:
  37:communication/can/can_simple.cpp ****         filter, [](void* ctx, const can_Message_t& msg) {
 5382              		.loc 3 37 30 view .LVU1267
 5383 007e 0434     		adds	r4, r4, #4
 5384 0080 0094     		str	r4, [sp]
 5385 0082 2B46     		mov	r3, r5
 5386 0084 1B4A     		ldr	r2, .L181+4
 5387 0086 03A9     		add	r1, sp, #12
 5388 0088 B047     		blx	r6
 5389              	.LVL382:
 5390              	.LEHE0:
  42:communication/can/can_simple.cpp **** 
 5391              		.loc 3 42 1 view .LVU1268
 5392 008a 08B0     		add	sp, sp, #32
 5393              	.LCFI96:
 5394              		.cfi_remember_state
 5395              		.cfi_def_cfa_offset 16
 5396              		@ sp needed
 5397 008c 70BD     		pop	{r4, r5, r6, pc}
 5398              	.LVL383:
 5399              	.L177:
 5400              	.LCFI97:
 5401              		.cfi_restore_state
 5402              	.LBB1838:
 5403              	.LBB1837:
 5404              	.LBB1836:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 5405              		.loc 1 1436 31 view .LVU1269
 5406 008e 069B     		ldr	r3, [sp, #24]
 5407              	.LVL384:
 5408              	.LBB1823:
 5409              	.LBI1823:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 5410              		.loc 1 1661 5 is_stmt 1 view .LVU1270
 5411              	.LBB1824:
 5412              	.LBB1825:
 5413              	.LBI1825:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 5414              		.loc 1 1571 24 view .LVU1271
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 5415              		.loc 1 1571 24 is_stmt 0 view .LVU1272
 5416              	.LBE1825:
 5417              		.loc 1 1665 7 view .LVU1273
 5418 0090 01D1     		bne	.L179
ARM GAS  /tmp/ccoErako.s 			page 244


 5419              	.LVL385:
 5420              	.LBB1826:
 5421              	.LBI1826:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 5422              		.loc 1 276 5 is_stmt 1 view .LVU1274
 5423              	.LBB1827:
 5424              	.LBB1828:
 5425              	.LBI1828:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 5426              		.loc 1 267 5 view .LVU1275
 5427              	.LBB1829:
 5428              	.LBB1830:
 5429              	.LBI1830:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 5430              		.loc 1 262 5 view .LVU1276
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 5431              		.loc 1 262 5 is_stmt 0 view .LVU1277
 5432              	.LBE1830:
 5433              	.LBE1829:
 5434              	.LBE1828:
 5435              	.LBE1827:
 5436              	.LBE1826:
 5437              	.LBE1824:
 5438              	.LBE1823:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 5439              		.loc 1 1436 31 view .LVU1278
 5440 0092 0393     		str	r3, [sp, #12]
 5441 0094 E6E7     		b	.L170
 5442              	.LVL386:
 5443              	.L179:
 5444              	.LBB1834:
 5445              	.LBB1833:
 5446              	.LBB1831:
 5447              	.LBI1831:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 5448              		.loc 1 1287 3 is_stmt 1 view .LVU1279
 5449              	.LBB1832:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 5450              		.loc 1 1289 5 view .LVU1280
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 5451              		.loc 1 1292 7 view .LVU1281
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 5452              		.loc 1 1292 33 is_stmt 0 view .LVU1282
 5453 0096 1848     		ldr	r0, .L181+8
 5454              	.LVL387:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 5455              		.loc 1 1292 33 view .LVU1283
 5456 0098 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 5457              	.LVL388:
 5458              	.L178:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 5459              		.loc 1 1292 33 view .LVU1284
 5460              	.LBE1832:
 5461              	.LBE1831:
 5462              	.LBE1833:
 5463              	.LBE1834:
 5464              	.LBB1835:
ARM GAS  /tmp/ccoErako.s 			page 245


 5465              	.LBB1822:
 5466              	.LBB1821:
 5467              	.LBB1820:
 5468              	.LBB1819:
 5469              	.LBB1817:
 5470              	.LBI1817:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 5471              		.loc 1 1287 3 is_stmt 1 view .LVU1285
 5472              	.LBB1818:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 5473              		.loc 1 1289 5 view .LVU1286
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 5474              		.loc 1 1292 7 view .LVU1287
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 5475              		.loc 1 1292 33 is_stmt 0 view .LVU1288
 5476 009c 1648     		ldr	r0, .L181+8
 5477 009e FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 5478              	.LVL389:
 5479              	.L165:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 5480              		.loc 1 1292 33 view .LVU1289
 5481              	.LBE1818:
 5482              	.LBE1817:
 5483              	.LBE1819:
 5484              	.LBE1820:
 5485              	.LBE1821:
 5486              	.LBE1822:
 5487              	.LBE1835:
 5488              	.LBE1836:
 5489              	.LBE1837:
 5490              	.LBE1838:
  30:communication/can/can_simple.cpp ****     }
 5491              		.loc 3 30 9 is_stmt 1 view .LVU1290
  30:communication/can/can_simple.cpp ****     }
 5492              		.loc 3 30 49 is_stmt 0 view .LVU1291
 5493 00a2 134B     		ldr	r3, .L181
 5494 00a4 4FF42C72 		mov	r2, #688
 5495 00a8 02FB0433 		mla	r3, r2, r4, r3
 5496 00ac 9B6F     		ldr	r3, [r3, #120]
  30:communication/can/can_simple.cpp ****     }
 5497              		.loc 3 30 57 view .LVU1292
 5498 00ae 5B01     		lsls	r3, r3, #5
  30:communication/can/can_simple.cpp ****     }
 5499              		.loc 3 30 21 view .LVU1293
 5500 00b0 ADF81E30 		strh	r3, [sp, #30]	@ movhi
 5501              	.LVL390:
 5502              	.LBB1839:
 5503              	.LBI1839:
1430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
 5504              		.loc 1 1430 2 is_stmt 1 view .LVU1294
 5505              	.LBB1840:
 5506              	.LBB1841:
 5507              	.LBB1842:
 5508              	.LBI1842:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 5509              		.loc 1 1571 24 view .LVU1295
 5510              	.LBB1843:
ARM GAS  /tmp/ccoErako.s 			page 246


1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 5511              		.loc 1 1575 17 is_stmt 0 view .LVU1296
 5512 00b4 9DF81030 		ldrb	r3, [sp, #16]	@ zero_extendqisi2
 5513              	.LVL391:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 5514              		.loc 1 1575 17 view .LVU1297
 5515              	.LBE1843:
 5516              	.LBE1842:
1435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
 5517              		.loc 1 1435 4 view .LVU1298
 5518 00b8 53B9     		cbnz	r3, .L171
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 5519              		.loc 1 1436 31 view .LVU1299
 5520 00ba BDF81E30 		ldrh	r3, [sp, #30]
 5521              	.LVL392:
 5522              	.LBB1844:
 5523              	.LBI1844:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 5524              		.loc 1 1661 5 is_stmt 1 view .LVU1300
 5525              	.LBB1845:
 5526              	.LBB1846:
 5527              	.LBI1846:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 5528              		.loc 1 1571 24 view .LVU1301
 5529              	.LBB1847:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 5530              		.loc 1 1575 17 is_stmt 0 view .LVU1302
 5531 00be 9DF81020 		ldrb	r2, [sp, #16]	@ zero_extendqisi2
 5532              	.LVL393:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 5533              		.loc 1 1575 17 view .LVU1303
 5534              	.LBE1847:
 5535              	.LBE1846:
 5536              		.loc 1 1665 7 view .LVU1304
 5537 00c2 12B9     		cbnz	r2, .L180
 5538              	.LVL394:
 5539              	.LBB1848:
 5540              	.LBI1848:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 5541              		.loc 1 276 5 is_stmt 1 view .LVU1305
 5542              	.LBB1849:
 5543              	.LBB1850:
 5544              	.LBI1850:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 5545              		.loc 1 262 5 view .LVU1306
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 5546              		.loc 1 262 5 is_stmt 0 view .LVU1307
 5547              	.LBE1850:
 5548              	.LBE1849:
 5549              	.LBE1848:
 5550              	.LBE1845:
 5551              	.LBE1844:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 5552              		.loc 1 1436 31 view .LVU1308
 5553 00c4 ADF80C30 		strh	r3, [sp, #12]	@ movhi
 5554 00c8 CCE7     		b	.L170
 5555              	.LVL395:
ARM GAS  /tmp/ccoErako.s 			page 247


 5556              	.L180:
 5557              	.LBB1854:
 5558              	.LBB1853:
 5559              	.LBB1851:
 5560              	.LBI1851:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 5561              		.loc 1 1287 3 is_stmt 1 view .LVU1309
 5562              	.LBB1852:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 5563              		.loc 1 1289 5 view .LVU1310
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 5564              		.loc 1 1292 7 view .LVU1311
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 5565              		.loc 1 1292 33 is_stmt 0 view .LVU1312
 5566 00ca 0B48     		ldr	r0, .L181+8
 5567              	.LVL396:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 5568              		.loc 1 1292 33 view .LVU1313
 5569 00cc FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 5570              	.LVL397:
 5571              	.L171:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 5572              		.loc 1 1292 33 view .LVU1314
 5573              	.LBE1852:
 5574              	.LBE1851:
 5575              	.LBE1853:
 5576              	.LBE1854:
 5577              	.LBB1855:
 5578              	.LBB1856:
 5579              	.LBI1856:
1472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 5580              		.loc 1 1472 2 is_stmt 1 view .LVU1315
 5581              	.LBB1857:
 5582              	.LBB1858:
 5583              	.LBI1858:
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_index = static_cast<__index_type>(variant_npos); }
 5584              		.loc 1 451 12 view .LVU1316
 5585              	.LBB1859:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 5586              		.loc 1 452 18 is_stmt 0 view .LVU1317
 5587 00d0 FF23     		movs	r3, #255
 5588 00d2 8DF81030 		strb	r3, [sp, #16]
 5589              	.LVL398:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 5590              		.loc 1 452 18 view .LVU1318
 5591              	.LBE1859:
 5592              	.LBE1858:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 5593              		.loc 1 1482 41 view .LVU1319
 5594 00d6 0DF11E01 		add	r1, sp, #30
 5595              	.LVL399:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 5596              		.loc 1 1482 41 view .LVU1320
 5597 00da 03A8     		add	r0, sp, #12
 5598              	.LVL400:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 5599              		.loc 1 1482 41 view .LVU1321
ARM GAS  /tmp/ccoErako.s 			page 248


 5600 00dc FFF7FEFF 		bl	_ZSt28__variant_construct_by_indexILj0ESt7variantIJtmEEJtEEvRT0_DpOT1_
 5601              	.LVL401:
 5602              	.LBB1860:
 5603              	.LBI1860:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 5604              		.loc 1 1661 5 is_stmt 1 view .LVU1322
 5605              	.LBB1861:
 5606              	.LBB1862:
 5607              	.LBI1862:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 5608              		.loc 1 1571 24 view .LVU1323
 5609              	.LBB1863:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 5610              		.loc 1 1575 17 is_stmt 0 view .LVU1324
 5611 00e0 9DF81030 		ldrb	r3, [sp, #16]	@ zero_extendqisi2
 5612              	.LVL402:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 5613              		.loc 1 1575 17 view .LVU1325
 5614              	.LBE1863:
 5615              	.LBE1862:
 5616              		.loc 1 1665 7 view .LVU1326
 5617 00e4 002B     		cmp	r3, #0
 5618 00e6 BDD0     		beq	.L170
 5619              	.LVL403:
 5620              	.LBB1864:
 5621              	.LBI1864:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 5622              		.loc 1 1287 3 is_stmt 1 view .LVU1327
 5623              	.LBB1865:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 5624              		.loc 1 1289 5 view .LVU1328
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 5625              		.loc 1 1292 7 view .LVU1329
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 5626              		.loc 1 1292 33 is_stmt 0 view .LVU1330
 5627 00e8 0348     		ldr	r0, .L181+8
 5628 00ea FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 5629              	.LVL404:
 5630              	.L182:
 5631 00ee 00BF     		.align	2
 5632              	.L181:
 5633 00f0 00000000 		.word	axes
 5634 00f4 00000000 		.word	_ZZN9CANSimple18renew_subscriptionEjENUlPvRK13can_Message_tE_4_FUNES0_S3_
 5635 00f8 00000000 		.word	.LC1
 5636              	.LBE1865:
 5637              	.LBE1864:
 5638              	.LBE1861:
 5639              	.LBE1860:
 5640              	.LBE1857:
 5641              	.LBE1856:
 5642              	.LBE1855:
 5643              	.LBE1841:
 5644              	.LBE1840:
 5645              	.LBE1839:
 5646              		.cfi_endproc
 5647              	.LFE5159:
 5648              		.global	__gxx_personality_v0
ARM GAS  /tmp/ccoErako.s 			page 249


 5649              		.personality	__gxx_personality_v0
 5650              		.handlerdata
 5651              	.LLSDA5159:
 5652 0008 FF       		.byte	0xff
 5653 0009 FF       		.byte	0xff
 5654 000a 01       		.byte	0x1
 5655 000b 04       		.uleb128 .LLSDACSE5159-.LLSDACSB5159
 5656              	.LLSDACSB5159:
 5657 000c 72       		.uleb128 .LEHB0-.LFB5159
 5658 000d 18       		.uleb128 .LEHE0-.LEHB0
 5659 000e 00       		.uleb128 0
 5660 000f 00       		.uleb128 0
 5661              	.LLSDACSE5159:
 5662              		.section	.text._ZN9CANSimple18renew_subscriptionEj
 5663              		.fnend
 5665              		.section	.text._ZN9CANSimple4initEv,"ax",%progbits
 5666              		.align	1
 5667              		.global	_ZN9CANSimple4initEv
 5668              		.syntax unified
 5669              		.thumb
 5670              		.thumb_func
 5672              	_ZN9CANSimple4initEv:
 5673              		.fnstart
 5674              	.LVL405:
 5675              	.LFB5158:
   7:communication/can/can_simple.cpp ****     for (size_t i = 0; i < AXIS_COUNT; ++i) {
 5676              		.loc 3 7 24 is_stmt 1 view -0
 5677              		.cfi_startproc
 5678              		@ args = 0, pretend = 0, frame = 0
 5679              		@ frame_needed = 0, uses_anonymous_args = 0
   7:communication/can/can_simple.cpp ****     for (size_t i = 0; i < AXIS_COUNT; ++i) {
 5680              		.loc 3 7 24 is_stmt 0 view .LVU1332
 5681 0000 38B5     		push	{r3, r4, r5, lr}
 5682              		.save {r3, r4, r5, lr}
 5683              	.LCFI98:
 5684              		.cfi_def_cfa_offset 16
 5685              		.cfi_offset 3, -16
 5686              		.cfi_offset 4, -12
 5687              		.cfi_offset 5, -8
 5688              		.cfi_offset 14, -4
 5689 0002 0546     		mov	r5, r0
   8:communication/can/can_simple.cpp ****         if (!renew_subscription(i)) {
 5690              		.loc 3 8 5 is_stmt 1 view .LVU1333
 5691              	.LVL406:
 5692              	.LBB1866:
   8:communication/can/can_simple.cpp ****         if (!renew_subscription(i)) {
 5693              		.loc 3 8 17 is_stmt 0 view .LVU1334
 5694 0004 0024     		movs	r4, #0
 5695              	.LVL407:
 5696              	.L185:
   8:communication/can/can_simple.cpp ****         if (!renew_subscription(i)) {
 5697              		.loc 3 8 26 is_stmt 1 discriminator 1 view .LVU1335
 5698 0006 012C     		cmp	r4, #1
 5699 0008 07D8     		bhi	.L186
   9:communication/can/can_simple.cpp ****             return false;
 5700              		.loc 3 9 9 view .LVU1336
   9:communication/can/can_simple.cpp ****             return false;
ARM GAS  /tmp/ccoErako.s 			page 250


 5701              		.loc 3 9 32 is_stmt 0 view .LVU1337
 5702 000a 2146     		mov	r1, r4
 5703 000c 2846     		mov	r0, r5
 5704 000e FFF7FEFF 		bl	_ZN9CANSimple18renew_subscriptionEj
 5705              	.LVL408:
   9:communication/can/can_simple.cpp ****             return false;
 5706              		.loc 3 9 9 view .LVU1338
 5707 0012 0346     		mov	r3, r0
 5708 0014 10B1     		cbz	r0, .L184
   8:communication/can/can_simple.cpp ****         if (!renew_subscription(i)) {
 5709              		.loc 3 8 5 is_stmt 1 discriminator 2 view .LVU1339
 5710 0016 0134     		adds	r4, r4, #1
 5711              	.LVL409:
   8:communication/can/can_simple.cpp ****         if (!renew_subscription(i)) {
 5712              		.loc 3 8 5 is_stmt 0 discriminator 2 view .LVU1340
 5713 0018 F5E7     		b	.L185
 5714              	.L186:
   8:communication/can/can_simple.cpp ****         if (!renew_subscription(i)) {
 5715              		.loc 3 8 5 discriminator 2 view .LVU1341
 5716              	.LBE1866:
  14:communication/can/can_simple.cpp **** }
 5717              		.loc 3 14 12 view .LVU1342
 5718 001a 0123     		movs	r3, #1
 5719              	.L184:
  15:communication/can/can_simple.cpp **** 
 5720              		.loc 3 15 1 view .LVU1343
 5721 001c 1846     		mov	r0, r3
 5722 001e 38BD     		pop	{r3, r4, r5, pc}
  15:communication/can/can_simple.cpp **** 
 5723              		.loc 3 15 1 view .LVU1344
 5724              		.cfi_endproc
 5725              	.LFE5158:
 5726              		.fnend
 5728              		.section	.text._ZN9CANSimple13service_stackEv,"ax",%progbits
 5729              		.align	1
 5730              		.global	_ZN9CANSimple13service_stackEv
 5731              		.syntax unified
 5732              		.thumb
 5733              		.thumb_func
 5735              	_ZN9CANSimple13service_stackEv:
 5736              		.fnstart
 5737              	.LVL410:
 5738              	.LFB5245:
 390:communication/can/can_simple.cpp ****     uint32_t nextServiceTime = UINT32_MAX;
 5739              		.loc 3 390 37 is_stmt 1 view -0
 5740              		.cfi_startproc
 5741              		@ args = 0, pretend = 0, frame = 192
 5742              		@ frame_needed = 0, uses_anonymous_args = 0
 390:communication/can/can_simple.cpp ****     uint32_t nextServiceTime = UINT32_MAX;
 5743              		.loc 3 390 37 is_stmt 0 view .LVU1346
 5744 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 5745              		.save {r4, r5, r6, r7, r8, r9, lr}
 5746              	.LCFI99:
 5747              		.cfi_def_cfa_offset 28
 5748              		.cfi_offset 4, -28
 5749              		.cfi_offset 5, -24
 5750              		.cfi_offset 6, -20
ARM GAS  /tmp/ccoErako.s 			page 251


 5751              		.cfi_offset 7, -16
 5752              		.cfi_offset 8, -12
 5753              		.cfi_offset 9, -8
 5754              		.cfi_offset 14, -4
 5755              		.pad #196
 5756 0004 B1B0     		sub	sp, sp, #196
 5757              	.LCFI100:
 5758              		.cfi_def_cfa_offset 224
 5759 0006 0746     		mov	r7, r0
 391:communication/can/can_simple.cpp ****     uint32_t now = HAL_GetTick();
 5760              		.loc 3 391 5 is_stmt 1 view .LVU1347
 391:communication/can/can_simple.cpp ****     uint32_t now = HAL_GetTick();
 5761              		.loc 3 391 14 is_stmt 0 view .LVU1348
 5762 0008 4FF0FF33 		mov	r3, #-1
 5763 000c 2D93     		str	r3, [sp, #180]
 392:communication/can/can_simple.cpp **** 
 5764              		.loc 3 392 5 is_stmt 1 view .LVU1349
 5765              	.LEHB1:
 392:communication/can/can_simple.cpp **** 
 5766              		.loc 3 392 31 is_stmt 0 view .LVU1350
 5767 000e FFF7FEFF 		bl	HAL_GetTick
 5768              	.LVL411:
 392:communication/can/can_simple.cpp **** 
 5769              		.loc 3 392 31 view .LVU1351
 5770 0012 0546     		mov	r5, r0
 5771              	.LBB1905:
 395:communication/can/can_simple.cpp ****         bool node_id_changed = (axes[i].config_.can.node_id != node_ids_[i]) || (axes[i].config_.ca
 5772              		.loc 3 395 17 view .LVU1352
 5773 0014 0024     		movs	r4, #0
 5774 0016 04E0     		b	.L192
 5775              	.LVL412:
 5776              	.L190:
 5777              	.LBB1906:
 397:communication/can/can_simple.cpp ****             renew_subscription(i);
 5778              		.loc 3 397 9 is_stmt 1 discriminator 3 view .LVU1353
 398:communication/can/can_simple.cpp ****         }
 5779              		.loc 3 398 13 discriminator 3 view .LVU1354
 398:communication/can/can_simple.cpp ****         }
 5780              		.loc 3 398 31 is_stmt 0 discriminator 3 view .LVU1355
 5781 0018 2146     		mov	r1, r4
 5782 001a 3846     		mov	r0, r7
 5783 001c FFF7FEFF 		bl	_ZN9CANSimple18renew_subscriptionEj
 5784              	.LVL413:
 5785              	.LEHE1:
 5786              	.L191:
 398:communication/can/can_simple.cpp ****         }
 5787              		.loc 3 398 31 discriminator 3 view .LVU1356
 5788              	.LBE1906:
 395:communication/can/can_simple.cpp ****         bool node_id_changed = (axes[i].config_.can.node_id != node_ids_[i]) || (axes[i].config_.ca
 5789              		.loc 3 395 5 is_stmt 1 discriminator 2 view .LVU1357
 5790 0020 0134     		adds	r4, r4, #1
 5791              	.LVL414:
 5792              	.L192:
 395:communication/can/can_simple.cpp ****         bool node_id_changed = (axes[i].config_.can.node_id != node_ids_[i]) || (axes[i].config_.ca
 5793              		.loc 3 395 26 discriminator 1 view .LVU1358
 5794 0022 012C     		cmp	r4, #1
 5795 0024 17D8     		bhi	.L207
ARM GAS  /tmp/ccoErako.s 			page 252


 5796              	.LBB1911:
 396:communication/can/can_simple.cpp ****         if (node_id_changed) {
 5797              		.loc 3 396 9 view .LVU1359
 5798              	.LVL415:
 5799              	.LBB1907:
 5800              	.LBI1907:
 5801              		.loc 17 185 7 view .LVU1360
 5802              	.LBB1908:
 5803              	.LBI1908:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 5804              		.loc 17 55 7 view .LVU1361
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 5805              		.loc 17 55 7 is_stmt 0 view .LVU1362
 5806              	.LBE1908:
 5807              	.LBE1907:
 396:communication/can/can_simple.cpp ****         if (node_id_changed) {
 5808              		.loc 3 396 53 view .LVU1363
 5809 0026 784B     		ldr	r3, .L217
 5810 0028 4FF42C72 		mov	r2, #688
 5811 002c 02FB0433 		mla	r3, r2, r4, r3
 5812 0030 9A6F     		ldr	r2, [r3, #120]
 396:communication/can/can_simple.cpp ****         if (node_id_changed) {
 5813              		.loc 3 396 75 view .LVU1364
 5814 0032 A31C     		adds	r3, r4, #2
 5815 0034 07EB8303 		add	r3, r7, r3, lsl #2
 5816 0038 5B68     		ldr	r3, [r3, #4]
 396:communication/can/can_simple.cpp ****         if (node_id_changed) {
 5817              		.loc 3 396 78 view .LVU1365
 5818 003a 9A42     		cmp	r2, r3
 5819 003c ECD1     		bne	.L190
 5820              	.LVL416:
 5821              	.LBB1909:
 5822              	.LBI1909:
 5823              		.loc 17 185 7 is_stmt 1 view .LVU1366
 5824              	.LBB1910:
 5825              	.LBI1910:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 5826              		.loc 17 55 7 view .LVU1367
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 5827              		.loc 17 55 7 is_stmt 0 view .LVU1368
 5828              	.LBE1910:
 5829              	.LBE1909:
 396:communication/can/can_simple.cpp ****         if (node_id_changed) {
 5830              		.loc 3 396 102 view .LVU1369
 5831 003e 724B     		ldr	r3, .L217
 5832 0040 4FF42C72 		mov	r2, #688
 5833 0044 02FB0433 		mla	r3, r2, r4, r3
 5834 0048 93F87C20 		ldrb	r2, [r3, #124]	@ zero_extendqisi2
 396:communication/can/can_simple.cpp ****         if (node_id_changed) {
 5835              		.loc 3 396 137 view .LVU1370
 5836 004c 3B19     		adds	r3, r7, r4
 5837 004e 1B7D     		ldrb	r3, [r3, #20]	@ zero_extendqisi2
 396:communication/can/can_simple.cpp ****         if (node_id_changed) {
 5838              		.loc 3 396 78 view .LVU1371
 5839 0050 9A42     		cmp	r2, r3
 5840 0052 E1D1     		bne	.L190
 5841 0054 E4E7     		b	.L191
ARM GAS  /tmp/ccoErako.s 			page 253


 5842              	.L207:
 396:communication/can/can_simple.cpp ****         if (node_id_changed) {
 5843              		.loc 3 396 78 view .LVU1372
 5844              	.LBE1911:
 5845              	.LBE1905:
 5846              	.LBB1912:
 408:communication/can/can_simple.cpp ****         std::array<periodic, 10> periodics = {{
 5847              		.loc 3 408 23 view .LVU1373
 5848 0056 6C4E     		ldr	r6, .L217
 5849 0058 5CE0     		b	.L189
 5850              	.LVL417:
 5851              	.L215:
 5852              	.LBB1913:
 5853              	.LBB1914:
 5854              	.LBB1915:
 5855              	.LBB1916:
 5856              	.LBB1917:
 426:communication/can/can_simple.cpp ****                             msg.last_time = now;
 5857              		.loc 3 426 25 is_stmt 1 view .LVU1374
 5858              	.LBB1918:
 5859              	.LBI1918:
 5860              		.file 18 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // <functional> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // Copyright (C) 2001-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** /*
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****  * Copyright (c) 1997
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****  * Silicon Graphics Computer Systems, Inc.
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****  *
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****  * Permission to use, copy, modify, distribute and sell this software
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****  * and its documentation for any purpose is hereby granted without fee,
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****  * provided that the above copyright notice appear in all copies and
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****  * that both that copyright notice and this permission notice appear
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****  * in supporting documentation.  Silicon Graphics makes no
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****  * representations about the suitability of this software for any
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****  * purpose.  It is provided "as is" without express or implied warranty.
ARM GAS  /tmp/ccoErako.s 			page 254


  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****  *
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****  */
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** 
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** /** @file include/functional
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****  *  This is a Standard C++ Library header.
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****  */
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** 
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #ifndef _GLIBCXX_FUNCTIONAL
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #define _GLIBCXX_FUNCTIONAL 1
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** 
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #pragma GCC system_header
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** 
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #include <bits/c++config.h>
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #include <bits/stl_function.h>
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** 
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #if __cplusplus >= 201103L
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** 
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #include <new>
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #include <tuple>
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #include <type_traits>
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #include <bits/functional_hash.h>
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #include <bits/invoke.h>
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #include <bits/refwrap.h>	// std::reference_wrapper and _Mem_fn_traits
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #include <bits/std_function.h>	// std::function
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #if __cplusplus > 201402L
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** # include <unordered_map>
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** # include <vector>
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** # include <array>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** # include <utility>
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** # include <bits/stl_algo.h>
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #endif
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #if __cplusplus > 201703L
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** # include <bits/range_cmp.h>
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** # include <compare>
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #endif
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** 
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** namespace std _GLIBCXX_VISIBILITY(default)
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** {
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** 
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #if __cplusplus >= 201703L
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** # define __cpp_lib_invoke 201411L
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** # if __cplusplus > 201703L
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** #  define __cpp_lib_constexpr_functional 201907L
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** # endif
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional **** 
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****   /// Invoke a callable object.
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****   template<typename _Callable, typename... _Args>
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****     inline _GLIBCXX20_CONSTEXPR invoke_result_t<_Callable, _Args...>
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional ****     invoke(_Callable&& __fn, _Args&&... __args)
 5861              		.loc 18 85 5 view .LVU1375
 5862              	.LBB1919:
 5863              	.LBI1919:
 5864              		.file 19 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // Implementation of INVOKE -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // Copyright (C) 2016-2020 Free Software Foundation, Inc.
ARM GAS  /tmp/ccoErako.s 			page 255


   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** /** @file include/bits/invoke.h
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****  *  This is an internal header file, included by other library headers.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****  *  Do not attempt to use it directly. @headername{functional}
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****  */
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** #ifndef _GLIBCXX_INVOKE_H
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** #define _GLIBCXX_INVOKE_H 1
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** #pragma GCC system_header
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** #if __cplusplus < 201103L
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** # include <bits/c++0x_warning.h>
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** #else
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** #include <type_traits>
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** namespace std _GLIBCXX_VISIBILITY(default)
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** {
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   /**
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****    *  @addtogroup utilities
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****    *  @{
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****    */
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   // Used by __invoke_impl instead of std::forward<_Tp> so that a
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   // reference_wrapper is converted to an lvalue-reference.
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr _Up&&
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     { return static_cast<_Up&&>(__t); }
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Res, typename _Fn, typename... _Args>
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr _Res
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }
ARM GAS  /tmp/ccoErako.s 			page 256


  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr _Res
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 		  _Args&&... __args)
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr _Res
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 		  _Args&&... __args)
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     {
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****       return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     }
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Res, typename _MemPtr, typename _Tp>
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr _Res
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     { return __invfwd<_Tp>(__t).*__f; }
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Res, typename _MemPtr, typename _Tp>
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr _Res
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     { return (*std::forward<_Tp>(__t)).*__f; }
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   /// Invoke a callable object.
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Callable, typename... _Args>
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr typename __invoke_result<_Callable, _Args...>::type
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invoke(_Callable&& __fn, _Args&&... __args)
 5865              		.loc 19 89 5 view .LVU1376
 5866              	.LBB1920:
 5867              	.LBB1921:
 5868              	.LBI1921:
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 		  _Args&&... __args)
 5869              		.loc 19 70 5 view .LVU1377
 5870              	.LBB1922:
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     }
 5871              		.loc 19 73 46 is_stmt 0 view .LVU1378
 5872 005a E068     		ldr	r0, [r4, #12]
 5873 005c 10F0010F 		tst	r0, #1
 5874 0060 05D1     		bne	.L198
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     }
 5875              		.loc 19 73 46 view .LVU1379
 5876 0062 A368     		ldr	r3, [r4, #8]
 5877              	.L199:
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     }
 5878              		.loc 19 73 46 view .LVU1380
 5879 0064 3146     		mov	r1, r6
 5880 0066 07EB6000 		add	r0, r7, r0, asr #1
 5881              	.LEHB2:
 5882 006a 9847     		blx	r3
 5883              	.LVL418:
 5884              	.LEHE2:
 5885 006c 04E0     		b	.L214
 5886              	.L198:
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     }
 5887              		.loc 19 73 46 view .LVU1381
ARM GAS  /tmp/ccoErako.s 			page 257


 5888 006e 4310     		asrs	r3, r0, #1
 5889 0070 FA58     		ldr	r2, [r7, r3]
 5890 0072 A368     		ldr	r3, [r4, #8]
 5891 0074 D358     		ldr	r3, [r2, r3]
 5892 0076 F5E7     		b	.L199
 5893              	.L214:
 5894              	.LVL419:
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     }
 5895              		.loc 19 73 46 view .LVU1382
 5896              	.LBE1922:
 5897              	.LBE1921:
 5898              	.LBE1920:
 5899              	.LBE1919:
 5900              	.LBE1918:
 426:communication/can/can_simple.cpp ****                             msg.last_time = now;
 5901              		.loc 3 426 25 view .LVU1383
 5902 0078 A0B1     		cbz	r0, .L197
 427:communication/can/can_simple.cpp ****                         }
 5903              		.loc 3 427 29 is_stmt 1 view .LVU1384
 427:communication/can/can_simple.cpp ****                         }
 5904              		.loc 3 427 33 is_stmt 0 view .LVU1385
 5905 007a 6368     		ldr	r3, [r4, #4]
 427:communication/can/can_simple.cpp ****                         }
 5906              		.loc 3 427 43 view .LVU1386
 5907 007c 1D60     		str	r5, [r3]
 5908 007e 11E0     		b	.L197
 5909              	.LVL420:
 5910              	.L208:
 5911              	.LBB1923:
 5912              	.LBB1924:
 5913              		.loc 13 260 9 view .LVU1387
 5914 0080 01AB     		add	r3, sp, #4
 5915              	.LVL421:
 5916              		.loc 13 260 9 view .LVU1388
 5917 0082 1BE0     		b	.L200
 5918              	.LVL422:
 5919              	.L209:
 5920              		.loc 13 260 9 view .LVU1389
 5921              	.LBE1924:
 5922              	.LBE1923:
 5923              	.LBB1926:
 5924              	.LBB1927:
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 5925              		.loc 13 236 9 view .LVU1390
 5926 0084 2EAB     		add	r3, sp, #184
 5927              	.LVL423:
 5928              	.L201:
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 5929              		.loc 13 236 9 view .LVU1391
 5930              	.LBE1927:
 5931              	.LBE1926:
 432:communication/can/can_simple.cpp ****                 }
 5932              		.loc 3 432 47 view .LVU1392
 5933 0086 1B68     		ldr	r3, [r3]
 432:communication/can/can_simple.cpp ****                 }
 5934              		.loc 3 432 37 view .LVU1393
 5935 0088 2D93     		str	r3, [sp, #180]
ARM GAS  /tmp/ccoErako.s 			page 258


 5936              	.L196:
 432:communication/can/can_simple.cpp ****                 }
 5937              		.loc 3 432 37 view .LVU1394
 5938              	.LBE1917:
 5939              	.LBE1916:
 423:communication/can/can_simple.cpp ****                 if (msg.rate > 0) {
 5940              		.loc 3 423 13 is_stmt 1 discriminator 3 view .LVU1395
 5941 008a 1034     		adds	r4, r4, #16
 5942              	.LVL424:
 5943              	.L202:
 423:communication/can/can_simple.cpp ****                 if (msg.rate > 0) {
 5944              		.loc 3 423 30 discriminator 1 view .LVU1396
 5945 008c 2DAB     		add	r3, sp, #180
 5946 008e 9C42     		cmp	r4, r3
 5947 0090 1BD0     		beq	.L195
 5948              	.LVL425:
 423:communication/can/can_simple.cpp ****                 if (msg.rate > 0) {
 5949              		.loc 3 423 30 is_stmt 0 discriminator 1 view .LVU1397
 5950              	.LBE1915:
 5951              	.LBE1914:
 5952              	.LBE1913:
 5953              	.LBE1912:
 424:communication/can/can_simple.cpp ****                     if ((now - msg.last_time) >= msg.rate) {
 5954              		.loc 3 424 17 is_stmt 1 discriminator 2 view .LVU1398
 5955              	.LBB1962:
 5956              	.LBB1960:
 5957              	.LBB1958:
 5958              	.LBB1933:
 5959              	.LBB1932:
 424:communication/can/can_simple.cpp ****                     if ((now - msg.last_time) >= msg.rate) {
 5960              		.loc 3 424 25 is_stmt 0 discriminator 2 view .LVU1399
 5961 0092 2368     		ldr	r3, [r4]
 5962 0094 1B68     		ldr	r3, [r3]
 424:communication/can/can_simple.cpp ****                     if ((now - msg.last_time) >= msg.rate) {
 5963              		.loc 3 424 17 discriminator 2 view .LVU1400
 5964 0096 002B     		cmp	r3, #0
 5965 0098 F7D0     		beq	.L196
 5966              	.LBB1931:
 425:communication/can/can_simple.cpp ****                         if (std::invoke(msg.callback, this, axis)) {
 5967              		.loc 3 425 21 is_stmt 1 view .LVU1401
 425:communication/can/can_simple.cpp ****                         if (std::invoke(msg.callback, this, axis)) {
 5968              		.loc 3 425 36 is_stmt 0 view .LVU1402
 5969 009a 6268     		ldr	r2, [r4, #4]
 5970 009c 1268     		ldr	r2, [r2]
 425:communication/can/can_simple.cpp ****                         if (std::invoke(msg.callback, this, axis)) {
 5971              		.loc 3 425 30 view .LVU1403
 5972 009e AA1A     		subs	r2, r5, r2
 425:communication/can/can_simple.cpp ****                         if (std::invoke(msg.callback, this, axis)) {
 5973              		.loc 3 425 21 view .LVU1404
 5974 00a0 9342     		cmp	r3, r2
 5975 00a2 DAD9     		bls	.L215
 5976              	.L197:
 431:communication/can/can_simple.cpp ****                     nextServiceTime = std::min(nextServiceTime, static_cast<uint32_t>(std::max(0, n
 5977              		.loc 3 431 21 is_stmt 1 discriminator 1 view .LVU1405
 431:communication/can/can_simple.cpp ****                     nextServiceTime = std::min(nextServiceTime, static_cast<uint32_t>(std::max(0, n
 5978              		.loc 3 431 47 is_stmt 0 discriminator 1 view .LVU1406
 5979 00a4 6368     		ldr	r3, [r4, #4]
ARM GAS  /tmp/ccoErako.s 			page 259


 5980 00a6 1B68     		ldr	r3, [r3]
 431:communication/can/can_simple.cpp ****                     nextServiceTime = std::min(nextServiceTime, static_cast<uint32_t>(std::max(0, n
 5981              		.loc 3 431 63 discriminator 1 view .LVU1407
 5982 00a8 2268     		ldr	r2, [r4]
 5983 00aa 1268     		ldr	r2, [r2]
 431:communication/can/can_simple.cpp ****                     nextServiceTime = std::min(nextServiceTime, static_cast<uint32_t>(std::max(0, n
 5984              		.loc 3 431 57 discriminator 1 view .LVU1408
 5985 00ac 1344     		add	r3, r3, r2
 431:communication/can/can_simple.cpp ****                     nextServiceTime = std::min(nextServiceTime, static_cast<uint32_t>(std::max(0, n
 5986              		.loc 3 431 68 discriminator 1 view .LVU1409
 5987 00ae 5B1B     		subs	r3, r3, r5
 431:communication/can/can_simple.cpp ****                     nextServiceTime = std::min(nextServiceTime, static_cast<uint32_t>(std::max(0, n
 5988              		.loc 3 431 25 discriminator 1 view .LVU1410
 5989 00b0 0193     		str	r3, [sp, #4]
 432:communication/can/can_simple.cpp ****                 }
 5990              		.loc 3 432 21 is_stmt 1 discriminator 1 view .LVU1411
 432:communication/can/can_simple.cpp ****                 }
 5991              		.loc 3 432 96 is_stmt 0 discriminator 1 view .LVU1412
 5992 00b2 0022     		movs	r2, #0
 5993 00b4 2F92     		str	r2, [sp, #188]
 5994              	.LVL426:
 5995              	.LBB1929:
 5996              	.LBI1923:
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 5997              		.loc 13 254 5 is_stmt 1 discriminator 1 view .LVU1413
 5998              	.LBB1925:
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 5999              		.loc 13 259 7 is_stmt 0 discriminator 1 view .LVU1414
 6000 00b6 9342     		cmp	r3, r2
 6001 00b8 E2DC     		bgt	.L208
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 6002              		.loc 13 261 14 view .LVU1415
 6003 00ba 2FAB     		add	r3, sp, #188
 6004              	.LVL427:
 6005              	.L200:
 6006              		.loc 13 261 14 view .LVU1416
 6007              	.LBE1925:
 6008              	.LBE1929:
 432:communication/can/can_simple.cpp ****                 }
 6009              		.loc 3 432 95 view .LVU1417
 6010 00bc 1B68     		ldr	r3, [r3]
 432:communication/can/can_simple.cpp ****                 }
 6011              		.loc 3 432 65 view .LVU1418
 6012 00be 2E93     		str	r3, [sp, #184]
 6013              	.LVL428:
 6014              	.LBB1930:
 6015              	.LBI1926:
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 6016              		.loc 13 230 5 is_stmt 1 view .LVU1419
 6017              	.LBB1928:
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 6018              		.loc 13 235 15 is_stmt 0 view .LVU1420
 6019 00c0 2D9A     		ldr	r2, [sp, #180]
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 6020              		.loc 13 235 7 view .LVU1421
 6021 00c2 9342     		cmp	r3, r2
 6022 00c4 DED3     		bcc	.L209
ARM GAS  /tmp/ccoErako.s 			page 260


 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 6023              		.loc 13 237 14 view .LVU1422
 6024 00c6 2DAB     		add	r3, sp, #180
 6025              	.LVL429:
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 6026              		.loc 13 237 14 view .LVU1423
 6027 00c8 DDE7     		b	.L201
 6028              	.LVL430:
 6029              	.L195:
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 6030              		.loc 13 237 14 view .LVU1424
 6031              	.LBE1928:
 6032              	.LBE1930:
 6033              	.LBE1931:
 6034              	.LBE1932:
 6035              	.LBE1933:
 422:communication/can/can_simple.cpp ****             for (auto& msg : periodics) {
 6036              		.loc 3 422 9 is_stmt 1 discriminator 3 view .LVU1425
 6037 00ca 0123     		movs	r3, #1
 6038 00cc 8DF81030 		strb	r3, [sp, #16]
 6039              	.LVL431:
 6040              	.L203:
 422:communication/can/can_simple.cpp ****             for (auto& msg : periodics) {
 6041              		.loc 3 422 9 discriminator 1 view .LVU1426
 6042 00d0 9DF81030 		ldrb	r3, [sp, #16]	@ zero_extendqisi2
 6043 00d4 0BB9     		cbnz	r3, .L194
 6044              	.LBB1934:
 423:communication/can/can_simple.cpp ****                 if (msg.rate > 0) {
 6045              		.loc 3 423 30 is_stmt 0 view .LVU1427
 6046 00d6 05AC     		add	r4, sp, #20
 6047 00d8 D8E7     		b	.L202
 6048              	.L194:
 6049              	.LVL432:
 423:communication/can/can_simple.cpp ****                 if (msg.rate > 0) {
 6050              		.loc 3 423 30 view .LVU1428
 6051              	.LBE1934:
 6052              	.LBB1935:
 6053              	.LBI1935:
  49:MotorControl/task_timer.hpp **** };
  50:MotorControl/task_timer.hpp **** 
  51:MotorControl/task_timer.hpp **** struct TaskTimerContext {
  52:MotorControl/task_timer.hpp ****     TaskTimerContext(const TaskTimerContext&) = delete;
  53:MotorControl/task_timer.hpp ****     TaskTimerContext(const TaskTimerContext&&) = delete;
  54:MotorControl/task_timer.hpp ****     void operator=(const TaskTimerContext&) = delete;
  55:MotorControl/task_timer.hpp ****     void operator=(const TaskTimerContext&&) = delete;
  56:MotorControl/task_timer.hpp ****     TaskTimerContext(TaskTimer& timer) : timer_(timer), start_time(timer.start()) {}
  57:MotorControl/task_timer.hpp ****     ~TaskTimerContext() { timer_.stop(start_time); }
 6054              		.loc 12 57 5 is_stmt 1 view .LVU1429
 6055              	.LBB1936:
 6056              		.loc 12 57 27 view .LVU1430
 6057              	.LBB1937:
 6058              	.LBI1937:
  30:MotorControl/task_timer.hpp ****         uint32_t end_time = sample_TIM13();
 6059              		.loc 12 30 10 view .LVU1431
 6060              	.LBB1938:
  31:MotorControl/task_timer.hpp ****         uint32_t length = end_time - start_time;
 6061              		.loc 12 31 9 view .LVU1432
ARM GAS  /tmp/ccoErako.s 			page 261


 6062              	.LBB1939:
 6063              	.LBI1939:
  12:MotorControl/task_timer.hpp ****     //!
 6064              		.loc 12 12 17 view .LVU1433
 6065              	.LBB1940:
  14:MotorControl/task_timer.hpp ****     return clocks_per_cnt * TIM13->CNT;  // TODO: Use a hw_config  
 6066              		.loc 12 14 5 view .LVU1434
  15:MotorControl/task_timer.hpp **** }
 6067              		.loc 12 15 5 view .LVU1435
  15:MotorControl/task_timer.hpp **** }
 6068              		.loc 12 15 36 is_stmt 0 view .LVU1436
 6069 00da 4C4B     		ldr	r3, .L217+4
 6070 00dc 5B6A     		ldr	r3, [r3, #36]
 6071 00de 5B00     		lsls	r3, r3, #1
 6072 00e0 9BB2     		uxth	r3, r3
 6073              	.LVL433:
  15:MotorControl/task_timer.hpp **** }
 6074              		.loc 12 15 36 view .LVU1437
 6075              	.LBE1940:
 6076              	.LBE1939:
  32:MotorControl/task_timer.hpp **** 
 6077              		.loc 12 32 9 is_stmt 1 view .LVU1438
  32:MotorControl/task_timer.hpp **** 
 6078              		.loc 12 32 36 is_stmt 0 view .LVU1439
 6079 00e2 A3EB0802 		sub	r2, r3, r8
  32:MotorControl/task_timer.hpp **** 
 6080              		.loc 12 32 18 view .LVU1440
 6081 00e6 0192     		str	r2, [sp, #4]
  34:MotorControl/task_timer.hpp **** #ifdef MEASURE_START_TIME
 6082              		.loc 12 34 9 is_stmt 1 view .LVU1441
 6083 00e8 494A     		ldr	r2, .L217+8
 6084 00ea 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 6085 00ec 32B1     		cbz	r2, .L204
  36:MotorControl/task_timer.hpp **** #endif
 6086              		.loc 12 36 13 view .LVU1442
  36:MotorControl/task_timer.hpp **** #endif
 6087              		.loc 12 36 25 is_stmt 0 view .LVU1443
 6088 00ee C9F80080 		str	r8, [r9]
  39:MotorControl/task_timer.hpp **** #endif
 6089              		.loc 12 39 13 is_stmt 1 view .LVU1444
  39:MotorControl/task_timer.hpp **** #endif
 6090              		.loc 12 39 23 is_stmt 0 view .LVU1445
 6091 00f2 C9F80430 		str	r3, [r9, #4]
  42:MotorControl/task_timer.hpp **** #endif
 6092              		.loc 12 42 13 is_stmt 1 view .LVU1446
  42:MotorControl/task_timer.hpp **** #endif
 6093              		.loc 12 42 21 is_stmt 0 view .LVU1447
 6094 00f6 019B     		ldr	r3, [sp, #4]
 6095              	.LVL434:
  42:MotorControl/task_timer.hpp **** #endif
 6096              		.loc 12 42 21 view .LVU1448
 6097 00f8 C9F80830 		str	r3, [r9, #8]
 6098              	.LVL435:
 6099              	.L204:
  46:MotorControl/task_timer.hpp **** #endif
 6100              		.loc 12 46 9 is_stmt 1 view .LVU1449
  46:MotorControl/task_timer.hpp **** #endif
ARM GAS  /tmp/ccoErako.s 			page 262


 6101              		.loc 12 46 32 is_stmt 0 view .LVU1450
 6102 00fc 09F10C03 		add	r3, r9, #12
 6103              	.LVL436:
 6104              	.LBB1941:
 6105              	.LBI1941:
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 6106              		.loc 13 254 5 is_stmt 1 view .LVU1451
 6107              	.LBB1942:
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 6108              		.loc 13 259 15 is_stmt 0 view .LVU1452
 6109 0100 D9F80C10 		ldr	r1, [r9, #12]
 6110 0104 019A     		ldr	r2, [sp, #4]
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 6111              		.loc 13 259 7 view .LVU1453
 6112 0106 9142     		cmp	r1, r2
 6113 0108 71D3     		bcc	.L216
 6114              	.LVL437:
 6115              	.L205:
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 6116              		.loc 13 259 7 view .LVU1454
 6117              	.LBE1942:
 6118              	.LBE1941:
  46:MotorControl/task_timer.hpp **** #endif
 6119              		.loc 12 46 31 view .LVU1455
 6120 010a 1B68     		ldr	r3, [r3]
  46:MotorControl/task_timer.hpp **** #endif
 6121              		.loc 12 46 21 view .LVU1456
 6122 010c C9F80C30 		str	r3, [r9, #12]
 6123              	.LVL438:
  46:MotorControl/task_timer.hpp **** #endif
 6124              		.loc 12 46 21 view .LVU1457
 6125              	.LBE1938:
 6126              	.LBE1937:
 6127              	.LBE1936:
 6128              	.LBE1935:
 6129              	.LBE1958:
 6130              	.LBE1960:
 408:communication/can/can_simple.cpp ****         std::array<periodic, 10> periodics = {{
 6131              		.loc 3 408 5 is_stmt 1 view .LVU1458
 6132 0110 06F52C76 		add	r6, r6, #688
 6133              	.LVL439:
 6134              	.L189:
 408:communication/can/can_simple.cpp ****         std::array<periodic, 10> periodics = {{
 6135              		.loc 3 408 23 discriminator 3 view .LVU1459
 6136 0114 3F4B     		ldr	r3, .L217+12
 6137 0116 9E42     		cmp	r6, r3
 6138 0118 71D0     		beq	.L193
 6139              	.LVL440:
 6140              	.LBB1961:
 409:communication/can/can_simple.cpp ****             {axis.config_.can.heartbeat_rate_ms, axis.can_.last_heartbeat, &CANSimple::send_heartbe
 6141              		.loc 3 409 9 discriminator 2 view .LVU1460
 410:communication/can/can_simple.cpp ****             {axis.config_.can.encoder_rate_ms, axis.can_.last_encoder, &CANSimple::get_encoder_esti
 6142              		.loc 3 410 31 is_stmt 0 discriminator 2 view .LVU1461
 6143 011a 06F18003 		add	r3, r6, #128
 420:communication/can/can_simple.cpp **** 
 6144              		.loc 3 420 10 discriminator 2 view .LVU1462
 6145 011e 0593     		str	r3, [sp, #20]
ARM GAS  /tmp/ccoErako.s 			page 263


 410:communication/can/can_simple.cpp ****             {axis.config_.can.encoder_rate_ms, axis.can_.last_encoder, &CANSimple::get_encoder_esti
 6146              		.loc 3 410 60 discriminator 2 view .LVU1463
 6147 0120 06F52073 		add	r3, r6, #640
 420:communication/can/can_simple.cpp **** 
 6148              		.loc 3 420 10 discriminator 2 view .LVU1464
 6149 0124 0693     		str	r3, [sp, #24]
 6150 0126 3C4B     		ldr	r3, .L217+16
 6151 0128 0793     		str	r3, [sp, #28]
 6152 012a 0023     		movs	r3, #0
 6153 012c 0893     		str	r3, [sp, #32]
 411:communication/can/can_simple.cpp ****             {axis.config_.can.motor_error_rate_ms, axis.can_.last_motor_error, &CANSimple::get_moto
 6154              		.loc 3 411 31 discriminator 2 view .LVU1465
 6155 012e 06F18402 		add	r2, r6, #132
 420:communication/can/can_simple.cpp **** 
 6156              		.loc 3 420 10 discriminator 2 view .LVU1466
 6157 0132 0992     		str	r2, [sp, #36]
 411:communication/can/can_simple.cpp ****             {axis.config_.can.motor_error_rate_ms, axis.can_.last_motor_error, &CANSimple::get_moto
 6158              		.loc 3 411 58 discriminator 2 view .LVU1467
 6159 0134 06F52172 		add	r2, r6, #644
 420:communication/can/can_simple.cpp **** 
 6160              		.loc 3 420 10 discriminator 2 view .LVU1468
 6161 0138 0A92     		str	r2, [sp, #40]
 6162 013a 384A     		ldr	r2, .L217+20
 6163 013c 0B92     		str	r2, [sp, #44]
 6164 013e 0C93     		str	r3, [sp, #48]
 412:communication/can/can_simple.cpp ****             {axis.config_.can.encoder_error_rate_ms, axis.can_.last_encoder_error, &CANSimple::get_
 6165              		.loc 3 412 31 discriminator 2 view .LVU1469
 6166 0140 06F18802 		add	r2, r6, #136
 420:communication/can/can_simple.cpp **** 
 6167              		.loc 3 420 10 discriminator 2 view .LVU1470
 6168 0144 0D92     		str	r2, [sp, #52]
 412:communication/can/can_simple.cpp ****             {axis.config_.can.encoder_error_rate_ms, axis.can_.last_encoder_error, &CANSimple::get_
 6169              		.loc 3 412 62 discriminator 2 view .LVU1471
 6170 0146 06F52272 		add	r2, r6, #648
 420:communication/can/can_simple.cpp **** 
 6171              		.loc 3 420 10 discriminator 2 view .LVU1472
 6172 014a 0E92     		str	r2, [sp, #56]
 6173 014c 344A     		ldr	r2, .L217+24
 6174 014e 0F92     		str	r2, [sp, #60]
 6175 0150 1093     		str	r3, [sp, #64]
 413:communication/can/can_simple.cpp ****             {axis.config_.can.controller_error_rate_ms, axis.can_.last_controller_error, &CANSimple
 6176              		.loc 3 413 31 discriminator 2 view .LVU1473
 6177 0152 06F18C02 		add	r2, r6, #140
 420:communication/can/can_simple.cpp **** 
 6178              		.loc 3 420 10 discriminator 2 view .LVU1474
 6179 0156 1192     		str	r2, [sp, #68]
 413:communication/can/can_simple.cpp ****             {axis.config_.can.controller_error_rate_ms, axis.can_.last_controller_error, &CANSimple
 6180              		.loc 3 413 64 discriminator 2 view .LVU1475
 6181 0158 06F52372 		add	r2, r6, #652
 420:communication/can/can_simple.cpp **** 
 6182              		.loc 3 420 10 discriminator 2 view .LVU1476
 6183 015c 1292     		str	r2, [sp, #72]
 6184 015e 314A     		ldr	r2, .L217+28
 6185 0160 1392     		str	r2, [sp, #76]
 6186 0162 1493     		str	r3, [sp, #80]
 414:communication/can/can_simple.cpp ****             {axis.config_.can.sensorless_error_rate_ms, axis.can_.last_sensorless_error, &CANSimple
 6187              		.loc 3 414 31 discriminator 2 view .LVU1477
ARM GAS  /tmp/ccoErako.s 			page 264


 6188 0164 06F19002 		add	r2, r6, #144
 420:communication/can/can_simple.cpp **** 
 6189              		.loc 3 420 10 discriminator 2 view .LVU1478
 6190 0168 1592     		str	r2, [sp, #84]
 414:communication/can/can_simple.cpp ****             {axis.config_.can.sensorless_error_rate_ms, axis.can_.last_sensorless_error, &CANSimple
 6191              		.loc 3 414 67 discriminator 2 view .LVU1479
 6192 016a 06F52472 		add	r2, r6, #656
 420:communication/can/can_simple.cpp **** 
 6193              		.loc 3 420 10 discriminator 2 view .LVU1480
 6194 016e 1692     		str	r2, [sp, #88]
 6195 0170 2D4A     		ldr	r2, .L217+32
 6196 0172 1792     		str	r2, [sp, #92]
 6197 0174 1893     		str	r3, [sp, #96]
 415:communication/can/can_simple.cpp ****             {axis.config_.can.encoder_count_rate_ms, axis.can_.last_encoder_count, &CANSimple::get_
 6198              		.loc 3 415 31 discriminator 2 view .LVU1481
 6199 0176 06F19402 		add	r2, r6, #148
 420:communication/can/can_simple.cpp **** 
 6200              		.loc 3 420 10 discriminator 2 view .LVU1482
 6201 017a 1992     		str	r2, [sp, #100]
 415:communication/can/can_simple.cpp ****             {axis.config_.can.encoder_count_rate_ms, axis.can_.last_encoder_count, &CANSimple::get_
 6202              		.loc 3 415 67 discriminator 2 view .LVU1483
 6203 017c 06F52572 		add	r2, r6, #660
 420:communication/can/can_simple.cpp **** 
 6204              		.loc 3 420 10 discriminator 2 view .LVU1484
 6205 0180 1A92     		str	r2, [sp, #104]
 6206 0182 2A4A     		ldr	r2, .L217+36
 6207 0184 1B92     		str	r2, [sp, #108]
 6208 0186 1C93     		str	r3, [sp, #112]
 416:communication/can/can_simple.cpp ****             {axis.config_.can.iq_rate_ms, axis.can_.last_iq, &CANSimple::get_iq_callback},
 6209              		.loc 3 416 31 discriminator 2 view .LVU1485
 6210 0188 06F19802 		add	r2, r6, #152
 420:communication/can/can_simple.cpp **** 
 6211              		.loc 3 420 10 discriminator 2 view .LVU1486
 6212 018c 1D92     		str	r2, [sp, #116]
 416:communication/can/can_simple.cpp ****             {axis.config_.can.iq_rate_ms, axis.can_.last_iq, &CANSimple::get_iq_callback},
 6213              		.loc 3 416 64 discriminator 2 view .LVU1487
 6214 018e 06F52672 		add	r2, r6, #664
 420:communication/can/can_simple.cpp **** 
 6215              		.loc 3 420 10 discriminator 2 view .LVU1488
 6216 0192 1E92     		str	r2, [sp, #120]
 6217 0194 264A     		ldr	r2, .L217+40
 6218 0196 1F92     		str	r2, [sp, #124]
 6219 0198 2093     		str	r3, [sp, #128]
 417:communication/can/can_simple.cpp ****             {axis.config_.can.sensorless_rate_ms, axis.can_.last_sensorless, &CANSimple::get_sensor
 6220              		.loc 3 417 31 discriminator 2 view .LVU1489
 6221 019a 06F19C02 		add	r2, r6, #156
 420:communication/can/can_simple.cpp **** 
 6222              		.loc 3 420 10 discriminator 2 view .LVU1490
 6223 019e 2192     		str	r2, [sp, #132]
 417:communication/can/can_simple.cpp ****             {axis.config_.can.sensorless_rate_ms, axis.can_.last_sensorless, &CANSimple::get_sensor
 6224              		.loc 3 417 53 discriminator 2 view .LVU1491
 6225 01a0 06F52772 		add	r2, r6, #668
 420:communication/can/can_simple.cpp **** 
 6226              		.loc 3 420 10 discriminator 2 view .LVU1492
 6227 01a4 2292     		str	r2, [sp, #136]
 6228 01a6 234A     		ldr	r2, .L217+44
 6229 01a8 2392     		str	r2, [sp, #140]
ARM GAS  /tmp/ccoErako.s 			page 265


 6230 01aa 2493     		str	r3, [sp, #144]
 418:communication/can/can_simple.cpp ****             {axis.config_.can.bus_vi_rate_ms, axis.can_.last_bus_vi, &CANSimple::get_bus_voltage_cu
 6231              		.loc 3 418 31 discriminator 2 view .LVU1493
 6232 01ac 06F1A002 		add	r2, r6, #160
 420:communication/can/can_simple.cpp **** 
 6233              		.loc 3 420 10 discriminator 2 view .LVU1494
 6234 01b0 2592     		str	r2, [sp, #148]
 418:communication/can/can_simple.cpp ****             {axis.config_.can.bus_vi_rate_ms, axis.can_.last_bus_vi, &CANSimple::get_bus_voltage_cu
 6235              		.loc 3 418 61 discriminator 2 view .LVU1495
 6236 01b2 06F52872 		add	r2, r6, #672
 420:communication/can/can_simple.cpp **** 
 6237              		.loc 3 420 10 discriminator 2 view .LVU1496
 6238 01b6 2692     		str	r2, [sp, #152]
 6239 01b8 1F4A     		ldr	r2, .L217+48
 6240 01ba 2792     		str	r2, [sp, #156]
 6241 01bc 2893     		str	r3, [sp, #160]
 419:communication/can/can_simple.cpp ****         }};
 6242              		.loc 3 419 31 discriminator 2 view .LVU1497
 6243 01be 06F1A402 		add	r2, r6, #164
 420:communication/can/can_simple.cpp **** 
 6244              		.loc 3 420 10 discriminator 2 view .LVU1498
 6245 01c2 2992     		str	r2, [sp, #164]
 419:communication/can/can_simple.cpp ****         }};
 6246              		.loc 3 419 57 discriminator 2 view .LVU1499
 6247 01c4 06F52972 		add	r2, r6, #676
 420:communication/can/can_simple.cpp **** 
 6248              		.loc 3 420 10 discriminator 2 view .LVU1500
 6249 01c8 2A92     		str	r2, [sp, #168]
 6250 01ca 1C4A     		ldr	r2, .L217+52
 6251 01cc 2B92     		str	r2, [sp, #172]
 6252 01ce 2C93     		str	r3, [sp, #176]
 422:communication/can/can_simple.cpp ****             for (auto& msg : periodics) {
 6253              		.loc 3 422 9 is_stmt 1 discriminator 2 view .LVU1501
 6254              	.LBB1959:
 6255 01d0 06F5D679 		add	r9, r6, #428
 6256              	.LVL441:
 6257              	.LBB1948:
 6258              	.LBI1948:
  56:MotorControl/task_timer.hpp ****     ~TaskTimerContext() { timer_.stop(start_time); }
 6259              		.loc 12 56 5 discriminator 2 view .LVU1502
 6260              	.LBB1949:
 6261              	.LBB1950:
  56:MotorControl/task_timer.hpp ****     ~TaskTimerContext() { timer_.stop(start_time); }
 6262              		.loc 12 56 81 is_stmt 0 discriminator 2 view .LVU1503
 6263 01d4 CDF80890 		str	r9, [sp, #8]
 6264              	.LVL442:
 6265              	.LBB1951:
 6266              	.LBI1951:
  26:MotorControl/task_timer.hpp ****         return sample_TIM13();
 6267              		.loc 12 26 14 is_stmt 1 discriminator 2 view .LVU1504
 6268              	.LBB1952:
  27:MotorControl/task_timer.hpp ****     }
 6269              		.loc 12 27 9 discriminator 2 view .LVU1505
 6270              	.LBB1953:
 6271              	.LBI1953:
  12:MotorControl/task_timer.hpp ****     //!
 6272              		.loc 12 12 17 discriminator 2 view .LVU1506
ARM GAS  /tmp/ccoErako.s 			page 266


 6273              	.LBB1954:
  14:MotorControl/task_timer.hpp ****     return clocks_per_cnt * TIM13->CNT;  // TODO: Use a hw_config  
 6274              		.loc 12 14 5 discriminator 2 view .LVU1507
  15:MotorControl/task_timer.hpp **** }
 6275              		.loc 12 15 5 discriminator 2 view .LVU1508
  15:MotorControl/task_timer.hpp **** }
 6276              		.loc 12 15 36 is_stmt 0 discriminator 2 view .LVU1509
 6277 01d8 0C4A     		ldr	r2, .L217+4
 6278 01da 526A     		ldr	r2, [r2, #36]
 6279 01dc 4FEA4208 		lsl	r8, r2, #1
 6280 01e0 1FFA88F8 		uxth	r8, r8
 6281              	.LVL443:
  15:MotorControl/task_timer.hpp **** }
 6282              		.loc 12 15 36 discriminator 2 view .LVU1510
 6283              	.LBE1954:
 6284              	.LBE1953:
 6285              	.LBE1952:
 6286              	.LBE1951:
  56:MotorControl/task_timer.hpp ****     ~TaskTimerContext() { timer_.stop(start_time); }
 6287              		.loc 12 56 81 discriminator 2 view .LVU1511
 6288 01e4 CDF80C80 		str	r8, [sp, #12]
 6289 01e8 8DF81030 		strb	r3, [sp, #16]
 6290              	.LBE1950:
  56:MotorControl/task_timer.hpp ****     ~TaskTimerContext() { timer_.stop(start_time); }
 6291              		.loc 12 56 84 discriminator 2 view .LVU1512
 6292 01ec 70E7     		b	.L203
 6293              	.LVL444:
 6294              	.L216:
  56:MotorControl/task_timer.hpp ****     ~TaskTimerContext() { timer_.stop(start_time); }
 6295              		.loc 12 56 84 discriminator 2 view .LVU1513
 6296              	.LBE1949:
 6297              	.LBE1948:
 6298              	.LBB1955:
 6299              	.LBB1947:
 6300              	.LBB1946:
 6301              	.LBB1945:
 6302              	.LBB1944:
 6303              	.LBB1943:
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 6304              		.loc 13 260 9 view .LVU1514
 6305 01ee 01AB     		add	r3, sp, #4
 6306              	.LVL445:
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 6307              		.loc 13 260 9 view .LVU1515
 6308 01f0 8BE7     		b	.L205
 6309              	.LVL446:
 6310              	.L211:
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 6311              		.loc 13 260 9 view .LVU1516
 6312              	.LBE1943:
 6313              	.LBE1944:
 6314              	.LBE1945:
 6315              	.LBE1946:
 6316              	.LBE1947:
 6317              	.LBE1955:
 6318              	.LBB1956:
 6319              	.LBI1956:
ARM GAS  /tmp/ccoErako.s 			page 267


 6320              		.loc 12 57 5 is_stmt 1 view .LVU1517
 6321              	.LBB1957:
 6322              		.loc 12 57 27 view .LVU1518
 6323              		.loc 12 57 38 is_stmt 0 view .LVU1519
 6324 01f2 4146     		mov	r1, r8
 6325 01f4 4846     		mov	r0, r9
 6326 01f6 FFF7FEFF 		bl	_ZN9TaskTimer4stopEm
 6327              	.LVL447:
 6328              	.LEHB3:
 6329              		.loc 12 57 38 view .LVU1520
 6330 01fa FFF7FEFF 		bl	__cxa_end_cleanup
 6331              	.LVL448:
 6332              	.LEHE3:
 6333              	.L193:
 6334              		.loc 12 57 38 view .LVU1521
 6335              	.LBE1957:
 6336              	.LBE1956:
 6337              	.LBE1959:
 6338              	.LBE1961:
 6339              	.LBE1962:
 438:communication/can/can_simple.cpp **** }
 6340              		.loc 3 438 5 is_stmt 1 view .LVU1522
 438:communication/can/can_simple.cpp **** }
 6341              		.loc 3 438 12 is_stmt 0 view .LVU1523
 6342 01fe 2D98     		ldr	r0, [sp, #180]
 439:communication/can/can_simple.cpp **** 
 6343              		.loc 3 439 1 view .LVU1524
 6344 0200 31B0     		add	sp, sp, #196
 6345              	.LCFI101:
 6346              		.cfi_def_cfa_offset 28
 6347              		@ sp needed
 6348 0202 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 6349              	.LVL449:
 6350              	.L218:
 439:communication/can/can_simple.cpp **** 
 6351              		.loc 3 439 1 view .LVU1525
 6352 0206 00BF     		.align	2
 6353              	.L217:
 6354 0208 00000000 		.word	axes
 6355 020c 001C0040 		.word	1073748992
 6356 0210 00000000 		.word	_ZN9TaskTimer7enabledE
 6357 0214 60050000 		.word	axes+1376
 6358 0218 00000000 		.word	_ZN9CANSimple14send_heartbeatERK4Axis
 6359 021c 00000000 		.word	_ZN9CANSimple30get_encoder_estimates_callbackERK4Axis
 6360 0220 00000000 		.word	_ZN9CANSimple24get_motor_error_callbackERK4Axis
 6361 0224 00000000 		.word	_ZN9CANSimple26get_encoder_error_callbackERK4Axis
 6362 0228 00000000 		.word	_ZN9CANSimple29get_controller_error_callbackERK4Axis
 6363 022c 00000000 		.word	_ZN9CANSimple29get_sensorless_error_callbackERK4Axis
 6364 0230 00000000 		.word	_ZN9CANSimple26get_encoder_count_callbackERK4Axis
 6365 0234 00000000 		.word	_ZN9CANSimple15get_iq_callbackERK4Axis
 6366 0238 00000000 		.word	_ZN9CANSimple33get_sensorless_estimates_callbackERK4Axis
 6367 023c 00000000 		.word	_ZN9CANSimple32get_bus_voltage_current_callbackERK4Axis
 6368              		.cfi_endproc
 6369              	.LFE5245:
 6370              		.personality	__gxx_personality_v0
 6371              		.handlerdata
 6372              	.LLSDA5245:
ARM GAS  /tmp/ccoErako.s 			page 268


 6373 0008 FF       		.byte	0xff
 6374 0009 FF       		.byte	0xff
 6375 000a 01       		.byte	0x1
 6376 000b 0E       		.uleb128 .LLSDACSE5245-.LLSDACSB5245
 6377              	.LLSDACSB5245:
 6378 000c 0E       		.uleb128 .LEHB1-.LFB5245
 6379 000d 12       		.uleb128 .LEHE1-.LEHB1
 6380 000e 00       		.uleb128 0
 6381 000f 00       		.uleb128 0
 6382 0010 6A       		.uleb128 .LEHB2-.LFB5245
 6383 0011 02       		.uleb128 .LEHE2-.LEHB2
 6384 0012 F203     		.uleb128 .L211-.LFB5245
 6385 0014 00       		.uleb128 0
 6386 0015 FA03     		.uleb128 .LEHB3-.LFB5245
 6387 0017 04       		.uleb128 .LEHE3-.LEHB3
 6388 0018 00       		.uleb128 0
 6389 0019 00       		.uleb128 0
 6390              	.LLSDACSE5245:
 6391              		.section	.text._ZN9CANSimple13service_stackEv
 6392              		.fnend
 6394              		.section	.text._ZN9CANSimple21clear_errors_callbackER4AxisRK13can_Message_t,"ax",%progbits
 6395              		.align	1
 6396              		.global	_ZN9CANSimple21clear_errors_callbackER4AxisRK13can_Message_t
 6397              		.syntax unified
 6398              		.thumb
 6399              		.thumb_func
 6401              	_ZN9CANSimple21clear_errors_callbackER4AxisRK13can_Message_t:
 6402              		.fnstart
 6403              	.LVL450:
 6404              	.LFB5244:
 386:communication/can/can_simple.cpp ****     odrv.clear_errors();  // TODO: might want to clear axis errors only
 6405              		.loc 3 386 77 is_stmt 1 view -0
 6406              		.cfi_startproc
 6407              		@ args = 0, pretend = 0, frame = 0
 6408              		@ frame_needed = 0, uses_anonymous_args = 0
 386:communication/can/can_simple.cpp ****     odrv.clear_errors();  // TODO: might want to clear axis errors only
 6409              		.loc 3 386 77 is_stmt 0 view .LVU1527
 6410 0000 08B5     		push	{r3, lr}
 6411              		.save {r3, lr}
 6412              	.LCFI102:
 6413              		.cfi_def_cfa_offset 8
 6414              		.cfi_offset 3, -8
 6415              		.cfi_offset 14, -4
 387:communication/can/can_simple.cpp **** }
 6416              		.loc 3 387 5 is_stmt 1 view .LVU1528
 387:communication/can/can_simple.cpp **** }
 6417              		.loc 3 387 22 is_stmt 0 view .LVU1529
 6418 0002 0248     		ldr	r0, .L221
 6419              	.LVL451:
 387:communication/can/can_simple.cpp **** }
 6420              		.loc 3 387 22 view .LVU1530
 6421 0004 FFF7FEFF 		bl	_ZN6ODrive12clear_errorsEv
 6422              	.LVL452:
 388:communication/can/can_simple.cpp **** 
 6423              		.loc 3 388 1 view .LVU1531
 6424 0008 08BD     		pop	{r3, pc}
 6425              	.L222:
ARM GAS  /tmp/ccoErako.s 			page 269


 6426 000a 00BF     		.align	2
 6427              	.L221:
 6428 000c 00000000 		.word	odrv
 6429              		.cfi_endproc
 6430              	.LFE5244:
 6431              		.fnend
 6433              		.section	.text._ZN9CANSimple10do_commandER4AxisRK13can_Message_t,"ax",%progbits
 6434              		.align	1
 6435              		.global	_ZN9CANSimple10do_commandER4AxisRK13can_Message_t
 6436              		.syntax unified
 6437              		.thumb
 6438              		.thumb_func
 6440              	_ZN9CANSimple10do_commandER4AxisRK13can_Message_t:
 6441              		.fnstart
 6442              	.LVL453:
 6443              	.LFB5200:
  58:communication/can/can_simple.cpp ****     const uint32_t cmd = get_cmd_id(msg.id);
 6444              		.loc 3 58 66 is_stmt 1 view -0
 6445              		.cfi_startproc
 6446              		@ args = 0, pretend = 0, frame = 0
 6447              		@ frame_needed = 0, uses_anonymous_args = 0
  58:communication/can/can_simple.cpp ****     const uint32_t cmd = get_cmd_id(msg.id);
 6448              		.loc 3 58 66 is_stmt 0 view .LVU1533
 6449 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 6450              		.save {r3, r4, r5, r6, r7, lr}
 6451              	.LCFI103:
 6452              		.cfi_def_cfa_offset 24
 6453              		.cfi_offset 3, -24
 6454              		.cfi_offset 4, -20
 6455              		.cfi_offset 5, -16
 6456              		.cfi_offset 6, -12
 6457              		.cfi_offset 7, -8
 6458              		.cfi_offset 14, -4
 6459 0002 0746     		mov	r7, r0
 6460 0004 0D46     		mov	r5, r1
 6461 0006 1646     		mov	r6, r2
  59:communication/can/can_simple.cpp ****     axis.watchdog_feed();
 6462              		.loc 3 59 5 is_stmt 1 view .LVU1534
 6463              	.LVL454:
 6464              	.LBB1971:
 6465              	.LBI1971:
 6466              		.file 20 "communication/can/can_simple.hpp"
   1:communication/can/can_simple.hpp **** #ifndef __CAN_SIMPLE_HPP_
   2:communication/can/can_simple.hpp **** #define __CAN_SIMPLE_HPP_
   3:communication/can/can_simple.hpp **** 
   4:communication/can/can_simple.hpp **** #include "canbus.hpp"
   5:communication/can/can_simple.hpp **** #include "axis.hpp"
   6:communication/can/can_simple.hpp **** 
   7:communication/can/can_simple.hpp **** class CANSimple {
   8:communication/can/can_simple.hpp ****    public:
   9:communication/can/can_simple.hpp ****     enum {
  10:communication/can/can_simple.hpp ****         MSG_CO_NMT_CTRL = 0x000,  // CANOpen NMT Message REC
  11:communication/can/can_simple.hpp ****         MSG_ODRIVE_HEARTBEAT,
  12:communication/can/can_simple.hpp ****         MSG_ODRIVE_ESTOP,
  13:communication/can/can_simple.hpp ****         MSG_GET_MOTOR_ERROR,  // Errors
  14:communication/can/can_simple.hpp ****         MSG_GET_ENCODER_ERROR,
  15:communication/can/can_simple.hpp ****         MSG_GET_SENSORLESS_ERROR,
ARM GAS  /tmp/ccoErako.s 			page 270


  16:communication/can/can_simple.hpp ****         MSG_SET_AXIS_NODE_ID,
  17:communication/can/can_simple.hpp ****         MSG_SET_AXIS_REQUESTED_STATE,
  18:communication/can/can_simple.hpp ****         MSG_SET_AXIS_STARTUP_CONFIG,
  19:communication/can/can_simple.hpp ****         MSG_GET_ENCODER_ESTIMATES,
  20:communication/can/can_simple.hpp ****         MSG_GET_ENCODER_COUNT,
  21:communication/can/can_simple.hpp ****         MSG_SET_CONTROLLER_MODES,
  22:communication/can/can_simple.hpp ****         MSG_SET_INPUT_POS,
  23:communication/can/can_simple.hpp ****         MSG_SET_INPUT_VEL,
  24:communication/can/can_simple.hpp ****         MSG_SET_INPUT_TORQUE,
  25:communication/can/can_simple.hpp ****         MSG_SET_LIMITS,
  26:communication/can/can_simple.hpp ****         MSG_START_ANTICOGGING,
  27:communication/can/can_simple.hpp ****         MSG_SET_TRAJ_VEL_LIMIT,
  28:communication/can/can_simple.hpp ****         MSG_SET_TRAJ_ACCEL_LIMITS,
  29:communication/can/can_simple.hpp ****         MSG_SET_TRAJ_INERTIA,
  30:communication/can/can_simple.hpp ****         MSG_GET_IQ,
  31:communication/can/can_simple.hpp ****         MSG_GET_SENSORLESS_ESTIMATES,
  32:communication/can/can_simple.hpp ****         MSG_RESET_ODRIVE,
  33:communication/can/can_simple.hpp ****         MSG_GET_BUS_VOLTAGE_CURRENT,
  34:communication/can/can_simple.hpp ****         MSG_CLEAR_ERRORS,
  35:communication/can/can_simple.hpp ****         MSG_SET_LINEAR_COUNT,
  36:communication/can/can_simple.hpp ****         MSG_SET_POS_GAIN,
  37:communication/can/can_simple.hpp ****         MSG_SET_VEL_GAINS,
  38:communication/can/can_simple.hpp ****         MSG_GET_ADC_VOLTAGE,
  39:communication/can/can_simple.hpp ****         MSG_GET_CONTROLLER_ERROR,
  40:communication/can/can_simple.hpp ****         MSG_CO_HEARTBEAT_CMD = 0x700,  // CANOpen NMT Heartbeat  SEND
  41:communication/can/can_simple.hpp ****     };
  42:communication/can/can_simple.hpp **** 
  43:communication/can/can_simple.hpp ****     CANSimple(CanBusBase* canbus) : canbus_(canbus) {}
  44:communication/can/can_simple.hpp **** 
  45:communication/can/can_simple.hpp ****     bool init();
  46:communication/can/can_simple.hpp ****     uint32_t service_stack();
  47:communication/can/can_simple.hpp **** 
  48:communication/can/can_simple.hpp ****    private:
  49:communication/can/can_simple.hpp **** 
  50:communication/can/can_simple.hpp ****     bool renew_subscription(size_t i);
  51:communication/can/can_simple.hpp ****     bool send_heartbeat(const Axis& axis);
  52:communication/can/can_simple.hpp **** 
  53:communication/can/can_simple.hpp ****     void handle_can_message(const can_Message_t& msg);
  54:communication/can/can_simple.hpp **** 
  55:communication/can/can_simple.hpp ****     void do_command(Axis& axis, const can_Message_t& cmd);
  56:communication/can/can_simple.hpp ****     
  57:communication/can/can_simple.hpp ****     // Get functions (msg.rtr bit must be set)
  58:communication/can/can_simple.hpp ****     bool get_motor_error_callback(const Axis& axis);
  59:communication/can/can_simple.hpp ****     bool get_encoder_error_callback(const Axis& axis);
  60:communication/can/can_simple.hpp ****     bool get_controller_error_callback(const Axis& axis);
  61:communication/can/can_simple.hpp ****     bool get_sensorless_error_callback(const Axis& axis);
  62:communication/can/can_simple.hpp ****     bool get_encoder_estimates_callback(const Axis& axis);
  63:communication/can/can_simple.hpp ****     bool get_encoder_count_callback(const Axis& axis);
  64:communication/can/can_simple.hpp ****     bool get_iq_callback(const Axis& axis);
  65:communication/can/can_simple.hpp ****     bool get_sensorless_estimates_callback(const Axis& axis);
  66:communication/can/can_simple.hpp ****     bool get_bus_voltage_current_callback(const Axis& axis);
  67:communication/can/can_simple.hpp ****     // msg.rtr bit must NOT be set
  68:communication/can/can_simple.hpp ****     bool get_adc_voltage_callback(const Axis& axis, const can_Message_t& msg);
  69:communication/can/can_simple.hpp **** 
  70:communication/can/can_simple.hpp ****     // Set functions
  71:communication/can/can_simple.hpp ****     static void set_axis_nodeid_callback(Axis& axis, const can_Message_t& msg);
  72:communication/can/can_simple.hpp ****     static void set_axis_requested_state_callback(Axis& axis, const can_Message_t& msg);
ARM GAS  /tmp/ccoErako.s 			page 271


  73:communication/can/can_simple.hpp ****     static void set_axis_startup_config_callback(Axis& axis, const can_Message_t& msg);
  74:communication/can/can_simple.hpp ****     static void set_input_pos_callback(Axis& axis, const can_Message_t& msg);
  75:communication/can/can_simple.hpp ****     static void set_input_vel_callback(Axis& axis, const can_Message_t& msg);
  76:communication/can/can_simple.hpp ****     static void set_input_torque_callback(Axis& axis, const can_Message_t& msg);
  77:communication/can/can_simple.hpp ****     static void set_controller_modes_callback(Axis& axis, const can_Message_t& msg);
  78:communication/can/can_simple.hpp ****     static void set_limits_callback(Axis& axis, const can_Message_t& msg);
  79:communication/can/can_simple.hpp ****     static void set_traj_vel_limit_callback(Axis& axis, const can_Message_t& msg);
  80:communication/can/can_simple.hpp ****     static void set_traj_accel_limits_callback(Axis& axis, const can_Message_t& msg);
  81:communication/can/can_simple.hpp ****     static void set_traj_inertia_callback(Axis& axis, const can_Message_t& msg);
  82:communication/can/can_simple.hpp ****     static void set_linear_count_callback(Axis& axis, const can_Message_t& msg);
  83:communication/can/can_simple.hpp ****     static void set_pos_gain_callback(Axis& axis, const can_Message_t& msg);
  84:communication/can/can_simple.hpp ****     static void set_vel_gains_callback(Axis& axis, const can_Message_t& msg);
  85:communication/can/can_simple.hpp **** 
  86:communication/can/can_simple.hpp ****     // Other functions
  87:communication/can/can_simple.hpp ****     static void nmt_callback(const Axis& axis, const can_Message_t& msg);
  88:communication/can/can_simple.hpp ****     static void estop_callback(Axis& axis, const can_Message_t& msg);
  89:communication/can/can_simple.hpp ****     static void clear_errors_callback(Axis& axis, const can_Message_t& msg);
  90:communication/can/can_simple.hpp ****     static void start_anticogging_callback(const Axis& axis, const can_Message_t& msg);
  91:communication/can/can_simple.hpp **** 
  92:communication/can/can_simple.hpp ****     static constexpr uint8_t NUM_NODE_ID_BITS = 6;
  93:communication/can/can_simple.hpp ****     static constexpr uint8_t NUM_CMD_ID_BITS = 11 - NUM_NODE_ID_BITS;
  94:communication/can/can_simple.hpp **** 
  95:communication/can/can_simple.hpp ****     // Utility functions
  96:communication/can/can_simple.hpp ****     static constexpr uint32_t get_node_id(uint32_t msgID) {
  97:communication/can/can_simple.hpp ****         return (msgID >> NUM_CMD_ID_BITS);  // Upper 6 or more bits
  98:communication/can/can_simple.hpp ****     };
  99:communication/can/can_simple.hpp **** 
 100:communication/can/can_simple.hpp ****     static constexpr uint8_t get_cmd_id(uint32_t msgID) {
 6467              		.loc 20 100 30 view .LVU1535
 6468              	.LBB1972:
 101:communication/can/can_simple.hpp ****         return (msgID & 0x01F);  // Bottom 5 bits
 6469              		.loc 20 101 9 view .LVU1536
 6470              		.loc 20 101 23 is_stmt 0 view .LVU1537
 6471 0008 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 6472              		.loc 20 101 30 view .LVU1538
 6473 000a 03F01F04 		and	r4, r3, #31
 6474              	.LVL455:
 6475              		.loc 20 101 30 view .LVU1539
 6476              	.LBE1972:
 6477              	.LBE1971:
  60:communication/can/can_simple.cpp ****     switch (cmd) {
 6478              		.loc 3 60 5 is_stmt 1 view .LVU1540
  60:communication/can/can_simple.cpp ****     switch (cmd) {
 6479              		.loc 3 60 24 is_stmt 0 view .LVU1541
 6480 000e 0B68     		ldr	r3, [r1]
 6481 0010 1B68     		ldr	r3, [r3]
  60:communication/can/can_simple.cpp ****     switch (cmd) {
 6482              		.loc 3 60 23 view .LVU1542
 6483 0012 0846     		mov	r0, r1
 6484              	.LVL456:
  60:communication/can/can_simple.cpp ****     switch (cmd) {
 6485              		.loc 3 60 23 view .LVU1543
 6486 0014 9847     		blx	r3
 6487              	.LVL457:
  61:communication/can/can_simple.cpp ****         case MSG_CO_NMT_CTRL:
 6488              		.loc 3 61 5 is_stmt 1 view .LVU1544
 6489 0016 A31E     		subs	r3, r4, #2
ARM GAS  /tmp/ccoErako.s 			page 272


 6490 0018 1B2B     		cmp	r3, #27
 6491 001a 13D8     		bhi	.L223
 6492 001c DFE803F0 		tbb	[pc, r3]
 6493              	.L226:
 6494 0020 0E       		.byte	(.L252-.L226)/2
 6495 0021 13       		.byte	(.L251-.L226)/2
 6496 0022 1D       		.byte	(.L250-.L226)/2
 6497 0023 27       		.byte	(.L249-.L226)/2
 6498 0024 31       		.byte	(.L248-.L226)/2
 6499 0025 36       		.byte	(.L247-.L226)/2
 6500 0026 12       		.byte	(.L223-.L226)/2
 6501 0027 3B       		.byte	(.L246-.L226)/2
 6502 0028 45       		.byte	(.L245-.L226)/2
 6503 0029 5E       		.byte	(.L244-.L226)/2
 6504 002a 4F       		.byte	(.L243-.L226)/2
 6505 002b 54       		.byte	(.L242-.L226)/2
 6506 002c 59       		.byte	(.L241-.L226)/2
 6507 002d 63       		.byte	(.L240-.L226)/2
 6508 002e 68       		.byte	(.L239-.L226)/2
 6509 002f 77       		.byte	(.L238-.L226)/2
 6510 0030 72       		.byte	(.L237-.L226)/2
 6511 0031 6D       		.byte	(.L236-.L226)/2
 6512 0032 7C       		.byte	(.L235-.L226)/2
 6513 0033 86       		.byte	(.L234-.L226)/2
 6514 0034 90       		.byte	(.L233-.L226)/2
 6515 0035 9D       		.byte	(.L232-.L226)/2
 6516 0036 A8       		.byte	(.L231-.L226)/2
 6517 0037 AD       		.byte	(.L230-.L226)/2
 6518 0038 B2       		.byte	(.L229-.L226)/2
 6519 0039 B7       		.byte	(.L228-.L226)/2
 6520 003a BC       		.byte	(.L227-.L226)/2
 6521 003b C2       		.byte	(.L225-.L226)/2
 6522              		.p2align 1
 6523              	.L252:
  69:communication/can/can_simple.cpp ****             estop_callback(axis, msg);
 6524              		.loc 3 69 9 view .LVU1545
  70:communication/can/can_simple.cpp ****             break;
 6525              		.loc 3 70 13 view .LVU1546
  70:communication/can/can_simple.cpp ****             break;
 6526              		.loc 3 70 27 is_stmt 0 view .LVU1547
 6527 003c 3146     		mov	r1, r6
 6528 003e 2846     		mov	r0, r5
 6529 0040 FFF7FEFF 		bl	_ZN9CANSimple14estop_callbackER4AxisRK13can_Message_t
 6530              	.LVL458:
  71:communication/can/can_simple.cpp ****         case MSG_GET_MOTOR_ERROR:
 6531              		.loc 3 71 13 is_stmt 1 view .LVU1548
 6532              	.L223:
 164:communication/can/can_simple.cpp **** 
 6533              		.loc 3 164 1 is_stmt 0 view .LVU1549
 6534 0044 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 6535              	.LVL459:
 6536              	.L251:
  72:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
 6537              		.loc 3 72 9 is_stmt 1 view .LVU1550
  73:communication/can/can_simple.cpp ****                 get_motor_error_callback(axis);
 6538              		.loc 3 73 13 view .LVU1551
  73:communication/can/can_simple.cpp ****                 get_motor_error_callback(axis);
ARM GAS  /tmp/ccoErako.s 			page 273


 6539              		.loc 3 73 21 is_stmt 0 view .LVU1552
 6540 0046 7379     		ldrb	r3, [r6, #5]	@ zero_extendqisi2
  73:communication/can/can_simple.cpp ****                 get_motor_error_callback(axis);
 6541              		.loc 3 73 13 view .LVU1553
 6542 0048 13B9     		cbnz	r3, .L253
  73:communication/can/can_simple.cpp ****                 get_motor_error_callback(axis);
 6543              		.loc 3 73 32 discriminator 1 view .LVU1554
 6544 004a B379     		ldrb	r3, [r6, #6]	@ zero_extendqisi2
  73:communication/can/can_simple.cpp ****                 get_motor_error_callback(axis);
 6545              		.loc 3 73 25 discriminator 1 view .LVU1555
 6546 004c 002B     		cmp	r3, #0
 6547 004e F9D1     		bne	.L223
 6548              	.L253:
  74:communication/can/can_simple.cpp ****             break;
 6549              		.loc 3 74 17 is_stmt 1 view .LVU1556
  74:communication/can/can_simple.cpp ****             break;
 6550              		.loc 3 74 41 is_stmt 0 view .LVU1557
 6551 0050 2946     		mov	r1, r5
 6552 0052 3846     		mov	r0, r7
 6553 0054 FFF7FEFF 		bl	_ZN9CANSimple24get_motor_error_callbackERK4Axis
 6554              	.LVL460:
 6555 0058 F4E7     		b	.L223
 6556              	.L250:
  76:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
 6557              		.loc 3 76 9 is_stmt 1 view .LVU1558
  77:communication/can/can_simple.cpp ****                 get_encoder_error_callback(axis);
 6558              		.loc 3 77 13 view .LVU1559
  77:communication/can/can_simple.cpp ****                 get_encoder_error_callback(axis);
 6559              		.loc 3 77 21 is_stmt 0 view .LVU1560
 6560 005a 7379     		ldrb	r3, [r6, #5]	@ zero_extendqisi2
  77:communication/can/can_simple.cpp ****                 get_encoder_error_callback(axis);
 6561              		.loc 3 77 13 view .LVU1561
 6562 005c 13B9     		cbnz	r3, .L254
  77:communication/can/can_simple.cpp ****                 get_encoder_error_callback(axis);
 6563              		.loc 3 77 32 discriminator 1 view .LVU1562
 6564 005e B379     		ldrb	r3, [r6, #6]	@ zero_extendqisi2
  77:communication/can/can_simple.cpp ****                 get_encoder_error_callback(axis);
 6565              		.loc 3 77 25 discriminator 1 view .LVU1563
 6566 0060 002B     		cmp	r3, #0
 6567 0062 EFD1     		bne	.L223
 6568              	.L254:
  78:communication/can/can_simple.cpp ****             break;
 6569              		.loc 3 78 17 is_stmt 1 view .LVU1564
  78:communication/can/can_simple.cpp ****             break;
 6570              		.loc 3 78 43 is_stmt 0 view .LVU1565
 6571 0064 2946     		mov	r1, r5
 6572 0066 3846     		mov	r0, r7
 6573 0068 FFF7FEFF 		bl	_ZN9CANSimple26get_encoder_error_callbackERK4Axis
 6574              	.LVL461:
 6575 006c EAE7     		b	.L223
 6576              	.L249:
  80:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
 6577              		.loc 3 80 9 is_stmt 1 view .LVU1566
  81:communication/can/can_simple.cpp ****                 get_sensorless_error_callback(axis);
 6578              		.loc 3 81 13 view .LVU1567
  81:communication/can/can_simple.cpp ****                 get_sensorless_error_callback(axis);
 6579              		.loc 3 81 21 is_stmt 0 view .LVU1568
ARM GAS  /tmp/ccoErako.s 			page 274


 6580 006e 7379     		ldrb	r3, [r6, #5]	@ zero_extendqisi2
  81:communication/can/can_simple.cpp ****                 get_sensorless_error_callback(axis);
 6581              		.loc 3 81 13 view .LVU1569
 6582 0070 13B9     		cbnz	r3, .L255
  81:communication/can/can_simple.cpp ****                 get_sensorless_error_callback(axis);
 6583              		.loc 3 81 32 discriminator 1 view .LVU1570
 6584 0072 B379     		ldrb	r3, [r6, #6]	@ zero_extendqisi2
  81:communication/can/can_simple.cpp ****                 get_sensorless_error_callback(axis);
 6585              		.loc 3 81 25 discriminator 1 view .LVU1571
 6586 0074 002B     		cmp	r3, #0
 6587 0076 E5D1     		bne	.L223
 6588              	.L255:
  82:communication/can/can_simple.cpp ****             break;
 6589              		.loc 3 82 17 is_stmt 1 view .LVU1572
  82:communication/can/can_simple.cpp ****             break;
 6590              		.loc 3 82 46 is_stmt 0 view .LVU1573
 6591 0078 2946     		mov	r1, r5
 6592 007a 3846     		mov	r0, r7
 6593 007c FFF7FEFF 		bl	_ZN9CANSimple29get_sensorless_error_callbackERK4Axis
 6594              	.LVL462:
 6595 0080 E0E7     		b	.L223
 6596              	.L248:
  84:communication/can/can_simple.cpp ****             set_axis_nodeid_callback(axis, msg);
 6597              		.loc 3 84 9 is_stmt 1 view .LVU1574
  85:communication/can/can_simple.cpp ****             break;
 6598              		.loc 3 85 13 view .LVU1575
  85:communication/can/can_simple.cpp ****             break;
 6599              		.loc 3 85 37 is_stmt 0 view .LVU1576
 6600 0082 3146     		mov	r1, r6
 6601 0084 2846     		mov	r0, r5
 6602 0086 FFF7FEFF 		bl	_ZN9CANSimple24set_axis_nodeid_callbackER4AxisRK13can_Message_t
 6603              	.LVL463:
  86:communication/can/can_simple.cpp ****         case MSG_SET_AXIS_REQUESTED_STATE:
 6604              		.loc 3 86 13 is_stmt 1 view .LVU1577
 6605 008a DBE7     		b	.L223
 6606              	.L247:
  87:communication/can/can_simple.cpp ****             set_axis_requested_state_callback(axis, msg);
 6607              		.loc 3 87 9 view .LVU1578
  88:communication/can/can_simple.cpp ****             break;
 6608              		.loc 3 88 13 view .LVU1579
  88:communication/can/can_simple.cpp ****             break;
 6609              		.loc 3 88 46 is_stmt 0 view .LVU1580
 6610 008c 3146     		mov	r1, r6
 6611 008e 2846     		mov	r0, r5
 6612 0090 FFF7FEFF 		bl	_ZN9CANSimple33set_axis_requested_state_callbackER4AxisRK13can_Message_t
 6613              	.LVL464:
  89:communication/can/can_simple.cpp ****         case MSG_SET_AXIS_STARTUP_CONFIG:
 6614              		.loc 3 89 13 is_stmt 1 view .LVU1581
 6615 0094 D6E7     		b	.L223
 6616              	.L246:
  93:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
 6617              		.loc 3 93 9 view .LVU1582
  94:communication/can/can_simple.cpp ****                 get_encoder_estimates_callback(axis);
 6618              		.loc 3 94 13 view .LVU1583
  94:communication/can/can_simple.cpp ****                 get_encoder_estimates_callback(axis);
 6619              		.loc 3 94 21 is_stmt 0 view .LVU1584
 6620 0096 7379     		ldrb	r3, [r6, #5]	@ zero_extendqisi2
ARM GAS  /tmp/ccoErako.s 			page 275


  94:communication/can/can_simple.cpp ****                 get_encoder_estimates_callback(axis);
 6621              		.loc 3 94 13 view .LVU1585
 6622 0098 13B9     		cbnz	r3, .L256
  94:communication/can/can_simple.cpp ****                 get_encoder_estimates_callback(axis);
 6623              		.loc 3 94 32 discriminator 1 view .LVU1586
 6624 009a B379     		ldrb	r3, [r6, #6]	@ zero_extendqisi2
  94:communication/can/can_simple.cpp ****                 get_encoder_estimates_callback(axis);
 6625              		.loc 3 94 25 discriminator 1 view .LVU1587
 6626 009c 002B     		cmp	r3, #0
 6627 009e D1D1     		bne	.L223
 6628              	.L256:
  95:communication/can/can_simple.cpp ****             break;
 6629              		.loc 3 95 17 is_stmt 1 view .LVU1588
  95:communication/can/can_simple.cpp ****             break;
 6630              		.loc 3 95 47 is_stmt 0 view .LVU1589
 6631 00a0 2946     		mov	r1, r5
 6632 00a2 3846     		mov	r0, r7
 6633 00a4 FFF7FEFF 		bl	_ZN9CANSimple30get_encoder_estimates_callbackERK4Axis
 6634              	.LVL465:
 6635 00a8 CCE7     		b	.L223
 6636              	.L245:
  97:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
 6637              		.loc 3 97 9 is_stmt 1 view .LVU1590
  98:communication/can/can_simple.cpp ****                 get_encoder_count_callback(axis);
 6638              		.loc 3 98 13 view .LVU1591
  98:communication/can/can_simple.cpp ****                 get_encoder_count_callback(axis);
 6639              		.loc 3 98 21 is_stmt 0 view .LVU1592
 6640 00aa 7379     		ldrb	r3, [r6, #5]	@ zero_extendqisi2
  98:communication/can/can_simple.cpp ****                 get_encoder_count_callback(axis);
 6641              		.loc 3 98 13 view .LVU1593
 6642 00ac 13B9     		cbnz	r3, .L257
  98:communication/can/can_simple.cpp ****                 get_encoder_count_callback(axis);
 6643              		.loc 3 98 32 discriminator 1 view .LVU1594
 6644 00ae B379     		ldrb	r3, [r6, #6]	@ zero_extendqisi2
  98:communication/can/can_simple.cpp ****                 get_encoder_count_callback(axis);
 6645              		.loc 3 98 25 discriminator 1 view .LVU1595
 6646 00b0 002B     		cmp	r3, #0
 6647 00b2 C7D1     		bne	.L223
 6648              	.L257:
  99:communication/can/can_simple.cpp ****             break;
 6649              		.loc 3 99 17 is_stmt 1 view .LVU1596
  99:communication/can/can_simple.cpp ****             break;
 6650              		.loc 3 99 43 is_stmt 0 view .LVU1597
 6651 00b4 2946     		mov	r1, r5
 6652 00b6 3846     		mov	r0, r7
 6653 00b8 FFF7FEFF 		bl	_ZN9CANSimple26get_encoder_count_callbackERK4Axis
 6654              	.LVL466:
 6655 00bc C2E7     		b	.L223
 6656              	.L243:
 101:communication/can/can_simple.cpp ****             set_input_pos_callback(axis, msg);
 6657              		.loc 3 101 9 is_stmt 1 view .LVU1598
 102:communication/can/can_simple.cpp ****             break;
 6658              		.loc 3 102 13 view .LVU1599
 102:communication/can/can_simple.cpp ****             break;
 6659              		.loc 3 102 35 is_stmt 0 view .LVU1600
 6660 00be 3146     		mov	r1, r6
 6661 00c0 2846     		mov	r0, r5
ARM GAS  /tmp/ccoErako.s 			page 276


 6662 00c2 FFF7FEFF 		bl	_ZN9CANSimple22set_input_pos_callbackER4AxisRK13can_Message_t
 6663              	.LVL467:
 103:communication/can/can_simple.cpp ****         case MSG_SET_INPUT_VEL:
 6664              		.loc 3 103 13 is_stmt 1 view .LVU1601
 6665 00c6 BDE7     		b	.L223
 6666              	.L242:
 104:communication/can/can_simple.cpp ****             set_input_vel_callback(axis, msg);
 6667              		.loc 3 104 9 view .LVU1602
 105:communication/can/can_simple.cpp ****             break;
 6668              		.loc 3 105 13 view .LVU1603
 105:communication/can/can_simple.cpp ****             break;
 6669              		.loc 3 105 35 is_stmt 0 view .LVU1604
 6670 00c8 3146     		mov	r1, r6
 6671 00ca 2846     		mov	r0, r5
 6672 00cc FFF7FEFF 		bl	_ZN9CANSimple22set_input_vel_callbackER4AxisRK13can_Message_t
 6673              	.LVL468:
 106:communication/can/can_simple.cpp ****         case MSG_SET_INPUT_TORQUE:
 6674              		.loc 3 106 13 is_stmt 1 view .LVU1605
 6675 00d0 B8E7     		b	.L223
 6676              	.L241:
 107:communication/can/can_simple.cpp ****             set_input_torque_callback(axis, msg);
 6677              		.loc 3 107 9 view .LVU1606
 108:communication/can/can_simple.cpp ****             break;
 6678              		.loc 3 108 13 view .LVU1607
 108:communication/can/can_simple.cpp ****             break;
 6679              		.loc 3 108 38 is_stmt 0 view .LVU1608
 6680 00d2 3146     		mov	r1, r6
 6681 00d4 2846     		mov	r0, r5
 6682 00d6 FFF7FEFF 		bl	_ZN9CANSimple25set_input_torque_callbackER4AxisRK13can_Message_t
 6683              	.LVL469:
 109:communication/can/can_simple.cpp ****         case MSG_SET_CONTROLLER_MODES:
 6684              		.loc 3 109 13 is_stmt 1 view .LVU1609
 6685 00da B3E7     		b	.L223
 6686              	.L244:
 110:communication/can/can_simple.cpp ****             set_controller_modes_callback(axis, msg);
 6687              		.loc 3 110 9 view .LVU1610
 111:communication/can/can_simple.cpp ****             break;
 6688              		.loc 3 111 13 view .LVU1611
 111:communication/can/can_simple.cpp ****             break;
 6689              		.loc 3 111 42 is_stmt 0 view .LVU1612
 6690 00dc 3146     		mov	r1, r6
 6691 00de 2846     		mov	r0, r5
 6692 00e0 FFF7FEFF 		bl	_ZN9CANSimple29set_controller_modes_callbackER4AxisRK13can_Message_t
 6693              	.LVL470:
 112:communication/can/can_simple.cpp ****         case MSG_SET_LIMITS:
 6694              		.loc 3 112 13 is_stmt 1 view .LVU1613
 6695 00e4 AEE7     		b	.L223
 6696              	.L240:
 113:communication/can/can_simple.cpp ****             set_limits_callback(axis, msg);
 6697              		.loc 3 113 9 view .LVU1614
 114:communication/can/can_simple.cpp ****             break;
 6698              		.loc 3 114 13 view .LVU1615
 114:communication/can/can_simple.cpp ****             break;
 6699              		.loc 3 114 32 is_stmt 0 view .LVU1616
 6700 00e6 3146     		mov	r1, r6
 6701 00e8 2846     		mov	r0, r5
 6702 00ea FFF7FEFF 		bl	_ZN9CANSimple19set_limits_callbackER4AxisRK13can_Message_t
ARM GAS  /tmp/ccoErako.s 			page 277


 6703              	.LVL471:
 115:communication/can/can_simple.cpp ****         case MSG_START_ANTICOGGING:
 6704              		.loc 3 115 13 is_stmt 1 view .LVU1617
 6705 00ee A9E7     		b	.L223
 6706              	.L239:
 116:communication/can/can_simple.cpp ****             start_anticogging_callback(axis, msg);
 6707              		.loc 3 116 9 view .LVU1618
 117:communication/can/can_simple.cpp ****             break;
 6708              		.loc 3 117 13 view .LVU1619
 117:communication/can/can_simple.cpp ****             break;
 6709              		.loc 3 117 39 is_stmt 0 view .LVU1620
 6710 00f0 3146     		mov	r1, r6
 6711 00f2 2846     		mov	r0, r5
 6712 00f4 FFF7FEFF 		bl	_ZN9CANSimple26start_anticogging_callbackERK4AxisRK13can_Message_t
 6713              	.LVL472:
 118:communication/can/can_simple.cpp ****         case MSG_SET_TRAJ_INERTIA:
 6714              		.loc 3 118 13 is_stmt 1 view .LVU1621
 6715 00f8 A4E7     		b	.L223
 6716              	.L236:
 119:communication/can/can_simple.cpp ****             set_traj_inertia_callback(axis, msg);
 6717              		.loc 3 119 9 view .LVU1622
 120:communication/can/can_simple.cpp ****             break;
 6718              		.loc 3 120 13 view .LVU1623
 120:communication/can/can_simple.cpp ****             break;
 6719              		.loc 3 120 38 is_stmt 0 view .LVU1624
 6720 00fa 3146     		mov	r1, r6
 6721 00fc 2846     		mov	r0, r5
 6722 00fe FFF7FEFF 		bl	_ZN9CANSimple25set_traj_inertia_callbackER4AxisRK13can_Message_t
 6723              	.LVL473:
 121:communication/can/can_simple.cpp ****         case MSG_SET_TRAJ_ACCEL_LIMITS:
 6724              		.loc 3 121 13 is_stmt 1 view .LVU1625
 6725 0102 9FE7     		b	.L223
 6726              	.L237:
 122:communication/can/can_simple.cpp ****             set_traj_accel_limits_callback(axis, msg);
 6727              		.loc 3 122 9 view .LVU1626
 123:communication/can/can_simple.cpp ****             break;
 6728              		.loc 3 123 13 view .LVU1627
 123:communication/can/can_simple.cpp ****             break;
 6729              		.loc 3 123 43 is_stmt 0 view .LVU1628
 6730 0104 3146     		mov	r1, r6
 6731 0106 2846     		mov	r0, r5
 6732 0108 FFF7FEFF 		bl	_ZN9CANSimple30set_traj_accel_limits_callbackER4AxisRK13can_Message_t
 6733              	.LVL474:
 124:communication/can/can_simple.cpp ****         case MSG_SET_TRAJ_VEL_LIMIT:
 6734              		.loc 3 124 13 is_stmt 1 view .LVU1629
 6735 010c 9AE7     		b	.L223
 6736              	.L238:
 125:communication/can/can_simple.cpp ****             set_traj_vel_limit_callback(axis, msg);
 6737              		.loc 3 125 9 view .LVU1630
 126:communication/can/can_simple.cpp ****             break;
 6738              		.loc 3 126 13 view .LVU1631
 126:communication/can/can_simple.cpp ****             break;
 6739              		.loc 3 126 40 is_stmt 0 view .LVU1632
 6740 010e 3146     		mov	r1, r6
 6741 0110 2846     		mov	r0, r5
 6742 0112 FFF7FEFF 		bl	_ZN9CANSimple27set_traj_vel_limit_callbackER4AxisRK13can_Message_t
 6743              	.LVL475:
ARM GAS  /tmp/ccoErako.s 			page 278


 127:communication/can/can_simple.cpp ****         case MSG_GET_IQ:
 6744              		.loc 3 127 13 is_stmt 1 view .LVU1633
 6745 0116 95E7     		b	.L223
 6746              	.L235:
 128:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
 6747              		.loc 3 128 9 view .LVU1634
 129:communication/can/can_simple.cpp ****                 get_iq_callback(axis);
 6748              		.loc 3 129 13 view .LVU1635
 129:communication/can/can_simple.cpp ****                 get_iq_callback(axis);
 6749              		.loc 3 129 21 is_stmt 0 view .LVU1636
 6750 0118 7379     		ldrb	r3, [r6, #5]	@ zero_extendqisi2
 129:communication/can/can_simple.cpp ****                 get_iq_callback(axis);
 6751              		.loc 3 129 13 view .LVU1637
 6752 011a 13B9     		cbnz	r3, .L258
 129:communication/can/can_simple.cpp ****                 get_iq_callback(axis);
 6753              		.loc 3 129 32 discriminator 1 view .LVU1638
 6754 011c B379     		ldrb	r3, [r6, #6]	@ zero_extendqisi2
 129:communication/can/can_simple.cpp ****                 get_iq_callback(axis);
 6755              		.loc 3 129 25 discriminator 1 view .LVU1639
 6756 011e 002B     		cmp	r3, #0
 6757 0120 90D1     		bne	.L223
 6758              	.L258:
 130:communication/can/can_simple.cpp ****             break;
 6759              		.loc 3 130 17 is_stmt 1 view .LVU1640
 130:communication/can/can_simple.cpp ****             break;
 6760              		.loc 3 130 32 is_stmt 0 view .LVU1641
 6761 0122 2946     		mov	r1, r5
 6762 0124 3846     		mov	r0, r7
 6763 0126 FFF7FEFF 		bl	_ZN9CANSimple15get_iq_callbackERK4Axis
 6764              	.LVL476:
 6765 012a 8BE7     		b	.L223
 6766              	.L234:
 132:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
 6767              		.loc 3 132 9 is_stmt 1 view .LVU1642
 133:communication/can/can_simple.cpp ****                 get_sensorless_estimates_callback(axis);
 6768              		.loc 3 133 13 view .LVU1643
 133:communication/can/can_simple.cpp ****                 get_sensorless_estimates_callback(axis);
 6769              		.loc 3 133 21 is_stmt 0 view .LVU1644
 6770 012c 7379     		ldrb	r3, [r6, #5]	@ zero_extendqisi2
 133:communication/can/can_simple.cpp ****                 get_sensorless_estimates_callback(axis);
 6771              		.loc 3 133 13 view .LVU1645
 6772 012e 13B9     		cbnz	r3, .L259
 133:communication/can/can_simple.cpp ****                 get_sensorless_estimates_callback(axis);
 6773              		.loc 3 133 32 discriminator 1 view .LVU1646
 6774 0130 B379     		ldrb	r3, [r6, #6]	@ zero_extendqisi2
 133:communication/can/can_simple.cpp ****                 get_sensorless_estimates_callback(axis);
 6775              		.loc 3 133 25 discriminator 1 view .LVU1647
 6776 0132 002B     		cmp	r3, #0
 6777 0134 86D1     		bne	.L223
 6778              	.L259:
 134:communication/can/can_simple.cpp ****             break;
 6779              		.loc 3 134 17 is_stmt 1 view .LVU1648
 134:communication/can/can_simple.cpp ****             break;
 6780              		.loc 3 134 50 is_stmt 0 view .LVU1649
 6781 0136 2946     		mov	r1, r5
 6782 0138 3846     		mov	r0, r7
 6783 013a FFF7FEFF 		bl	_ZN9CANSimple33get_sensorless_estimates_callbackERK4Axis
ARM GAS  /tmp/ccoErako.s 			page 279


 6784              	.LVL477:
 6785 013e 81E7     		b	.L223
 6786              	.L233:
 136:communication/can/can_simple.cpp ****             NVIC_SystemReset();
 6787              		.loc 3 136 9 is_stmt 1 view .LVU1650
 137:communication/can/can_simple.cpp ****             break;
 6788              		.loc 3 137 13 view .LVU1651
 6789              	.LBB1973:
 6790              	.LBI1973:
 6791              		.file 21 "ThirdParty/CMSIS/Include/core_cm4.h"
   1:ThirdParty/CMSIS/Include/core_cm4.h **** /**************************************************************************//**
   2:ThirdParty/CMSIS/Include/core_cm4.h ****  * @file     core_cm4.h
   3:ThirdParty/CMSIS/Include/core_cm4.h ****  * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
   4:ThirdParty/CMSIS/Include/core_cm4.h ****  * @version  V5.0.8
   5:ThirdParty/CMSIS/Include/core_cm4.h ****  * @date     04. June 2018
   6:ThirdParty/CMSIS/Include/core_cm4.h ****  ******************************************************************************/
   7:ThirdParty/CMSIS/Include/core_cm4.h **** /*
   8:ThirdParty/CMSIS/Include/core_cm4.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:ThirdParty/CMSIS/Include/core_cm4.h ****  *
  10:ThirdParty/CMSIS/Include/core_cm4.h ****  * SPDX-License-Identifier: Apache-2.0
  11:ThirdParty/CMSIS/Include/core_cm4.h ****  *
  12:ThirdParty/CMSIS/Include/core_cm4.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:ThirdParty/CMSIS/Include/core_cm4.h ****  * not use this file except in compliance with the License.
  14:ThirdParty/CMSIS/Include/core_cm4.h ****  * You may obtain a copy of the License at
  15:ThirdParty/CMSIS/Include/core_cm4.h ****  *
  16:ThirdParty/CMSIS/Include/core_cm4.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:ThirdParty/CMSIS/Include/core_cm4.h ****  *
  18:ThirdParty/CMSIS/Include/core_cm4.h ****  * Unless required by applicable law or agreed to in writing, software
  19:ThirdParty/CMSIS/Include/core_cm4.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:ThirdParty/CMSIS/Include/core_cm4.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:ThirdParty/CMSIS/Include/core_cm4.h ****  * See the License for the specific language governing permissions and
  22:ThirdParty/CMSIS/Include/core_cm4.h ****  * limitations under the License.
  23:ThirdParty/CMSIS/Include/core_cm4.h ****  */
  24:ThirdParty/CMSIS/Include/core_cm4.h **** 
  25:ThirdParty/CMSIS/Include/core_cm4.h **** #if   defined ( __ICCARM__ )
  26:ThirdParty/CMSIS/Include/core_cm4.h ****   #pragma system_include         /* treat file as system include file for MISRA check */
  27:ThirdParty/CMSIS/Include/core_cm4.h **** #elif defined (__clang__)
  28:ThirdParty/CMSIS/Include/core_cm4.h ****   #pragma clang system_header   /* treat file as system include file */
  29:ThirdParty/CMSIS/Include/core_cm4.h **** #endif
  30:ThirdParty/CMSIS/Include/core_cm4.h **** 
  31:ThirdParty/CMSIS/Include/core_cm4.h **** #ifndef __CORE_CM4_H_GENERIC
  32:ThirdParty/CMSIS/Include/core_cm4.h **** #define __CORE_CM4_H_GENERIC
  33:ThirdParty/CMSIS/Include/core_cm4.h **** 
  34:ThirdParty/CMSIS/Include/core_cm4.h **** #include <stdint.h>
  35:ThirdParty/CMSIS/Include/core_cm4.h **** 
  36:ThirdParty/CMSIS/Include/core_cm4.h **** #ifdef __cplusplus
  37:ThirdParty/CMSIS/Include/core_cm4.h ****  extern "C" {
  38:ThirdParty/CMSIS/Include/core_cm4.h **** #endif
  39:ThirdParty/CMSIS/Include/core_cm4.h **** 
  40:ThirdParty/CMSIS/Include/core_cm4.h **** /**
  41:ThirdParty/CMSIS/Include/core_cm4.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:ThirdParty/CMSIS/Include/core_cm4.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:ThirdParty/CMSIS/Include/core_cm4.h **** 
  44:ThirdParty/CMSIS/Include/core_cm4.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:ThirdParty/CMSIS/Include/core_cm4.h ****      Function definitions in header files are used to allow 'inlining'.
  46:ThirdParty/CMSIS/Include/core_cm4.h **** 
  47:ThirdParty/CMSIS/Include/core_cm4.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
ARM GAS  /tmp/ccoErako.s 			page 280


  48:ThirdParty/CMSIS/Include/core_cm4.h ****      Unions are used for effective representation of core registers.
  49:ThirdParty/CMSIS/Include/core_cm4.h **** 
  50:ThirdParty/CMSIS/Include/core_cm4.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:ThirdParty/CMSIS/Include/core_cm4.h ****      Function-like macros are used to allow more efficient code.
  52:ThirdParty/CMSIS/Include/core_cm4.h ****  */
  53:ThirdParty/CMSIS/Include/core_cm4.h **** 
  54:ThirdParty/CMSIS/Include/core_cm4.h **** 
  55:ThirdParty/CMSIS/Include/core_cm4.h **** /*******************************************************************************
  56:ThirdParty/CMSIS/Include/core_cm4.h ****  *                 CMSIS definitions
  57:ThirdParty/CMSIS/Include/core_cm4.h ****  ******************************************************************************/
  58:ThirdParty/CMSIS/Include/core_cm4.h **** /**
  59:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup Cortex_M4
  60:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
  61:ThirdParty/CMSIS/Include/core_cm4.h ****  */
  62:ThirdParty/CMSIS/Include/core_cm4.h **** 
  63:ThirdParty/CMSIS/Include/core_cm4.h **** #include "cmsis_version.h"
  64:ThirdParty/CMSIS/Include/core_cm4.h **** 
  65:ThirdParty/CMSIS/Include/core_cm4.h **** /* CMSIS CM4 definitions */
  66:ThirdParty/CMSIS/Include/core_cm4.h **** #define __CM4_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] C
  67:ThirdParty/CMSIS/Include/core_cm4.h **** #define __CM4_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  C
  68:ThirdParty/CMSIS/Include/core_cm4.h **** #define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
  69:ThirdParty/CMSIS/Include/core_cm4.h ****                                     __CM4_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL
  70:ThirdParty/CMSIS/Include/core_cm4.h **** 
  71:ThirdParty/CMSIS/Include/core_cm4.h **** #define __CORTEX_M                (4U)                                   /*!< Cortex-M Core */
  72:ThirdParty/CMSIS/Include/core_cm4.h **** 
  73:ThirdParty/CMSIS/Include/core_cm4.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:ThirdParty/CMSIS/Include/core_cm4.h ****     For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and fun
  75:ThirdParty/CMSIS/Include/core_cm4.h **** */
  76:ThirdParty/CMSIS/Include/core_cm4.h **** #if defined ( __CC_ARM )
  77:ThirdParty/CMSIS/Include/core_cm4.h ****   #if defined __TARGET_FPU_VFP
  78:ThirdParty/CMSIS/Include/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
  79:ThirdParty/CMSIS/Include/core_cm4.h ****       #define __FPU_USED       1U
  80:ThirdParty/CMSIS/Include/core_cm4.h ****     #else
  81:ThirdParty/CMSIS/Include/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
  82:ThirdParty/CMSIS/Include/core_cm4.h ****       #define __FPU_USED       0U
  83:ThirdParty/CMSIS/Include/core_cm4.h ****     #endif
  84:ThirdParty/CMSIS/Include/core_cm4.h ****   #else
  85:ThirdParty/CMSIS/Include/core_cm4.h ****     #define __FPU_USED         0U
  86:ThirdParty/CMSIS/Include/core_cm4.h ****   #endif
  87:ThirdParty/CMSIS/Include/core_cm4.h **** 
  88:ThirdParty/CMSIS/Include/core_cm4.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  89:ThirdParty/CMSIS/Include/core_cm4.h ****   #if defined __ARM_PCS_VFP
  90:ThirdParty/CMSIS/Include/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
  91:ThirdParty/CMSIS/Include/core_cm4.h ****       #define __FPU_USED       1U
  92:ThirdParty/CMSIS/Include/core_cm4.h ****     #else
  93:ThirdParty/CMSIS/Include/core_cm4.h ****       #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESEN
  94:ThirdParty/CMSIS/Include/core_cm4.h ****       #define __FPU_USED       0U
  95:ThirdParty/CMSIS/Include/core_cm4.h ****     #endif
  96:ThirdParty/CMSIS/Include/core_cm4.h ****   #else
  97:ThirdParty/CMSIS/Include/core_cm4.h ****     #define __FPU_USED         0U
  98:ThirdParty/CMSIS/Include/core_cm4.h ****   #endif
  99:ThirdParty/CMSIS/Include/core_cm4.h **** 
 100:ThirdParty/CMSIS/Include/core_cm4.h **** #elif defined ( __GNUC__ )
 101:ThirdParty/CMSIS/Include/core_cm4.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
 102:ThirdParty/CMSIS/Include/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 103:ThirdParty/CMSIS/Include/core_cm4.h ****       #define __FPU_USED       1U
 104:ThirdParty/CMSIS/Include/core_cm4.h ****     #else
ARM GAS  /tmp/ccoErako.s 			page 281


 105:ThirdParty/CMSIS/Include/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 106:ThirdParty/CMSIS/Include/core_cm4.h ****       #define __FPU_USED       0U
 107:ThirdParty/CMSIS/Include/core_cm4.h ****     #endif
 108:ThirdParty/CMSIS/Include/core_cm4.h ****   #else
 109:ThirdParty/CMSIS/Include/core_cm4.h ****     #define __FPU_USED         0U
 110:ThirdParty/CMSIS/Include/core_cm4.h ****   #endif
 111:ThirdParty/CMSIS/Include/core_cm4.h **** 
 112:ThirdParty/CMSIS/Include/core_cm4.h **** #elif defined ( __ICCARM__ )
 113:ThirdParty/CMSIS/Include/core_cm4.h ****   #if defined __ARMVFP__
 114:ThirdParty/CMSIS/Include/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 115:ThirdParty/CMSIS/Include/core_cm4.h ****       #define __FPU_USED       1U
 116:ThirdParty/CMSIS/Include/core_cm4.h ****     #else
 117:ThirdParty/CMSIS/Include/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 118:ThirdParty/CMSIS/Include/core_cm4.h ****       #define __FPU_USED       0U
 119:ThirdParty/CMSIS/Include/core_cm4.h ****     #endif
 120:ThirdParty/CMSIS/Include/core_cm4.h ****   #else
 121:ThirdParty/CMSIS/Include/core_cm4.h ****     #define __FPU_USED         0U
 122:ThirdParty/CMSIS/Include/core_cm4.h ****   #endif
 123:ThirdParty/CMSIS/Include/core_cm4.h **** 
 124:ThirdParty/CMSIS/Include/core_cm4.h **** #elif defined ( __TI_ARM__ )
 125:ThirdParty/CMSIS/Include/core_cm4.h ****   #if defined __TI_VFP_SUPPORT__
 126:ThirdParty/CMSIS/Include/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 127:ThirdParty/CMSIS/Include/core_cm4.h ****       #define __FPU_USED       1U
 128:ThirdParty/CMSIS/Include/core_cm4.h ****     #else
 129:ThirdParty/CMSIS/Include/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 130:ThirdParty/CMSIS/Include/core_cm4.h ****       #define __FPU_USED       0U
 131:ThirdParty/CMSIS/Include/core_cm4.h ****     #endif
 132:ThirdParty/CMSIS/Include/core_cm4.h ****   #else
 133:ThirdParty/CMSIS/Include/core_cm4.h ****     #define __FPU_USED         0U
 134:ThirdParty/CMSIS/Include/core_cm4.h ****   #endif
 135:ThirdParty/CMSIS/Include/core_cm4.h **** 
 136:ThirdParty/CMSIS/Include/core_cm4.h **** #elif defined ( __TASKING__ )
 137:ThirdParty/CMSIS/Include/core_cm4.h ****   #if defined __FPU_VFP__
 138:ThirdParty/CMSIS/Include/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 139:ThirdParty/CMSIS/Include/core_cm4.h ****       #define __FPU_USED       1U
 140:ThirdParty/CMSIS/Include/core_cm4.h ****     #else
 141:ThirdParty/CMSIS/Include/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 142:ThirdParty/CMSIS/Include/core_cm4.h ****       #define __FPU_USED       0U
 143:ThirdParty/CMSIS/Include/core_cm4.h ****     #endif
 144:ThirdParty/CMSIS/Include/core_cm4.h ****   #else
 145:ThirdParty/CMSIS/Include/core_cm4.h ****     #define __FPU_USED         0U
 146:ThirdParty/CMSIS/Include/core_cm4.h ****   #endif
 147:ThirdParty/CMSIS/Include/core_cm4.h **** 
 148:ThirdParty/CMSIS/Include/core_cm4.h **** #elif defined ( __CSMC__ )
 149:ThirdParty/CMSIS/Include/core_cm4.h ****   #if ( __CSMC__ & 0x400U)
 150:ThirdParty/CMSIS/Include/core_cm4.h ****     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
 151:ThirdParty/CMSIS/Include/core_cm4.h ****       #define __FPU_USED       1U
 152:ThirdParty/CMSIS/Include/core_cm4.h ****     #else
 153:ThirdParty/CMSIS/Include/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 154:ThirdParty/CMSIS/Include/core_cm4.h ****       #define __FPU_USED       0U
 155:ThirdParty/CMSIS/Include/core_cm4.h ****     #endif
 156:ThirdParty/CMSIS/Include/core_cm4.h ****   #else
 157:ThirdParty/CMSIS/Include/core_cm4.h ****     #define __FPU_USED         0U
 158:ThirdParty/CMSIS/Include/core_cm4.h ****   #endif
 159:ThirdParty/CMSIS/Include/core_cm4.h **** 
 160:ThirdParty/CMSIS/Include/core_cm4.h **** #endif
 161:ThirdParty/CMSIS/Include/core_cm4.h **** 
ARM GAS  /tmp/ccoErako.s 			page 282


 162:ThirdParty/CMSIS/Include/core_cm4.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 163:ThirdParty/CMSIS/Include/core_cm4.h **** 
 164:ThirdParty/CMSIS/Include/core_cm4.h **** 
 165:ThirdParty/CMSIS/Include/core_cm4.h **** #ifdef __cplusplus
 166:ThirdParty/CMSIS/Include/core_cm4.h **** }
 167:ThirdParty/CMSIS/Include/core_cm4.h **** #endif
 168:ThirdParty/CMSIS/Include/core_cm4.h **** 
 169:ThirdParty/CMSIS/Include/core_cm4.h **** #endif /* __CORE_CM4_H_GENERIC */
 170:ThirdParty/CMSIS/Include/core_cm4.h **** 
 171:ThirdParty/CMSIS/Include/core_cm4.h **** #ifndef __CMSIS_GENERIC
 172:ThirdParty/CMSIS/Include/core_cm4.h **** 
 173:ThirdParty/CMSIS/Include/core_cm4.h **** #ifndef __CORE_CM4_H_DEPENDANT
 174:ThirdParty/CMSIS/Include/core_cm4.h **** #define __CORE_CM4_H_DEPENDANT
 175:ThirdParty/CMSIS/Include/core_cm4.h **** 
 176:ThirdParty/CMSIS/Include/core_cm4.h **** #ifdef __cplusplus
 177:ThirdParty/CMSIS/Include/core_cm4.h ****  extern "C" {
 178:ThirdParty/CMSIS/Include/core_cm4.h **** #endif
 179:ThirdParty/CMSIS/Include/core_cm4.h **** 
 180:ThirdParty/CMSIS/Include/core_cm4.h **** /* check device defines and use defaults */
 181:ThirdParty/CMSIS/Include/core_cm4.h **** #if defined __CHECK_DEVICE_DEFINES
 182:ThirdParty/CMSIS/Include/core_cm4.h ****   #ifndef __CM4_REV
 183:ThirdParty/CMSIS/Include/core_cm4.h ****     #define __CM4_REV               0x0000U
 184:ThirdParty/CMSIS/Include/core_cm4.h ****     #warning "__CM4_REV not defined in device header file; using default!"
 185:ThirdParty/CMSIS/Include/core_cm4.h ****   #endif
 186:ThirdParty/CMSIS/Include/core_cm4.h **** 
 187:ThirdParty/CMSIS/Include/core_cm4.h ****   #ifndef __FPU_PRESENT
 188:ThirdParty/CMSIS/Include/core_cm4.h ****     #define __FPU_PRESENT             0U
 189:ThirdParty/CMSIS/Include/core_cm4.h ****     #warning "__FPU_PRESENT not defined in device header file; using default!"
 190:ThirdParty/CMSIS/Include/core_cm4.h ****   #endif
 191:ThirdParty/CMSIS/Include/core_cm4.h **** 
 192:ThirdParty/CMSIS/Include/core_cm4.h ****   #ifndef __MPU_PRESENT
 193:ThirdParty/CMSIS/Include/core_cm4.h ****     #define __MPU_PRESENT             0U
 194:ThirdParty/CMSIS/Include/core_cm4.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 195:ThirdParty/CMSIS/Include/core_cm4.h ****   #endif
 196:ThirdParty/CMSIS/Include/core_cm4.h **** 
 197:ThirdParty/CMSIS/Include/core_cm4.h ****   #ifndef __NVIC_PRIO_BITS
 198:ThirdParty/CMSIS/Include/core_cm4.h ****     #define __NVIC_PRIO_BITS          3U
 199:ThirdParty/CMSIS/Include/core_cm4.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 200:ThirdParty/CMSIS/Include/core_cm4.h ****   #endif
 201:ThirdParty/CMSIS/Include/core_cm4.h **** 
 202:ThirdParty/CMSIS/Include/core_cm4.h ****   #ifndef __Vendor_SysTickConfig
 203:ThirdParty/CMSIS/Include/core_cm4.h ****     #define __Vendor_SysTickConfig    0U
 204:ThirdParty/CMSIS/Include/core_cm4.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 205:ThirdParty/CMSIS/Include/core_cm4.h ****   #endif
 206:ThirdParty/CMSIS/Include/core_cm4.h **** #endif
 207:ThirdParty/CMSIS/Include/core_cm4.h **** 
 208:ThirdParty/CMSIS/Include/core_cm4.h **** /* IO definitions (access restrictions to peripheral registers) */
 209:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 210:ThirdParty/CMSIS/Include/core_cm4.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 211:ThirdParty/CMSIS/Include/core_cm4.h **** 
 212:ThirdParty/CMSIS/Include/core_cm4.h ****     <strong>IO Type Qualifiers</strong> are used
 213:ThirdParty/CMSIS/Include/core_cm4.h ****     \li to specify the access to peripheral variables.
 214:ThirdParty/CMSIS/Include/core_cm4.h ****     \li for automatic generation of peripheral register debug information.
 215:ThirdParty/CMSIS/Include/core_cm4.h **** */
 216:ThirdParty/CMSIS/Include/core_cm4.h **** #ifdef __cplusplus
 217:ThirdParty/CMSIS/Include/core_cm4.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 218:ThirdParty/CMSIS/Include/core_cm4.h **** #else
ARM GAS  /tmp/ccoErako.s 			page 283


 219:ThirdParty/CMSIS/Include/core_cm4.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 220:ThirdParty/CMSIS/Include/core_cm4.h **** #endif
 221:ThirdParty/CMSIS/Include/core_cm4.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 222:ThirdParty/CMSIS/Include/core_cm4.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 223:ThirdParty/CMSIS/Include/core_cm4.h **** 
 224:ThirdParty/CMSIS/Include/core_cm4.h **** /* following defines should be used for structure members */
 225:ThirdParty/CMSIS/Include/core_cm4.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 226:ThirdParty/CMSIS/Include/core_cm4.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 227:ThirdParty/CMSIS/Include/core_cm4.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 228:ThirdParty/CMSIS/Include/core_cm4.h **** 
 229:ThirdParty/CMSIS/Include/core_cm4.h **** /*@} end of group Cortex_M4 */
 230:ThirdParty/CMSIS/Include/core_cm4.h **** 
 231:ThirdParty/CMSIS/Include/core_cm4.h **** 
 232:ThirdParty/CMSIS/Include/core_cm4.h **** 
 233:ThirdParty/CMSIS/Include/core_cm4.h **** /*******************************************************************************
 234:ThirdParty/CMSIS/Include/core_cm4.h ****  *                 Register Abstraction
 235:ThirdParty/CMSIS/Include/core_cm4.h ****   Core Register contain:
 236:ThirdParty/CMSIS/Include/core_cm4.h ****   - Core Register
 237:ThirdParty/CMSIS/Include/core_cm4.h ****   - Core NVIC Register
 238:ThirdParty/CMSIS/Include/core_cm4.h ****   - Core SCB Register
 239:ThirdParty/CMSIS/Include/core_cm4.h ****   - Core SysTick Register
 240:ThirdParty/CMSIS/Include/core_cm4.h ****   - Core Debug Register
 241:ThirdParty/CMSIS/Include/core_cm4.h ****   - Core MPU Register
 242:ThirdParty/CMSIS/Include/core_cm4.h ****   - Core FPU Register
 243:ThirdParty/CMSIS/Include/core_cm4.h ****  ******************************************************************************/
 244:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 245:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 246:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 247:ThirdParty/CMSIS/Include/core_cm4.h **** */
 248:ThirdParty/CMSIS/Include/core_cm4.h **** 
 249:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 250:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup    CMSIS_core_register
 251:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 252:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief      Core Register type definitions.
 253:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
 254:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 255:ThirdParty/CMSIS/Include/core_cm4.h **** 
 256:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 257:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 258:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 259:ThirdParty/CMSIS/Include/core_cm4.h **** typedef union
 260:ThirdParty/CMSIS/Include/core_cm4.h **** {
 261:ThirdParty/CMSIS/Include/core_cm4.h ****   struct
 262:ThirdParty/CMSIS/Include/core_cm4.h ****   {
 263:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
 264:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
 265:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
 266:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
 267:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 268:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 269:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 270:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 271:ThirdParty/CMSIS/Include/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 272:ThirdParty/CMSIS/Include/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 273:ThirdParty/CMSIS/Include/core_cm4.h **** } APSR_Type;
 274:ThirdParty/CMSIS/Include/core_cm4.h **** 
 275:ThirdParty/CMSIS/Include/core_cm4.h **** /* APSR Register Definitions */
ARM GAS  /tmp/ccoErako.s 			page 284


 276:ThirdParty/CMSIS/Include/core_cm4.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 277:ThirdParty/CMSIS/Include/core_cm4.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 278:ThirdParty/CMSIS/Include/core_cm4.h **** 
 279:ThirdParty/CMSIS/Include/core_cm4.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 280:ThirdParty/CMSIS/Include/core_cm4.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 281:ThirdParty/CMSIS/Include/core_cm4.h **** 
 282:ThirdParty/CMSIS/Include/core_cm4.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 283:ThirdParty/CMSIS/Include/core_cm4.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 284:ThirdParty/CMSIS/Include/core_cm4.h **** 
 285:ThirdParty/CMSIS/Include/core_cm4.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 286:ThirdParty/CMSIS/Include/core_cm4.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 287:ThirdParty/CMSIS/Include/core_cm4.h **** 
 288:ThirdParty/CMSIS/Include/core_cm4.h **** #define APSR_Q_Pos                         27U                                            /*!< APSR
 289:ThirdParty/CMSIS/Include/core_cm4.h **** #define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR
 290:ThirdParty/CMSIS/Include/core_cm4.h **** 
 291:ThirdParty/CMSIS/Include/core_cm4.h **** #define APSR_GE_Pos                        16U                                            /*!< APSR
 292:ThirdParty/CMSIS/Include/core_cm4.h **** #define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR
 293:ThirdParty/CMSIS/Include/core_cm4.h **** 
 294:ThirdParty/CMSIS/Include/core_cm4.h **** 
 295:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 296:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 297:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 298:ThirdParty/CMSIS/Include/core_cm4.h **** typedef union
 299:ThirdParty/CMSIS/Include/core_cm4.h **** {
 300:ThirdParty/CMSIS/Include/core_cm4.h ****   struct
 301:ThirdParty/CMSIS/Include/core_cm4.h ****   {
 302:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 303:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 304:ThirdParty/CMSIS/Include/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 305:ThirdParty/CMSIS/Include/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 306:ThirdParty/CMSIS/Include/core_cm4.h **** } IPSR_Type;
 307:ThirdParty/CMSIS/Include/core_cm4.h **** 
 308:ThirdParty/CMSIS/Include/core_cm4.h **** /* IPSR Register Definitions */
 309:ThirdParty/CMSIS/Include/core_cm4.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 310:ThirdParty/CMSIS/Include/core_cm4.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 311:ThirdParty/CMSIS/Include/core_cm4.h **** 
 312:ThirdParty/CMSIS/Include/core_cm4.h **** 
 313:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 314:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 315:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 316:ThirdParty/CMSIS/Include/core_cm4.h **** typedef union
 317:ThirdParty/CMSIS/Include/core_cm4.h **** {
 318:ThirdParty/CMSIS/Include/core_cm4.h ****   struct
 319:ThirdParty/CMSIS/Include/core_cm4.h ****   {
 320:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 321:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
 322:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
 323:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
 324:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
 325:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit */
 326:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
 327:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
 328:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 329:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 330:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 331:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 332:ThirdParty/CMSIS/Include/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
ARM GAS  /tmp/ccoErako.s 			page 285


 333:ThirdParty/CMSIS/Include/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 334:ThirdParty/CMSIS/Include/core_cm4.h **** } xPSR_Type;
 335:ThirdParty/CMSIS/Include/core_cm4.h **** 
 336:ThirdParty/CMSIS/Include/core_cm4.h **** /* xPSR Register Definitions */
 337:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 338:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 339:ThirdParty/CMSIS/Include/core_cm4.h **** 
 340:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 341:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 342:ThirdParty/CMSIS/Include/core_cm4.h **** 
 343:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 344:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 345:ThirdParty/CMSIS/Include/core_cm4.h **** 
 346:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 347:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 348:ThirdParty/CMSIS/Include/core_cm4.h **** 
 349:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_Q_Pos                         27U                                            /*!< xPSR
 350:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR
 351:ThirdParty/CMSIS/Include/core_cm4.h **** 
 352:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR
 353:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR
 354:ThirdParty/CMSIS/Include/core_cm4.h **** 
 355:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 356:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 357:ThirdParty/CMSIS/Include/core_cm4.h **** 
 358:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_GE_Pos                        16U                                            /*!< xPSR
 359:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR
 360:ThirdParty/CMSIS/Include/core_cm4.h **** 
 361:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR
 362:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR
 363:ThirdParty/CMSIS/Include/core_cm4.h **** 
 364:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 365:ThirdParty/CMSIS/Include/core_cm4.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 366:ThirdParty/CMSIS/Include/core_cm4.h **** 
 367:ThirdParty/CMSIS/Include/core_cm4.h **** 
 368:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 369:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief  Union type to access the Control Registers (CONTROL).
 370:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 371:ThirdParty/CMSIS/Include/core_cm4.h **** typedef union
 372:ThirdParty/CMSIS/Include/core_cm4.h **** {
 373:ThirdParty/CMSIS/Include/core_cm4.h ****   struct
 374:ThirdParty/CMSIS/Include/core_cm4.h ****   {
 375:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 376:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 377:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
 378:ThirdParty/CMSIS/Include/core_cm4.h ****     uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
 379:ThirdParty/CMSIS/Include/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access */
 380:ThirdParty/CMSIS/Include/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access */
 381:ThirdParty/CMSIS/Include/core_cm4.h **** } CONTROL_Type;
 382:ThirdParty/CMSIS/Include/core_cm4.h **** 
 383:ThirdParty/CMSIS/Include/core_cm4.h **** /* CONTROL Register Definitions */
 384:ThirdParty/CMSIS/Include/core_cm4.h **** #define CONTROL_FPCA_Pos                    2U                                            /*!< CONT
 385:ThirdParty/CMSIS/Include/core_cm4.h **** #define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONT
 386:ThirdParty/CMSIS/Include/core_cm4.h **** 
 387:ThirdParty/CMSIS/Include/core_cm4.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 388:ThirdParty/CMSIS/Include/core_cm4.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 389:ThirdParty/CMSIS/Include/core_cm4.h **** 
ARM GAS  /tmp/ccoErako.s 			page 286


 390:ThirdParty/CMSIS/Include/core_cm4.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 391:ThirdParty/CMSIS/Include/core_cm4.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 392:ThirdParty/CMSIS/Include/core_cm4.h **** 
 393:ThirdParty/CMSIS/Include/core_cm4.h **** /*@} end of group CMSIS_CORE */
 394:ThirdParty/CMSIS/Include/core_cm4.h **** 
 395:ThirdParty/CMSIS/Include/core_cm4.h **** 
 396:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 397:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup    CMSIS_core_register
 398:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 399:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief      Type definitions for the NVIC Registers
 400:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
 401:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 402:ThirdParty/CMSIS/Include/core_cm4.h **** 
 403:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 404:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 405:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 406:ThirdParty/CMSIS/Include/core_cm4.h **** typedef struct
 407:ThirdParty/CMSIS/Include/core_cm4.h **** {
 408:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 409:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED0[24U];
 410:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 411:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RSERVED1[24U];
 412:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 413:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED2[24U];
 414:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 415:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED3[24U];
 416:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
 417:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED4[56U];
 418:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bi
 419:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED5[644U];
 420:ThirdParty/CMSIS/Include/core_cm4.h ****   __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Regis
 421:ThirdParty/CMSIS/Include/core_cm4.h **** }  NVIC_Type;
 422:ThirdParty/CMSIS/Include/core_cm4.h **** 
 423:ThirdParty/CMSIS/Include/core_cm4.h **** /* Software Triggered Interrupt Register Definitions */
 424:ThirdParty/CMSIS/Include/core_cm4.h **** #define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: I
 425:ThirdParty/CMSIS/Include/core_cm4.h **** #define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: I
 426:ThirdParty/CMSIS/Include/core_cm4.h **** 
 427:ThirdParty/CMSIS/Include/core_cm4.h **** /*@} end of group CMSIS_NVIC */
 428:ThirdParty/CMSIS/Include/core_cm4.h **** 
 429:ThirdParty/CMSIS/Include/core_cm4.h **** 
 430:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 431:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup  CMSIS_core_register
 432:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 433:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief    Type definitions for the System Control Block Registers
 434:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
 435:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 436:ThirdParty/CMSIS/Include/core_cm4.h **** 
 437:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 438:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief  Structure type to access the System Control Block (SCB).
 439:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 440:ThirdParty/CMSIS/Include/core_cm4.h **** typedef struct
 441:ThirdParty/CMSIS/Include/core_cm4.h **** {
 442:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 443:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 444:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 445:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 446:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
ARM GAS  /tmp/ccoErako.s 			page 287


 447:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 448:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registe
 449:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 450:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Regist
 451:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
 452:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
 453:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register
 454:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
 455:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register 
 456:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
 457:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
 458:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
 459:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
 460:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Regis
 461:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED0[5U];
 462:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Regis
 463:ThirdParty/CMSIS/Include/core_cm4.h **** } SCB_Type;
 464:ThirdParty/CMSIS/Include/core_cm4.h **** 
 465:ThirdParty/CMSIS/Include/core_cm4.h **** /* SCB CPUID Register Definitions */
 466:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 467:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 468:ThirdParty/CMSIS/Include/core_cm4.h **** 
 469:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 470:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 471:ThirdParty/CMSIS/Include/core_cm4.h **** 
 472:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 473:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 474:ThirdParty/CMSIS/Include/core_cm4.h **** 
 475:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 476:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 477:ThirdParty/CMSIS/Include/core_cm4.h **** 
 478:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 479:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 480:ThirdParty/CMSIS/Include/core_cm4.h **** 
 481:ThirdParty/CMSIS/Include/core_cm4.h **** /* SCB Interrupt Control State Register Definitions */
 482:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 483:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 484:ThirdParty/CMSIS/Include/core_cm4.h **** 
 485:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 486:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 487:ThirdParty/CMSIS/Include/core_cm4.h **** 
 488:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 489:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 490:ThirdParty/CMSIS/Include/core_cm4.h **** 
 491:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 492:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 493:ThirdParty/CMSIS/Include/core_cm4.h **** 
 494:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 495:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 496:ThirdParty/CMSIS/Include/core_cm4.h **** 
 497:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 498:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 499:ThirdParty/CMSIS/Include/core_cm4.h **** 
 500:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 501:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 502:ThirdParty/CMSIS/Include/core_cm4.h **** 
 503:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
ARM GAS  /tmp/ccoErako.s 			page 288


 504:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 505:ThirdParty/CMSIS/Include/core_cm4.h **** 
 506:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB 
 507:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB 
 508:ThirdParty/CMSIS/Include/core_cm4.h **** 
 509:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 510:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 511:ThirdParty/CMSIS/Include/core_cm4.h **** 
 512:ThirdParty/CMSIS/Include/core_cm4.h **** /* SCB Vector Table Offset Register Definitions */
 513:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB 
 514:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB 
 515:ThirdParty/CMSIS/Include/core_cm4.h **** 
 516:ThirdParty/CMSIS/Include/core_cm4.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 517:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 518:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 519:ThirdParty/CMSIS/Include/core_cm4.h **** 
 520:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 521:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 522:ThirdParty/CMSIS/Include/core_cm4.h **** 
 523:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 524:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 525:ThirdParty/CMSIS/Include/core_cm4.h **** 
 526:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB 
 527:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB 
 528:ThirdParty/CMSIS/Include/core_cm4.h **** 
 529:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 530:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 531:ThirdParty/CMSIS/Include/core_cm4.h **** 
 532:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 533:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 534:ThirdParty/CMSIS/Include/core_cm4.h **** 
 535:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB 
 536:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB 
 537:ThirdParty/CMSIS/Include/core_cm4.h **** 
 538:ThirdParty/CMSIS/Include/core_cm4.h **** /* SCB System Control Register Definitions */
 539:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 540:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 541:ThirdParty/CMSIS/Include/core_cm4.h **** 
 542:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 543:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 544:ThirdParty/CMSIS/Include/core_cm4.h **** 
 545:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 546:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 547:ThirdParty/CMSIS/Include/core_cm4.h **** 
 548:ThirdParty/CMSIS/Include/core_cm4.h **** /* SCB Configuration Control Register Definitions */
 549:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 550:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 551:ThirdParty/CMSIS/Include/core_cm4.h **** 
 552:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB 
 553:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB 
 554:ThirdParty/CMSIS/Include/core_cm4.h **** 
 555:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB 
 556:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB 
 557:ThirdParty/CMSIS/Include/core_cm4.h **** 
 558:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 559:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 560:ThirdParty/CMSIS/Include/core_cm4.h **** 
ARM GAS  /tmp/ccoErako.s 			page 289


 561:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB 
 562:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB 
 563:ThirdParty/CMSIS/Include/core_cm4.h **** 
 564:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB 
 565:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB 
 566:ThirdParty/CMSIS/Include/core_cm4.h **** 
 567:ThirdParty/CMSIS/Include/core_cm4.h **** /* SCB System Handler Control and State Register Definitions */
 568:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB 
 569:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB 
 570:ThirdParty/CMSIS/Include/core_cm4.h **** 
 571:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB 
 572:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB 
 573:ThirdParty/CMSIS/Include/core_cm4.h **** 
 574:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB 
 575:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB 
 576:ThirdParty/CMSIS/Include/core_cm4.h **** 
 577:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 578:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 579:ThirdParty/CMSIS/Include/core_cm4.h **** 
 580:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB 
 581:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB 
 582:ThirdParty/CMSIS/Include/core_cm4.h **** 
 583:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB 
 584:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB 
 585:ThirdParty/CMSIS/Include/core_cm4.h **** 
 586:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB 
 587:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB 
 588:ThirdParty/CMSIS/Include/core_cm4.h **** 
 589:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB 
 590:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB 
 591:ThirdParty/CMSIS/Include/core_cm4.h **** 
 592:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB 
 593:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB 
 594:ThirdParty/CMSIS/Include/core_cm4.h **** 
 595:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB 
 596:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB 
 597:ThirdParty/CMSIS/Include/core_cm4.h **** 
 598:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB 
 599:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB 
 600:ThirdParty/CMSIS/Include/core_cm4.h **** 
 601:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB 
 602:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB 
 603:ThirdParty/CMSIS/Include/core_cm4.h **** 
 604:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB 
 605:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB 
 606:ThirdParty/CMSIS/Include/core_cm4.h **** 
 607:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB 
 608:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB 
 609:ThirdParty/CMSIS/Include/core_cm4.h **** 
 610:ThirdParty/CMSIS/Include/core_cm4.h **** /* SCB Configurable Fault Status Register Definitions */
 611:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB 
 612:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB 
 613:ThirdParty/CMSIS/Include/core_cm4.h **** 
 614:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB 
 615:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB 
 616:ThirdParty/CMSIS/Include/core_cm4.h **** 
 617:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB 
ARM GAS  /tmp/ccoErako.s 			page 290


 618:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB 
 619:ThirdParty/CMSIS/Include/core_cm4.h **** 
 620:ThirdParty/CMSIS/Include/core_cm4.h **** /* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
 621:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_MMARVALID_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 7U)               /*!< SCB 
 622:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB 
 623:ThirdParty/CMSIS/Include/core_cm4.h **** 
 624:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_MLSPERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 5U)               /*!< SCB 
 625:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_MLSPERR_Msk               (1UL << SCB_CFSR_MLSPERR_Pos)                  /*!< SCB 
 626:ThirdParty/CMSIS/Include/core_cm4.h **** 
 627:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_MSTKERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 4U)               /*!< SCB 
 628:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB 
 629:ThirdParty/CMSIS/Include/core_cm4.h **** 
 630:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_MUNSTKERR_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 3U)               /*!< SCB 
 631:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB 
 632:ThirdParty/CMSIS/Include/core_cm4.h **** 
 633:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_DACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 1U)               /*!< SCB 
 634:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB 
 635:ThirdParty/CMSIS/Include/core_cm4.h **** 
 636:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_IACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 0U)               /*!< SCB 
 637:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB 
 638:ThirdParty/CMSIS/Include/core_cm4.h **** 
 639:ThirdParty/CMSIS/Include/core_cm4.h **** /* BusFault Status Register (part of SCB Configurable Fault Status Register) */
 640:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB 
 641:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB 
 642:ThirdParty/CMSIS/Include/core_cm4.h **** 
 643:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_LSPERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 5U)                  /*!< SCB 
 644:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_LSPERR_Msk               (1UL << SCB_CFSR_LSPERR_Pos)                    /*!< SCB 
 645:ThirdParty/CMSIS/Include/core_cm4.h **** 
 646:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB 
 647:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB 
 648:ThirdParty/CMSIS/Include/core_cm4.h **** 
 649:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB 
 650:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB 
 651:ThirdParty/CMSIS/Include/core_cm4.h **** 
 652:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB 
 653:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB 
 654:ThirdParty/CMSIS/Include/core_cm4.h **** 
 655:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB 
 656:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB 
 657:ThirdParty/CMSIS/Include/core_cm4.h **** 
 658:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB 
 659:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB 
 660:ThirdParty/CMSIS/Include/core_cm4.h **** 
 661:ThirdParty/CMSIS/Include/core_cm4.h **** /* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
 662:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB 
 663:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB 
 664:ThirdParty/CMSIS/Include/core_cm4.h **** 
 665:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB 
 666:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB 
 667:ThirdParty/CMSIS/Include/core_cm4.h **** 
 668:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB 
 669:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB 
 670:ThirdParty/CMSIS/Include/core_cm4.h **** 
 671:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB 
 672:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB 
 673:ThirdParty/CMSIS/Include/core_cm4.h **** 
 674:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB 
ARM GAS  /tmp/ccoErako.s 			page 291


 675:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB 
 676:ThirdParty/CMSIS/Include/core_cm4.h **** 
 677:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB 
 678:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB 
 679:ThirdParty/CMSIS/Include/core_cm4.h **** 
 680:ThirdParty/CMSIS/Include/core_cm4.h **** /* SCB Hard Fault Status Register Definitions */
 681:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB 
 682:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB 
 683:ThirdParty/CMSIS/Include/core_cm4.h **** 
 684:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB 
 685:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB 
 686:ThirdParty/CMSIS/Include/core_cm4.h **** 
 687:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB 
 688:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB 
 689:ThirdParty/CMSIS/Include/core_cm4.h **** 
 690:ThirdParty/CMSIS/Include/core_cm4.h **** /* SCB Debug Fault Status Register Definitions */
 691:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB 
 692:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB 
 693:ThirdParty/CMSIS/Include/core_cm4.h **** 
 694:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB 
 695:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB 
 696:ThirdParty/CMSIS/Include/core_cm4.h **** 
 697:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB 
 698:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB 
 699:ThirdParty/CMSIS/Include/core_cm4.h **** 
 700:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB 
 701:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB 
 702:ThirdParty/CMSIS/Include/core_cm4.h **** 
 703:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB 
 704:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB 
 705:ThirdParty/CMSIS/Include/core_cm4.h **** 
 706:ThirdParty/CMSIS/Include/core_cm4.h **** /*@} end of group CMSIS_SCB */
 707:ThirdParty/CMSIS/Include/core_cm4.h **** 
 708:ThirdParty/CMSIS/Include/core_cm4.h **** 
 709:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 710:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup  CMSIS_core_register
 711:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
 712:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief    Type definitions for the System Control and ID Register not in the SCB
 713:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
 714:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 715:ThirdParty/CMSIS/Include/core_cm4.h **** 
 716:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 717:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief  Structure type to access the System Control and ID Register not in the SCB.
 718:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 719:ThirdParty/CMSIS/Include/core_cm4.h **** typedef struct
 720:ThirdParty/CMSIS/Include/core_cm4.h **** {
 721:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED0[1U];
 722:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Regist
 723:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
 724:ThirdParty/CMSIS/Include/core_cm4.h **** } SCnSCB_Type;
 725:ThirdParty/CMSIS/Include/core_cm4.h **** 
 726:ThirdParty/CMSIS/Include/core_cm4.h **** /* Interrupt Controller Type Register Definitions */
 727:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: I
 728:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: I
 729:ThirdParty/CMSIS/Include/core_cm4.h **** 
 730:ThirdParty/CMSIS/Include/core_cm4.h **** /* Auxiliary Control Register Definitions */
 731:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: 
ARM GAS  /tmp/ccoErako.s 			page 292


 732:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: 
 733:ThirdParty/CMSIS/Include/core_cm4.h **** 
 734:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: 
 735:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: 
 736:ThirdParty/CMSIS/Include/core_cm4.h **** 
 737:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: 
 738:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: 
 739:ThirdParty/CMSIS/Include/core_cm4.h **** 
 740:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: 
 741:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: 
 742:ThirdParty/CMSIS/Include/core_cm4.h **** 
 743:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: 
 744:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: 
 745:ThirdParty/CMSIS/Include/core_cm4.h **** 
 746:ThirdParty/CMSIS/Include/core_cm4.h **** /*@} end of group CMSIS_SCnotSCB */
 747:ThirdParty/CMSIS/Include/core_cm4.h **** 
 748:ThirdParty/CMSIS/Include/core_cm4.h **** 
 749:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 750:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup  CMSIS_core_register
 751:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 752:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief    Type definitions for the System Timer Registers.
 753:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
 754:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 755:ThirdParty/CMSIS/Include/core_cm4.h **** 
 756:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 757:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief  Structure type to access the System Timer (SysTick).
 758:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 759:ThirdParty/CMSIS/Include/core_cm4.h **** typedef struct
 760:ThirdParty/CMSIS/Include/core_cm4.h **** {
 761:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 762:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 763:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 764:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 765:ThirdParty/CMSIS/Include/core_cm4.h **** } SysTick_Type;
 766:ThirdParty/CMSIS/Include/core_cm4.h **** 
 767:ThirdParty/CMSIS/Include/core_cm4.h **** /* SysTick Control / Status Register Definitions */
 768:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 769:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 770:ThirdParty/CMSIS/Include/core_cm4.h **** 
 771:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 772:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 773:ThirdParty/CMSIS/Include/core_cm4.h **** 
 774:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 775:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 776:ThirdParty/CMSIS/Include/core_cm4.h **** 
 777:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 778:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 779:ThirdParty/CMSIS/Include/core_cm4.h **** 
 780:ThirdParty/CMSIS/Include/core_cm4.h **** /* SysTick Reload Register Definitions */
 781:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 782:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 783:ThirdParty/CMSIS/Include/core_cm4.h **** 
 784:ThirdParty/CMSIS/Include/core_cm4.h **** /* SysTick Current Register Definitions */
 785:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 786:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 787:ThirdParty/CMSIS/Include/core_cm4.h **** 
 788:ThirdParty/CMSIS/Include/core_cm4.h **** /* SysTick Calibration Register Definitions */
ARM GAS  /tmp/ccoErako.s 			page 293


 789:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 790:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 791:ThirdParty/CMSIS/Include/core_cm4.h **** 
 792:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 793:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 794:ThirdParty/CMSIS/Include/core_cm4.h **** 
 795:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 796:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 797:ThirdParty/CMSIS/Include/core_cm4.h **** 
 798:ThirdParty/CMSIS/Include/core_cm4.h **** /*@} end of group CMSIS_SysTick */
 799:ThirdParty/CMSIS/Include/core_cm4.h **** 
 800:ThirdParty/CMSIS/Include/core_cm4.h **** 
 801:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 802:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup  CMSIS_core_register
 803:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
 804:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
 805:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
 806:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 807:ThirdParty/CMSIS/Include/core_cm4.h **** 
 808:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 809:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
 810:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 811:ThirdParty/CMSIS/Include/core_cm4.h **** typedef struct
 812:ThirdParty/CMSIS/Include/core_cm4.h **** {
 813:ThirdParty/CMSIS/Include/core_cm4.h ****   __OM  union
 814:ThirdParty/CMSIS/Include/core_cm4.h ****   {
 815:ThirdParty/CMSIS/Include/core_cm4.h ****     __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
 816:ThirdParty/CMSIS/Include/core_cm4.h ****     __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
 817:ThirdParty/CMSIS/Include/core_cm4.h ****     __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
 818:ThirdParty/CMSIS/Include/core_cm4.h ****   }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
 819:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED0[864U];
 820:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
 821:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED1[15U];
 822:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
 823:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED2[15U];
 824:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
 825:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED3[29U];
 826:ThirdParty/CMSIS/Include/core_cm4.h ****   __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register *
 827:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
 828:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Reg
 829:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED4[43U];
 830:ThirdParty/CMSIS/Include/core_cm4.h ****   __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
 831:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
 832:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED5[6U];
 833:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Re
 834:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Re
 835:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Re
 836:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Re
 837:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Re
 838:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Re
 839:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Re
 840:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Re
 841:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Re
 842:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Re
 843:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Re
 844:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Re
 845:ThirdParty/CMSIS/Include/core_cm4.h **** } ITM_Type;
ARM GAS  /tmp/ccoErako.s 			page 294


 846:ThirdParty/CMSIS/Include/core_cm4.h **** 
 847:ThirdParty/CMSIS/Include/core_cm4.h **** /* ITM Trace Privilege Register Definitions */
 848:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM 
 849:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TPR_PRIVMASK_Msk               (0xFFFFFFFFUL /*<< ITM_TPR_PRIVMASK_Pos*/)     /*!< ITM 
 850:ThirdParty/CMSIS/Include/core_cm4.h **** 
 851:ThirdParty/CMSIS/Include/core_cm4.h **** /* ITM Trace Control Register Definitions */
 852:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM 
 853:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM 
 854:ThirdParty/CMSIS/Include/core_cm4.h **** 
 855:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM 
 856:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM 
 857:ThirdParty/CMSIS/Include/core_cm4.h **** 
 858:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM 
 859:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM 
 860:ThirdParty/CMSIS/Include/core_cm4.h **** 
 861:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM 
 862:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM 
 863:ThirdParty/CMSIS/Include/core_cm4.h **** 
 864:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM 
 865:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM 
 866:ThirdParty/CMSIS/Include/core_cm4.h **** 
 867:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM 
 868:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM 
 869:ThirdParty/CMSIS/Include/core_cm4.h **** 
 870:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM 
 871:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM 
 872:ThirdParty/CMSIS/Include/core_cm4.h **** 
 873:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM 
 874:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM 
 875:ThirdParty/CMSIS/Include/core_cm4.h **** 
 876:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM 
 877:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM 
 878:ThirdParty/CMSIS/Include/core_cm4.h **** 
 879:ThirdParty/CMSIS/Include/core_cm4.h **** /* ITM Integration Write Register Definitions */
 880:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM 
 881:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM 
 882:ThirdParty/CMSIS/Include/core_cm4.h **** 
 883:ThirdParty/CMSIS/Include/core_cm4.h **** /* ITM Integration Read Register Definitions */
 884:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM 
 885:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM 
 886:ThirdParty/CMSIS/Include/core_cm4.h **** 
 887:ThirdParty/CMSIS/Include/core_cm4.h **** /* ITM Integration Mode Control Register Definitions */
 888:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM 
 889:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM 
 890:ThirdParty/CMSIS/Include/core_cm4.h **** 
 891:ThirdParty/CMSIS/Include/core_cm4.h **** /* ITM Lock Status Register Definitions */
 892:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM 
 893:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM 
 894:ThirdParty/CMSIS/Include/core_cm4.h **** 
 895:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_LSR_Access_Pos                  1U                                            /*!< ITM 
 896:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM 
 897:ThirdParty/CMSIS/Include/core_cm4.h **** 
 898:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_LSR_Present_Pos                 0U                                            /*!< ITM 
 899:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM 
 900:ThirdParty/CMSIS/Include/core_cm4.h **** 
 901:ThirdParty/CMSIS/Include/core_cm4.h **** /*@}*/ /* end of group CMSIS_ITM */
 902:ThirdParty/CMSIS/Include/core_cm4.h **** 
ARM GAS  /tmp/ccoErako.s 			page 295


 903:ThirdParty/CMSIS/Include/core_cm4.h **** 
 904:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 905:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup  CMSIS_core_register
 906:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
 907:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief    Type definitions for the Data Watchpoint and Trace (DWT)
 908:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
 909:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 910:ThirdParty/CMSIS/Include/core_cm4.h **** 
 911:ThirdParty/CMSIS/Include/core_cm4.h **** /**
 912:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
 913:ThirdParty/CMSIS/Include/core_cm4.h ****  */
 914:ThirdParty/CMSIS/Include/core_cm4.h **** typedef struct
 915:ThirdParty/CMSIS/Include/core_cm4.h **** {
 916:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
 917:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
 918:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
 919:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Registe
 920:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
 921:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
 922:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Registe
 923:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register 
 924:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
 925:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
 926:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
 927:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED0[1U];
 928:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
 929:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
 930:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
 931:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED1[1U];
 932:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
 933:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
 934:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
 935:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED2[1U];
 936:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
 937:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
 938:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
 939:ThirdParty/CMSIS/Include/core_cm4.h **** } DWT_Type;
 940:ThirdParty/CMSIS/Include/core_cm4.h **** 
 941:ThirdParty/CMSIS/Include/core_cm4.h **** /* DWT Control Register Definitions */
 942:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTR
 943:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTR
 944:ThirdParty/CMSIS/Include/core_cm4.h **** 
 945:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTR
 946:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTR
 947:ThirdParty/CMSIS/Include/core_cm4.h **** 
 948:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTR
 949:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTR
 950:ThirdParty/CMSIS/Include/core_cm4.h **** 
 951:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTR
 952:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTR
 953:ThirdParty/CMSIS/Include/core_cm4.h **** 
 954:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTR
 955:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTR
 956:ThirdParty/CMSIS/Include/core_cm4.h **** 
 957:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTR
 958:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTR
 959:ThirdParty/CMSIS/Include/core_cm4.h **** 
ARM GAS  /tmp/ccoErako.s 			page 296


 960:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTR
 961:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTR
 962:ThirdParty/CMSIS/Include/core_cm4.h **** 
 963:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTR
 964:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTR
 965:ThirdParty/CMSIS/Include/core_cm4.h **** 
 966:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTR
 967:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTR
 968:ThirdParty/CMSIS/Include/core_cm4.h **** 
 969:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTR
 970:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTR
 971:ThirdParty/CMSIS/Include/core_cm4.h **** 
 972:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTR
 973:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTR
 974:ThirdParty/CMSIS/Include/core_cm4.h **** 
 975:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTR
 976:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTR
 977:ThirdParty/CMSIS/Include/core_cm4.h **** 
 978:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTR
 979:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTR
 980:ThirdParty/CMSIS/Include/core_cm4.h **** 
 981:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTR
 982:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTR
 983:ThirdParty/CMSIS/Include/core_cm4.h **** 
 984:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTR
 985:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTR
 986:ThirdParty/CMSIS/Include/core_cm4.h **** 
 987:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTR
 988:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTR
 989:ThirdParty/CMSIS/Include/core_cm4.h **** 
 990:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTR
 991:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTR
 992:ThirdParty/CMSIS/Include/core_cm4.h **** 
 993:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTR
 994:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTR
 995:ThirdParty/CMSIS/Include/core_cm4.h **** 
 996:ThirdParty/CMSIS/Include/core_cm4.h **** /* DWT CPI Count Register Definitions */
 997:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPI
 998:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPI
 999:ThirdParty/CMSIS/Include/core_cm4.h **** 
1000:ThirdParty/CMSIS/Include/core_cm4.h **** /* DWT Exception Overhead Count Register Definitions */
1001:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXC
1002:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXC
1003:ThirdParty/CMSIS/Include/core_cm4.h **** 
1004:ThirdParty/CMSIS/Include/core_cm4.h **** /* DWT Sleep Count Register Definitions */
1005:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLE
1006:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLE
1007:ThirdParty/CMSIS/Include/core_cm4.h **** 
1008:ThirdParty/CMSIS/Include/core_cm4.h **** /* DWT LSU Count Register Definitions */
1009:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSU
1010:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSU
1011:ThirdParty/CMSIS/Include/core_cm4.h **** 
1012:ThirdParty/CMSIS/Include/core_cm4.h **** /* DWT Folded-instruction Count Register Definitions */
1013:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOL
1014:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOL
1015:ThirdParty/CMSIS/Include/core_cm4.h **** 
1016:ThirdParty/CMSIS/Include/core_cm4.h **** /* DWT Comparator Mask Register Definitions */
ARM GAS  /tmp/ccoErako.s 			page 297


1017:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MAS
1018:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MAS
1019:ThirdParty/CMSIS/Include/core_cm4.h **** 
1020:ThirdParty/CMSIS/Include/core_cm4.h **** /* DWT Comparator Function Register Definitions */
1021:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUN
1022:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUN
1023:ThirdParty/CMSIS/Include/core_cm4.h **** 
1024:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUN
1025:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUN
1026:ThirdParty/CMSIS/Include/core_cm4.h **** 
1027:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUN
1028:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUN
1029:ThirdParty/CMSIS/Include/core_cm4.h **** 
1030:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUN
1031:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUN
1032:ThirdParty/CMSIS/Include/core_cm4.h **** 
1033:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUN
1034:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUN
1035:ThirdParty/CMSIS/Include/core_cm4.h **** 
1036:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUN
1037:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUN
1038:ThirdParty/CMSIS/Include/core_cm4.h **** 
1039:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUN
1040:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUN
1041:ThirdParty/CMSIS/Include/core_cm4.h **** 
1042:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUN
1043:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUN
1044:ThirdParty/CMSIS/Include/core_cm4.h **** 
1045:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUN
1046:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUN
1047:ThirdParty/CMSIS/Include/core_cm4.h **** 
1048:ThirdParty/CMSIS/Include/core_cm4.h **** /*@}*/ /* end of group CMSIS_DWT */
1049:ThirdParty/CMSIS/Include/core_cm4.h **** 
1050:ThirdParty/CMSIS/Include/core_cm4.h **** 
1051:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1052:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup  CMSIS_core_register
1053:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup CMSIS_TPI     Trace Port Interface (TPI)
1054:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief    Type definitions for the Trace Port Interface (TPI)
1055:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
1056:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1057:ThirdParty/CMSIS/Include/core_cm4.h **** 
1058:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1059:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief  Structure type to access the Trace Port Interface Register (TPI).
1060:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1061:ThirdParty/CMSIS/Include/core_cm4.h **** typedef struct
1062:ThirdParty/CMSIS/Include/core_cm4.h **** {
1063:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Reg
1064:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Regis
1065:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED0[2U];
1066:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Reg
1067:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED1[55U];
1068:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register *
1069:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED2[131U];
1070:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Regis
1071:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Regi
1072:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counte
1073:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED3[759U];
ARM GAS  /tmp/ccoErako.s 			page 298


1074:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER Register */
1075:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
1076:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
1077:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED4[1U];
1078:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
1079:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
1080:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
1081:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED5[39U];
1082:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
1083:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
1084:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED7[8U];
1085:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
1086:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
1087:ThirdParty/CMSIS/Include/core_cm4.h **** } TPI_Type;
1088:ThirdParty/CMSIS/Include/core_cm4.h **** 
1089:ThirdParty/CMSIS/Include/core_cm4.h **** /* TPI Asynchronous Clock Prescaler Register Definitions */
1090:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACP
1091:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACP
1092:ThirdParty/CMSIS/Include/core_cm4.h **** 
1093:ThirdParty/CMSIS/Include/core_cm4.h **** /* TPI Selected Pin Protocol Register Definitions */
1094:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPP
1095:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPP
1096:ThirdParty/CMSIS/Include/core_cm4.h **** 
1097:ThirdParty/CMSIS/Include/core_cm4.h **** /* TPI Formatter and Flush Status Register Definitions */
1098:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFS
1099:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFS
1100:ThirdParty/CMSIS/Include/core_cm4.h **** 
1101:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFS
1102:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFS
1103:ThirdParty/CMSIS/Include/core_cm4.h **** 
1104:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFS
1105:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFS
1106:ThirdParty/CMSIS/Include/core_cm4.h **** 
1107:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFS
1108:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFS
1109:ThirdParty/CMSIS/Include/core_cm4.h **** 
1110:ThirdParty/CMSIS/Include/core_cm4.h **** /* TPI Formatter and Flush Control Register Definitions */
1111:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFC
1112:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFC
1113:ThirdParty/CMSIS/Include/core_cm4.h **** 
1114:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFC
1115:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFC
1116:ThirdParty/CMSIS/Include/core_cm4.h **** 
1117:ThirdParty/CMSIS/Include/core_cm4.h **** /* TPI TRIGGER Register Definitions */
1118:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRI
1119:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRI
1120:ThirdParty/CMSIS/Include/core_cm4.h **** 
1121:ThirdParty/CMSIS/Include/core_cm4.h **** /* TPI Integration ETM Data Register Definitions (FIFO0) */
1122:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIF
1123:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIF
1124:ThirdParty/CMSIS/Include/core_cm4.h **** 
1125:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIF
1126:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIF
1127:ThirdParty/CMSIS/Include/core_cm4.h **** 
1128:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIF
1129:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIF
1130:ThirdParty/CMSIS/Include/core_cm4.h **** 
ARM GAS  /tmp/ccoErako.s 			page 299


1131:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIF
1132:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIF
1133:ThirdParty/CMSIS/Include/core_cm4.h **** 
1134:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIF
1135:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIF
1136:ThirdParty/CMSIS/Include/core_cm4.h **** 
1137:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIF
1138:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIF
1139:ThirdParty/CMSIS/Include/core_cm4.h **** 
1140:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIF
1141:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIF
1142:ThirdParty/CMSIS/Include/core_cm4.h **** 
1143:ThirdParty/CMSIS/Include/core_cm4.h **** /* TPI ITATBCTR2 Register Definitions */
1144:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_ITATBCTR2_ATREADY2_Pos          0U                                         /*!< TPI ITA
1145:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_ITATBCTR2_ATREADY2_Msk         (0x1UL /*<< TPI_ITATBCTR2_ATREADY2_Pos*/)   /*!< TPI ITA
1146:ThirdParty/CMSIS/Include/core_cm4.h **** 
1147:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_ITATBCTR2_ATREADY1_Pos          0U                                         /*!< TPI ITA
1148:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_ITATBCTR2_ATREADY1_Msk         (0x1UL /*<< TPI_ITATBCTR2_ATREADY1_Pos*/)   /*!< TPI ITA
1149:ThirdParty/CMSIS/Include/core_cm4.h **** 
1150:ThirdParty/CMSIS/Include/core_cm4.h **** /* TPI Integration ITM Data Register Definitions (FIFO1) */
1151:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIF
1152:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIF
1153:ThirdParty/CMSIS/Include/core_cm4.h **** 
1154:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIF
1155:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIF
1156:ThirdParty/CMSIS/Include/core_cm4.h **** 
1157:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIF
1158:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIF
1159:ThirdParty/CMSIS/Include/core_cm4.h **** 
1160:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIF
1161:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIF
1162:ThirdParty/CMSIS/Include/core_cm4.h **** 
1163:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIF
1164:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIF
1165:ThirdParty/CMSIS/Include/core_cm4.h **** 
1166:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIF
1167:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIF
1168:ThirdParty/CMSIS/Include/core_cm4.h **** 
1169:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIF
1170:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIF
1171:ThirdParty/CMSIS/Include/core_cm4.h **** 
1172:ThirdParty/CMSIS/Include/core_cm4.h **** /* TPI ITATBCTR0 Register Definitions */
1173:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_ITATBCTR0_ATREADY2_Pos          0U                                         /*!< TPI ITA
1174:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_ITATBCTR0_ATREADY2_Msk         (0x1UL /*<< TPI_ITATBCTR0_ATREADY2_Pos*/)   /*!< TPI ITA
1175:ThirdParty/CMSIS/Include/core_cm4.h **** 
1176:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_ITATBCTR0_ATREADY1_Pos          0U                                         /*!< TPI ITA
1177:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_ITATBCTR0_ATREADY1_Msk         (0x1UL /*<< TPI_ITATBCTR0_ATREADY1_Pos*/)   /*!< TPI ITA
1178:ThirdParty/CMSIS/Include/core_cm4.h **** 
1179:ThirdParty/CMSIS/Include/core_cm4.h **** /* TPI Integration Mode Control Register Definitions */
1180:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITC
1181:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_ITCTRL_Mode_Msk                (0x3UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITC
1182:ThirdParty/CMSIS/Include/core_cm4.h **** 
1183:ThirdParty/CMSIS/Include/core_cm4.h **** /* TPI DEVID Register Definitions */
1184:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEV
1185:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEV
1186:ThirdParty/CMSIS/Include/core_cm4.h **** 
1187:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEV
ARM GAS  /tmp/ccoErako.s 			page 300


1188:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEV
1189:ThirdParty/CMSIS/Include/core_cm4.h **** 
1190:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEV
1191:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEV
1192:ThirdParty/CMSIS/Include/core_cm4.h **** 
1193:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEV
1194:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEV
1195:ThirdParty/CMSIS/Include/core_cm4.h **** 
1196:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEV
1197:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEV
1198:ThirdParty/CMSIS/Include/core_cm4.h **** 
1199:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEV
1200:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEV
1201:ThirdParty/CMSIS/Include/core_cm4.h **** 
1202:ThirdParty/CMSIS/Include/core_cm4.h **** /* TPI DEVTYPE Register Definitions */
1203:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVTYPE_SubType_Pos             4U                                         /*!< TPI DEV
1204:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEV
1205:ThirdParty/CMSIS/Include/core_cm4.h **** 
1206:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVTYPE_MajorType_Pos           0U                                         /*!< TPI DEV
1207:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEV
1208:ThirdParty/CMSIS/Include/core_cm4.h **** 
1209:ThirdParty/CMSIS/Include/core_cm4.h **** /*@}*/ /* end of group CMSIS_TPI */
1210:ThirdParty/CMSIS/Include/core_cm4.h **** 
1211:ThirdParty/CMSIS/Include/core_cm4.h **** 
1212:ThirdParty/CMSIS/Include/core_cm4.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
1213:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1214:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup  CMSIS_core_register
1215:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
1216:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
1217:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
1218:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1219:ThirdParty/CMSIS/Include/core_cm4.h **** 
1220:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1221:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
1222:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1223:ThirdParty/CMSIS/Include/core_cm4.h **** typedef struct
1224:ThirdParty/CMSIS/Include/core_cm4.h **** {
1225:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
1226:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
1227:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
1228:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
1229:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
1230:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address 
1231:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and
1232:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address 
1233:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and
1234:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address 
1235:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and
1236:ThirdParty/CMSIS/Include/core_cm4.h **** } MPU_Type;
1237:ThirdParty/CMSIS/Include/core_cm4.h **** 
1238:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_TYPE_RALIASES                  4U
1239:ThirdParty/CMSIS/Include/core_cm4.h **** 
1240:ThirdParty/CMSIS/Include/core_cm4.h **** /* MPU Type Register Definitions */
1241:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
1242:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
1243:ThirdParty/CMSIS/Include/core_cm4.h **** 
1244:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
ARM GAS  /tmp/ccoErako.s 			page 301


1245:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
1246:ThirdParty/CMSIS/Include/core_cm4.h **** 
1247:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
1248:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
1249:ThirdParty/CMSIS/Include/core_cm4.h **** 
1250:ThirdParty/CMSIS/Include/core_cm4.h **** /* MPU Control Register Definitions */
1251:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
1252:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
1253:ThirdParty/CMSIS/Include/core_cm4.h **** 
1254:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
1255:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
1256:ThirdParty/CMSIS/Include/core_cm4.h **** 
1257:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
1258:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
1259:ThirdParty/CMSIS/Include/core_cm4.h **** 
1260:ThirdParty/CMSIS/Include/core_cm4.h **** /* MPU Region Number Register Definitions */
1261:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
1262:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
1263:ThirdParty/CMSIS/Include/core_cm4.h **** 
1264:ThirdParty/CMSIS/Include/core_cm4.h **** /* MPU Region Base Address Register Definitions */
1265:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU 
1266:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU 
1267:ThirdParty/CMSIS/Include/core_cm4.h **** 
1268:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
1269:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
1270:ThirdParty/CMSIS/Include/core_cm4.h **** 
1271:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
1272:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
1273:ThirdParty/CMSIS/Include/core_cm4.h **** 
1274:ThirdParty/CMSIS/Include/core_cm4.h **** /* MPU Region Attribute and Size Register Definitions */
1275:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
1276:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
1277:ThirdParty/CMSIS/Include/core_cm4.h **** 
1278:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
1279:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
1280:ThirdParty/CMSIS/Include/core_cm4.h **** 
1281:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
1282:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
1283:ThirdParty/CMSIS/Include/core_cm4.h **** 
1284:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
1285:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
1286:ThirdParty/CMSIS/Include/core_cm4.h **** 
1287:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
1288:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
1289:ThirdParty/CMSIS/Include/core_cm4.h **** 
1290:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
1291:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
1292:ThirdParty/CMSIS/Include/core_cm4.h **** 
1293:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
1294:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
1295:ThirdParty/CMSIS/Include/core_cm4.h **** 
1296:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
1297:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
1298:ThirdParty/CMSIS/Include/core_cm4.h **** 
1299:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
1300:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
1301:ThirdParty/CMSIS/Include/core_cm4.h **** 
ARM GAS  /tmp/ccoErako.s 			page 302


1302:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
1303:ThirdParty/CMSIS/Include/core_cm4.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
1304:ThirdParty/CMSIS/Include/core_cm4.h **** 
1305:ThirdParty/CMSIS/Include/core_cm4.h **** /*@} end of group CMSIS_MPU */
1306:ThirdParty/CMSIS/Include/core_cm4.h **** #endif /* defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U) */
1307:ThirdParty/CMSIS/Include/core_cm4.h **** 
1308:ThirdParty/CMSIS/Include/core_cm4.h **** 
1309:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1310:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup  CMSIS_core_register
1311:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup CMSIS_FPU     Floating Point Unit (FPU)
1312:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief    Type definitions for the Floating Point Unit (FPU)
1313:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
1314:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1315:ThirdParty/CMSIS/Include/core_cm4.h **** 
1316:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1317:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief  Structure type to access the Floating Point Unit (FPU).
1318:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1319:ThirdParty/CMSIS/Include/core_cm4.h **** typedef struct
1320:ThirdParty/CMSIS/Include/core_cm4.h **** {
1321:ThirdParty/CMSIS/Include/core_cm4.h ****         uint32_t RESERVED0[1U];
1322:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control R
1323:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address R
1324:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Co
1325:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 
1326:ThirdParty/CMSIS/Include/core_cm4.h ****   __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 
1327:ThirdParty/CMSIS/Include/core_cm4.h **** } FPU_Type;
1328:ThirdParty/CMSIS/Include/core_cm4.h **** 
1329:ThirdParty/CMSIS/Include/core_cm4.h **** /* Floating-Point Context Control Register Definitions */
1330:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCC
1331:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCC
1332:ThirdParty/CMSIS/Include/core_cm4.h **** 
1333:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCC
1334:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCC
1335:ThirdParty/CMSIS/Include/core_cm4.h **** 
1336:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCC
1337:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCC
1338:ThirdParty/CMSIS/Include/core_cm4.h **** 
1339:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCC
1340:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCC
1341:ThirdParty/CMSIS/Include/core_cm4.h **** 
1342:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCC
1343:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCC
1344:ThirdParty/CMSIS/Include/core_cm4.h **** 
1345:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCC
1346:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCC
1347:ThirdParty/CMSIS/Include/core_cm4.h **** 
1348:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCC
1349:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCC
1350:ThirdParty/CMSIS/Include/core_cm4.h **** 
1351:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCC
1352:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCC
1353:ThirdParty/CMSIS/Include/core_cm4.h **** 
1354:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCC
1355:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCC
1356:ThirdParty/CMSIS/Include/core_cm4.h **** 
1357:ThirdParty/CMSIS/Include/core_cm4.h **** /* Floating-Point Context Address Register Definitions */
1358:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCA
ARM GAS  /tmp/ccoErako.s 			page 303


1359:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCA
1360:ThirdParty/CMSIS/Include/core_cm4.h **** 
1361:ThirdParty/CMSIS/Include/core_cm4.h **** /* Floating-Point Default Status Control Register Definitions */
1362:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDS
1363:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDS
1364:ThirdParty/CMSIS/Include/core_cm4.h **** 
1365:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDS
1366:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDS
1367:ThirdParty/CMSIS/Include/core_cm4.h **** 
1368:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDS
1369:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDS
1370:ThirdParty/CMSIS/Include/core_cm4.h **** 
1371:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDS
1372:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDS
1373:ThirdParty/CMSIS/Include/core_cm4.h **** 
1374:ThirdParty/CMSIS/Include/core_cm4.h **** /* Media and FP Feature Register 0 Definitions */
1375:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR
1376:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR
1377:ThirdParty/CMSIS/Include/core_cm4.h **** 
1378:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR
1379:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR
1380:ThirdParty/CMSIS/Include/core_cm4.h **** 
1381:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR
1382:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR
1383:ThirdParty/CMSIS/Include/core_cm4.h **** 
1384:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR
1385:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR
1386:ThirdParty/CMSIS/Include/core_cm4.h **** 
1387:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR
1388:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR
1389:ThirdParty/CMSIS/Include/core_cm4.h **** 
1390:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR
1391:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR
1392:ThirdParty/CMSIS/Include/core_cm4.h **** 
1393:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR
1394:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR
1395:ThirdParty/CMSIS/Include/core_cm4.h **** 
1396:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR
1397:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR
1398:ThirdParty/CMSIS/Include/core_cm4.h **** 
1399:ThirdParty/CMSIS/Include/core_cm4.h **** /* Media and FP Feature Register 1 Definitions */
1400:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR
1401:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR
1402:ThirdParty/CMSIS/Include/core_cm4.h **** 
1403:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR
1404:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR
1405:ThirdParty/CMSIS/Include/core_cm4.h **** 
1406:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR
1407:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR
1408:ThirdParty/CMSIS/Include/core_cm4.h **** 
1409:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR
1410:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR
1411:ThirdParty/CMSIS/Include/core_cm4.h **** 
1412:ThirdParty/CMSIS/Include/core_cm4.h **** /*@} end of group CMSIS_FPU */
1413:ThirdParty/CMSIS/Include/core_cm4.h **** 
1414:ThirdParty/CMSIS/Include/core_cm4.h **** 
1415:ThirdParty/CMSIS/Include/core_cm4.h **** /**
ARM GAS  /tmp/ccoErako.s 			page 304


1416:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup  CMSIS_core_register
1417:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
1418:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief    Type definitions for the Core Debug Registers
1419:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
1420:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1421:ThirdParty/CMSIS/Include/core_cm4.h **** 
1422:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1423:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief  Structure type to access the Core Debug Register (CoreDebug).
1424:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1425:ThirdParty/CMSIS/Include/core_cm4.h **** typedef struct
1426:ThirdParty/CMSIS/Include/core_cm4.h **** {
1427:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status
1428:ThirdParty/CMSIS/Include/core_cm4.h ****   __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Reg
1429:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Registe
1430:ThirdParty/CMSIS/Include/core_cm4.h ****   __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Cont
1431:ThirdParty/CMSIS/Include/core_cm4.h **** } CoreDebug_Type;
1432:ThirdParty/CMSIS/Include/core_cm4.h **** 
1433:ThirdParty/CMSIS/Include/core_cm4.h **** /* Debug Halting Control and Status Register Definitions */
1434:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< Core
1435:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< Core
1436:ThirdParty/CMSIS/Include/core_cm4.h **** 
1437:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< Core
1438:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< Core
1439:ThirdParty/CMSIS/Include/core_cm4.h **** 
1440:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< Core
1441:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< Core
1442:ThirdParty/CMSIS/Include/core_cm4.h **** 
1443:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< Core
1444:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< Core
1445:ThirdParty/CMSIS/Include/core_cm4.h **** 
1446:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< Core
1447:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< Core
1448:ThirdParty/CMSIS/Include/core_cm4.h **** 
1449:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< Core
1450:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< Core
1451:ThirdParty/CMSIS/Include/core_cm4.h **** 
1452:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< Core
1453:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< Core
1454:ThirdParty/CMSIS/Include/core_cm4.h **** 
1455:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< Core
1456:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< Core
1457:ThirdParty/CMSIS/Include/core_cm4.h **** 
1458:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< Core
1459:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< Core
1460:ThirdParty/CMSIS/Include/core_cm4.h **** 
1461:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< Core
1462:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< Core
1463:ThirdParty/CMSIS/Include/core_cm4.h **** 
1464:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< Core
1465:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< Core
1466:ThirdParty/CMSIS/Include/core_cm4.h **** 
1467:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< Core
1468:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< Core
1469:ThirdParty/CMSIS/Include/core_cm4.h **** 
1470:ThirdParty/CMSIS/Include/core_cm4.h **** /* Debug Core Register Selector Register Definitions */
1471:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< Core
1472:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< Core
ARM GAS  /tmp/ccoErako.s 			page 305


1473:ThirdParty/CMSIS/Include/core_cm4.h **** 
1474:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< Core
1475:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< Core
1476:ThirdParty/CMSIS/Include/core_cm4.h **** 
1477:ThirdParty/CMSIS/Include/core_cm4.h **** /* Debug Exception and Monitor Control Register Definitions */
1478:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< Core
1479:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< Core
1480:ThirdParty/CMSIS/Include/core_cm4.h **** 
1481:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< Core
1482:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< Core
1483:ThirdParty/CMSIS/Include/core_cm4.h **** 
1484:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< Core
1485:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< Core
1486:ThirdParty/CMSIS/Include/core_cm4.h **** 
1487:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< Core
1488:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< Core
1489:ThirdParty/CMSIS/Include/core_cm4.h **** 
1490:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< Core
1491:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< Core
1492:ThirdParty/CMSIS/Include/core_cm4.h **** 
1493:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< Core
1494:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< Core
1495:ThirdParty/CMSIS/Include/core_cm4.h **** 
1496:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< Core
1497:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< Core
1498:ThirdParty/CMSIS/Include/core_cm4.h **** 
1499:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< Core
1500:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< Core
1501:ThirdParty/CMSIS/Include/core_cm4.h **** 
1502:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< Core
1503:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< Core
1504:ThirdParty/CMSIS/Include/core_cm4.h **** 
1505:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< Core
1506:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< Core
1507:ThirdParty/CMSIS/Include/core_cm4.h **** 
1508:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< Core
1509:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< Core
1510:ThirdParty/CMSIS/Include/core_cm4.h **** 
1511:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< Core
1512:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< Core
1513:ThirdParty/CMSIS/Include/core_cm4.h **** 
1514:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< Core
1515:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< Core
1516:ThirdParty/CMSIS/Include/core_cm4.h **** 
1517:ThirdParty/CMSIS/Include/core_cm4.h **** /*@} end of group CMSIS_CoreDebug */
1518:ThirdParty/CMSIS/Include/core_cm4.h **** 
1519:ThirdParty/CMSIS/Include/core_cm4.h **** 
1520:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1521:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup    CMSIS_core_register
1522:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
1523:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
1524:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
1525:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1526:ThirdParty/CMSIS/Include/core_cm4.h **** 
1527:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1528:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
1529:ThirdParty/CMSIS/Include/core_cm4.h ****   \param[in] field  Name of the register bit field.
ARM GAS  /tmp/ccoErako.s 			page 306


1530:ThirdParty/CMSIS/Include/core_cm4.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
1531:ThirdParty/CMSIS/Include/core_cm4.h ****   \return           Masked and shifted value.
1532:ThirdParty/CMSIS/Include/core_cm4.h **** */
1533:ThirdParty/CMSIS/Include/core_cm4.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
1534:ThirdParty/CMSIS/Include/core_cm4.h **** 
1535:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1536:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief     Mask and shift a register value to extract a bit filed value.
1537:ThirdParty/CMSIS/Include/core_cm4.h ****   \param[in] field  Name of the register bit field.
1538:ThirdParty/CMSIS/Include/core_cm4.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
1539:ThirdParty/CMSIS/Include/core_cm4.h ****   \return           Masked and shifted bit field value.
1540:ThirdParty/CMSIS/Include/core_cm4.h **** */
1541:ThirdParty/CMSIS/Include/core_cm4.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
1542:ThirdParty/CMSIS/Include/core_cm4.h **** 
1543:ThirdParty/CMSIS/Include/core_cm4.h **** /*@} end of group CMSIS_core_bitfield */
1544:ThirdParty/CMSIS/Include/core_cm4.h **** 
1545:ThirdParty/CMSIS/Include/core_cm4.h **** 
1546:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1547:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup    CMSIS_core_register
1548:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup   CMSIS_core_base     Core Definitions
1549:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief      Definitions for base addresses, unions, and structures.
1550:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
1551:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1552:ThirdParty/CMSIS/Include/core_cm4.h **** 
1553:ThirdParty/CMSIS/Include/core_cm4.h **** /* Memory mapping of Core Hardware */
1554:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
1555:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
1556:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
1557:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
1558:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address 
1559:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
1560:ThirdParty/CMSIS/Include/core_cm4.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
1561:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
1562:ThirdParty/CMSIS/Include/core_cm4.h **** 
1563:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register 
1564:ThirdParty/CMSIS/Include/core_cm4.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
1565:ThirdParty/CMSIS/Include/core_cm4.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
1566:ThirdParty/CMSIS/Include/core_cm4.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
1567:ThirdParty/CMSIS/Include/core_cm4.h **** #define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct
1568:ThirdParty/CMSIS/Include/core_cm4.h **** #define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct
1569:ThirdParty/CMSIS/Include/core_cm4.h **** #define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct
1570:ThirdParty/CMSIS/Include/core_cm4.h **** #define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration
1571:ThirdParty/CMSIS/Include/core_cm4.h **** 
1572:ThirdParty/CMSIS/Include/core_cm4.h **** #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
1573:ThirdParty/CMSIS/Include/core_cm4.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
1574:ThirdParty/CMSIS/Include/core_cm4.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
1575:ThirdParty/CMSIS/Include/core_cm4.h **** #endif
1576:ThirdParty/CMSIS/Include/core_cm4.h **** 
1577:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU_BASE            (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
1578:ThirdParty/CMSIS/Include/core_cm4.h **** #define FPU                 ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
1579:ThirdParty/CMSIS/Include/core_cm4.h **** 
1580:ThirdParty/CMSIS/Include/core_cm4.h **** /*@} */
1581:ThirdParty/CMSIS/Include/core_cm4.h **** 
1582:ThirdParty/CMSIS/Include/core_cm4.h **** 
1583:ThirdParty/CMSIS/Include/core_cm4.h **** 
1584:ThirdParty/CMSIS/Include/core_cm4.h **** /*******************************************************************************
1585:ThirdParty/CMSIS/Include/core_cm4.h ****  *                Hardware Abstraction Layer
1586:ThirdParty/CMSIS/Include/core_cm4.h ****   Core Function Interface contains:
ARM GAS  /tmp/ccoErako.s 			page 307


1587:ThirdParty/CMSIS/Include/core_cm4.h ****   - Core NVIC Functions
1588:ThirdParty/CMSIS/Include/core_cm4.h ****   - Core SysTick Functions
1589:ThirdParty/CMSIS/Include/core_cm4.h ****   - Core Debug Functions
1590:ThirdParty/CMSIS/Include/core_cm4.h ****   - Core Register Access Functions
1591:ThirdParty/CMSIS/Include/core_cm4.h ****  ******************************************************************************/
1592:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1593:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
1594:ThirdParty/CMSIS/Include/core_cm4.h **** */
1595:ThirdParty/CMSIS/Include/core_cm4.h **** 
1596:ThirdParty/CMSIS/Include/core_cm4.h **** 
1597:ThirdParty/CMSIS/Include/core_cm4.h **** 
1598:ThirdParty/CMSIS/Include/core_cm4.h **** /* ##########################   NVIC functions  #################################### */
1599:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1600:ThirdParty/CMSIS/Include/core_cm4.h ****   \ingroup  CMSIS_Core_FunctionInterface
1601:ThirdParty/CMSIS/Include/core_cm4.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
1602:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
1603:ThirdParty/CMSIS/Include/core_cm4.h ****   @{
1604:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1605:ThirdParty/CMSIS/Include/core_cm4.h **** 
1606:ThirdParty/CMSIS/Include/core_cm4.h **** #ifdef CMSIS_NVIC_VIRTUAL
1607:ThirdParty/CMSIS/Include/core_cm4.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
1608:ThirdParty/CMSIS/Include/core_cm4.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
1609:ThirdParty/CMSIS/Include/core_cm4.h ****   #endif
1610:ThirdParty/CMSIS/Include/core_cm4.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
1611:ThirdParty/CMSIS/Include/core_cm4.h **** #else
1612:ThirdParty/CMSIS/Include/core_cm4.h ****   #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
1613:ThirdParty/CMSIS/Include/core_cm4.h ****   #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
1614:ThirdParty/CMSIS/Include/core_cm4.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
1615:ThirdParty/CMSIS/Include/core_cm4.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
1616:ThirdParty/CMSIS/Include/core_cm4.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
1617:ThirdParty/CMSIS/Include/core_cm4.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
1618:ThirdParty/CMSIS/Include/core_cm4.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
1619:ThirdParty/CMSIS/Include/core_cm4.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
1620:ThirdParty/CMSIS/Include/core_cm4.h ****   #define NVIC_GetActive              __NVIC_GetActive
1621:ThirdParty/CMSIS/Include/core_cm4.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
1622:ThirdParty/CMSIS/Include/core_cm4.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
1623:ThirdParty/CMSIS/Include/core_cm4.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
1624:ThirdParty/CMSIS/Include/core_cm4.h **** #endif /* CMSIS_NVIC_VIRTUAL */
1625:ThirdParty/CMSIS/Include/core_cm4.h **** 
1626:ThirdParty/CMSIS/Include/core_cm4.h **** #ifdef CMSIS_VECTAB_VIRTUAL
1627:ThirdParty/CMSIS/Include/core_cm4.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
1628:ThirdParty/CMSIS/Include/core_cm4.h ****    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
1629:ThirdParty/CMSIS/Include/core_cm4.h ****   #endif
1630:ThirdParty/CMSIS/Include/core_cm4.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
1631:ThirdParty/CMSIS/Include/core_cm4.h **** #else
1632:ThirdParty/CMSIS/Include/core_cm4.h ****   #define NVIC_SetVector              __NVIC_SetVector
1633:ThirdParty/CMSIS/Include/core_cm4.h ****   #define NVIC_GetVector              __NVIC_GetVector
1634:ThirdParty/CMSIS/Include/core_cm4.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
1635:ThirdParty/CMSIS/Include/core_cm4.h **** 
1636:ThirdParty/CMSIS/Include/core_cm4.h **** #define NVIC_USER_IRQ_OFFSET          16
1637:ThirdParty/CMSIS/Include/core_cm4.h **** 
1638:ThirdParty/CMSIS/Include/core_cm4.h **** 
1639:ThirdParty/CMSIS/Include/core_cm4.h **** /* The following EXC_RETURN values are saved the LR on exception entry */
1640:ThirdParty/CMSIS/Include/core_cm4.h **** #define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after ret
1641:ThirdParty/CMSIS/Include/core_cm4.h **** #define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after retu
1642:ThirdParty/CMSIS/Include/core_cm4.h **** #define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after retu
1643:ThirdParty/CMSIS/Include/core_cm4.h **** #define EXC_RETURN_HANDLER_FPU     (0xFFFFFFE1UL)     /* return to Handler mode, uses MSP after ret
ARM GAS  /tmp/ccoErako.s 			page 308


1644:ThirdParty/CMSIS/Include/core_cm4.h **** #define EXC_RETURN_THREAD_MSP_FPU  (0xFFFFFFE9UL)     /* return to Thread mode, uses MSP after retu
1645:ThirdParty/CMSIS/Include/core_cm4.h **** #define EXC_RETURN_THREAD_PSP_FPU  (0xFFFFFFEDUL)     /* return to Thread mode, uses PSP after retu
1646:ThirdParty/CMSIS/Include/core_cm4.h **** 
1647:ThirdParty/CMSIS/Include/core_cm4.h **** 
1648:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1649:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Set Priority Grouping
1650:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Sets the priority grouping field using the required unlock sequence.
1651:ThirdParty/CMSIS/Include/core_cm4.h ****            The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
1652:ThirdParty/CMSIS/Include/core_cm4.h ****            Only values from 0..7 are used.
1653:ThirdParty/CMSIS/Include/core_cm4.h ****            In case of a conflict between priority grouping and available
1654:ThirdParty/CMSIS/Include/core_cm4.h ****            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
1655:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]      PriorityGroup  Priority grouping field.
1656:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1657:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
1658:ThirdParty/CMSIS/Include/core_cm4.h **** {
1659:ThirdParty/CMSIS/Include/core_cm4.h ****   uint32_t reg_value;
1660:ThirdParty/CMSIS/Include/core_cm4.h ****   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 a
1661:ThirdParty/CMSIS/Include/core_cm4.h **** 
1662:ThirdParty/CMSIS/Include/core_cm4.h ****   reg_value  =  SCB->AIRCR;                                                   /* read old register 
1663:ThirdParty/CMSIS/Include/core_cm4.h ****   reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to chan
1664:ThirdParty/CMSIS/Include/core_cm4.h ****   reg_value  =  (reg_value                                   |
1665:ThirdParty/CMSIS/Include/core_cm4.h ****                 ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
1666:ThirdParty/CMSIS/Include/core_cm4.h ****                 (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key a
1667:ThirdParty/CMSIS/Include/core_cm4.h ****   SCB->AIRCR =  reg_value;
1668:ThirdParty/CMSIS/Include/core_cm4.h **** }
1669:ThirdParty/CMSIS/Include/core_cm4.h **** 
1670:ThirdParty/CMSIS/Include/core_cm4.h **** 
1671:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1672:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Get Priority Grouping
1673:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Reads the priority grouping field from the NVIC Interrupt Controller.
1674:ThirdParty/CMSIS/Include/core_cm4.h ****   \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
1675:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1676:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
1677:ThirdParty/CMSIS/Include/core_cm4.h **** {
1678:ThirdParty/CMSIS/Include/core_cm4.h ****   return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
1679:ThirdParty/CMSIS/Include/core_cm4.h **** }
1680:ThirdParty/CMSIS/Include/core_cm4.h **** 
1681:ThirdParty/CMSIS/Include/core_cm4.h **** 
1682:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1683:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Enable Interrupt
1684:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
1685:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]      IRQn  Device specific interrupt number.
1686:ThirdParty/CMSIS/Include/core_cm4.h ****   \note    IRQn must not be negative.
1687:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1688:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
1689:ThirdParty/CMSIS/Include/core_cm4.h **** {
1690:ThirdParty/CMSIS/Include/core_cm4.h ****   if ((int32_t)(IRQn) >= 0)
1691:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1692:ThirdParty/CMSIS/Include/core_cm4.h ****     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
1693:ThirdParty/CMSIS/Include/core_cm4.h ****   }
1694:ThirdParty/CMSIS/Include/core_cm4.h **** }
1695:ThirdParty/CMSIS/Include/core_cm4.h **** 
1696:ThirdParty/CMSIS/Include/core_cm4.h **** 
1697:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1698:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Get Interrupt Enable status
1699:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
1700:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]      IRQn  Device specific interrupt number.
ARM GAS  /tmp/ccoErako.s 			page 309


1701:ThirdParty/CMSIS/Include/core_cm4.h ****   \return             0  Interrupt is not enabled.
1702:ThirdParty/CMSIS/Include/core_cm4.h ****   \return             1  Interrupt is enabled.
1703:ThirdParty/CMSIS/Include/core_cm4.h ****   \note    IRQn must not be negative.
1704:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1705:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
1706:ThirdParty/CMSIS/Include/core_cm4.h **** {
1707:ThirdParty/CMSIS/Include/core_cm4.h ****   if ((int32_t)(IRQn) >= 0)
1708:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1709:ThirdParty/CMSIS/Include/core_cm4.h ****     return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL)
1710:ThirdParty/CMSIS/Include/core_cm4.h ****   }
1711:ThirdParty/CMSIS/Include/core_cm4.h ****   else
1712:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1713:ThirdParty/CMSIS/Include/core_cm4.h ****     return(0U);
1714:ThirdParty/CMSIS/Include/core_cm4.h ****   }
1715:ThirdParty/CMSIS/Include/core_cm4.h **** }
1716:ThirdParty/CMSIS/Include/core_cm4.h **** 
1717:ThirdParty/CMSIS/Include/core_cm4.h **** 
1718:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1719:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Disable Interrupt
1720:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Disables a device specific interrupt in the NVIC interrupt controller.
1721:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]      IRQn  Device specific interrupt number.
1722:ThirdParty/CMSIS/Include/core_cm4.h ****   \note    IRQn must not be negative.
1723:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1724:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
1725:ThirdParty/CMSIS/Include/core_cm4.h **** {
1726:ThirdParty/CMSIS/Include/core_cm4.h ****   if ((int32_t)(IRQn) >= 0)
1727:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1728:ThirdParty/CMSIS/Include/core_cm4.h ****     NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
1729:ThirdParty/CMSIS/Include/core_cm4.h ****     __DSB();
1730:ThirdParty/CMSIS/Include/core_cm4.h ****     __ISB();
1731:ThirdParty/CMSIS/Include/core_cm4.h ****   }
1732:ThirdParty/CMSIS/Include/core_cm4.h **** }
1733:ThirdParty/CMSIS/Include/core_cm4.h **** 
1734:ThirdParty/CMSIS/Include/core_cm4.h **** 
1735:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1736:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Get Pending Interrupt
1737:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Reads the NVIC pending register and returns the pending bit for the specified device spe
1738:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]      IRQn  Device specific interrupt number.
1739:ThirdParty/CMSIS/Include/core_cm4.h ****   \return             0  Interrupt status is not pending.
1740:ThirdParty/CMSIS/Include/core_cm4.h ****   \return             1  Interrupt status is pending.
1741:ThirdParty/CMSIS/Include/core_cm4.h ****   \note    IRQn must not be negative.
1742:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1743:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
1744:ThirdParty/CMSIS/Include/core_cm4.h **** {
1745:ThirdParty/CMSIS/Include/core_cm4.h ****   if ((int32_t)(IRQn) >= 0)
1746:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1747:ThirdParty/CMSIS/Include/core_cm4.h ****     return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL)
1748:ThirdParty/CMSIS/Include/core_cm4.h ****   }
1749:ThirdParty/CMSIS/Include/core_cm4.h ****   else
1750:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1751:ThirdParty/CMSIS/Include/core_cm4.h ****     return(0U);
1752:ThirdParty/CMSIS/Include/core_cm4.h ****   }
1753:ThirdParty/CMSIS/Include/core_cm4.h **** }
1754:ThirdParty/CMSIS/Include/core_cm4.h **** 
1755:ThirdParty/CMSIS/Include/core_cm4.h **** 
1756:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1757:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Set Pending Interrupt
ARM GAS  /tmp/ccoErako.s 			page 310


1758:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
1759:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]      IRQn  Device specific interrupt number.
1760:ThirdParty/CMSIS/Include/core_cm4.h ****   \note    IRQn must not be negative.
1761:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1762:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
1763:ThirdParty/CMSIS/Include/core_cm4.h **** {
1764:ThirdParty/CMSIS/Include/core_cm4.h ****   if ((int32_t)(IRQn) >= 0)
1765:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1766:ThirdParty/CMSIS/Include/core_cm4.h ****     NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
1767:ThirdParty/CMSIS/Include/core_cm4.h ****   }
1768:ThirdParty/CMSIS/Include/core_cm4.h **** }
1769:ThirdParty/CMSIS/Include/core_cm4.h **** 
1770:ThirdParty/CMSIS/Include/core_cm4.h **** 
1771:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1772:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Clear Pending Interrupt
1773:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
1774:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]      IRQn  Device specific interrupt number.
1775:ThirdParty/CMSIS/Include/core_cm4.h ****   \note    IRQn must not be negative.
1776:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1777:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
1778:ThirdParty/CMSIS/Include/core_cm4.h **** {
1779:ThirdParty/CMSIS/Include/core_cm4.h ****   if ((int32_t)(IRQn) >= 0)
1780:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1781:ThirdParty/CMSIS/Include/core_cm4.h ****     NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
1782:ThirdParty/CMSIS/Include/core_cm4.h ****   }
1783:ThirdParty/CMSIS/Include/core_cm4.h **** }
1784:ThirdParty/CMSIS/Include/core_cm4.h **** 
1785:ThirdParty/CMSIS/Include/core_cm4.h **** 
1786:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1787:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Get Active Interrupt
1788:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Reads the active register in the NVIC and returns the active bit for the device specific
1789:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]      IRQn  Device specific interrupt number.
1790:ThirdParty/CMSIS/Include/core_cm4.h ****   \return             0  Interrupt status is not active.
1791:ThirdParty/CMSIS/Include/core_cm4.h ****   \return             1  Interrupt status is active.
1792:ThirdParty/CMSIS/Include/core_cm4.h ****   \note    IRQn must not be negative.
1793:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1794:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
1795:ThirdParty/CMSIS/Include/core_cm4.h **** {
1796:ThirdParty/CMSIS/Include/core_cm4.h ****   if ((int32_t)(IRQn) >= 0)
1797:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1798:ThirdParty/CMSIS/Include/core_cm4.h ****     return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL)
1799:ThirdParty/CMSIS/Include/core_cm4.h ****   }
1800:ThirdParty/CMSIS/Include/core_cm4.h ****   else
1801:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1802:ThirdParty/CMSIS/Include/core_cm4.h ****     return(0U);
1803:ThirdParty/CMSIS/Include/core_cm4.h ****   }
1804:ThirdParty/CMSIS/Include/core_cm4.h **** }
1805:ThirdParty/CMSIS/Include/core_cm4.h **** 
1806:ThirdParty/CMSIS/Include/core_cm4.h **** 
1807:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1808:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Set Interrupt Priority
1809:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Sets the priority of a device specific interrupt or a processor exception.
1810:ThirdParty/CMSIS/Include/core_cm4.h ****            The interrupt number can be positive to specify a device specific interrupt,
1811:ThirdParty/CMSIS/Include/core_cm4.h ****            or negative to specify a processor exception.
1812:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]      IRQn  Interrupt number.
1813:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]  priority  Priority to set.
1814:ThirdParty/CMSIS/Include/core_cm4.h ****   \note    The priority cannot be set for every processor exception.
ARM GAS  /tmp/ccoErako.s 			page 311


1815:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1816:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
1817:ThirdParty/CMSIS/Include/core_cm4.h **** {
1818:ThirdParty/CMSIS/Include/core_cm4.h ****   if ((int32_t)(IRQn) >= 0)
1819:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1820:ThirdParty/CMSIS/Include/core_cm4.h ****     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (u
1821:ThirdParty/CMSIS/Include/core_cm4.h ****   }
1822:ThirdParty/CMSIS/Include/core_cm4.h ****   else
1823:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1824:ThirdParty/CMSIS/Include/core_cm4.h ****     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (u
1825:ThirdParty/CMSIS/Include/core_cm4.h ****   }
1826:ThirdParty/CMSIS/Include/core_cm4.h **** }
1827:ThirdParty/CMSIS/Include/core_cm4.h **** 
1828:ThirdParty/CMSIS/Include/core_cm4.h **** 
1829:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1830:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Get Interrupt Priority
1831:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Reads the priority of a device specific interrupt or a processor exception.
1832:ThirdParty/CMSIS/Include/core_cm4.h ****            The interrupt number can be positive to specify a device specific interrupt,
1833:ThirdParty/CMSIS/Include/core_cm4.h ****            or negative to specify a processor exception.
1834:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]   IRQn  Interrupt number.
1835:ThirdParty/CMSIS/Include/core_cm4.h ****   \return             Interrupt Priority.
1836:ThirdParty/CMSIS/Include/core_cm4.h ****                       Value is aligned automatically to the implemented priority bits of the microc
1837:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1838:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
1839:ThirdParty/CMSIS/Include/core_cm4.h **** {
1840:ThirdParty/CMSIS/Include/core_cm4.h **** 
1841:ThirdParty/CMSIS/Include/core_cm4.h ****   if ((int32_t)(IRQn) >= 0)
1842:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1843:ThirdParty/CMSIS/Include/core_cm4.h ****     return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
1844:ThirdParty/CMSIS/Include/core_cm4.h ****   }
1845:ThirdParty/CMSIS/Include/core_cm4.h ****   else
1846:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1847:ThirdParty/CMSIS/Include/core_cm4.h ****     return(((uint32_t)SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
1848:ThirdParty/CMSIS/Include/core_cm4.h ****   }
1849:ThirdParty/CMSIS/Include/core_cm4.h **** }
1850:ThirdParty/CMSIS/Include/core_cm4.h **** 
1851:ThirdParty/CMSIS/Include/core_cm4.h **** 
1852:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1853:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Encode Priority
1854:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Encodes the priority for an interrupt with the given priority group,
1855:ThirdParty/CMSIS/Include/core_cm4.h ****            preemptive priority value, and subpriority value.
1856:ThirdParty/CMSIS/Include/core_cm4.h ****            In case of a conflict between priority grouping and available
1857:ThirdParty/CMSIS/Include/core_cm4.h ****            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
1858:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]     PriorityGroup  Used priority group.
1859:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
1860:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]       SubPriority  Subpriority value (starting from 0).
1861:ThirdParty/CMSIS/Include/core_cm4.h ****   \return                        Encoded priority. Value can be used in the function \ref NVIC_SetP
1862:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1863:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uin
1864:ThirdParty/CMSIS/Include/core_cm4.h **** {
1865:ThirdParty/CMSIS/Include/core_cm4.h ****   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used   
1866:ThirdParty/CMSIS/Include/core_cm4.h ****   uint32_t PreemptPriorityBits;
1867:ThirdParty/CMSIS/Include/core_cm4.h ****   uint32_t SubPriorityBits;
1868:ThirdParty/CMSIS/Include/core_cm4.h **** 
1869:ThirdParty/CMSIS/Include/core_cm4.h ****   PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NV
1870:ThirdParty/CMSIS/Include/core_cm4.h ****   SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint
1871:ThirdParty/CMSIS/Include/core_cm4.h **** 
ARM GAS  /tmp/ccoErako.s 			page 312


1872:ThirdParty/CMSIS/Include/core_cm4.h ****   return (
1873:ThirdParty/CMSIS/Include/core_cm4.h ****            ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits
1874:ThirdParty/CMSIS/Include/core_cm4.h ****            ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
1875:ThirdParty/CMSIS/Include/core_cm4.h ****          );
1876:ThirdParty/CMSIS/Include/core_cm4.h **** }
1877:ThirdParty/CMSIS/Include/core_cm4.h **** 
1878:ThirdParty/CMSIS/Include/core_cm4.h **** 
1879:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1880:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Decode Priority
1881:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Decodes an interrupt priority value with a given priority group to
1882:ThirdParty/CMSIS/Include/core_cm4.h ****            preemptive priority value and subpriority value.
1883:ThirdParty/CMSIS/Include/core_cm4.h ****            In case of a conflict between priority grouping and available
1884:ThirdParty/CMSIS/Include/core_cm4.h ****            priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
1885:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC
1886:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]     PriorityGroup  Used priority group.
1887:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
1888:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [out]     pSubPriority  Subpriority value (starting from 0).
1889:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1890:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* cons
1891:ThirdParty/CMSIS/Include/core_cm4.h **** {
1892:ThirdParty/CMSIS/Include/core_cm4.h ****   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used   
1893:ThirdParty/CMSIS/Include/core_cm4.h ****   uint32_t PreemptPriorityBits;
1894:ThirdParty/CMSIS/Include/core_cm4.h ****   uint32_t SubPriorityBits;
1895:ThirdParty/CMSIS/Include/core_cm4.h **** 
1896:ThirdParty/CMSIS/Include/core_cm4.h ****   PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NV
1897:ThirdParty/CMSIS/Include/core_cm4.h ****   SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint
1898:ThirdParty/CMSIS/Include/core_cm4.h **** 
1899:ThirdParty/CMSIS/Include/core_cm4.h ****   *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1
1900:ThirdParty/CMSIS/Include/core_cm4.h ****   *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1
1901:ThirdParty/CMSIS/Include/core_cm4.h **** }
1902:ThirdParty/CMSIS/Include/core_cm4.h **** 
1903:ThirdParty/CMSIS/Include/core_cm4.h **** 
1904:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1905:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Set Interrupt Vector
1906:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Sets an interrupt vector in SRAM based interrupt vector table.
1907:ThirdParty/CMSIS/Include/core_cm4.h ****            The interrupt number can be positive to specify a device specific interrupt,
1908:ThirdParty/CMSIS/Include/core_cm4.h ****            or negative to specify a processor exception.
1909:ThirdParty/CMSIS/Include/core_cm4.h ****            VTOR must been relocated to SRAM before.
1910:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]   IRQn      Interrupt number
1911:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]   vector    Address of interrupt handler function
1912:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1913:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
1914:ThirdParty/CMSIS/Include/core_cm4.h **** {
1915:ThirdParty/CMSIS/Include/core_cm4.h ****   uint32_t *vectors = (uint32_t *)SCB->VTOR;
1916:ThirdParty/CMSIS/Include/core_cm4.h ****   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
1917:ThirdParty/CMSIS/Include/core_cm4.h **** }
1918:ThirdParty/CMSIS/Include/core_cm4.h **** 
1919:ThirdParty/CMSIS/Include/core_cm4.h **** 
1920:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1921:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   Get Interrupt Vector
1922:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Reads an interrupt vector from interrupt vector table.
1923:ThirdParty/CMSIS/Include/core_cm4.h ****            The interrupt number can be positive to specify a device specific interrupt,
1924:ThirdParty/CMSIS/Include/core_cm4.h ****            or negative to specify a processor exception.
1925:ThirdParty/CMSIS/Include/core_cm4.h ****   \param [in]   IRQn      Interrupt number.
1926:ThirdParty/CMSIS/Include/core_cm4.h ****   \return                 Address of interrupt handler function
1927:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1928:ThirdParty/CMSIS/Include/core_cm4.h **** __STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
ARM GAS  /tmp/ccoErako.s 			page 313


1929:ThirdParty/CMSIS/Include/core_cm4.h **** {
1930:ThirdParty/CMSIS/Include/core_cm4.h ****   uint32_t *vectors = (uint32_t *)SCB->VTOR;
1931:ThirdParty/CMSIS/Include/core_cm4.h ****   return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
1932:ThirdParty/CMSIS/Include/core_cm4.h **** }
1933:ThirdParty/CMSIS/Include/core_cm4.h **** 
1934:ThirdParty/CMSIS/Include/core_cm4.h **** 
1935:ThirdParty/CMSIS/Include/core_cm4.h **** /**
1936:ThirdParty/CMSIS/Include/core_cm4.h ****   \brief   System Reset
1937:ThirdParty/CMSIS/Include/core_cm4.h ****   \details Initiates a system reset request to reset the MCU.
1938:ThirdParty/CMSIS/Include/core_cm4.h ****  */
1939:ThirdParty/CMSIS/Include/core_cm4.h **** __NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
 6792              		.loc 21 1939 34 view .LVU1652
 6793              	.LBB1974:
1940:ThirdParty/CMSIS/Include/core_cm4.h **** {
1941:ThirdParty/CMSIS/Include/core_cm4.h ****   __DSB();                                                          /* Ensure all outstanding memor
 6794              		.loc 21 1941 3 view .LVU1653
 6795              	.LBB1975:
 6796              	.LBI1975:
 6797              		.file 22 "ThirdParty/CMSIS/Include/cmsis_gcc.h"
   1:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /*
   8:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  *
  10:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  *
  12:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  *
  16:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  *
  18:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
  24:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
  25:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
  28:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
  34:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  38:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccoErako.s 			page 314


  39:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  43:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  46:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  49:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  55:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  58:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  61:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  64:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  67:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  70:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  78:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  86:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  94:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
ARM GAS  /tmp/ccoErako.s 			page 315


  96:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 102:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 110:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 113:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 116:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 117:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 118:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:ThirdParty/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   @{
 122:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 123:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 124:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 125:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 129:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 131:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 133:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 134:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 135:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 136:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 140:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 142:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 144:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 145:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 146:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 147:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 148:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 151:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  /tmp/ccoErako.s 			page 316


 153:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 155:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 158:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 159:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 160:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 162:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 166:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 168:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 170:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 173:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 174:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 175:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 176:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 177:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 181:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 183:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 185:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 186:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 187:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 189:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 193:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 195:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 197:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 198:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 199:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 200:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 201:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 204:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 205:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 207:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 209:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
ARM GAS  /tmp/ccoErako.s 			page 317


 210:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 212:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 213:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 214:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 215:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 216:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 219:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 221:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 223:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 226:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 227:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 228:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 229:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 233:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 235:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 237:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 240:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 241:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 242:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 243:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 247:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 249:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 251:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 254:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 255:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 256:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 258:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 261:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 262:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 264:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 266:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
ARM GAS  /tmp/ccoErako.s 			page 318


 267:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 269:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 270:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 271:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 272:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 273:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 277:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 279:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 281:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 282:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 283:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 285:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 289:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 291:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 293:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 294:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 295:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 296:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 297:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 301:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 303:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 305:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 308:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 309:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 310:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 312:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 315:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 316:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 318:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 319:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 320:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 323:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  /tmp/ccoErako.s 			page 319


 324:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 325:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 326:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 327:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 331:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 333:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 335:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 336:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 337:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 339:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 343:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 345:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 347:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 348:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 349:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 350:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 352:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 356:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 358:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 360:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 363:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 364:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 365:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 366:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 370:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 372:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 374:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 375:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 376:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 377:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 378:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
ARM GAS  /tmp/ccoErako.s 			page 320


 381:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 382:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 384:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 385:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 386:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 387:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 388:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 389:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 390:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 391:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 393:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 397:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 399:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 401:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 404:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 405:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 406:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 407:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 408:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 412:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 414:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 416:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 417:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 418:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 420:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 424:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 426:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 428:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 429:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 430:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 431:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 432:ThirdParty/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:ThirdParty/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 434:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 435:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 436:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 437:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
ARM GAS  /tmp/ccoErako.s 			page 321


 438:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 439:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 441:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 443:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 444:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 445:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 446:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 447:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 450:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 452:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 454:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 455:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 456:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 457:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 458:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 460:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 461:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 463:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 464:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 465:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 466:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 467:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 468:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 469:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 470:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 472:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 475:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 476:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 478:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 479:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 480:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 482:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 483:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 484:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 485:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 486:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 487:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 488:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 489:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 491:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 493:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 494:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  /tmp/ccoErako.s 			page 322


 495:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 496:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 497:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 499:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 500:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 501:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 503:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 504:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 505:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 507:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 508:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 509:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 510:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 511:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 513:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 516:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 518:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 520:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 521:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 522:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 523:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 524:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 525:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 526:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 527:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 529:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 530:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 531:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 533:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 534:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 535:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 536:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 538:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 541:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 542:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 543:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 544:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 545:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 546:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 548:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 549:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 550:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 551:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccoErako.s 			page 323


 552:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 553:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 554:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 557:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 558:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 559:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 561:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 562:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 563:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 565:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 569:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 570:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 571:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 573:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 574:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 575:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 579:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 580:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:ThirdParty/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 582:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 583:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 584:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 586:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 587:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   mode.
 588:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   
 589:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 590:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 591:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 592:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 593:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 594:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 595:ThirdParty/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 596:ThirdParty/CMSIS/Include/cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 597:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 598:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #else
 599:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 600:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 601:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return result;
 602:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 603:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 604:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 605:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 606:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 607:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 608:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
ARM GAS  /tmp/ccoErako.s 			page 324


 609:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 610:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 611:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 612:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 613:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 614:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 615:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 616:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 617:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 618:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 619:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #else
 620:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 621:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 622:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return result;
 623:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 624:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 625:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 626:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 627:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 628:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 629:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 630:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 631:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 632:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   mode.
 633:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   
 634:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 635:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 636:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 637:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 638:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 639:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 640:ThirdParty/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 641:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 642:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 643:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #else
 644:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 645:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 646:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 647:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 648:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 649:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 650:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 651:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 652:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 654:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 655:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 656:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 657:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 658:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 659:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 660:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 661:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 662:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 663:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #else
 664:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 665:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  /tmp/ccoErako.s 			page 325


 666:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 667:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 668:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 669:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 670:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 671:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 672:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 673:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 674:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   mode.
 675:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 676:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 677:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 678:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 679:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 680:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 681:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 682:ThirdParty/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 683:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 684:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 685:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #else
 686:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 687:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 688:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return result;
 689:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 690:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 691:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 692:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 693:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 694:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 695:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 696:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 697:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 698:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 699:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 700:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 701:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 702:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 703:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 704:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 705:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 706:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 707:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #else
 708:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 709:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 710:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return result;
 711:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 712:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 713:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 714:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 715:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 716:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 717:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 718:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 719:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 720:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   mode.
 721:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 722:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
ARM GAS  /tmp/ccoErako.s 			page 326


 723:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 724:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 725:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 726:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 727:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 728:ThirdParty/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 729:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 730:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 731:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #else
 732:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 733:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 734:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 735:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 736:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 737:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 738:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 739:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 740:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 741:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 742:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 743:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 744:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 745:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 746:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 747:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 748:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 749:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 750:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 751:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #else
 752:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 753:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 754:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 755:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 756:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 757:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 758:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 759:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 760:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 761:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 762:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 763:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 764:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 765:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 766:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 767:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 768:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 769:ThirdParty/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 770:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
 771:ThirdParty/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 772:ThirdParty/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 773:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 774:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 775:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #else
 776:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 777:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 778:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 779:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
ARM GAS  /tmp/ccoErako.s 			page 327


 780:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 781:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #else
 782:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(0U);
 783:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 784:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 785:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 786:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 787:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 788:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 789:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 790:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 791:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 792:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 793:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 794:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 795:ThirdParty/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 796:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 797:ThirdParty/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 798:ThirdParty/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 799:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 800:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 801:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #else
 802:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 803:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 804:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #else
 805:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 806:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 807:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 808:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 809:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 810:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 811:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 812:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 813:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 814:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 815:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 816:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   @{
 817:ThirdParty/CMSIS/Include/cmsis_gcc.h **** */
 818:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 819:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 820:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 821:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 822:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 823:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 824:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 825:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 826:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #else
 827:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 828:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 829:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 830:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 831:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 832:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 833:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 834:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 835:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 836:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
ARM GAS  /tmp/ccoErako.s 			page 328


 837:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 838:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 839:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 840:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 841:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 842:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
 843:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 844:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 845:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 846:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 847:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 848:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 849:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 850:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 851:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 852:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 853:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 854:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 855:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 856:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 857:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 858:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 859:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 860:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 861:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 862:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 863:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 864:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 865:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 866:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 867:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 868:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 869:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 870:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 871:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 872:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 873:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 874:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 875:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 876:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 877:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 6798              		.loc 22 877 27 view .LVU1654
 6799              	.LBB1976:
 878:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 879:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 6800              		.loc 22 879 3 view .LVU1655
 6801              		.syntax unified
 6802              	@ 879 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 6803 0140 BFF34F8F 		dsb 0xF
 6804              	@ 0 "" 2
 6805              		.thumb
 6806              		.syntax unified
 6807              	.LBE1976:
 6808              	.LBE1975:
1942:ThirdParty/CMSIS/Include/core_cm4.h ****                                                                        buffered write are completed
1943:ThirdParty/CMSIS/Include/core_cm4.h ****   SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 6809              		.loc 21 1943 3 view .LVU1656
ARM GAS  /tmp/ccoErako.s 			page 329


1944:ThirdParty/CMSIS/Include/core_cm4.h ****                            (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 6810              		.loc 21 1944 34 is_stmt 0 view .LVU1657
 6811 0144 1A49     		ldr	r1, .L263
 6812 0146 CA68     		ldr	r2, [r1, #12]
 6813              		.loc 21 1944 40 view .LVU1658
 6814 0148 02F4E062 		and	r2, r2, #1792
 6815              		.loc 21 1944 66 view .LVU1659
 6816 014c 194B     		ldr	r3, .L263+4
 6817 014e 1343     		orrs	r3, r3, r2
1943:ThirdParty/CMSIS/Include/core_cm4.h ****                            (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 6818              		.loc 21 1943 15 view .LVU1660
 6819 0150 CB60     		str	r3, [r1, #12]
1945:ThirdParty/CMSIS/Include/core_cm4.h ****                             SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchange
1946:ThirdParty/CMSIS/Include/core_cm4.h ****   __DSB();                                                          /* Ensure completion of memory 
 6820              		.loc 21 1946 3 is_stmt 1 view .LVU1661
 6821              	.LBB1977:
 6822              	.LBI1977:
 877:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 6823              		.loc 22 877 27 view .LVU1662
 6824              	.LBB1978:
 6825              		.loc 22 879 3 view .LVU1663
 6826              		.syntax unified
 6827              	@ 879 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 6828 0152 BFF34F8F 		dsb 0xF
 6829              	@ 0 "" 2
 6830              		.thumb
 6831              		.syntax unified
 6832              	.L260:
 6833              	.LBE1978:
 6834              	.LBE1977:
1947:ThirdParty/CMSIS/Include/core_cm4.h **** 
1948:ThirdParty/CMSIS/Include/core_cm4.h ****   for(;;)                                                           /* wait until reset */
 6835              		.loc 21 1948 3 view .LVU1664
1949:ThirdParty/CMSIS/Include/core_cm4.h ****   {
1950:ThirdParty/CMSIS/Include/core_cm4.h ****     __NOP();
 6836              		.loc 21 1950 5 view .LVU1665
 6837              		.syntax unified
 6838              	@ 1950 "ThirdParty/CMSIS/Include/core_cm4.h" 1
 6839 0156 00BF     		nop
 6840              	@ 0 "" 2
1948:ThirdParty/CMSIS/Include/core_cm4.h ****   {
 6841              		.loc 21 1948 3 view .LVU1666
 6842              		.thumb
 6843              		.syntax unified
 6844 0158 FDE7     		b	.L260
 6845              	.L232:
 6846              	.LBE1974:
 6847              	.LBE1973:
 138:communication/can/can_simple.cpp ****         case MSG_GET_BUS_VOLTAGE_CURRENT:
 6848              		.loc 3 138 13 view .LVU1667
 139:communication/can/can_simple.cpp ****             if (msg.rtr || msg.len == 0)
 6849              		.loc 3 139 9 view .LVU1668
 140:communication/can/can_simple.cpp ****                 get_bus_voltage_current_callback(axis);
 6850              		.loc 3 140 13 view .LVU1669
 140:communication/can/can_simple.cpp ****                 get_bus_voltage_current_callback(axis);
 6851              		.loc 3 140 21 is_stmt 0 view .LVU1670
 6852 015a 7379     		ldrb	r3, [r6, #5]	@ zero_extendqisi2
ARM GAS  /tmp/ccoErako.s 			page 330


 140:communication/can/can_simple.cpp ****                 get_bus_voltage_current_callback(axis);
 6853              		.loc 3 140 13 view .LVU1671
 6854 015c 1BB9     		cbnz	r3, .L261
 140:communication/can/can_simple.cpp ****                 get_bus_voltage_current_callback(axis);
 6855              		.loc 3 140 32 discriminator 1 view .LVU1672
 6856 015e B379     		ldrb	r3, [r6, #6]	@ zero_extendqisi2
 140:communication/can/can_simple.cpp ****                 get_bus_voltage_current_callback(axis);
 6857              		.loc 3 140 25 discriminator 1 view .LVU1673
 6858 0160 002B     		cmp	r3, #0
 6859 0162 7FF46FAF 		bne	.L223
 6860              	.L261:
 141:communication/can/can_simple.cpp ****             break;
 6861              		.loc 3 141 17 is_stmt 1 view .LVU1674
 141:communication/can/can_simple.cpp ****             break;
 6862              		.loc 3 141 49 is_stmt 0 view .LVU1675
 6863 0166 2946     		mov	r1, r5
 6864 0168 3846     		mov	r0, r7
 6865 016a FFF7FEFF 		bl	_ZN9CANSimple32get_bus_voltage_current_callbackERK4Axis
 6866              	.LVL478:
 6867 016e 69E7     		b	.L223
 6868              	.L231:
 143:communication/can/can_simple.cpp ****             clear_errors_callback(axis, msg);
 6869              		.loc 3 143 9 is_stmt 1 view .LVU1676
 144:communication/can/can_simple.cpp ****             break;
 6870              		.loc 3 144 13 view .LVU1677
 144:communication/can/can_simple.cpp ****             break;
 6871              		.loc 3 144 34 is_stmt 0 view .LVU1678
 6872 0170 3146     		mov	r1, r6
 6873 0172 2846     		mov	r0, r5
 6874 0174 FFF7FEFF 		bl	_ZN9CANSimple21clear_errors_callbackER4AxisRK13can_Message_t
 6875              	.LVL479:
 145:communication/can/can_simple.cpp ****         case MSG_SET_LINEAR_COUNT:
 6876              		.loc 3 145 13 is_stmt 1 view .LVU1679
 6877 0178 64E7     		b	.L223
 6878              	.L230:
 146:communication/can/can_simple.cpp ****             set_linear_count_callback(axis, msg);
 6879              		.loc 3 146 9 view .LVU1680
 147:communication/can/can_simple.cpp ****             break;
 6880              		.loc 3 147 13 view .LVU1681
 147:communication/can/can_simple.cpp ****             break;
 6881              		.loc 3 147 38 is_stmt 0 view .LVU1682
 6882 017a 3146     		mov	r1, r6
 6883 017c 2846     		mov	r0, r5
 6884 017e FFF7FEFF 		bl	_ZN9CANSimple25set_linear_count_callbackER4AxisRK13can_Message_t
 6885              	.LVL480:
 148:communication/can/can_simple.cpp ****         case MSG_SET_POS_GAIN:
 6886              		.loc 3 148 13 is_stmt 1 view .LVU1683
 6887 0182 5FE7     		b	.L223
 6888              	.L229:
 149:communication/can/can_simple.cpp ****             set_pos_gain_callback(axis, msg);
 6889              		.loc 3 149 9 view .LVU1684
 150:communication/can/can_simple.cpp ****             break;
 6890              		.loc 3 150 13 view .LVU1685
 150:communication/can/can_simple.cpp ****             break;
 6891              		.loc 3 150 34 is_stmt 0 view .LVU1686
 6892 0184 3146     		mov	r1, r6
 6893 0186 2846     		mov	r0, r5
ARM GAS  /tmp/ccoErako.s 			page 331


 6894 0188 FFF7FEFF 		bl	_ZN9CANSimple21set_pos_gain_callbackER4AxisRK13can_Message_t
 6895              	.LVL481:
 151:communication/can/can_simple.cpp ****         case MSG_SET_VEL_GAINS:
 6896              		.loc 3 151 13 is_stmt 1 view .LVU1687
 6897 018c 5AE7     		b	.L223
 6898              	.L228:
 152:communication/can/can_simple.cpp ****             set_vel_gains_callback(axis, msg);
 6899              		.loc 3 152 9 view .LVU1688
 153:communication/can/can_simple.cpp ****             break;
 6900              		.loc 3 153 13 view .LVU1689
 153:communication/can/can_simple.cpp ****             break;
 6901              		.loc 3 153 35 is_stmt 0 view .LVU1690
 6902 018e 3146     		mov	r1, r6
 6903 0190 2846     		mov	r0, r5
 6904 0192 FFF7FEFF 		bl	_ZN9CANSimple22set_vel_gains_callbackER4AxisRK13can_Message_t
 6905              	.LVL482:
 154:communication/can/can_simple.cpp ****         case MSG_GET_ADC_VOLTAGE:
 6906              		.loc 3 154 13 is_stmt 1 view .LVU1691
 6907 0196 55E7     		b	.L223
 6908              	.L227:
 155:communication/can/can_simple.cpp ****             get_adc_voltage_callback(axis, msg);
 6909              		.loc 3 155 9 view .LVU1692
 156:communication/can/can_simple.cpp ****             break;
 6910              		.loc 3 156 13 view .LVU1693
 156:communication/can/can_simple.cpp ****             break;
 6911              		.loc 3 156 37 is_stmt 0 view .LVU1694
 6912 0198 3246     		mov	r2, r6
 6913 019a 2946     		mov	r1, r5
 6914 019c 3846     		mov	r0, r7
 6915 019e FFF7FEFF 		bl	_ZN9CANSimple24get_adc_voltage_callbackERK4AxisRK13can_Message_t
 6916              	.LVL483:
 157:communication/can/can_simple.cpp ****         case MSG_GET_CONTROLLER_ERROR:
 6917              		.loc 3 157 13 is_stmt 1 view .LVU1695
 6918 01a2 4FE7     		b	.L223
 6919              	.L225:
 158:communication/can/can_simple.cpp ****             get_controller_error_callback(axis);
 6920              		.loc 3 158 9 view .LVU1696
 159:communication/can/can_simple.cpp ****             break;
 6921              		.loc 3 159 13 view .LVU1697
 159:communication/can/can_simple.cpp ****             break;
 6922              		.loc 3 159 42 is_stmt 0 view .LVU1698
 6923 01a4 2946     		mov	r1, r5
 6924 01a6 3846     		mov	r0, r7
 6925 01a8 FFF7FEFF 		bl	_ZN9CANSimple29get_controller_error_callbackERK4Axis
 6926              	.LVL484:
 160:communication/can/can_simple.cpp ****         default:
 6927              		.loc 3 160 13 is_stmt 1 view .LVU1699
 164:communication/can/can_simple.cpp **** 
 6928              		.loc 3 164 1 is_stmt 0 view .LVU1700
 6929 01ac 4AE7     		b	.L223
 6930              	.L264:
 6931 01ae 00BF     		.align	2
 6932              	.L263:
 6933 01b0 00ED00E0 		.word	-536810240
 6934 01b4 0400FA05 		.word	100270084
 6935              		.cfi_endproc
 6936              	.LFE5200:
ARM GAS  /tmp/ccoErako.s 			page 332


 6937              		.fnend
 6939              		.section	.text._ZN9CANSimple18handle_can_messageERK13can_Message_t,"ax",%progbits
 6940              		.align	1
 6941              		.global	_ZN9CANSimple18handle_can_messageERK13can_Message_t
 6942              		.syntax unified
 6943              		.thumb
 6944              		.thumb_func
 6946              	_ZN9CANSimple18handle_can_messageERK13can_Message_t:
 6947              		.fnstart
 6948              	.LVL485:
 6949              	.LFB5195:
  44:communication/can/can_simple.cpp ****     //     Frame
 6950              		.loc 3 44 62 is_stmt 1 view -0
 6951              		.cfi_startproc
 6952              		@ args = 0, pretend = 0, frame = 0
 6953              		@ frame_needed = 0, uses_anonymous_args = 0
  44:communication/can/can_simple.cpp ****     //     Frame
 6954              		.loc 3 44 62 is_stmt 0 view .LVU1702
 6955 0000 10B5     		push	{r4, lr}
 6956              		.save {r4, lr}
 6957              	.LCFI104:
 6958              		.cfi_def_cfa_offset 8
 6959              		.cfi_offset 4, -8
 6960              		.cfi_offset 14, -4
  48:communication/can/can_simple.cpp **** 
 6961              		.loc 3 48 5 is_stmt 1 view .LVU1703
  48:communication/can/can_simple.cpp **** 
 6962              		.loc 3 48 39 is_stmt 0 view .LVU1704
 6963 0002 0B68     		ldr	r3, [r1]
 6964              	.LVL486:
 6965              	.LBB1979:
 6966              	.LBI1979:
  96:communication/can/can_simple.hpp ****         return (msgID >> NUM_CMD_ID_BITS);  // Upper 6 or more bits
 6967              		.loc 20 96 31 is_stmt 1 view .LVU1705
 6968              	.LBB1980:
  97:communication/can/can_simple.hpp ****     };
 6969              		.loc 20 97 9 view .LVU1706
  97:communication/can/can_simple.hpp ****     };
 6970              		.loc 20 97 41 is_stmt 0 view .LVU1707
 6971 0004 4FEA531C 		lsr	ip, r3, #5
 6972              	.LVL487:
  97:communication/can/can_simple.hpp ****     };
 6973              		.loc 20 97 41 view .LVU1708
 6974              	.LBE1980:
 6975              	.LBE1979:
  50:communication/can/can_simple.cpp ****         if ((axis.config_.can.node_id == nodeID) && (axis.config_.can.is_extended == msg.isExt)) {
 6976              		.loc 3 50 5 is_stmt 1 view .LVU1709
 6977              	.LBB1981:
  50:communication/can/can_simple.cpp ****         if ((axis.config_.can.node_id == nodeID) && (axis.config_.can.is_extended == msg.isExt)) {
 6978              		.loc 3 50 23 is_stmt 0 view .LVU1710
 6979 0008 094B     		ldr	r3, .L270
 6980 000a 01E0     		b	.L268
 6981              	.LVL488:
 6982              	.L267:
  50:communication/can/can_simple.cpp ****         if ((axis.config_.can.node_id == nodeID) && (axis.config_.can.is_extended == msg.isExt)) {
 6983              		.loc 3 50 5 is_stmt 1 discriminator 3 view .LVU1711
 6984 000c 03F52C73 		add	r3, r3, #688
ARM GAS  /tmp/ccoErako.s 			page 333


 6985              	.LVL489:
 6986              	.L268:
  50:communication/can/can_simple.cpp ****         if ((axis.config_.can.node_id == nodeID) && (axis.config_.can.is_extended == msg.isExt)) {
 6987              		.loc 3 50 23 discriminator 1 view .LVU1712
 6988 0010 084C     		ldr	r4, .L270+4
 6989              	.LVL490:
  50:communication/can/can_simple.cpp ****         if ((axis.config_.can.node_id == nodeID) && (axis.config_.can.is_extended == msg.isExt)) {
 6990              		.loc 3 50 23 is_stmt 0 discriminator 1 view .LVU1713
 6991 0012 A342     		cmp	r3, r4
 6992 0014 0BD0     		beq	.L265
 6993              	.LVL491:
  51:communication/can/can_simple.cpp ****             do_command(axis, msg);
 6994              		.loc 3 51 9 is_stmt 1 discriminator 2 view .LVU1714
  51:communication/can/can_simple.cpp ****             do_command(axis, msg);
 6995              		.loc 3 51 31 is_stmt 0 discriminator 2 view .LVU1715
 6996 0016 9A6F     		ldr	r2, [r3, #120]
  51:communication/can/can_simple.cpp ****             do_command(axis, msg);
 6997              		.loc 3 51 9 discriminator 2 view .LVU1716
 6998 0018 6245     		cmp	r2, ip
 6999 001a F7D1     		bne	.L267
  51:communication/can/can_simple.cpp ****             do_command(axis, msg);
 7000              		.loc 3 51 71 discriminator 1 view .LVU1717
 7001 001c 93F87C40 		ldrb	r4, [r3, #124]	@ zero_extendqisi2
 7002              	.LVL492:
  51:communication/can/can_simple.cpp ****             do_command(axis, msg);
 7003              		.loc 3 51 90 discriminator 1 view .LVU1718
 7004 0020 0A79     		ldrb	r2, [r1, #4]	@ zero_extendqisi2
  51:communication/can/can_simple.cpp ****             do_command(axis, msg);
 7005              		.loc 3 51 50 discriminator 1 view .LVU1719
 7006 0022 9442     		cmp	r4, r2
 7007 0024 F2D1     		bne	.L267
  52:communication/can/can_simple.cpp ****             return;
 7008              		.loc 3 52 13 is_stmt 1 view .LVU1720
  52:communication/can/can_simple.cpp ****             return;
 7009              		.loc 3 52 23 is_stmt 0 view .LVU1721
 7010 0026 0A46     		mov	r2, r1
 7011 0028 1946     		mov	r1, r3
 7012              	.LVL493:
  52:communication/can/can_simple.cpp ****             return;
 7013              		.loc 3 52 23 view .LVU1722
 7014 002a FFF7FEFF 		bl	_ZN9CANSimple10do_commandER4AxisRK13can_Message_t
 7015              	.LVL494:
  53:communication/can/can_simple.cpp ****         }
 7016              		.loc 3 53 13 is_stmt 1 view .LVU1723
 7017              	.L265:
  53:communication/can/can_simple.cpp ****         }
 7018              		.loc 3 53 13 is_stmt 0 view .LVU1724
 7019              	.LBE1981:
  56:communication/can/can_simple.cpp **** 
 7020              		.loc 3 56 1 view .LVU1725
 7021 002e 10BD     		pop	{r4, pc}
 7022              	.L271:
 7023              		.align	2
 7024              	.L270:
 7025 0030 00000000 		.word	axes
 7026 0034 60050000 		.word	axes+1376
 7027              		.cfi_endproc
ARM GAS  /tmp/ccoErako.s 			page 334


 7028              	.LFE5195:
 7029              		.fnend
 7031              		.section	.text._ZZN9CANSimple18renew_subscriptionEjENUlPvRK13can_Message_tE_4_FUNES0_S3_,"ax",%pro
 7032              		.align	1
 7033              		.syntax unified
 7034              		.thumb
 7035              		.thumb_func
 7037              	_ZZN9CANSimple18renew_subscriptionEjENUlPvRK13can_Message_tE_4_FUNES0_S3_:
 7038              		.fnstart
 7039              	.LFB5193:
  38:communication/can/can_simple.cpp ****             ((CANSimple*)ctx)->handle_can_message(msg);
 7040              		.loc 3 38 17 is_stmt 1 view -0
 7041              		.cfi_startproc
 7042              		@ args = 0, pretend = 0, frame = 0
 7043              		@ frame_needed = 0, uses_anonymous_args = 0
 7044 0000 08B5     		push	{r3, lr}
 7045              		.save {r3, lr}
 7046              	.LCFI105:
 7047              		.cfi_def_cfa_offset 8
 7048              		.cfi_offset 3, -8
 7049              		.cfi_offset 14, -4
 7050              	.LVL495:
 7051              	.LBB1982:
 7052              	.LBI1982:
  38:communication/can/can_simple.cpp ****             ((CANSimple*)ctx)->handle_can_message(msg);
 7053              		.loc 3 38 17 view .LVU1727
 7054              	.LBB1983:
  39:communication/can/can_simple.cpp ****         },
 7055              		.loc 3 39 13 view .LVU1728
  39:communication/can/can_simple.cpp ****         },
 7056              		.loc 3 39 50 is_stmt 0 view .LVU1729
 7057 0002 FFF7FEFF 		bl	_ZN9CANSimple18handle_can_messageERK13can_Message_t
 7058              	.LVL496:
  39:communication/can/can_simple.cpp ****         },
 7059              		.loc 3 39 50 view .LVU1730
 7060              	.LBE1983:
 7061              	.LBE1982:
  40:communication/can/can_simple.cpp ****         this, &subscription_handles_[i]);
 7062              		.loc 3 40 9 view .LVU1731
 7063 0006 08BD     		pop	{r3, pc}
 7064              		.cfi_endproc
 7065              	.LFE5193:
 7066              		.fnend
 7068              		.weak	_ZTSSt18bad_variant_access
 7069              		.section	.rodata._ZTSSt18bad_variant_access,"aG",%progbits,_ZTSSt18bad_variant_access,comdat
 7070              		.align	2
 7073              	_ZTSSt18bad_variant_access:
 7074 0000 53743138 		.ascii	"St18bad_variant_access\000"
 7074      6261645F 
 7074      76617269 
 7074      616E745F 
 7074      61636365 
 7075              		.weak	_ZTISt18bad_variant_access
 7076              		.section	.rodata._ZTISt18bad_variant_access,"aG",%progbits,_ZTISt18bad_variant_access,comdat
 7077              		.align	2
 7080              	_ZTISt18bad_variant_access:
 7081 0000 08000000 		.word	_ZTVN10__cxxabiv120__si_class_type_infoE+8
ARM GAS  /tmp/ccoErako.s 			page 335


 7082 0004 00000000 		.word	_ZTSSt18bad_variant_access
 7083 0008 00000000 		.word	_ZTISt9exception
 7084              		.weak	_ZTVSt18bad_variant_access
 7085              		.section	.rodata._ZTVSt18bad_variant_access,"aG",%progbits,_ZTVSt18bad_variant_access,comdat
 7086              		.align	2
 7089              	_ZTVSt18bad_variant_access:
 7090 0000 00000000 		.word	0
 7091 0004 00000000 		.word	_ZTISt18bad_variant_access
 7092 0008 00000000 		.word	_ZNSt18bad_variant_accessD1Ev
 7093 000c 00000000 		.word	_ZNSt18bad_variant_accessD0Ev
 7094 0010 00000000 		.word	_ZNKSt18bad_variant_access4whatEv
 7095              		.section	.rodata
 7096              		.align	2
 7097              		.set	.LANCHOR0,. + 0
 7098              	.LC0:
 7099 0000 00000000 		.word	0
 7100 0004 00       		.byte	0
 7101 0005 00       		.byte	0
 7102 0006 08       		.byte	8
 7103 0007 00000000 		.ascii	"\000\000\000\000\000\000\000\000"
 7103      00000000 
 7104 000f 00       		.space	1
 7105              		.text
 7106              	.Letext0:
 7107              		.file 23 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/machine/_default_types.h"
 7108              		.file 24 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/_stdint.h"
 7109              		.file 25 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdint.h"
 7110              		.file 26 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/type_traits"
 7111              		.file 27 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/arm-none-eabi/thumb/v7e-m+fp/har
 7112              		.file 28 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/utility"
 7113              		.file 29 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_iterator_base_types.h"
 7114              		.file 30 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/debug/debug.h"
 7115              		.file 31 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdlib"
 7116              		.file 32 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/algorithmfwd.h"
 7117              		.file 33 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception_ptr.h"
 7118              		.file 34 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_iterator.h"
 7119              		.file 35 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/enable_special_members.h"
 7120              		.file 36 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstring"
 7121              		.file 37 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cwchar"
 7122              		.file 38 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/clocale"
 7123              		.file 39 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdint"
 7124              		.file 40 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/string_view"
 7125              		.file 41 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/basic_string.h"
 7126              		.file 42 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdio"
 7127              		.file 43 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/parse_numbers.h"
 7128              		.file 44 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h"
 7129              		.file 45 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath"
 7130              		.file 46 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/predefined_ops.h"
 7131              		.file 47 "/opt/gcc-arm-none-eabi/lib/gcc/arm-none-eabi/10.3.1/include/stddef.h"
 7132              		.file 48 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/_types.h"
 7133              		.file 49 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/reent.h"
 7134              		.file 50 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/lock.h"
 7135              		.file 51 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdlib.h"
 7136              		.file 52 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/pstl/execution_defs.h"
 7137              		.file 53 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h"
 7138              		.file 54 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/string.h"
 7139              		.file 55 "/opt/gcc-arm-none-eabi/lib/gcc/arm-none-eabi/10.3.1/include/stdarg.h"
ARM GAS  /tmp/ccoErako.s 			page 336


 7140              		.file 56 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/wchar.h"
 7141              		.file 57 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/locale.h"
 7142              		.file 58 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdio.h"
 7143              		.file 59 "communication/can/canbus.hpp"
 7144              		.file 60 "ThirdParty/CMSIS/Device/ST/STM32F4xx/Include/stm32f405xx.h"
 7145              		.file 61 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/stdlib.h"
 7146              		.file 62 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/math.h"
 7147              		.file 63 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/math.h"
 7148              		.file 64 "./Drivers/STM32/stm32_gpio.hpp"
 7149              		.file 65 "fibre-cpp/include/fibre/cpp_utils.hpp"
 7150              		.file 66 "fibre-cpp/include/fibre/callback.hpp"
 7151              		.file 67 "Board/v3/Inc/board.h"
 7152              		.file 68 "MotorControl/utils.hpp"
 7153              		.file 69 "MotorControl/low_level.h"
 7154              		.file 70 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal.h"
 7155              		.file 71 "<built-in>"
ARM GAS  /tmp/ccoErako.s 			page 337


DEFINED SYMBOLS
                            *ABS*:0000000000000000 can_simple.cpp
     /tmp/ccoErako.s:20     .text._ZNKSt18bad_variant_access4whatEv:0000000000000000 $t
     /tmp/ccoErako.s:26     .text._ZNKSt18bad_variant_access4whatEv:0000000000000000 _ZNKSt18bad_variant_access4whatEv
.ARM.exidx.text._ZNKSt18bad_variant_access4whatEv:0000000000000000 $d
     /tmp/ccoErako.s:48     .text._ZL8get_gpioj:0000000000000000 $t
     /tmp/ccoErako.s:53     .text._ZL8get_gpioj:0000000000000000 _ZL8get_gpioj
     /tmp/ccoErako.s:92     .text._ZL8get_gpioj:000000000000001c $d
    .ARM.exidx.text._ZL8get_gpioj:0000000000000000 $d
     /tmp/ccoErako.s:99     .text._ZNSt18bad_variant_accessD2Ev:0000000000000000 $t
     /tmp/ccoErako.s:105    .text._ZNSt18bad_variant_accessD2Ev:0000000000000000 _ZNSt18bad_variant_accessD2Ev
     /tmp/ccoErako.s:135    .text._ZNSt18bad_variant_accessD2Ev:0000000000000010 $d
     /tmp/ccoErako.s:7089   .rodata._ZTVSt18bad_variant_access:0000000000000000 _ZTVSt18bad_variant_access
.ARM.exidx.text._ZNSt18bad_variant_accessD2Ev:0000000000000000 $d
     /tmp/ccoErako.s:105    .text._ZNSt18bad_variant_accessD2Ev:0000000000000000 _ZNSt18bad_variant_accessD1Ev
     /tmp/ccoErako.s:144    .text._ZNSt18bad_variant_accessD0Ev:0000000000000000 $t
     /tmp/ccoErako.s:150    .text._ZNSt18bad_variant_accessD0Ev:0000000000000000 _ZNSt18bad_variant_accessD0Ev
     /tmp/ccoErako.s:188    .text._ZNSt18bad_variant_accessD0Ev:0000000000000018 $d
.ARM.exidx.text._ZNSt18bad_variant_accessD0Ev:0000000000000000 $d
     /tmp/ccoErako.s:195    .text._ZN9CANSimple26get_encoder_error_callbackERK4Axis:0000000000000000 $t
     /tmp/ccoErako.s:201    .text._ZN9CANSimple26get_encoder_error_callbackERK4Axis:0000000000000000 _ZN9CANSimple26get_encoder_error_callbackERK4Axis
     /tmp/ccoErako.s:316    .text._ZN9CANSimple26get_encoder_error_callbackERK4Axis:0000000000000078 $d
.ARM.exidx.text._ZN9CANSimple26get_encoder_error_callbackERK4Axis:0000000000000000 $d
     /tmp/ccoErako.s:322    .text._ZN9CANSimple29get_sensorless_error_callbackERK4Axis:0000000000000000 $t
     /tmp/ccoErako.s:328    .text._ZN9CANSimple29get_sensorless_error_callbackERK4Axis:0000000000000000 _ZN9CANSimple29get_sensorless_error_callbackERK4Axis
     /tmp/ccoErako.s:441    .text._ZN9CANSimple29get_sensorless_error_callbackERK4Axis:0000000000000074 $d
.ARM.exidx.text._ZN9CANSimple29get_sensorless_error_callbackERK4Axis:0000000000000000 $d
     /tmp/ccoErako.s:447    .text._ZN9CANSimple29get_controller_error_callbackERK4Axis:0000000000000000 $t
     /tmp/ccoErako.s:453    .text._ZN9CANSimple29get_controller_error_callbackERK4Axis:0000000000000000 _ZN9CANSimple29get_controller_error_callbackERK4Axis
     /tmp/ccoErako.s:568    .text._ZN9CANSimple29get_controller_error_callbackERK4Axis:0000000000000078 $d
.ARM.exidx.text._ZN9CANSimple29get_controller_error_callbackERK4Axis:0000000000000000 $d
     /tmp/ccoErako.s:574    .text._ZN9CANSimple24get_motor_error_callbackERK4Axis:0000000000000000 $t
     /tmp/ccoErako.s:580    .text._ZN9CANSimple24get_motor_error_callbackERK4Axis:0000000000000000 _ZN9CANSimple24get_motor_error_callbackERK4Axis
     /tmp/ccoErako.s:688    .text._ZN9CANSimple24get_motor_error_callbackERK4Axis:0000000000000078 $d
.ARM.exidx.text._ZN9CANSimple24get_motor_error_callbackERK4Axis:0000000000000000 $d
     /tmp/ccoErako.s:696    .text._ZN9CANSimple26get_encoder_count_callbackERK4Axis:0000000000000000 $t
     /tmp/ccoErako.s:702    .text._ZN9CANSimple26get_encoder_count_callbackERK4Axis:0000000000000000 _ZN9CANSimple26get_encoder_count_callbackERK4Axis
     /tmp/ccoErako.s:851    .text._ZN9CANSimple26get_encoder_count_callbackERK4Axis:00000000000000a4 $d
.ARM.exidx.text._ZN9CANSimple26get_encoder_count_callbackERK4Axis:0000000000000000 $d
     /tmp/ccoErako.s:857    .text._ZN9CANSimple14send_heartbeatERK4Axis:0000000000000000 $t
     /tmp/ccoErako.s:863    .text._ZN9CANSimple14send_heartbeatERK4Axis:0000000000000000 _ZN9CANSimple14send_heartbeatERK4Axis
     /tmp/ccoErako.s:1170   .text._ZN9CANSimple14send_heartbeatERK4Axis:000000000000017c $d
.ARM.exidx.text._ZN9CANSimple14send_heartbeatERK4Axis:0000000000000000 $d
     /tmp/ccoErako.s:1176   .text._ZN9CANSimple32get_bus_voltage_current_callbackERK4Axis:0000000000000000 $t
     /tmp/ccoErako.s:1182   .text._ZN9CANSimple32get_bus_voltage_current_callbackERK4Axis:0000000000000000 _ZN9CANSimple32get_bus_voltage_current_callbackERK4Axis
     /tmp/ccoErako.s:1331   .text._ZN9CANSimple32get_bus_voltage_current_callbackERK4Axis:00000000000000a0 $d
.ARM.exidx.text._ZN9CANSimple32get_bus_voltage_current_callbackERK4Axis:0000000000000000 $d
     /tmp/ccoErako.s:1339   .text._ZN9CANSimple33get_sensorless_estimates_callbackERK4Axis:0000000000000000 $t
     /tmp/ccoErako.s:1345   .text._ZN9CANSimple33get_sensorless_estimates_callbackERK4Axis:0000000000000000 _ZN9CANSimple33get_sensorless_estimates_callbackERK4Axis
     /tmp/ccoErako.s:1582   .text._ZN9CANSimple33get_sensorless_estimates_callbackERK4Axis:00000000000000a8 $d
.ARM.exidx.text._ZN9CANSimple33get_sensorless_estimates_callbackERK4Axis:0000000000000000 $d
     /tmp/ccoErako.s:1588   .text._ZN9CANSimple15get_iq_callbackERK4Axis:0000000000000000 $t
     /tmp/ccoErako.s:1594   .text._ZN9CANSimple15get_iq_callbackERK4Axis:0000000000000000 _ZN9CANSimple15get_iq_callbackERK4Axis
     /tmp/ccoErako.s:1823   .text._ZN9CANSimple15get_iq_callbackERK4Axis:00000000000000c8 $d
.ARM.exidx.text._ZN9CANSimple15get_iq_callbackERK4Axis:0000000000000000 $d
     /tmp/ccoErako.s:1829   .text._ZSt26__throw_bad_variant_accessPKc:0000000000000000 $t
     /tmp/ccoErako.s:1835   .text._ZSt26__throw_bad_variant_accessPKc:0000000000000000 _ZSt26__throw_bad_variant_accessPKc
ARM GAS  /tmp/ccoErako.s 			page 338


     /tmp/ccoErako.s:1889   .text._ZSt26__throw_bad_variant_accessPKc:000000000000001c $d
     /tmp/ccoErako.s:7080   .rodata._ZTISt18bad_variant_access:0000000000000000 _ZTISt18bad_variant_access
.ARM.exidx.text._ZSt26__throw_bad_variant_accessPKc:0000000000000000 $d
     /tmp/ccoErako.s:1898   .rodata._ZN9CANSimple30get_encoder_estimates_callbackERK4Axis.str1.4:0000000000000000 $d
     /tmp/ccoErako.s:1902   .text._ZN9CANSimple30get_encoder_estimates_callbackERK4Axis:0000000000000000 $t
     /tmp/ccoErako.s:1908   .text._ZN9CANSimple30get_encoder_estimates_callbackERK4Axis:0000000000000000 _ZN9CANSimple30get_encoder_estimates_callbackERK4Axis
     /tmp/ccoErako.s:3188   .text._ZN9CANSimple30get_encoder_estimates_callbackERK4Axis:0000000000000190 $d
.ARM.exidx.text._ZN9CANSimple30get_encoder_estimates_callbackERK4Axis:0000000000000000 $d
     /tmp/ccoErako.s:3197   .text._ZoRRN10ODriveIntf8AxisIntf5ErrorES1_:0000000000000000 $t
     /tmp/ccoErako.s:3203   .text._ZoRRN10ODriveIntf8AxisIntf5ErrorES1_:0000000000000000 _ZoRRN10ODriveIntf8AxisIntf5ErrorES1_
.ARM.exidx.text._ZoRRN10ODriveIntf8AxisIntf5ErrorES1_:0000000000000000 $d
     /tmp/ccoErako.s:3228   .text._ZN9TaskTimer4stopEm:0000000000000000 $t
     /tmp/ccoErako.s:3234   .text._ZN9TaskTimer4stopEm:0000000000000000 _ZN9TaskTimer4stopEm
     /tmp/ccoErako.s:3335   .text._ZN9TaskTimer4stopEm:0000000000000034 $d
.ARM.exidx.text._ZN9TaskTimer4stopEm:0000000000000000 $d
     /tmp/ccoErako.s:3345   .text._ZN9CANSimple12nmt_callbackERK4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:3351   .text._ZN9CANSimple12nmt_callbackERK4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple12nmt_callbackERK4AxisRK13can_Message_t
.ARM.exidx.text._ZN9CANSimple12nmt_callbackERK4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:3368   .text._ZN9CANSimple14estop_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:3374   .text._ZN9CANSimple14estop_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple14estop_callbackER4AxisRK13can_Message_t
.ARM.exidx.text._ZN9CANSimple14estop_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:3406   .text._ZN9CANSimple24set_axis_nodeid_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:3412   .text._ZN9CANSimple24set_axis_nodeid_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple24set_axis_nodeid_callbackER4AxisRK13can_Message_t
.ARM.exidx.text._ZN9CANSimple24set_axis_nodeid_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:3472   .text._ZN9CANSimple33set_axis_requested_state_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:3478   .text._ZN9CANSimple33set_axis_requested_state_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple33set_axis_requested_state_callbackER4AxisRK13can_Message_t
.ARM.exidx.text._ZN9CANSimple33set_axis_requested_state_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:3540   .text._ZN9CANSimple32set_axis_startup_config_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:3546   .text._ZN9CANSimple32set_axis_startup_config_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple32set_axis_startup_config_callbackER4AxisRK13can_Message_t
.ARM.exidx.text._ZN9CANSimple32set_axis_startup_config_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:3563   .text._ZN9CANSimple22set_input_vel_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:3569   .text._ZN9CANSimple22set_input_vel_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple22set_input_vel_callbackER4AxisRK13can_Message_t
     /tmp/ccoErako.s:3666   .text._ZN9CANSimple22set_input_vel_callbackER4AxisRK13can_Message_t:0000000000000068 $d
.ARM.exidx.text._ZN9CANSimple22set_input_vel_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:3674   .text._ZN9CANSimple25set_input_torque_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:3680   .text._ZN9CANSimple25set_input_torque_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple25set_input_torque_callbackER4AxisRK13can_Message_t
.ARM.exidx.text._ZN9CANSimple25set_input_torque_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:3749   .text._ZN9CANSimple29set_controller_modes_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:3755   .text._ZN9CANSimple29set_controller_modes_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple29set_controller_modes_callbackER4AxisRK13can_Message_t
     /tmp/ccoErako.s:3858   .text._ZN9CANSimple29set_controller_modes_callbackER4AxisRK13can_Message_t:0000000000000068 $d
.ARM.exidx.text._ZN9CANSimple29set_controller_modes_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:3865   .text._ZN9CANSimple19set_limits_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:3871   .text._ZN9CANSimple19set_limits_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple19set_limits_callbackER4AxisRK13can_Message_t
     /tmp/ccoErako.s:3964   .text._ZN9CANSimple19set_limits_callbackER4AxisRK13can_Message_t:0000000000000060 $d
.ARM.exidx.text._ZN9CANSimple19set_limits_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:3972   .text._ZN9CANSimple26start_anticogging_callbackERK4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:3978   .text._ZN9CANSimple26start_anticogging_callbackERK4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple26start_anticogging_callbackERK4AxisRK13can_Message_t
.ARM.extab.text._ZN9CANSimple26start_anticogging_callbackERK4AxisRK13can_Message_t:0000000000000000 $d
.ARM.exidx.text._ZN9CANSimple26start_anticogging_callbackERK4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:4010   .text._ZN9CANSimple27set_traj_vel_limit_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:4016   .text._ZN9CANSimple27set_traj_vel_limit_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple27set_traj_vel_limit_callbackER4AxisRK13can_Message_t
.ARM.exidx.text._ZN9CANSimple27set_traj_vel_limit_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:4082   .text._ZN9CANSimple30set_traj_accel_limits_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:4088   .text._ZN9CANSimple30set_traj_accel_limits_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple30set_traj_accel_limits_callbackER4AxisRK13can_Message_t
     /tmp/ccoErako.s:4181   .text._ZN9CANSimple30set_traj_accel_limits_callbackER4AxisRK13can_Message_t:0000000000000060 $d
.ARM.exidx.text._ZN9CANSimple30set_traj_accel_limits_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:4189   .text._ZN9CANSimple25set_traj_inertia_callbackER4AxisRK13can_Message_t:0000000000000000 $t
ARM GAS  /tmp/ccoErako.s 			page 339


     /tmp/ccoErako.s:4195   .text._ZN9CANSimple25set_traj_inertia_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple25set_traj_inertia_callbackER4AxisRK13can_Message_t
.ARM.exidx.text._ZN9CANSimple25set_traj_inertia_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:4261   .text._ZN9CANSimple25set_linear_count_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:4267   .text._ZN9CANSimple25set_linear_count_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple25set_linear_count_callbackER4AxisRK13can_Message_t
.ARM.exidx.text._ZN9CANSimple25set_linear_count_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:4337   .text._ZN9CANSimple21set_pos_gain_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:4343   .text._ZN9CANSimple21set_pos_gain_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple21set_pos_gain_callbackER4AxisRK13can_Message_t
.ARM.exidx.text._ZN9CANSimple21set_pos_gain_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:4409   .text._ZN9CANSimple22set_vel_gains_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:4415   .text._ZN9CANSimple22set_vel_gains_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple22set_vel_gains_callbackER4AxisRK13can_Message_t
     /tmp/ccoErako.s:4508   .text._ZN9CANSimple22set_vel_gains_callbackER4AxisRK13can_Message_t:0000000000000060 $d
.ARM.exidx.text._ZN9CANSimple22set_vel_gains_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:4516   .text._ZN9CANSimple24get_adc_voltage_callbackERK4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:4522   .text._ZN9CANSimple24get_adc_voltage_callbackERK4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple24get_adc_voltage_callbackERK4AxisRK13can_Message_t
     /tmp/ccoErako.s:4693   .text._ZN9CANSimple24get_adc_voltage_callbackERK4AxisRK13can_Message_t:00000000000000b8 $d
.ARM.exidx.text._ZN9CANSimple24get_adc_voltage_callbackERK4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:4701   .text._ZSt9__reverseIPhEvT_S1_St26random_access_iterator_tag:0000000000000000 $t
     /tmp/ccoErako.s:4707   .text._ZSt9__reverseIPhEvT_S1_St26random_access_iterator_tag:0000000000000000 _ZSt9__reverseIPhEvT_S1_St26random_access_iterator_tag
.ARM.exidx.text._ZSt9__reverseIPhEvT_S1_St26random_access_iterator_tag:0000000000000000 $d
     /tmp/ccoErako.s:4761   .text._Z13can_getSignalIsEf13can_Message_thhbff:0000000000000000 $t
     /tmp/ccoErako.s:4767   .text._Z13can_getSignalIsEf13can_Message_thhbff:0000000000000000 _Z13can_getSignalIsEf13can_Message_thhbff
.ARM.exidx.text._Z13can_getSignalIsEf13can_Message_thhbff:0000000000000000 $d
     /tmp/ccoErako.s:4953   .text._ZN9CANSimple22set_input_pos_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:4959   .text._ZN9CANSimple22set_input_pos_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple22set_input_pos_callbackER4AxisRK13can_Message_t
     /tmp/ccoErako.s:5097   .text._ZN9CANSimple22set_input_pos_callbackER4AxisRK13can_Message_t:00000000000000ac $d
.ARM.extab.text._ZN9CANSimple22set_input_pos_callbackER4AxisRK13can_Message_t:0000000000000000 $d
.ARM.exidx.text._ZN9CANSimple22set_input_pos_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:5104   .text._ZSt28__variant_construct_by_indexILj1ESt7variantIJtmEEJmEEvRT0_DpOT1_:0000000000000000 $t
     /tmp/ccoErako.s:5110   .text._ZSt28__variant_construct_by_indexILj1ESt7variantIJtmEEJmEEvRT0_DpOT1_:0000000000000000 _ZSt28__variant_construct_by_indexILj1ESt7variantIJtmEEJmEEvRT0_DpOT1_
.ARM.exidx.text._ZSt28__variant_construct_by_indexILj1ESt7variantIJtmEEJmEEvRT0_DpOT1_:0000000000000000 $d
     /tmp/ccoErako.s:5154   .text._ZSt28__variant_construct_by_indexILj0ESt7variantIJtmEEJtEEvRT0_DpOT1_:0000000000000000 $t
     /tmp/ccoErako.s:5160   .text._ZSt28__variant_construct_by_indexILj0ESt7variantIJtmEEJtEEvRT0_DpOT1_:0000000000000000 _ZSt28__variant_construct_by_indexILj0ESt7variantIJtmEEJtEEvRT0_DpOT1_
.ARM.exidx.text._ZSt28__variant_construct_by_indexILj0ESt7variantIJtmEEJtEEvRT0_DpOT1_:0000000000000000 $d
     /tmp/ccoErako.s:5198   .text._ZN9CANSimple18renew_subscriptionEj:0000000000000000 $t
     /tmp/ccoErako.s:5204   .text._ZN9CANSimple18renew_subscriptionEj:0000000000000000 _ZN9CANSimple18renew_subscriptionEj
     /tmp/ccoErako.s:5633   .text._ZN9CANSimple18renew_subscriptionEj:00000000000000f0 $d
     /tmp/ccoErako.s:7037   .text._ZZN9CANSimple18renew_subscriptionEjENUlPvRK13can_Message_tE_4_FUNES0_S3_:0000000000000000 _ZZN9CANSimple18renew_subscriptionEjENUlPvRK13can_Message_tE_4_FUNES0_S3_
.ARM.extab.text._ZN9CANSimple18renew_subscriptionEj:0000000000000000 $d
.ARM.exidx.text._ZN9CANSimple18renew_subscriptionEj:0000000000000000 $d
     /tmp/ccoErako.s:5666   .text._ZN9CANSimple4initEv:0000000000000000 $t
     /tmp/ccoErako.s:5672   .text._ZN9CANSimple4initEv:0000000000000000 _ZN9CANSimple4initEv
.ARM.exidx.text._ZN9CANSimple4initEv:0000000000000000 $d
     /tmp/ccoErako.s:5729   .text._ZN9CANSimple13service_stackEv:0000000000000000 $t
     /tmp/ccoErako.s:5735   .text._ZN9CANSimple13service_stackEv:0000000000000000 _ZN9CANSimple13service_stackEv
     /tmp/ccoErako.s:6354   .text._ZN9CANSimple13service_stackEv:0000000000000208 $d
.ARM.extab.text._ZN9CANSimple13service_stackEv:0000000000000000 $d
.ARM.exidx.text._ZN9CANSimple13service_stackEv:0000000000000000 $d
     /tmp/ccoErako.s:6395   .text._ZN9CANSimple21clear_errors_callbackER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:6401   .text._ZN9CANSimple21clear_errors_callbackER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple21clear_errors_callbackER4AxisRK13can_Message_t
     /tmp/ccoErako.s:6428   .text._ZN9CANSimple21clear_errors_callbackER4AxisRK13can_Message_t:000000000000000c $d
.ARM.extab.text._ZN9CANSimple21clear_errors_callbackER4AxisRK13can_Message_t:0000000000000000 $d
.ARM.exidx.text._ZN9CANSimple21clear_errors_callbackER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:6434   .text._ZN9CANSimple10do_commandER4AxisRK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:6440   .text._ZN9CANSimple10do_commandER4AxisRK13can_Message_t:0000000000000000 _ZN9CANSimple10do_commandER4AxisRK13can_Message_t
     /tmp/ccoErako.s:6494   .text._ZN9CANSimple10do_commandER4AxisRK13can_Message_t:0000000000000020 $d
     /tmp/ccoErako.s:6522   .text._ZN9CANSimple10do_commandER4AxisRK13can_Message_t:000000000000003c $t
     /tmp/ccoErako.s:6933   .text._ZN9CANSimple10do_commandER4AxisRK13can_Message_t:00000000000001b0 $d
ARM GAS  /tmp/ccoErako.s 			page 340


.ARM.exidx.text._ZN9CANSimple10do_commandER4AxisRK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:6940   .text._ZN9CANSimple18handle_can_messageERK13can_Message_t:0000000000000000 $t
     /tmp/ccoErako.s:6946   .text._ZN9CANSimple18handle_can_messageERK13can_Message_t:0000000000000000 _ZN9CANSimple18handle_can_messageERK13can_Message_t
     /tmp/ccoErako.s:7025   .text._ZN9CANSimple18handle_can_messageERK13can_Message_t:0000000000000030 $d
.ARM.exidx.text._ZN9CANSimple18handle_can_messageERK13can_Message_t:0000000000000000 $d
     /tmp/ccoErako.s:7032   .text._ZZN9CANSimple18renew_subscriptionEjENUlPvRK13can_Message_tE_4_FUNES0_S3_:0000000000000000 $t
.ARM.extab.text._ZZN9CANSimple18renew_subscriptionEjENUlPvRK13can_Message_tE_4_FUNES0_S3_:0000000000000000 $d
.ARM.exidx.text._ZZN9CANSimple18renew_subscriptionEjENUlPvRK13can_Message_tE_4_FUNES0_S3_:0000000000000000 $d
     /tmp/ccoErako.s:7073   .rodata._ZTSSt18bad_variant_access:0000000000000000 _ZTSSt18bad_variant_access
     /tmp/ccoErako.s:7070   .rodata._ZTSSt18bad_variant_access:0000000000000000 $d
     /tmp/ccoErako.s:7077   .rodata._ZTISt18bad_variant_access:0000000000000000 $d
     /tmp/ccoErako.s:7086   .rodata._ZTVSt18bad_variant_access:0000000000000000 $d
     /tmp/ccoErako.s:7096   .rodata:0000000000000000 $d
                           .group:0000000000000000 _ZNSt18bad_variant_accessD5Ev

UNDEFINED SYMBOLS
gpios
_ZNSt9exceptionD2Ev
_ZdlPvj
__aeabi_unwind_cpp_pr0
vbus_voltage
ibus_
__cxa_allocate_exception
__cxa_throw
_ZTVSt9exception
_ZN9TaskTimer7enabledE
_ZN10Controller20control_mode_updatedEv
__aeabi_unwind_cpp_pr1
get_adc_voltage
_ZN10Controller23set_input_pos_and_stepsEf
axes
__gxx_personality_v0
HAL_GetTick
__cxa_end_cleanup
_ZN6ODrive12clear_errorsEv
odrv
_ZTVN10__cxxabiv120__si_class_type_infoE
_ZTISt9exception
