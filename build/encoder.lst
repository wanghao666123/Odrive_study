ARM GAS  /tmp/cc5nV8qb.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"encoder.cpp"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text._ZNKSt18bad_variant_access4whatEv,"axG",%progbits,_ZNKSt18bad_variant_access4whatEv
  20              		.align	1
  21              		.weak	_ZNKSt18bad_variant_access4whatEv
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	_ZNKSt18bad_variant_access4whatEv:
  27              		.fnstart
  28              	.LVL0:
  29              	.LFB3066:
  30              		.file 1 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // <variant> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // Copyright (C) 2016-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** /** @file variant
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****  *  This is the `<variant>` C++ Library header.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****  */
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 2


  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #ifndef _GLIBCXX_VARIANT
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define _GLIBCXX_VARIANT 1
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #pragma GCC system_header
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #if __cplusplus >= 201703L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <type_traits>
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <utility>
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/enable_special_members.h>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/functexcept.h>
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/move.h>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/functional_hash.h>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/invoke.h>
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <ext/aligned_buffer.h>
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/parse_numbers.h>
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/stl_iterator_base_types.h>
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/stl_iterator_base_funcs.h>
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/stl_construct.h>
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #if __cplusplus > 201703L
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** # include <compare>
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #endif
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace std _GLIBCXX_VISIBILITY(default)
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __detail
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __variant
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Nth_type;
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _First, typename... _Rest>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Nth_type<_Np, _First, _Rest...>
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _Nth_type<_Np-1, _Rest...> { };
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _First, typename... _Rest>
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Nth_type<0, _First, _Rest...>
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = _First; };
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __variant
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __detail
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define __cpp_lib_variant 201606L
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types> class tuple;
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types> class variant;
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename> struct hash;
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size;
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<const _Variant> : variant_size<_Variant> {};
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 3


  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<volatile _Variant> : variant_size<_Variant> {};
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<const volatile _Variant> : variant_size<_Variant> {};
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<variant<_Types...>>
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : std::integral_constant<size_t, sizeof...(_Types)> {};
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr size_t variant_size_v = variant_size<_Variant>::value;
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative;
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _First, typename... _Rest>
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, variant<_First, _Rest...>>
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : variant_alternative<_Np-1, variant<_Rest...>> {};
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _First, typename... _Rest>
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<0, variant<_First, _Rest...>>
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = _First; };
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using variant_alternative_t =
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       typename variant_alternative<_Np, _Variant>::type;
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, const _Variant>
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = add_const_t<variant_alternative_t<_Np, _Variant>>; };
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, volatile _Variant>
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = add_volatile_t<variant_alternative_t<_Np, _Variant>>; };
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, const volatile _Variant>
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = add_cv_t<variant_alternative_t<_Np, _Variant>>; };
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   inline constexpr size_t variant_npos = -1;
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>>&
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(variant<_Types...>&);
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>>&&
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(variant<_Types...>&&);
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>> const&
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(const variant<_Types...>&);
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>> const&&
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(const variant<_Types...>&&);
ARM GAS  /tmp/cc5nV8qb.s 			page 4


 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, typename... _Variants>
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __do_visit(_Visitor&& __visitor, _Variants&&... __variants);
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename... _Types, typename _Tp>
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     decltype(auto)
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __variant_cast(_Tp&& __rhs)
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if constexpr (is_lvalue_reference_v<_Tp>)
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (is_const_v<remove_reference_t<_Tp>>)
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return static_cast<const variant<_Types...>&>(__rhs);
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return static_cast<variant<_Types...>&>(__rhs);
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       else
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         return static_cast<variant<_Types...>&&>(__rhs);
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __detail
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __variant
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns the first appearence of _Tp in _Types.
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns sizeof...(_Types) if _Tp is not in _Types.
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __index_of : std::integral_constant<size_t, 0> {};
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr size_t __index_of_v = __index_of<_Tp, _Types...>::value;
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _First, typename... _Rest>
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __index_of<_Tp, _First, _Rest...> :
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       std::integral_constant<size_t, is_same_v<_Tp, _First>
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	? 0 : __index_of_v<_Tp, _Rest...> + 1> {};
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // used for raw visitation
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   struct __variant_cookie {};
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // used for raw visitation with indices passed in
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   struct __variant_idx_cookie { using type = __variant_idx_cookie; };
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Used to enable deduction (and same-type checking) for std::visit:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename> struct __deduce_visit_result { };
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Visit variants that might be valueless.
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr void
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __raw_visit(_Visitor&& __visitor, _Variants&&... __variants)
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       std::__do_visit<__variant_cookie>(std::forward<_Visitor>(__visitor),
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				        std::forward<_Variants>(__variants)...);
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Visit variants that might be valueless, passing indices to the visitor.
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr void
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __raw_idx_visit(_Visitor&& __visitor, _Variants&&... __variants)
ARM GAS  /tmp/cc5nV8qb.s 			page 5


 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       std::__do_visit<__variant_idx_cookie>(std::forward<_Visitor>(__visitor),
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  std::forward<_Variants>(__variants)...);
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // _Uninitialized<T> is guaranteed to be a trivially destructible type,
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // even if T is not.
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Type, bool = std::is_trivially_destructible_v<_Type>>
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Uninitialized;
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Type>
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Uninitialized<_Type, true>
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Uninitialized(in_place_index_t<0>, _Args&&... __args)
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_storage(std::forward<_Args>(__args)...)
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr const _Type& _M_get() const & noexcept
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr _Type& _M_get() & noexcept
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr const _Type&& _M_get() const && noexcept
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(_M_storage); }
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr _Type&& _M_get() && noexcept
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(_M_storage); }
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Type _M_storage;
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Type>
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Uninitialized<_Type, false>
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Uninitialized(in_place_index_t<0>, _Args&&... __args)
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  ::new ((void*)std::addressof(_M_storage))
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    _Type(std::forward<_Args>(__args)...);
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       const _Type& _M_get() const & noexcept
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return *_M_storage._M_ptr(); }
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Type& _M_get() & noexcept
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return *_M_storage._M_ptr(); }
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       const _Type&& _M_get() const && noexcept
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(*_M_storage._M_ptr()); }
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Type&& _M_get() && noexcept
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(*_M_storage._M_ptr()); }
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 6


 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __gnu_cxx::__aligned_membuf<_Type> _M_storage;
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Union>
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __get(in_place_index_t<0>, _Union&& __u) noexcept
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Union>
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __get(in_place_index_t<_Np>, _Union&& __u) noexcept
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __variant::__get(in_place_index<_Np-1>,
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			      std::forward<_Union>(__u)._M_rest);
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns the typed storage for __v.
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __get(_Variant&& __v) noexcept
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __variant::__get(std::in_place_index<_Np>,
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			      std::forward<_Variant>(__v)._M_u);
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Traits
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_default_ctor =
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  is_default_constructible_v<typename _Nth_type<0, _Types...>::type>;
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_copy_ctor =
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_copy_constructible_v<_Types> && ...);
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_move_ctor =
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_move_constructible_v<_Types> && ...);
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_copy_assign =
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_copy_ctor
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_copy_assignable_v<_Types> && ...);
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_move_assign =
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_move_ctor
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_move_assignable_v<_Types> && ...);
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_dtor =
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_trivially_destructible_v<_Types> && ...);
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_copy_ctor =
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_trivially_copy_constructible_v<_Types> && ...);
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_move_ctor =
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_trivially_move_constructible_v<_Types> && ...);
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_copy_assign =
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_trivial_dtor && _S_trivial_copy_ctor
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_trivially_copy_assignable_v<_Types> && ...);
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_move_assign =
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_trivial_dtor && _S_trivial_move_ctor
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_trivially_move_assignable_v<_Types> && ...);
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // The following nothrow traits are for non-trivial SMFs. Trivial SMFs
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // are always nothrow.
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_default_ctor =
ARM GAS  /tmp/cc5nV8qb.s 			page 7


 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  is_nothrow_default_constructible_v<
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      typename _Nth_type<0, _Types...>::type>;
 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_copy_ctor = false;
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_move_ctor =
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_nothrow_move_constructible_v<_Types> && ...);
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_copy_assign = false;
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_move_assign =
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_nothrow_move_ctor
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_nothrow_move_assignable_v<_Types> && ...);
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Defines members and ctors.
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     union _Variadic_union { };
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _First, typename... _Rest>
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     union _Variadic_union<_First, _Rest...>
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr _Variadic_union() : _M_rest() { }
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr _Variadic_union(in_place_index_t<0>, _Args&&... __args)
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_first(in_place_index<0>, std::forward<_Args>(__args)...)
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr _Variadic_union(in_place_index_t<_Np>, _Args&&... __args)
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_rest(in_place_index<_Np-1>, std::forward<_Args>(__args)...)
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Uninitialized<_First> _M_first;
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variadic_union<_Rest...> _M_rest;
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // _Never_valueless_alt is true for variant alternatives that can
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // always be placed in a variant without it becoming valueless.
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // For suitably-small, trivially copyable types we can create temporaries
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // on the stack and then memcpy them into place.
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp>
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Never_valueless_alt
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : __and_<bool_constant<sizeof(_Tp) <= 256>, is_trivially_copyable<_Tp>>
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { };
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Specialize _Never_valueless_alt for other types which have a
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // non-throwing and cheap move construction and move assignment operator,
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // so that emplacing the type will provide the strong exception-safety
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // guarantee, by creating and moving a temporary.
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Whether _Never_valueless_alt<T> is true or not affects the ABI of a
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // variant using that alternative, so we can't change the value later!
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // True if every alternative in _Types... can be emplaced in a variant
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // without it becoming valueless. If this is true, variant<_Types...>
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // can never be valueless, which enables some minor optimizations.
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename... _Types>
 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr bool __never_valueless()
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
ARM GAS  /tmp/cc5nV8qb.s 			page 8


 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return _Traits<_Types...>::_S_move_assign
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	&& (_Never_valueless_alt<_Types>::value && ...);
 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Defines index and the dtor, possibly trivial.
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool __trivially_destructible, typename... _Types>
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_storage;
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename... _Types>
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using __select_index =
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       typename __select_int::_Select_int_base<sizeof...(_Types),
 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					      unsigned char,
 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					      unsigned short>::type::value_type;
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_storage<false, _Types...>
 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_storage()
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       : _M_index(static_cast<__index_type>(variant_npos))
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { }
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
 397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_index{_Np}
 398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void _M_reset()
 401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if (!_M_valid()) [[unlikely]]
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return;
 404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::__do_visit<void>([](auto&& __this_mem) mutable
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::_Destroy(std::__addressof(__this_mem));
 408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __variant_cast<_Types...>(*this));
 409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_index = static_cast<__index_type>(variant_npos);
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       ~_Variant_storage()
 414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_reset(); }
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void*
 417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_storage() const noexcept
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return const_cast<void*>(static_cast<const void*>(
 420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::addressof(_M_u)));
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr bool
 424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_valid() const noexcept
 425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (__variant::__never_valueless<_Types...>())
 427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return true;
ARM GAS  /tmp/cc5nV8qb.s 			page 9


 428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return this->_M_index != __index_type(variant_npos);
 429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variadic_union<_Types...> _M_u;
 432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using __index_type = __select_index<_Types...>;
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __index_type _M_index;
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_storage<true, _Types...>
 438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr
 440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_storage()
 441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       : _M_index(static_cast<__index_type>(variant_npos))
 442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { }
 443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
 447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_index{_Np}
 449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void _M_reset() noexcept
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_index = static_cast<__index_type>(variant_npos); }
 453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void*
 455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_storage() const noexcept
 456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return const_cast<void*>(static_cast<const void*>(
 458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::addressof(_M_u)));
 459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr bool
 462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_valid() const noexcept
 463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (__variant::__never_valueless<_Types...>())
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return true;
 466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return this->_M_index != static_cast<__index_type>(variant_npos);
 467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variadic_union<_Types...> _M_u;
 470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using __index_type = __select_index<_Types...>;
 471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __index_type _M_index;
 472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Variant_storage_alias =
 476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_storage<_Traits<_Types...>::_S_trivial_dtor, _Types...>;
 477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Up>
 479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void __variant_construct_single(_Tp&& __lhs, _Up&& __rhs_mem)
 480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void* __storage = std::addressof(__lhs._M_u);
 482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Type = remove_reference_t<decltype(__rhs_mem)>;
 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if constexpr (!is_same_v<_Type, __variant_cookie>)
 484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         ::new (__storage)
ARM GAS  /tmp/cc5nV8qb.s 			page 10


 485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Type(std::forward<decltype(__rhs_mem)>(__rhs_mem));
 486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types, typename _Tp, typename _Up>
 489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void __variant_construct(_Tp&& __lhs, _Up&& __rhs)
 490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __lhs._M_index = __rhs._M_index;
 492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __variant::__raw_visit([&__lhs](auto&& __rhs_mem) mutable
 493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(std::forward<_Tp>(__lhs),
 495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      std::forward<decltype(__rhs_mem)>(__rhs_mem));
 496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}, __variant_cast<_Types...>(std::forward<_Up>(__rhs)));
 497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The following are (Copy|Move) (ctor|assign) layers for forwarding
 500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // triviality and handling non-trivial SMF behaviors.
 501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_ctor_base : _Variant_storage_alias<_Types...>
 504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Variant_storage_alias<_Types...>;
 506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base(const _Copy_ctor_base& __rhs)
 509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_copy_ctor)
 510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant_construct<_Types...>(*this, __rhs);
 512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base(_Copy_ctor_base&&) = default;
 515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base& operator=(const _Copy_ctor_base&) = default;
 516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base& operator=(_Copy_ctor_base&&) = default;
 517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_ctor_base<true, _Types...> : _Variant_storage_alias<_Types...>
 521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Variant_storage_alias<_Types...>;
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Copy_ctor_alias =
 528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Copy_ctor_base<_Traits<_Types...>::_S_trivial_copy_ctor, _Types...>;
 529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_ctor_base : _Copy_ctor_alias<_Types...>
 532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_ctor_alias<_Types...>;
 534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base(_Move_ctor_base&& __rhs)
 537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_move_ctor)
 538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant_construct<_Types...>(*this, std::move(__rhs));
 540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 11


 542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)
 544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, std::forward<_Up>(__rhs));
 547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)
 552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, __rhs);
 555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base(const _Move_ctor_base&) = default;
 559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base& operator=(const _Move_ctor_base&) = default;
 560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base& operator=(_Move_ctor_base&&) = default;
 561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_ctor_base<true, _Types...> : _Copy_ctor_alias<_Types...>
 565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_ctor_alias<_Types...>;
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)
 571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, std::forward<_Up>(__rhs));
 574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)
 579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, __rhs);
 582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Move_ctor_alias =
 588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Move_ctor_base<_Traits<_Types...>::_S_trivial_move_ctor, _Types...>;
 589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_assign_base : _Move_ctor_alias<_Types...>
 592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Move_ctor_alias<_Types...>;
 594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base&
 597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       operator=(const _Copy_assign_base& __rhs)
 598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_copy_assign)
ARM GAS  /tmp/cc5nV8qb.s 			page 12


 599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant::__raw_idx_visit(
 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  [this](auto&& __rhs_mem, auto __rhs_index) mutable
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
 603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    if constexpr (__rhs_index != variant_npos)
 604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      {
 605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		if (this->_M_index == __rhs_index)
 606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant::__get<__rhs_index>(*this) = __rhs_mem;
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		else
 608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  {
 609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    using __rhs_type = __remove_cvref_t<decltype(__rhs_mem)>;
 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    if constexpr (is_nothrow_copy_constructible_v<__rhs_type>
 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			|| !is_nothrow_move_constructible_v<__rhs_type>)
 612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // The standard says this->emplace<__rhs_type>(__rhs_mem)
 613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // should be used here, but _M_destructive_copy is
 614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // equivalent in this case. Either copy construction
 615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // doesn't throw, so _M_destructive_copy gives strong
 616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // exception safety guarantee, or both copy construction
 617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // and move construction can throw, so emplace only gives
 618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // basic exception safety anyway.
 619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      this->_M_destructive_copy(__rhs_index, __rhs_mem);
 620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    else
 621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      __variant_cast<_Types...>(*this)
 622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			= variant<_Types...>(std::in_place_index<__rhs_index>,
 623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					     __rhs_mem);
 624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  }
 625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      }
 626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    else
 627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
 628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __variant_cast<_Types...>(__rhs));
 629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return *this;
 630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base(const _Copy_assign_base&) = default;
 633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base(_Copy_assign_base&&) = default;
 634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base& operator=(_Copy_assign_base&&) = default;
 635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_assign_base<true, _Types...> : _Move_ctor_alias<_Types...>
 639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Move_ctor_alias<_Types...>;
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Copy_assign_alias =
 646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base<_Traits<_Types...>::_S_trivial_copy_assign, _Types...>;
 647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_assign_base : _Copy_assign_alias<_Types...>
 650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_assign_alias<_Types...>;
 652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base&
 655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       operator=(_Move_assign_base&& __rhs)
ARM GAS  /tmp/cc5nV8qb.s 			page 13


 656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_move_assign)
 657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant::__raw_idx_visit(
 659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  [this](auto&& __rhs_mem, auto __rhs_index) mutable
 660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
 661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    if constexpr (__rhs_index != variant_npos)
 662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      {
 663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		if (this->_M_index == __rhs_index)
 664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant::__get<__rhs_index>(*this) = std::move(__rhs_mem);
 665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		else
 666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant_cast<_Types...>(*this)
 667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    .template emplace<__rhs_index>(std::move(__rhs_mem));
 668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      }
 669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    else
 670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
 671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __variant_cast<_Types...>(__rhs));
 672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return *this;
 673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base(const _Move_assign_base&) = default;
 676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base(_Move_assign_base&&) = default;
 677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base& operator=(const _Move_assign_base&) = default;
 678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_assign_base<true, _Types...> : _Copy_assign_alias<_Types...>
 682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_assign_alias<_Types...>;
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Move_assign_alias =
 689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base<_Traits<_Types...>::_S_trivial_move_assign, _Types...>;
 690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_base : _Move_assign_alias<_Types...>
 693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Move_assign_alias<_Types...>;
 695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base()
 698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_default_ctor)
 699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       : _Variant_base(in_place_index<0>) { }
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_base(in_place_index_t<_Np> __i, _Args&&... __args)
 704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _Base(__i, std::forward<_Args>(__args)...)
 705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base(const _Variant_base&) = default;
 708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base(_Variant_base&&) = default;
 709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base& operator=(const _Variant_base&) = default;
 710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base& operator=(_Variant_base&&) = default;
 711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 14


 713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // For how many times does _Tp appear in _Tuple?
 714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Tuple>
 715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __tuple_count;
 716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Tuple>
 718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr size_t __tuple_count_v =
 719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __tuple_count<_Tp, _Tuple>::value;
 720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __tuple_count<_Tp, tuple<_Types...>>
 723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : integral_constant<size_t, 0> { };
 724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _First, typename... _Rest>
 726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __tuple_count<_Tp, tuple<_First, _Rest...>>
 727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : integral_constant<
 728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	size_t,
 729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__tuple_count_v<_Tp, tuple<_Rest...>> + is_same_v<_Tp, _First>> { };
 730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // TODO: Reuse this in <tuple> ?
 732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr bool __exactly_once =
 734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __tuple_count_v<_Tp, tuple<_Types...>> == 1;
 735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Helper used to check for valid conversions that don't involve narrowing.
 737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Ti> struct _Arr { _Ti _M_x[1]; };
 738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Build an imaginary function FUN(Ti) for each alternative type Ti
 740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Ind, typename _Tp, typename _Ti,
 741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   bool _Ti_is_cv_bool = is_same_v<remove_cv_t<_Ti>, bool>,
 742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename = void>
 743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUN
 744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // This function means 'using _Build_FUN<I, T, Ti>::_S_fun;' is valid,
 746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // but only static functions will be considered in the call below.
 747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void _S_fun();
 748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // ... for which Ti x[] = {std::forward<T>(t)}; is well-formed,
 751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Ind, typename _Tp, typename _Ti>
 752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUN<_Ind, _Tp, _Ti, false,
 753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      void_t<decltype(_Arr<_Ti>{{std::declval<_Tp>()}})>>
 754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // This is the FUN function for type _Ti, with index _Ind
 756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static integral_constant<size_t, _Ind> _S_fun(_Ti);
 757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // ... and if Ti is cv bool, remove_cvref_t<T> is bool.
 760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Ind, typename _Tp, typename _Ti>
 761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUN<_Ind, _Tp, _Ti, true,
 762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      enable_if_t<is_same_v<__remove_cvref_t<_Tp>, bool>>>
 763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // This is the FUN function for when _Ti is cv bool, with index _Ind
 765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static integral_constant<size_t, _Ind> _S_fun(_Ti);
 766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant,
 769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename = make_index_sequence<variant_size_v<_Variant>>>
ARM GAS  /tmp/cc5nV8qb.s 			page 15


 770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUNs;
 771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Ti, size_t... _Ind>
 773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUNs<_Tp, variant<_Ti...>, index_sequence<_Ind...>>
 774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _Build_FUN<_Ind, _Tp, _Ti>...
 775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Build_FUN<_Ind, _Tp, _Ti>::_S_fun...;
 777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The index j of the overload FUN(Tj) selected by overload resolution
 780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // for FUN(std::forward<_Tp>(t))
 781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant>
 782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _FUN_type
 783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       = decltype(_Build_FUNs<_Tp, _Variant>::_S_fun(std::declval<_Tp>()));
 784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The index selected for FUN(std::forward<T>(t)), or variant_npos if none.
 786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant, typename = void>
 787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __accepted_index
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : integral_constant<size_t, variant_npos>
 789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { };
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant>
 792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __accepted_index<_Tp, _Variant, void_t<_FUN_type<_Tp, _Variant>>>
 793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _FUN_type<_Tp, _Variant>
 794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { };
 795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns the raw storage for __v.
 797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
 798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void* __get_storage(_Variant&& __v) noexcept
 799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return __v._M_storage(); }
 800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename _Maybe_variant_cookie, typename _Variant>
 802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Extra_visit_slot_needed
 803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename> struct _Variant_never_valueless;
 805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Types>
 807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct _Variant_never_valueless<variant<_Types...>>
 808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: bool_constant<__variant::__never_valueless<_Types...>()> {};
 809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool value =
 811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	(is_same_v<_Maybe_variant_cookie, __variant_cookie>
 812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	 || is_same_v<_Maybe_variant_cookie, __variant_idx_cookie>)
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	&& !_Variant_never_valueless<__remove_cvref_t<_Variant>>::value;
 814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Used for storing a multi-dimensional vtable.
 817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, size_t... _Dimensions>
 818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Multi_array;
 819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Partial specialization with rank zero, stores a single _Tp element.
 821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp>
 822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Multi_array<_Tp>
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename>
 825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result
 826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
ARM GAS  /tmp/cc5nV8qb.s 			page 16


 827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = _Tp; };
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Args>
 830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<const void(*)(_Args...)>
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
 832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = void(*)(_Args...); };
 833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Args>
 835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<__variant_cookie(*)(_Args...)>
 836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
 837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = void(*)(_Args...); };
 838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Args>
 840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<__variant_idx_cookie(*)(_Args...)>
 841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
 842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = void(*)(_Args...); };
 843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename _Res, typename... _Args>
 845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<__deduce_visit_result<_Res>(*)(_Args...)>
 846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: true_type
 847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = _Res(*)(_Args...); };
 848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using __result_is_deduced = __untag_result<_Tp>;
 850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr const typename __untag_result<_Tp>::element_type&
 852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_access() const
 853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_data; }
 854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       typename __untag_result<_Tp>::element_type _M_data;
 856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Partial specialization with rank >= 1.
 859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Ret,
 860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename _Visitor,
 861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename... _Variants,
 862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   size_t __first, size_t... __rest>
 863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Multi_array<_Ret(*)(_Visitor, _Variants...), __first, __rest...>
 864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr size_t __index =
 866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	sizeof...(_Variants) - sizeof...(__rest) - 1;
 867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Variant = typename _Nth_type<__index, _Variants...>::type;
 869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr int __do_cookie =
 871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Extra_visit_slot_needed<_Ret, _Variant>::value ? 1 : 0;
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Tp = _Ret(*)(_Visitor, _Variants...);
 874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr decltype(auto)
 877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_access(size_t __first_index, _Args... __rest_indices) const
 878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return _M_arr[__first_index + __do_cookie]
 880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    ._M_access(__rest_indices...);
 881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Multi_array<_Tp, __rest...> _M_arr[__first + __do_cookie];
ARM GAS  /tmp/cc5nV8qb.s 			page 17


 884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Creates a multi-dimensional vtable recursively.
 887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //
 888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // For example,
 889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // visit([](auto, auto){},
 890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //       variant<int, char>(),  // typedef'ed as V1
 891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //       variant<float, double, long double>())  // typedef'ed as V2
 892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // will trigger instantiations of:
 893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 2, 3>,
 894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                   tuple<V1&&, V2&&>, std::index_sequence<>>
 895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //   __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 3>,
 896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                     tuple<V1&&, V2&&>, std::index_sequence<0>>
 897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 0>>
 899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 1>>
 901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 2>>
 903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //   __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 3>,
 904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                     tuple<V1&&, V2&&>, std::index_sequence<1>>
 905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 0>>
 907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 1>>
 909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 2>>
 911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The returned multi-dimensional vtable can be fast accessed by the visitor
 912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // using index calculation.
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Array_type, typename _Index_seq>
 914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable_impl;
 915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Defines the _S_apply() member that returns a _Multi_array populated
 917:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // with function pointers that perform the visitation expressions e(m)
 918:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // for each valid pack of indexes into the variant types _Variants.
 919:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //
 920:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // This partial specialization builds up the index sequences by recursively
 921:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // calling _S_apply() on the next specialization of __gen_vtable_impl.
 922:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The base case of the recursion defines the actual function pointers.
 923:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, size_t... __dimensions,
 924:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename... _Variants, size_t... __indices>
 925:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable_impl<
 926:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Multi_array<_Result_type (*)(_Visitor, _Variants...), __dimensions...>,
 927:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::index_sequence<__indices...>>
 928:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 929:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Next =
 930:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  remove_reference_t<typename _Nth_type<sizeof...(__indices),
 931:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			     _Variants...>::type>;
 932:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Array_type =
 933:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Multi_array<_Result_type (*)(_Visitor, _Variants...),
 934:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		       __dimensions...>;
 935:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 936:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr _Array_type
 937:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _S_apply()
 938:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 939:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Array_type __vtable{};
 940:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_S_apply_all_alts(
ARM GAS  /tmp/cc5nV8qb.s 			page 18


 941:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __vtable, make_index_sequence<variant_size_v<_Next>>());
 942:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return __vtable;
 943:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 944:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 945:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t... __var_indices>
 946:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr void
 947:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_S_apply_all_alts(_Array_type& __vtable,
 948:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			  std::index_sequence<__var_indices...>)
 949:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 950:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (_Extra_visit_slot_needed<_Result_type, _Next>::value)
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    (_S_apply_single_alt<true, __var_indices>(
 952:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __vtable._M_arr[__var_indices + 1],
 953:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      &(__vtable._M_arr[0])), ...);
 954:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 955:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    (_S_apply_single_alt<false, __var_indices>(
 956:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __vtable._M_arr[__var_indices]), ...);
 957:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 958:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 959:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<bool __do_cookie, size_t __index, typename _Tp>
 960:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr void
 961:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_S_apply_single_alt(_Tp& __element, _Tp* __cookie_element = nullptr)
 962:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 963:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__do_cookie)
 964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
 965:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element = __gen_vtable_impl<
 966:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		_Tp,
 967:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::index_sequence<__indices..., __index>>::_S_apply();
 968:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      *__cookie_element = __gen_vtable_impl<
 969:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		_Tp,
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::index_sequence<__indices..., variant_npos>>::_S_apply();
 971:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
 972:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 973:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
 974:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element = __gen_vtable_impl<
 975:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		remove_reference_t<decltype(__element)>,
 976:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::index_sequence<__indices..., __index>>::_S_apply();
 977:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
 978:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 979:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 980:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 981:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // This partial specialization is the base case for the recursion.
 982:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // It populates a _Multi_array element with the address of a function
 983:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // that invokes the visitor with the alternatives specified by __indices.
 984:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, typename... _Variants,
 985:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   size_t... __indices>
 986:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable_impl<
 987:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Multi_array<_Result_type (*)(_Visitor, _Variants...)>,
 988:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		   std::index_sequence<__indices...>>
 989:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 990:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Array_type =
 991:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Multi_array<_Result_type (*)(_Visitor, _Variants...)>;
 992:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 993:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t __index, typename _Variant>
 994:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr decltype(auto)
 995:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__element_by_index_or_cookie(_Variant&& __var) noexcept
 996:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 997:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__index != variant_npos)
ARM GAS  /tmp/cc5nV8qb.s 			page 19


 998:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return __variant::__get<__index>(std::forward<_Variant>(__var));
 999:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
1000:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return __variant_cookie{};
1001:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1002:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1003:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr decltype(auto)
1004:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __visit_invoke(_Visitor&& __visitor, _Variants... __vars)
1005:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
1006:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (is_same_v<_Result_type, __variant_idx_cookie>)
1007:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // For raw visitation using indices, pass the indices to the visitor
1008:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // and discard the return value:
1009:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  std::__invoke(std::forward<_Visitor>(__visitor),
1010:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element_by_index_or_cookie<__indices>(
1011:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::forward<_Variants>(__vars))...,
1012:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      integral_constant<size_t, __indices>()...);
1013:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (is_same_v<_Result_type, __variant_cookie>)
1014:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // For raw visitation without indices, and discard the return value:
1015:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  std::__invoke(std::forward<_Visitor>(__visitor),
1016:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element_by_index_or_cookie<__indices>(
1017:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::forward<_Variants>(__vars))...);
1018:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (_Array_type::__result_is_deduced::value)
1019:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // For the usual std::visit case deduce the return value:
1020:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return std::__invoke(std::forward<_Visitor>(__visitor),
1021:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element_by_index_or_cookie<__indices>(
1022:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::forward<_Variants>(__vars))...);
1023:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else // for std::visit<R> use INVOKE<R>
1024:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return std::__invoke_r<_Result_type>(
1025:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      std::forward<_Visitor>(__visitor),
1026:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __variant::__get<__indices>(std::forward<_Variants>(__vars))...);
1027:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
1028:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1029:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr auto
1030:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _S_apply()
1031:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _Array_type{&__visit_invoke}; }
1032:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
1033:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1034:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, typename... _Variants>
1035:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable
1036:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1037:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Array_type =
1038:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Multi_array<_Result_type (*)(_Visitor, _Variants...),
1039:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		       variant_size_v<remove_reference_t<_Variants>>...>;
1040:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1041:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr _Array_type _S_vtable
1042:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	= __gen_vtable_impl<_Array_type, std::index_sequence<>>::_S_apply();
1043:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
1044:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1045:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Tp>
1046:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Base_dedup : public _Tp { };
1047:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1048:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant, typename __indices>
1049:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_hash_base;
1050:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1051:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types, size_t... __indices>
1052:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_hash_base<variant<_Types...>,
1053:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			      std::index_sequence<__indices...>>
1054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _Base_dedup<__indices, __poison_hash<remove_const_t<_Types>>>... { };
ARM GAS  /tmp/cc5nV8qb.s 			page 20


1055:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1056:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
1057:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using __get_t = decltype(std::get<_Np>(std::declval<_Variant>()));
1058:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1059:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Return type of std::visit.
1060:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
1061:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using __visit_result_t
1062:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       = invoke_result_t<_Visitor, __get_t<0, _Variants>...>;
1063:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1064:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __variant
1065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __detail
1066:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1067:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant, typename... _Args>
1068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void __variant_construct_by_index(_Variant& __v, _Args&&... __args)
1069:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __v._M_index = _Np;
1071:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       auto&& __storage = __detail::__variant::__get<_Np>(__v);
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       ::new ((void*)std::addressof(__storage))
1073:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         remove_reference_t<decltype(__storage)>
1074:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (std::forward<_Args>(__args)...);
1075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1076:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1077:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1078:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr bool
1079:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     holds_alternative(const variant<_Types...>& __v) noexcept
1080:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1081:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1082:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1083:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __v.index() == __detail::__variant::__index_of_v<_Tp, _Types...>;
1084:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1085:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1086:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1087:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr _Tp& get(variant<_Types...>& __v)
1088:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1089:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1090:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1091:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1092:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
1093:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1094:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1095:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1096:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr _Tp&& get(variant<_Types...>&& __v)
1097:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1098:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1099:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::move(__v));
1103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr const _Tp& get(const variant<_Types...>& __v)
1107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
ARM GAS  /tmp/cc5nV8qb.s 			page 21


1112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr const _Tp&& get(const variant<_Types...>&& __v)
1116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::move(__v));
1122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
1125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr add_pointer_t<variant_alternative_t<_Np, variant<_Types...>>>
1126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(variant<_Types...>* __ptr) noexcept
1127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
1129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(_Np < sizeof...(_Types),
1130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "The index must be in [0, number of alternatives)");
1131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Alternative_type>, "_Tp must not be void");
1132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if (__ptr && __ptr->index() == _Np)
1133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return std::addressof(__detail::__variant::__get<_Np>(*__ptr));
1134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return nullptr;
1135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
1138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr
1139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     add_pointer_t<const variant_alternative_t<_Np, variant<_Types...>>>
1140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(const variant<_Types...>* __ptr) noexcept
1141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
1143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(_Np < sizeof...(_Types),
1144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "The index must be in [0, number of alternatives)");
1145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Alternative_type>, "_Tp must not be void");
1146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if (__ptr && __ptr->index() == _Np)
1147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return std::addressof(__detail::__variant::__get<_Np>(*__ptr));
1148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return nullptr;
1149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr add_pointer_t<_Tp>
1153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(variant<_Types...>* __ptr) noexcept
1154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __ptr);
1160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr add_pointer_t<const _Tp>
1164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(const variant<_Types...>* __ptr) noexcept
1165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
ARM GAS  /tmp/cc5nV8qb.s 			page 22


1169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __ptr);
1171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   struct monostate { };
1174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP, __NAME) \
1176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types> \
1177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr bool operator __OP(const variant<_Types...>& __lhs, \
1178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				 const variant<_Types...>& __rhs) \
1179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { \
1180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       bool __ret = true; \
1181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __detail::__variant::__raw_idx_visit( \
1182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         [&__ret, &__lhs] (auto&& __rhs_mem, auto __rhs_index) mutable \
1183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         { \
1184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__rhs_index != variant_npos) \
1185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    { \
1186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      if (__lhs.index() == __rhs_index) \
1187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	        { \
1188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  auto& __this_mem = std::get<__rhs_index>(__lhs);	\
1189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****                   __ret = __this_mem __OP __rhs_mem; \
1190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****                 } \
1191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      else \
1192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		__ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \
1193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****             } \
1194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****           else \
1195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****             __ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \
1196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}, __rhs); \
1197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __ret; \
1198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(<, less)
1201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(<=, less_equal)
1202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(==, equal)
1203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(!=, not_equal)
1204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(>=, greater_equal)
1205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(>, greater)
1206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #undef _VARIANT_RELATION_FUNCTION_TEMPLATE
1208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator==(monostate, monostate) noexcept { return true; }
1210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #ifdef __cpp_lib_three_way_comparison
1212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     requires (three_way_comparable<_Types> && ...)
1214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr
1215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     common_comparison_category_t<compare_three_way_result_t<_Types>...>
1216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     operator<=>(const variant<_Types...>& __v, const variant<_Types...>& __w)
1217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       common_comparison_category_t<compare_three_way_result_t<_Types>...> __ret
1219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	= strong_ordering::equal;
1220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __detail::__variant::__raw_idx_visit(
1222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	[&__ret, &__v] (auto&& __w_mem, auto __w_index) mutable
1223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__w_index != variant_npos)
1225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
ARM GAS  /tmp/cc5nV8qb.s 			page 23


1226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      if (__v.index() == __w_index)
1227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  auto& __this_mem = std::get<__w_index>(__v);
1229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __ret = __this_mem <=> __w_mem;
1230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  return;
1231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __ret = (__v.index() + 1) <=> (__w_index + 1);
1234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}, __w);
1235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __ret;
1236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr strong_ordering
1239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   operator<=>(monostate, monostate) noexcept { return strong_ordering::equal; }
1240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #else
1241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator!=(monostate, monostate) noexcept { return false; }
1242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator<(monostate, monostate) noexcept { return false; }
1243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator>(monostate, monostate) noexcept { return false; }
1244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator<=(monostate, monostate) noexcept { return true; }
1245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator>=(monostate, monostate) noexcept { return true; }
1246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #endif
1247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
1249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
1250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     visit(_Visitor&&, _Variants&&...);
1251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline enable_if_t<(is_move_constructible_v<_Types> && ...)
1254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			&& (is_swappable_v<_Types> && ...)>
1255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     swap(variant<_Types...>& __lhs, variant<_Types...>& __rhs)
1256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     noexcept(noexcept(__lhs.swap(__rhs)))
1257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { __lhs.swap(__rhs); }
1258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     enable_if_t<!((is_move_constructible_v<_Types> && ...)
1261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		   && (is_swappable_v<_Types> && ...))>
1262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     swap(variant<_Types...>&, variant<_Types...>&) = delete;
1263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   class bad_variant_access : public exception
1265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
1266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   public:
1267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     bad_variant_access() noexcept { }
1268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     const char* what() const noexcept override
  31              		.loc 1 1269 17 view -0
  32              		.cfi_startproc
  33              		@ args = 0, pretend = 0, frame = 0
  34              		@ frame_needed = 0, uses_anonymous_args = 0
  35              		@ link register save eliminated.
1270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return _M_reason; }
  36              		.loc 1 1270 7 view .LVU1
  37              		.loc 1 1270 25 is_stmt 0 view .LVU2
  38 0000 4068     		ldr	r0, [r0, #4]
  39              	.LVL1:
  40              		.loc 1 1270 25 view .LVU3
  41 0002 7047     		bx	lr
  42              		.cfi_endproc
ARM GAS  /tmp/cc5nV8qb.s 			page 24


  43              	.LFE3066:
  44              		.cantunwind
  45              		.fnend
  47              		.section	.text._ZL8get_gpioj,"ax",%progbits
  48              		.align	1
  49              		.syntax unified
  50              		.thumb
  51              		.thumb_func
  53              	_ZL8get_gpioj:
  54              		.fnstart
  55              	.LVL2:
  56              	.LFB5151:
  57              		.file 2 "MotorControl/odrive_main.h"
   1:MotorControl/odrive_main.h **** #ifndef __ODRIVE_MAIN_H
   2:MotorControl/odrive_main.h **** #define __ODRIVE_MAIN_H
   3:MotorControl/odrive_main.h **** 
   4:MotorControl/odrive_main.h **** // Hardware configuration
   5:MotorControl/odrive_main.h **** #include <board.h>
   6:MotorControl/odrive_main.h **** 
   7:MotorControl/odrive_main.h **** #ifdef __cplusplus
   8:MotorControl/odrive_main.h **** #include <communication/interface_usb.h>
   9:MotorControl/odrive_main.h **** #include <communication/interface_i2c.h>
  10:MotorControl/odrive_main.h **** #include <communication/interface_uart.h>
  11:MotorControl/odrive_main.h **** #include <task_timer.hpp>
  12:MotorControl/odrive_main.h **** extern "C" {
  13:MotorControl/odrive_main.h **** #endif
  14:MotorControl/odrive_main.h **** 
  15:MotorControl/odrive_main.h **** // OS includes
  16:MotorControl/odrive_main.h **** #include <cmsis_os.h>
  17:MotorControl/odrive_main.h **** 
  18:MotorControl/odrive_main.h **** // extern const float elec_rad_per_enc;
  19:MotorControl/odrive_main.h **** extern uint32_t _reboot_cookie;
  20:MotorControl/odrive_main.h **** 
  21:MotorControl/odrive_main.h **** extern uint64_t serial_number;
  22:MotorControl/odrive_main.h **** extern char serial_number_str[13];
  23:MotorControl/odrive_main.h **** 
  24:MotorControl/odrive_main.h **** #ifdef __cplusplus
  25:MotorControl/odrive_main.h **** }
  26:MotorControl/odrive_main.h **** 
  27:MotorControl/odrive_main.h **** typedef struct {
  28:MotorControl/odrive_main.h ****     bool fully_booted;
  29:MotorControl/odrive_main.h ****     uint32_t uptime; // [ms]
  30:MotorControl/odrive_main.h ****     uint32_t min_heap_space; // FreeRTOS heap [Bytes]
  31:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_axis; // minimum remaining space since startup [Bytes]
  32:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_usb;
  33:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_uart;
  34:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_startup;
  35:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_can;
  36:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_analog;
  37:MotorControl/odrive_main.h **** 
  38:MotorControl/odrive_main.h ****     uint32_t stack_size_axis;
  39:MotorControl/odrive_main.h ****     uint32_t stack_size_usb;
  40:MotorControl/odrive_main.h ****     uint32_t stack_size_uart;
  41:MotorControl/odrive_main.h ****     uint32_t stack_size_startup;
  42:MotorControl/odrive_main.h ****     uint32_t stack_size_can;
  43:MotorControl/odrive_main.h ****     uint32_t stack_size_analog;
  44:MotorControl/odrive_main.h **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 25


  45:MotorControl/odrive_main.h ****     int32_t prio_axis;
  46:MotorControl/odrive_main.h ****     int32_t prio_usb;
  47:MotorControl/odrive_main.h ****     int32_t prio_uart;
  48:MotorControl/odrive_main.h ****     int32_t prio_startup;
  49:MotorControl/odrive_main.h ****     int32_t prio_can;
  50:MotorControl/odrive_main.h ****     int32_t prio_analog;
  51:MotorControl/odrive_main.h **** 
  52:MotorControl/odrive_main.h ****     USBStats_t& usb = usb_stats_;
  53:MotorControl/odrive_main.h ****     I2CStats_t& i2c = i2c_stats_;
  54:MotorControl/odrive_main.h **** } SystemStats_t;
  55:MotorControl/odrive_main.h **** 
  56:MotorControl/odrive_main.h **** struct PWMMapping_t {
  57:MotorControl/odrive_main.h ****     endpoint_ref_t endpoint = {0, 0};
  58:MotorControl/odrive_main.h ****     float min = 0;
  59:MotorControl/odrive_main.h ****     float max = 0;
  60:MotorControl/odrive_main.h **** };
  61:MotorControl/odrive_main.h **** 
  62:MotorControl/odrive_main.h **** // @brief general user configurable board configuration
  63:MotorControl/odrive_main.h **** struct BoardConfig_t {
  64:MotorControl/odrive_main.h ****     ODriveIntf::GpioMode gpio_modes[GPIO_COUNT] = {
  65:MotorControl/odrive_main.h ****         DEFAULT_GPIO_MODES
  66:MotorControl/odrive_main.h ****     };
  67:MotorControl/odrive_main.h **** 
  68:MotorControl/odrive_main.h ****     bool enable_uart_a = true;
  69:MotorControl/odrive_main.h ****     bool enable_uart_b = false;
  70:MotorControl/odrive_main.h ****     bool enable_uart_c = false;
  71:MotorControl/odrive_main.h ****     uint32_t uart_a_baudrate = 115200;
  72:MotorControl/odrive_main.h ****     uint32_t uart_b_baudrate = 115200;
  73:MotorControl/odrive_main.h ****     uint32_t uart_c_baudrate = 115200;
  74:MotorControl/odrive_main.h ****     bool enable_can_a = true;
  75:MotorControl/odrive_main.h ****     bool enable_i2c_a = false;
  76:MotorControl/odrive_main.h ****     ODriveIntf::StreamProtocolType uart0_protocol = ODriveIntf::STREAM_PROTOCOL_TYPE_ASCII_AND_STDO
  77:MotorControl/odrive_main.h ****     ODriveIntf::StreamProtocolType uart1_protocol = ODriveIntf::STREAM_PROTOCOL_TYPE_ASCII_AND_STDO
  78:MotorControl/odrive_main.h ****     ODriveIntf::StreamProtocolType uart2_protocol = ODriveIntf::STREAM_PROTOCOL_TYPE_ASCII_AND_STDO
  79:MotorControl/odrive_main.h ****     ODriveIntf::StreamProtocolType usb_cdc_protocol = ODriveIntf::STREAM_PROTOCOL_TYPE_ASCII_AND_ST
  80:MotorControl/odrive_main.h ****     float max_regen_current = 0.0f;
  81:MotorControl/odrive_main.h ****     float brake_resistance = DEFAULT_BRAKE_RESISTANCE;
  82:MotorControl/odrive_main.h ****     bool enable_brake_resistor = false;
  83:MotorControl/odrive_main.h ****     float dc_bus_undervoltage_trip_level = DEFAULT_MIN_DC_VOLTAGE;      //<! [V] minimum voltage be
  84:MotorControl/odrive_main.h ****     float dc_bus_overvoltage_trip_level = 1.07f * HW_VERSION_VOLTAGE;   //<! [V] maximum voltage ab
  85:MotorControl/odrive_main.h ****                                                                         //<! This protects against 
  86:MotorControl/odrive_main.h ****                                                                         //<! the brake power if the
  87:MotorControl/odrive_main.h ****                                                                         //<! The default is 26V for
  88:MotorControl/odrive_main.h **** 
  89:MotorControl/odrive_main.h ****     /**
  90:MotorControl/odrive_main.h ****      * If enabled, if the measured DC voltage exceeds `dc_bus_overvoltage_ramp_start`,
  91:MotorControl/odrive_main.h ****      * the ODrive will sink more power than usual into the the brake resistor
  92:MotorControl/odrive_main.h ****      * in an attempt to bring the voltage down again.
  93:MotorControl/odrive_main.h ****      * 
  94:MotorControl/odrive_main.h ****      * The brake duty cycle is increased by the following amount:
  95:MotorControl/odrive_main.h ****      *  vbus_voltage == dc_bus_overvoltage_ramp_start  =>  brake_duty_cycle += 0%
  96:MotorControl/odrive_main.h ****      *  vbus_voltage == dc_bus_overvoltage_ramp_end  =>  brake_duty_cycle += 100%
  97:MotorControl/odrive_main.h ****      * 
  98:MotorControl/odrive_main.h ****      * Remarks:
  99:MotorControl/odrive_main.h ****      *  - This feature is active even when all motors are disarmed.
 100:MotorControl/odrive_main.h ****      *  - This feature is disabled if `brake_resistance` is non-positive.
 101:MotorControl/odrive_main.h ****      */
ARM GAS  /tmp/cc5nV8qb.s 			page 26


 102:MotorControl/odrive_main.h ****     bool enable_dc_bus_overvoltage_ramp = false;
 103:MotorControl/odrive_main.h ****     float dc_bus_overvoltage_ramp_start = 1.07f * HW_VERSION_VOLTAGE; //!< See `enable_dc_bus_overv
 104:MotorControl/odrive_main.h ****                                                                       //!< Do not set this lower th
 105:MotorControl/odrive_main.h ****                                                                       //!< unless you like fried br
 106:MotorControl/odrive_main.h ****     float dc_bus_overvoltage_ramp_end = 1.07f * HW_VERSION_VOLTAGE; //!< See `enable_dc_bus_overvol
 107:MotorControl/odrive_main.h ****                                                                     //!< Must be larger than `dc_bu
 108:MotorControl/odrive_main.h ****                                                                     //!< otherwise the ramp feature
 109:MotorControl/odrive_main.h **** 
 110:MotorControl/odrive_main.h ****     float dc_max_positive_current = INFINITY; // Max current [A] the power supply can source
 111:MotorControl/odrive_main.h ****     float dc_max_negative_current = -0.01f; // Max current [A] the power supply can sink. You most 
 112:MotorControl/odrive_main.h ****     uint32_t error_gpio_pin = DEFAULT_ERROR_PIN;
 113:MotorControl/odrive_main.h ****     PWMMapping_t pwm_mappings[4];
 114:MotorControl/odrive_main.h ****     PWMMapping_t analog_mappings[GPIO_COUNT];
 115:MotorControl/odrive_main.h **** };
 116:MotorControl/odrive_main.h **** 
 117:MotorControl/odrive_main.h **** struct TaskTimes {
 118:MotorControl/odrive_main.h ****     TaskTimer sampling;
 119:MotorControl/odrive_main.h ****     TaskTimer control_loop_misc;
 120:MotorControl/odrive_main.h ****     TaskTimer control_loop_checks;
 121:MotorControl/odrive_main.h ****     TaskTimer dc_calib_wait;
 122:MotorControl/odrive_main.h **** };
 123:MotorControl/odrive_main.h **** 
 124:MotorControl/odrive_main.h **** 
 125:MotorControl/odrive_main.h **** // Forward Declarations
 126:MotorControl/odrive_main.h **** class Axis;
 127:MotorControl/odrive_main.h **** class Motor;
 128:MotorControl/odrive_main.h **** 
 129:MotorControl/odrive_main.h **** // TODO: move
 130:MotorControl/odrive_main.h **** // this is technically not thread-safe but practically it might be
 131:MotorControl/odrive_main.h **** #define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE) \
 132:MotorControl/odrive_main.h **** inline ENUMTYPE operator | (ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<std:
 133:MotorControl/odrive_main.h **** inline ENUMTYPE operator & (ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<std:
 134:MotorControl/odrive_main.h **** inline ENUMTYPE operator ^ (ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<std:
 135:MotorControl/odrive_main.h **** inline ENUMTYPE &operator |= (ENUMTYPE &a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinter
 136:MotorControl/odrive_main.h **** inline ENUMTYPE &operator &= (ENUMTYPE &a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinter
 137:MotorControl/odrive_main.h **** inline ENUMTYPE &operator ^= (ENUMTYPE &a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinter
 138:MotorControl/odrive_main.h **** inline ENUMTYPE operator ~ (ENUMTYPE a) { return static_cast<ENUMTYPE>(~static_cast<std::underlying
 139:MotorControl/odrive_main.h **** 
 140:MotorControl/odrive_main.h **** #include "autogen/interfaces.hpp"
 141:MotorControl/odrive_main.h **** 
 142:MotorControl/odrive_main.h **** // ODrive specific includes
 143:MotorControl/odrive_main.h **** #include <utils.hpp>
 144:MotorControl/odrive_main.h **** #include <low_level.h>
 145:MotorControl/odrive_main.h **** #include <encoder.hpp>
 146:MotorControl/odrive_main.h **** #include <sensorless_estimator.hpp>
 147:MotorControl/odrive_main.h **** #include <controller.hpp>
 148:MotorControl/odrive_main.h **** #include <current_limiter.hpp>
 149:MotorControl/odrive_main.h **** #include <thermistor.hpp>
 150:MotorControl/odrive_main.h **** #include <trapTraj.hpp>
 151:MotorControl/odrive_main.h **** #include <endstop.hpp>
 152:MotorControl/odrive_main.h **** #include <mechanical_brake.hpp>
 153:MotorControl/odrive_main.h **** #include <axis.hpp>
 154:MotorControl/odrive_main.h **** #include <oscilloscope.hpp>
 155:MotorControl/odrive_main.h **** #include <communication/communication.h>
 156:MotorControl/odrive_main.h **** #include <communication/can/odrive_can.hpp>
 157:MotorControl/odrive_main.h **** 
 158:MotorControl/odrive_main.h **** // Defined in autogen/version.c based on git-derived version numbers
ARM GAS  /tmp/cc5nV8qb.s 			page 27


 159:MotorControl/odrive_main.h **** extern "C" {
 160:MotorControl/odrive_main.h **** extern const unsigned char fw_version_major_;
 161:MotorControl/odrive_main.h **** extern const unsigned char fw_version_minor_;
 162:MotorControl/odrive_main.h **** extern const unsigned char fw_version_revision_;
 163:MotorControl/odrive_main.h **** extern const unsigned char fw_version_unreleased_;
 164:MotorControl/odrive_main.h **** }
 165:MotorControl/odrive_main.h **** 
 166:MotorControl/odrive_main.h **** static Stm32Gpio get_gpio(size_t gpio_num) {
  58              		.loc 2 166 44 is_stmt 1 view -0
  59              		.cfi_startproc
  60              		@ args = 0, pretend = 0, frame = 0
  61              		@ frame_needed = 0, uses_anonymous_args = 0
  62              		@ link register save eliminated.
  63              		.loc 2 166 44 is_stmt 0 view .LVU5
  64 0000 0346     		mov	r3, r0
 167:MotorControl/odrive_main.h ****     return (gpio_num < GPIO_COUNT) ? gpios[gpio_num] : GPIO_COUNT ? gpios[0] : Stm32Gpio::none;
  65              		.loc 2 167 5 is_stmt 1 view .LVU6
  66              		.loc 2 167 36 is_stmt 0 view .LVU7
  67 0002 1029     		cmp	r1, #16
  68 0004 07D8     		bhi	.L4
  69              		.loc 2 167 36 discriminator 1 view .LVU8
  70 0006 054A     		ldr	r2, .L5
  71 0008 02EBC101 		add	r1, r2, r1, lsl #3
  72              	.LVL3:
  73              	.L3:
  74              		.loc 2 167 91 discriminator 4 view .LVU9
  75 000c 03C9     		ldm	r1, {r0, r1}
  76              	.LVL4:
  77              		.loc 2 167 91 discriminator 4 view .LVU10
  78 000e 83E80300 		stm	r3, {r0, r1}
 168:MotorControl/odrive_main.h **** }
  79              		.loc 2 168 1 discriminator 4 view .LVU11
  80 0012 1846     		mov	r0, r3
  81 0014 7047     		bx	lr
  82              	.LVL5:
  83              	.L4:
 167:MotorControl/odrive_main.h ****     return (gpio_num < GPIO_COUNT) ? gpios[gpio_num] : GPIO_COUNT ? gpios[0] : Stm32Gpio::none;
  84              		.loc 2 167 36 view .LVU12
  85 0016 0149     		ldr	r1, .L5
  86              	.LVL6:
 167:MotorControl/odrive_main.h ****     return (gpio_num < GPIO_COUNT) ? gpios[gpio_num] : GPIO_COUNT ? gpios[0] : Stm32Gpio::none;
  87              		.loc 2 167 36 view .LVU13
  88 0018 F8E7     		b	.L3
  89              	.L6:
  90 001a 00BF     		.align	2
  91              	.L5:
  92 001c 00000000 		.word	gpios
  93              		.cfi_endproc
  94              	.LFE5151:
  95              		.cantunwind
  96              		.fnend
  98              		.section	.text._ZN7Encoder16set_linear_countEl,"ax",%progbits
  99              		.align	1
 100              		.global	_ZN7Encoder16set_linear_countEl
 101              		.syntax unified
 102              		.thumb
 103              		.thumb_func
ARM GAS  /tmp/cc5nV8qb.s 			page 28


 105              	_ZN7Encoder16set_linear_countEl:
 106              		.fnstart
 107              	.LVL7:
 108              	.LFB5339:
 109              		.file 3 "MotorControl/encoder.cpp"
   1:MotorControl/encoder.cpp **** 
   2:MotorControl/encoder.cpp **** #include "odrive_main.h"
   3:MotorControl/encoder.cpp **** #include <Drivers/STM32/stm32_system.h>
   4:MotorControl/encoder.cpp **** #include <bitset>
   5:MotorControl/encoder.cpp **** 
   6:MotorControl/encoder.cpp **** Encoder::Encoder(TIM_HandleTypeDef* timer, Stm32Gpio index_gpio,
   7:MotorControl/encoder.cpp ****                  Stm32Gpio hallA_gpio, Stm32Gpio hallB_gpio, Stm32Gpio hallC_gpio,
   8:MotorControl/encoder.cpp ****                  Stm32SpiArbiter* spi_arbiter) :
   9:MotorControl/encoder.cpp ****         timer_(timer), index_gpio_(index_gpio),
  10:MotorControl/encoder.cpp ****         hallA_gpio_(hallA_gpio), hallB_gpio_(hallB_gpio), hallC_gpio_(hallC_gpio),
  11:MotorControl/encoder.cpp ****         spi_arbiter_(spi_arbiter)
  12:MotorControl/encoder.cpp **** {
  13:MotorControl/encoder.cpp **** }
  14:MotorControl/encoder.cpp **** 
  15:MotorControl/encoder.cpp **** static void enc_index_cb_wrapper(void* ctx) {
  16:MotorControl/encoder.cpp ****     reinterpret_cast<Encoder*>(ctx)->enc_index_cb();
  17:MotorControl/encoder.cpp **** }
  18:MotorControl/encoder.cpp **** 
  19:MotorControl/encoder.cpp **** bool Encoder::apply_config(ODriveIntf::MotorIntf::MotorType motor_type) {
  20:MotorControl/encoder.cpp ****     config_.parent = this;
  21:MotorControl/encoder.cpp **** 
  22:MotorControl/encoder.cpp ****     update_pll_gains();
  23:MotorControl/encoder.cpp **** 
  24:MotorControl/encoder.cpp ****     if (config_.pre_calibrated) {
  25:MotorControl/encoder.cpp ****         if (config_.mode == Encoder::MODE_HALL && config_.hall_polarity_calibrated)
  26:MotorControl/encoder.cpp ****             is_ready_ = true;
  27:MotorControl/encoder.cpp ****         if (config_.mode == Encoder::MODE_SINCOS)
  28:MotorControl/encoder.cpp ****             is_ready_ = true;
  29:MotorControl/encoder.cpp ****         if (motor_type == Motor::MOTOR_TYPE_ACIM)
  30:MotorControl/encoder.cpp ****             is_ready_ = true;
  31:MotorControl/encoder.cpp ****     }
  32:MotorControl/encoder.cpp **** 
  33:MotorControl/encoder.cpp ****     return true;
  34:MotorControl/encoder.cpp **** }
  35:MotorControl/encoder.cpp **** 
  36:MotorControl/encoder.cpp **** void Encoder::setup() {
  37:MotorControl/encoder.cpp ****     HAL_TIM_Encoder_Start(timer_, TIM_CHANNEL_ALL);
  38:MotorControl/encoder.cpp ****     set_idx_subscribe();
  39:MotorControl/encoder.cpp **** 
  40:MotorControl/encoder.cpp ****     mode_ = config_.mode;
  41:MotorControl/encoder.cpp **** 
  42:MotorControl/encoder.cpp ****     spi_task_.config = {
  43:MotorControl/encoder.cpp ****         .Mode = SPI_MODE_MASTER,
  44:MotorControl/encoder.cpp ****         .Direction = SPI_DIRECTION_2LINES,
  45:MotorControl/encoder.cpp ****         .DataSize = SPI_DATASIZE_16BIT,
  46:MotorControl/encoder.cpp ****         .CLKPolarity = (mode_ == MODE_SPI_ABS_AEAT || mode_ == MODE_SPI_ABS_MA732) ? SPI_POLARITY_H
  47:MotorControl/encoder.cpp ****         .CLKPhase = SPI_PHASE_2EDGE,
  48:MotorControl/encoder.cpp ****         .NSS = SPI_NSS_SOFT,
  49:MotorControl/encoder.cpp ****         .BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16,
  50:MotorControl/encoder.cpp ****         .FirstBit = SPI_FIRSTBIT_MSB,
  51:MotorControl/encoder.cpp ****         .TIMode = SPI_TIMODE_DISABLE,
  52:MotorControl/encoder.cpp ****         .CRCCalculation = SPI_CRCCALCULATION_DISABLE,
ARM GAS  /tmp/cc5nV8qb.s 			page 29


  53:MotorControl/encoder.cpp ****         .CRCPolynomial = 10,
  54:MotorControl/encoder.cpp ****     };
  55:MotorControl/encoder.cpp **** 
  56:MotorControl/encoder.cpp ****     if (mode_ == MODE_SPI_ABS_MA732) {
  57:MotorControl/encoder.cpp ****         abs_spi_dma_tx_[0] = 0x0000;
  58:MotorControl/encoder.cpp ****     }
  59:MotorControl/encoder.cpp **** 
  60:MotorControl/encoder.cpp ****     if(mode_ & MODE_FLAG_ABS){
  61:MotorControl/encoder.cpp ****         abs_spi_cs_pin_init();
  62:MotorControl/encoder.cpp **** 
  63:MotorControl/encoder.cpp ****         if (axis_->controller_.config_.anticogging.pre_calibrated) {
  64:MotorControl/encoder.cpp ****             axis_->controller_.anticogging_valid_ = true;
  65:MotorControl/encoder.cpp ****         }
  66:MotorControl/encoder.cpp ****     }
  67:MotorControl/encoder.cpp **** }
  68:MotorControl/encoder.cpp **** 
  69:MotorControl/encoder.cpp **** void Encoder::set_error(Error error) {
  70:MotorControl/encoder.cpp ****     vel_estimate_valid_ = false;
  71:MotorControl/encoder.cpp ****     pos_estimate_valid_ = false;
  72:MotorControl/encoder.cpp ****     error_ |= error;
  73:MotorControl/encoder.cpp ****     axis_->error_ |= Axis::ERROR_ENCODER_FAILED;
  74:MotorControl/encoder.cpp **** }
  75:MotorControl/encoder.cpp **** 
  76:MotorControl/encoder.cpp **** bool Encoder::do_checks(){
  77:MotorControl/encoder.cpp ****     return error_ == ERROR_NONE;
  78:MotorControl/encoder.cpp **** }
  79:MotorControl/encoder.cpp **** 
  80:MotorControl/encoder.cpp **** //--------------------
  81:MotorControl/encoder.cpp **** // Hardware Dependent
  82:MotorControl/encoder.cpp **** //--------------------
  83:MotorControl/encoder.cpp **** 
  84:MotorControl/encoder.cpp **** // Triggered when an encoder passes over the "Index" pin
  85:MotorControl/encoder.cpp **** // TODO: only arm index edge interrupt when we know encoder has powered up
  86:MotorControl/encoder.cpp **** // (maybe by attaching the interrupt on start search, synergistic with following)
  87:MotorControl/encoder.cpp **** void Encoder::enc_index_cb() {
  88:MotorControl/encoder.cpp ****     if (config_.use_index) {
  89:MotorControl/encoder.cpp ****         set_circular_count(0, false);
  90:MotorControl/encoder.cpp ****         if (config_.use_index_offset)
  91:MotorControl/encoder.cpp ****             set_linear_count((int32_t)(config_.index_offset * config_.cpr));
  92:MotorControl/encoder.cpp ****         if (config_.pre_calibrated) {
  93:MotorControl/encoder.cpp ****             is_ready_ = true;
  94:MotorControl/encoder.cpp ****             if(axis_->controller_.config_.anticogging.pre_calibrated){
  95:MotorControl/encoder.cpp ****                 axis_->controller_.anticogging_valid_ = true;
  96:MotorControl/encoder.cpp ****             }
  97:MotorControl/encoder.cpp ****         } else {
  98:MotorControl/encoder.cpp ****             // We can't use the update_offset facility in set_circular_count because
  99:MotorControl/encoder.cpp ****             // we also set the linear count before there is a chance to update. Therefore:
 100:MotorControl/encoder.cpp ****             // Invalidate offset calibration that may have happened before idx search
 101:MotorControl/encoder.cpp ****             is_ready_ = false;
 102:MotorControl/encoder.cpp ****         }
 103:MotorControl/encoder.cpp ****         index_found_ = true;
 104:MotorControl/encoder.cpp ****     }
 105:MotorControl/encoder.cpp **** 
 106:MotorControl/encoder.cpp ****     // Disable interrupt
 107:MotorControl/encoder.cpp ****     index_gpio_.unsubscribe();
 108:MotorControl/encoder.cpp **** }
 109:MotorControl/encoder.cpp **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 30


 110:MotorControl/encoder.cpp **** void Encoder::set_idx_subscribe(bool override_enable) {
 111:MotorControl/encoder.cpp ****     if (config_.use_index && (override_enable || !config_.find_idx_on_lockin_only)) {
 112:MotorControl/encoder.cpp ****         if (!index_gpio_.subscribe(true, false, enc_index_cb_wrapper, this)) {
 113:MotorControl/encoder.cpp ****             odrv.misconfigured_ = true;
 114:MotorControl/encoder.cpp ****         }
 115:MotorControl/encoder.cpp ****     } else if (!config_.use_index || config_.find_idx_on_lockin_only) {
 116:MotorControl/encoder.cpp ****         index_gpio_.unsubscribe();
 117:MotorControl/encoder.cpp ****     }
 118:MotorControl/encoder.cpp **** }
 119:MotorControl/encoder.cpp **** 
 120:MotorControl/encoder.cpp **** void Encoder::update_pll_gains() {
 121:MotorControl/encoder.cpp ****     pll_kp_ = 2.0f * config_.bandwidth;  // basic conversion to discrete time
 122:MotorControl/encoder.cpp ****     pll_ki_ = 0.25f * (pll_kp_ * pll_kp_); // Critically damped
 123:MotorControl/encoder.cpp **** 
 124:MotorControl/encoder.cpp ****     // Check that we don't get problems with discrete time approximation
 125:MotorControl/encoder.cpp ****     if (!(current_meas_period * pll_kp_ < 1.0f)) {
 126:MotorControl/encoder.cpp ****         set_error(ERROR_UNSTABLE_GAIN);
 127:MotorControl/encoder.cpp ****     }
 128:MotorControl/encoder.cpp **** }
 129:MotorControl/encoder.cpp **** 
 130:MotorControl/encoder.cpp **** void Encoder::check_pre_calibrated() {
 131:MotorControl/encoder.cpp ****     // TODO: restoring config from python backup is fragile here (ACIM motor type must be set first
 132:MotorControl/encoder.cpp ****     if (axis_->motor_.config_.motor_type != Motor::MOTOR_TYPE_ACIM) {
 133:MotorControl/encoder.cpp ****         if (!is_ready_)
 134:MotorControl/encoder.cpp ****             config_.pre_calibrated = false;
 135:MotorControl/encoder.cpp ****         if (mode_ == MODE_INCREMENTAL && !index_found_)
 136:MotorControl/encoder.cpp ****             config_.pre_calibrated = false;
 137:MotorControl/encoder.cpp ****     }
 138:MotorControl/encoder.cpp **** }
 139:MotorControl/encoder.cpp **** 
 140:MotorControl/encoder.cpp **** // Function that sets the current encoder count to a desired 32-bit value.
 141:MotorControl/encoder.cpp **** void Encoder::set_linear_count(int32_t count) {
 110              		.loc 3 141 47 is_stmt 1 view -0
 111              		.cfi_startproc
 112              		@ args = 0, pretend = 0, frame = 0
 113              		@ frame_needed = 0, uses_anonymous_args = 0
 114              		@ link register save eliminated.
 142:MotorControl/encoder.cpp ****     // Disable interrupts to make a critical section to avoid race condition
 143:MotorControl/encoder.cpp ****     uint32_t prim = cpu_enter_critical();
 115              		.loc 3 143 5 view .LVU15
 116              	.LBB1196:
 117              	.LBI1196:
 118              		.file 4 "./Drivers/STM32/stm32_system.h"
   1:./Drivers/STM32/stm32_system.h **** #ifndef __STM32_SYSTEM_H
   2:./Drivers/STM32/stm32_system.h **** #define __STM32_SYSTEM_H
   3:./Drivers/STM32/stm32_system.h **** 
   4:./Drivers/STM32/stm32_system.h **** #if defined(STM32F405xx)
   5:./Drivers/STM32/stm32_system.h **** #include <stm32f405xx.h>
   6:./Drivers/STM32/stm32_system.h **** #elif defined(STM32F722xx)
   7:./Drivers/STM32/stm32_system.h **** #include <stm32f722xx.h>
   8:./Drivers/STM32/stm32_system.h **** #else
   9:./Drivers/STM32/stm32_system.h **** #error "unknown STM32 microcontroller"
  10:./Drivers/STM32/stm32_system.h **** #endif
  11:./Drivers/STM32/stm32_system.h **** 
  12:./Drivers/STM32/stm32_system.h **** // C/C++ definitions
  13:./Drivers/STM32/stm32_system.h **** 
  14:./Drivers/STM32/stm32_system.h **** #ifdef __cplusplus
ARM GAS  /tmp/cc5nV8qb.s 			page 31


  15:./Drivers/STM32/stm32_system.h **** extern "C" {
  16:./Drivers/STM32/stm32_system.h **** #endif
  17:./Drivers/STM32/stm32_system.h **** 
  18:./Drivers/STM32/stm32_system.h **** // Uncomment the following line to sacrifice 1kB of RAM for the ability to
  19:./Drivers/STM32/stm32_system.h **** // monitor the number of times each interrupt fires.
  20:./Drivers/STM32/stm32_system.h **** //#define ENABLE_IRQ_COUNTER
  21:./Drivers/STM32/stm32_system.h **** 
  22:./Drivers/STM32/stm32_system.h **** #ifdef ENABLE_IRQ_COUNTER
  23:./Drivers/STM32/stm32_system.h **** extern uint32_t irq_counters[];
  24:./Drivers/STM32/stm32_system.h **** #define COUNT_IRQ(irqn) (++irq_counters[irqn + 14])
  25:./Drivers/STM32/stm32_system.h **** #define GET_IRQ_COUNTER(irqn) irq_counters[irqn + 14]
  26:./Drivers/STM32/stm32_system.h **** #else
  27:./Drivers/STM32/stm32_system.h **** #define COUNT_IRQ(irqn) ((void)0)
  28:./Drivers/STM32/stm32_system.h **** #define GET_IRQ_COUNTER(irqn) 0
  29:./Drivers/STM32/stm32_system.h **** #endif
  30:./Drivers/STM32/stm32_system.h **** 
  31:./Drivers/STM32/stm32_system.h **** static inline uint32_t cpu_enter_critical() {
 119              		.loc 4 31 24 view .LVU16
 120              	.LBB1197:
  32:./Drivers/STM32/stm32_system.h ****     uint32_t primask = __get_PRIMASK();
 121              		.loc 4 32 5 view .LVU17
 122              	.LBB1198:
 123              	.LBI1198:
 124              		.file 5 "ThirdParty/CMSIS/Include/cmsis_gcc.h"
   1:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /*
   8:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  *
  10:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  *
  12:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  *
  16:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  *
  18:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
  24:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
  25:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
  28:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 32


  34:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  38:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
  39:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  43:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  46:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  49:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  55:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  58:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  61:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  64:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  67:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  70:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  78:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  86:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
ARM GAS  /tmp/cc5nV8qb.s 			page 33


  91:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  94:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 102:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 110:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 113:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 116:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 117:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 118:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:ThirdParty/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   @{
 122:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 123:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 124:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 125:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 129:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 131:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 133:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 134:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 135:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 136:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 140:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 142:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 144:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 145:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 146:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 147:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
ARM GAS  /tmp/cc5nV8qb.s 			page 34


 148:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 151:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 153:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 155:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 158:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 159:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 160:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 162:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 166:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 168:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 170:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 173:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 174:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 175:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 176:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 177:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 181:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 183:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 185:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 186:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 187:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 189:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 193:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 195:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 197:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 198:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 199:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 200:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 201:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 204:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/cc5nV8qb.s 			page 35


 205:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 207:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 209:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 212:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 213:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 214:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 215:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 216:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 219:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 221:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 223:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 226:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 227:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 228:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 229:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 233:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 235:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 237:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 240:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 241:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 242:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 243:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 247:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 249:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 251:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 254:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 255:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 256:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 258:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 261:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/cc5nV8qb.s 			page 36


 262:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 264:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 266:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 269:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 270:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 271:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 272:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 273:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 277:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 279:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 281:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 282:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 283:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 285:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 289:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 291:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 293:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 294:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 295:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 296:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 297:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 301:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 303:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 305:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 308:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 309:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 310:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 312:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 315:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 316:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 318:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
ARM GAS  /tmp/cc5nV8qb.s 			page 37


 319:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 320:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 323:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 324:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 325:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 326:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 327:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 331:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 333:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 335:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 336:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 337:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 339:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 343:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 345:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 347:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 348:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 349:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 350:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 352:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 356:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 358:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 360:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 363:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 364:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 365:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 366:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 370:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 372:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 374:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 375:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 38


 376:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 377:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 378:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 381:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 382:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 125              		.loc 5 382 31 view .LVU18
 126              	.LBB1199:
 383:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 384:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 127              		.loc 5 384 3 view .LVU19
 385:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 386:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 128              		.loc 5 386 3 view .LVU20
 129              		.syntax unified
 130              	@ 386 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 131 0000 EFF31083 		MRS r3, primask
 132              	@ 0 "" 2
 133              	.LVL8:
 387:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 134              		.loc 5 387 3 view .LVU21
 135              		.loc 5 387 3 is_stmt 0 view .LVU22
 136              		.thumb
 137              		.syntax unified
 138              	.LBE1199:
 139              	.LBE1198:
  33:./Drivers/STM32/stm32_system.h ****     __disable_irq();
 140              		.loc 4 33 5 is_stmt 1 view .LVU23
 141              	.LBB1200:
 142              	.LBI1200:
 140:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 143              		.loc 5 140 27 view .LVU24
 144              	.LBB1201:
 142:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 145              		.loc 5 142 3 view .LVU25
 146              		.syntax unified
 147              	@ 142 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 148 0004 72B6     		cpsid i
 149              	@ 0 "" 2
 150              		.thumb
 151              		.syntax unified
 152              	.LBE1201:
 153              	.LBE1200:
  34:./Drivers/STM32/stm32_system.h ****     return primask;
 154              		.loc 4 34 5 view .LVU26
 155              	.LVL9:
 156              		.loc 4 34 5 is_stmt 0 view .LVU27
 157              	.LBE1197:
 158              	.LBE1196:
 144:MotorControl/encoder.cpp **** 
 145:MotorControl/encoder.cpp ****     // Update states
 146:MotorControl/encoder.cpp ****     shadow_count_ = count;
 159              		.loc 3 146 5 is_stmt 1 view .LVU28
 160              		.loc 3 146 19 is_stmt 0 view .LVU29
 161 0006 C0F89010 		str	r1, [r0, #144]
 147:MotorControl/encoder.cpp ****     pos_estimate_counts_ = (float)count;
ARM GAS  /tmp/cc5nV8qb.s 			page 39


 162              		.loc 3 147 5 is_stmt 1 view .LVU30
 163              		.loc 3 147 28 is_stmt 0 view .LVU31
 164 000a 07EE901A 		vmov	s15, r1	@ int
 165 000e F8EEE77A 		vcvt.f32.s32	s15, s15
 166              		.loc 3 147 26 view .LVU32
 167 0012 C0ED2B7A 		vstr.32	s15, [r0, #172]
 148:MotorControl/encoder.cpp ****     tim_cnt_sample_ = count;
 168              		.loc 3 148 5 is_stmt 1 view .LVU33
 169              		.loc 3 148 21 is_stmt 0 view .LVU34
 170 0016 A0F8EA10 		strh	r1, [r0, #234]	@ movhi
 149:MotorControl/encoder.cpp **** 
 150:MotorControl/encoder.cpp ****     //Write hardware last
 151:MotorControl/encoder.cpp ****     timer_->Instance->CNT = count;
 171              		.loc 3 151 5 is_stmt 1 view .LVU35
 172 001a 8268     		ldr	r2, [r0, #8]
 173              		.loc 3 151 13 is_stmt 0 view .LVU36
 174 001c 1268     		ldr	r2, [r2]
 175              		.loc 3 151 27 view .LVU37
 176 001e 5162     		str	r1, [r2, #36]
 152:MotorControl/encoder.cpp **** 
 153:MotorControl/encoder.cpp ****     cpu_exit_critical(prim);
 177              		.loc 3 153 5 is_stmt 1 view .LVU38
 178              	.LVL10:
 179              	.LBB1202:
 180              	.LBI1202:
  35:./Drivers/STM32/stm32_system.h **** }
  36:./Drivers/STM32/stm32_system.h **** 
  37:./Drivers/STM32/stm32_system.h **** static inline void cpu_exit_critical(uint32_t priority_mask) {
 181              		.loc 4 37 20 view .LVU39
 182              	.LBE1202:
  38:./Drivers/STM32/stm32_system.h ****     __set_PRIMASK(priority_mask);
 183              		.loc 4 38 5 view .LVU40
 184              	.LBB1205:
 185              	.LBB1203:
 186              	.LBI1203:
 388:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 389:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 390:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 391:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 393:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 397:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 399:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 401:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 404:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 405:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 406:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 407:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 408:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
ARM GAS  /tmp/cc5nV8qb.s 			page 40


 410:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 412:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 187              		.loc 5 412 27 view .LVU41
 188              	.LBB1204:
 413:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 414:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 189              		.loc 5 414 3 view .LVU42
 190              		.syntax unified
 191              	@ 414 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 192 0020 83F31088 		MSR primask, r3
 193              	@ 0 "" 2
 194              	.LVL11:
 195              		.loc 5 414 3 is_stmt 0 view .LVU43
 196              		.thumb
 197              		.syntax unified
 198              	.LBE1204:
 199              	.LBE1203:
 200              	.LBE1205:
 154:MotorControl/encoder.cpp **** }
 201              		.loc 3 154 1 view .LVU44
 202 0024 7047     		bx	lr
 203              		.cfi_endproc
 204              	.LFE5339:
 205              		.cantunwind
 206              		.fnend
 208              		.section	.text._ZL11decode_hallhPl,"ax",%progbits
 209              		.align	1
 210              		.syntax unified
 211              		.thumb
 212              		.thumb_func
 214              	_ZL11decode_hallhPl:
 215              		.fnstart
 216              	.LVL12:
 217              	.LFB5357:
 155:MotorControl/encoder.cpp **** 
 156:MotorControl/encoder.cpp **** // Function that sets the CPR circular tracking encoder count to a desired 32-bit value.
 157:MotorControl/encoder.cpp **** // Note that this will get mod'ed down to [0, cpr)
 158:MotorControl/encoder.cpp **** void Encoder::set_circular_count(int32_t count, bool update_offset) {
 159:MotorControl/encoder.cpp ****     // Disable interrupts to make a critical section to avoid race condition
 160:MotorControl/encoder.cpp ****     uint32_t prim = cpu_enter_critical();
 161:MotorControl/encoder.cpp **** 
 162:MotorControl/encoder.cpp ****     if (update_offset) {
 163:MotorControl/encoder.cpp ****         config_.phase_offset += count - count_in_cpr_;
 164:MotorControl/encoder.cpp ****         config_.phase_offset = mod(config_.phase_offset, config_.cpr);
 165:MotorControl/encoder.cpp ****     }
 166:MotorControl/encoder.cpp **** 
 167:MotorControl/encoder.cpp ****     // Update states
 168:MotorControl/encoder.cpp ****     count_in_cpr_ = mod(count, config_.cpr);
 169:MotorControl/encoder.cpp ****     pos_cpr_counts_ = (float)count_in_cpr_;
 170:MotorControl/encoder.cpp **** 
 171:MotorControl/encoder.cpp ****     cpu_exit_critical(prim);
 172:MotorControl/encoder.cpp **** }
 173:MotorControl/encoder.cpp **** 
 174:MotorControl/encoder.cpp **** bool Encoder::run_index_search() {
 175:MotorControl/encoder.cpp ****     config_.use_index = true;
 176:MotorControl/encoder.cpp ****     index_found_ = false;
ARM GAS  /tmp/cc5nV8qb.s 			page 41


 177:MotorControl/encoder.cpp ****     set_idx_subscribe();
 178:MotorControl/encoder.cpp **** 
 179:MotorControl/encoder.cpp ****     bool success = axis_->run_lockin_spin(axis_->config_.calibration_lockin, false);
 180:MotorControl/encoder.cpp ****     return success;
 181:MotorControl/encoder.cpp **** }
 182:MotorControl/encoder.cpp **** 
 183:MotorControl/encoder.cpp **** bool Encoder::run_direction_find() {
 184:MotorControl/encoder.cpp ****     int32_t init_enc_val = shadow_count_;
 185:MotorControl/encoder.cpp **** 
 186:MotorControl/encoder.cpp ****     Axis::LockinConfig_t lockin_config = axis_->config_.calibration_lockin;
 187:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 3.0f; // run for 3 seconds
 188:MotorControl/encoder.cpp ****     lockin_config.finish_on_distance = true;
 189:MotorControl/encoder.cpp ****     lockin_config.finish_on_enc_idx = false;
 190:MotorControl/encoder.cpp ****     lockin_config.finish_on_vel = false;
 191:MotorControl/encoder.cpp ****     bool success = axis_->run_lockin_spin(lockin_config, false);
 192:MotorControl/encoder.cpp **** 
 193:MotorControl/encoder.cpp ****     if (success) {
 194:MotorControl/encoder.cpp ****         // Check response and direction
 195:MotorControl/encoder.cpp ****         if (shadow_count_ > init_enc_val + 8) {
 196:MotorControl/encoder.cpp ****             // motor same dir as encoder
 197:MotorControl/encoder.cpp ****             config_.direction = 1;
 198:MotorControl/encoder.cpp ****         } else if (shadow_count_ < init_enc_val - 8) {
 199:MotorControl/encoder.cpp ****             // motor opposite dir as encoder
 200:MotorControl/encoder.cpp ****             config_.direction = -1;
 201:MotorControl/encoder.cpp ****         } else {
 202:MotorControl/encoder.cpp ****             config_.direction = 0;
 203:MotorControl/encoder.cpp ****         }
 204:MotorControl/encoder.cpp ****     }
 205:MotorControl/encoder.cpp **** 
 206:MotorControl/encoder.cpp ****     return success;
 207:MotorControl/encoder.cpp **** }
 208:MotorControl/encoder.cpp **** 
 209:MotorControl/encoder.cpp **** 
 210:MotorControl/encoder.cpp **** bool Encoder::run_hall_polarity_calibration() {
 211:MotorControl/encoder.cpp ****     Axis::LockinConfig_t lockin_config = axis_->config_.calibration_lockin;
 212:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 3.0f; // run for 3 seconds
 213:MotorControl/encoder.cpp ****     lockin_config.finish_on_distance = true;
 214:MotorControl/encoder.cpp ****     lockin_config.finish_on_enc_idx = false;
 215:MotorControl/encoder.cpp ****     lockin_config.finish_on_vel = false;
 216:MotorControl/encoder.cpp **** 
 217:MotorControl/encoder.cpp ****     auto loop_cb = [this](bool const_vel) {
 218:MotorControl/encoder.cpp ****         if (const_vel)
 219:MotorControl/encoder.cpp ****             sample_hall_states_ = true;
 220:MotorControl/encoder.cpp ****         // No need to cancel early
 221:MotorControl/encoder.cpp ****         return true;
 222:MotorControl/encoder.cpp ****     };
 223:MotorControl/encoder.cpp **** 
 224:MotorControl/encoder.cpp ****     config_.hall_polarity_calibrated = false;
 225:MotorControl/encoder.cpp ****     states_seen_count_.fill(0);
 226:MotorControl/encoder.cpp ****     bool success = axis_->run_lockin_spin(lockin_config, false, loop_cb);
 227:MotorControl/encoder.cpp ****     sample_hall_states_ = false;
 228:MotorControl/encoder.cpp **** 
 229:MotorControl/encoder.cpp ****     if (success) {
 230:MotorControl/encoder.cpp ****         std::bitset<8> state_seen;
 231:MotorControl/encoder.cpp ****         std::bitset<8> state_confirmed;
 232:MotorControl/encoder.cpp ****         for (int i = 0; i < 8; i++) {
 233:MotorControl/encoder.cpp ****             if (states_seen_count_[i] > 0)
ARM GAS  /tmp/cc5nV8qb.s 			page 42


 234:MotorControl/encoder.cpp ****                 state_seen[i] = true;
 235:MotorControl/encoder.cpp ****             if (states_seen_count_[i] > 50)
 236:MotorControl/encoder.cpp ****                 state_confirmed[i] = true;
 237:MotorControl/encoder.cpp ****         }
 238:MotorControl/encoder.cpp ****         if (!(state_seen == state_confirmed)) {
 239:MotorControl/encoder.cpp ****             set_error(ERROR_ILLEGAL_HALL_STATE);
 240:MotorControl/encoder.cpp ****             return false;
 241:MotorControl/encoder.cpp ****         }
 242:MotorControl/encoder.cpp **** 
 243:MotorControl/encoder.cpp ****         // Hall effect sensors can be arranged at 60 or 120 electrical degrees.
 244:MotorControl/encoder.cpp ****         // Out of 8 possible states, 120 and 60 deg arrangements each miss 2 states.
 245:MotorControl/encoder.cpp ****         // ODrive assumes 120 deg separation - if a 60 deg setup is used, it can
 246:MotorControl/encoder.cpp ****         // be converted to 120 deg states by flipping the polarity of one sensor.
 247:MotorControl/encoder.cpp ****         uint8_t states = state_seen.to_ulong();
 248:MotorControl/encoder.cpp ****         uint8_t hall_polarity = 0;
 249:MotorControl/encoder.cpp ****         auto flip_detect = [](uint8_t states, unsigned int idx)->bool {
 250:MotorControl/encoder.cpp ****             return (~states & 0xFF) == (1<<(0+idx) | 1<<(7-idx));
 251:MotorControl/encoder.cpp ****         };
 252:MotorControl/encoder.cpp ****         if (flip_detect(states, 0)) {
 253:MotorControl/encoder.cpp ****             hall_polarity = 0b000;
 254:MotorControl/encoder.cpp ****         } else if (flip_detect(states, 1)) {
 255:MotorControl/encoder.cpp ****             hall_polarity = 0b001;
 256:MotorControl/encoder.cpp ****         } else if (flip_detect(states, 2)) {
 257:MotorControl/encoder.cpp ****             hall_polarity = 0b010;
 258:MotorControl/encoder.cpp ****         } else if (flip_detect(states, 3)) {
 259:MotorControl/encoder.cpp ****             hall_polarity = 0b100;
 260:MotorControl/encoder.cpp ****         } else {
 261:MotorControl/encoder.cpp ****             set_error(ERROR_ILLEGAL_HALL_STATE);
 262:MotorControl/encoder.cpp ****             return false;
 263:MotorControl/encoder.cpp ****         }
 264:MotorControl/encoder.cpp ****         config_.hall_polarity = hall_polarity;
 265:MotorControl/encoder.cpp ****         config_.hall_polarity_calibrated = true;
 266:MotorControl/encoder.cpp ****     }
 267:MotorControl/encoder.cpp **** 
 268:MotorControl/encoder.cpp ****     return success;
 269:MotorControl/encoder.cpp **** }
 270:MotorControl/encoder.cpp **** 
 271:MotorControl/encoder.cpp **** bool Encoder::run_hall_phase_calibration() {
 272:MotorControl/encoder.cpp ****     Axis::LockinConfig_t lockin_config = axis_->config_.calibration_lockin;
 273:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 30.0f; // run for 30 seconds
 274:MotorControl/encoder.cpp ****     lockin_config.finish_on_distance = true;
 275:MotorControl/encoder.cpp ****     lockin_config.finish_on_enc_idx = false;
 276:MotorControl/encoder.cpp ****     lockin_config.finish_on_vel = false;
 277:MotorControl/encoder.cpp **** 
 278:MotorControl/encoder.cpp ****     auto loop_cb = [this](bool const_vel) {
 279:MotorControl/encoder.cpp ****         if (const_vel)
 280:MotorControl/encoder.cpp ****             sample_hall_phase_ = true;
 281:MotorControl/encoder.cpp ****         // No need to cancel early
 282:MotorControl/encoder.cpp ****         return true;
 283:MotorControl/encoder.cpp ****     };
 284:MotorControl/encoder.cpp **** 
 285:MotorControl/encoder.cpp ****     // TODO: There is a race condition here with the execution in Encoder::update.
 286:MotorControl/encoder.cpp ****     // We should evaluate making thread execution synchronous with the control loops
 287:MotorControl/encoder.cpp ****     // at least optionally.
 288:MotorControl/encoder.cpp ****     // Perhaps the new loop_sync feature will give a loose timing guarantee that may be sufficient
 289:MotorControl/encoder.cpp ****     calibrate_hall_phase_ = true;
 290:MotorControl/encoder.cpp ****     config_.hall_edge_phcnt.fill(0.0f);
ARM GAS  /tmp/cc5nV8qb.s 			page 43


 291:MotorControl/encoder.cpp ****     hall_phase_calib_seen_count_.fill(0);
 292:MotorControl/encoder.cpp ****     bool success = axis_->run_lockin_spin(lockin_config, false, loop_cb);
 293:MotorControl/encoder.cpp ****     if (error_ & ERROR_ILLEGAL_HALL_STATE)
 294:MotorControl/encoder.cpp ****         success = false;
 295:MotorControl/encoder.cpp **** 
 296:MotorControl/encoder.cpp ****     if (success) {
 297:MotorControl/encoder.cpp ****         // Check deltas to dicern rotation direction
 298:MotorControl/encoder.cpp ****         float delta_phase = 0.0f;
 299:MotorControl/encoder.cpp ****         for (int i = 0; i < 6; i++) {
 300:MotorControl/encoder.cpp ****             int next_i = (i == 5) ? 0 : i+1;
 301:MotorControl/encoder.cpp ****             delta_phase += wrap_pm_pi(config_.hall_edge_phcnt[next_i] - config_.hall_edge_phcnt[i])
 302:MotorControl/encoder.cpp ****         }
 303:MotorControl/encoder.cpp ****         // Correct reverse rotation
 304:MotorControl/encoder.cpp ****         if (delta_phase < 0.0f) {
 305:MotorControl/encoder.cpp ****             config_.direction = -1;
 306:MotorControl/encoder.cpp ****             for (int i = 0; i < 6; i++)
 307:MotorControl/encoder.cpp ****                 config_.hall_edge_phcnt[i] = wrap_pm_pi(-config_.hall_edge_phcnt[i]);
 308:MotorControl/encoder.cpp ****         } else {
 309:MotorControl/encoder.cpp ****             config_.direction = 1;
 310:MotorControl/encoder.cpp ****         }
 311:MotorControl/encoder.cpp ****         // Normalize edge timing to 1st edge in sequence, and change units to counts
 312:MotorControl/encoder.cpp ****         float offset = config_.hall_edge_phcnt[0];
 313:MotorControl/encoder.cpp ****         for (int i = 0; i < 6; i++) {
 314:MotorControl/encoder.cpp ****             float& phcnt = config_.hall_edge_phcnt[i];
 315:MotorControl/encoder.cpp ****             phcnt = fmodf_pos((6.0f / (2.0f * M_PI)) * (phcnt - offset), 6.0f);
 316:MotorControl/encoder.cpp ****         }
 317:MotorControl/encoder.cpp ****     } else {
 318:MotorControl/encoder.cpp ****         config_.hall_edge_phcnt = hall_edge_defaults;
 319:MotorControl/encoder.cpp ****     }
 320:MotorControl/encoder.cpp **** 
 321:MotorControl/encoder.cpp ****     calibrate_hall_phase_ = false;
 322:MotorControl/encoder.cpp ****     return success;
 323:MotorControl/encoder.cpp **** }
 324:MotorControl/encoder.cpp **** 
 325:MotorControl/encoder.cpp **** // @brief Turns the motor in one direction for a bit and then in the other
 326:MotorControl/encoder.cpp **** // direction in order to find the offset between the electrical phase 0
 327:MotorControl/encoder.cpp **** // and the encoder state 0.
 328:MotorControl/encoder.cpp **** bool Encoder::run_offset_calibration() {
 329:MotorControl/encoder.cpp ****     const float start_lock_duration = 1.0f;
 330:MotorControl/encoder.cpp **** 
 331:MotorControl/encoder.cpp ****     // Require index found if enabled
 332:MotorControl/encoder.cpp ****     if (config_.use_index && !index_found_) {
 333:MotorControl/encoder.cpp ****         set_error(ERROR_INDEX_NOT_FOUND_YET);
 334:MotorControl/encoder.cpp ****         return false;
 335:MotorControl/encoder.cpp ****     }
 336:MotorControl/encoder.cpp **** 
 337:MotorControl/encoder.cpp ****     if (config_.mode == MODE_HALL && !config_.hall_polarity_calibrated) {
 338:MotorControl/encoder.cpp ****         set_error(ERROR_HALL_NOT_CALIBRATED_YET);
 339:MotorControl/encoder.cpp ****         return false;
 340:MotorControl/encoder.cpp ****     }
 341:MotorControl/encoder.cpp **** 
 342:MotorControl/encoder.cpp ****     // We use shadow_count_ to do the calibration, but the offset is used by count_in_cpr_
 343:MotorControl/encoder.cpp ****     // Therefore we have to sync them for calibration
 344:MotorControl/encoder.cpp ****     shadow_count_ = count_in_cpr_;
 345:MotorControl/encoder.cpp **** 
 346:MotorControl/encoder.cpp ****     CRITICAL_SECTION() {
 347:MotorControl/encoder.cpp ****         // Reset state variables
ARM GAS  /tmp/cc5nV8qb.s 			page 44


 348:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.Idq_setpoint_ = {0.0f, 0.0f};
 349:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.Vdq_setpoint_ = {0.0f, 0.0f};
 350:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.phase_ = 0.0f;
 351:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.phase_vel_ = 0.0f;
 352:MotorControl/encoder.cpp **** 
 353:MotorControl/encoder.cpp ****         float max_current_ramp = axis_->motor_.config_.calibration_current / start_lock_duration * 
 354:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.max_current_ramp_ = max_current_ramp;
 355:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.max_voltage_ramp_ = max_current_ramp;
 356:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.max_phase_vel_ramp_ = INFINITY;
 357:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_current_ = axis_->motor_.config_.motor_type != Motor::M
 358:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_voltage_ = axis_->motor_.config_.motor_type != Motor::M
 359:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_vel_ = 0.0f;
 360:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.total_distance_ = 0.0f;
 361:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.phase_ = axis_->open_loop_controller_.initial_phase_ = wrap_pm
 362:MotorControl/encoder.cpp **** 
 363:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.enable_current_control_src_ = (axis_->motor_.config_.motor_t
 364:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.Idq_setpoint_src_.connect_to(&axis_->open_loop_controller_.I
 365:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.Vdq_setpoint_src_.connect_to(&axis_->open_loop_controller_.V
 366:MotorControl/encoder.cpp ****         
 367:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.phase_src_.connect_to(&axis_->open_loop_controller_.phase_);
 368:MotorControl/encoder.cpp ****         axis_->acim_estimator_.rotor_phase_src_.connect_to(&axis_->open_loop_controller_.phase_);
 369:MotorControl/encoder.cpp **** 
 370:MotorControl/encoder.cpp ****         axis_->motor_.phase_vel_src_.connect_to(&axis_->open_loop_controller_.phase_vel_);
 371:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.phase_vel_src_.connect_to(&axis_->open_loop_controller_.phas
 372:MotorControl/encoder.cpp ****         axis_->acim_estimator_.rotor_phase_vel_src_.connect_to(&axis_->open_loop_controller_.phase_
 373:MotorControl/encoder.cpp ****     }
 374:MotorControl/encoder.cpp ****     axis_->wait_for_control_iteration();
 375:MotorControl/encoder.cpp **** 
 376:MotorControl/encoder.cpp ****     axis_->motor_.arm(&axis_->motor_.current_control_);
 377:MotorControl/encoder.cpp **** 
 378:MotorControl/encoder.cpp ****     // go to start position of forward scan for start_lock_duration to get ready to scan
 379:MotorControl/encoder.cpp ****     for (size_t i = 0; i < (size_t)(start_lock_duration * 1000.0f); ++i) {
 380:MotorControl/encoder.cpp ****         if (!axis_->motor_.is_armed_) {
 381:MotorControl/encoder.cpp ****             return false; // TODO: return "disarmed" error code
 382:MotorControl/encoder.cpp ****         }
 383:MotorControl/encoder.cpp ****         if (axis_->requested_state_ != Axis::AXIS_STATE_UNDEFINED) {
 384:MotorControl/encoder.cpp ****             axis_->motor_.disarm();
 385:MotorControl/encoder.cpp ****             return false; // TODO: return "aborted" error code
 386:MotorControl/encoder.cpp ****         }
 387:MotorControl/encoder.cpp ****         osDelay(1);
 388:MotorControl/encoder.cpp ****     }
 389:MotorControl/encoder.cpp **** 
 390:MotorControl/encoder.cpp **** 
 391:MotorControl/encoder.cpp ****     int32_t init_enc_val = shadow_count_;
 392:MotorControl/encoder.cpp ****     uint32_t num_steps = 0;
 393:MotorControl/encoder.cpp ****     int64_t encvaluesum = 0;
 394:MotorControl/encoder.cpp **** 
 395:MotorControl/encoder.cpp ****     CRITICAL_SECTION() {
 396:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_vel_ = config_.calib_scan_omega;
 397:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.total_distance_ = 0.0f;
 398:MotorControl/encoder.cpp ****     }
 399:MotorControl/encoder.cpp **** 
 400:MotorControl/encoder.cpp ****     // scan forward
 401:MotorControl/encoder.cpp ****     while ((axis_->requested_state_ == Axis::AXIS_STATE_UNDEFINED) && axis_->motor_.is_armed_) {
 402:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(-INF
 403:MotorControl/encoder.cpp ****         if (reached_target_dist) {
 404:MotorControl/encoder.cpp ****             break;
ARM GAS  /tmp/cc5nV8qb.s 			page 45


 405:MotorControl/encoder.cpp ****         }
 406:MotorControl/encoder.cpp ****         encvaluesum += shadow_count_;
 407:MotorControl/encoder.cpp ****         num_steps++;
 408:MotorControl/encoder.cpp ****         osDelay(1);
 409:MotorControl/encoder.cpp ****     }
 410:MotorControl/encoder.cpp **** 
 411:MotorControl/encoder.cpp ****     // Check response and direction
 412:MotorControl/encoder.cpp ****     if (shadow_count_ > init_enc_val + 8) {
 413:MotorControl/encoder.cpp ****         // motor same dir as encoder
 414:MotorControl/encoder.cpp ****         config_.direction = 1;
 415:MotorControl/encoder.cpp ****     } else if (shadow_count_ < init_enc_val - 8) {
 416:MotorControl/encoder.cpp ****         // motor opposite dir as encoder
 417:MotorControl/encoder.cpp ****         config_.direction = -1;
 418:MotorControl/encoder.cpp ****     } else {
 419:MotorControl/encoder.cpp ****         // Encoder response error
 420:MotorControl/encoder.cpp ****         set_error(ERROR_NO_RESPONSE);
 421:MotorControl/encoder.cpp ****         axis_->motor_.disarm();
 422:MotorControl/encoder.cpp ****         return false;
 423:MotorControl/encoder.cpp ****     }
 424:MotorControl/encoder.cpp **** 
 425:MotorControl/encoder.cpp ****     // Check CPR
 426:MotorControl/encoder.cpp ****     float elec_rad_per_enc = axis_->motor_.config_.pole_pairs * 2 * M_PI * (1.0f / (float)(config_.
 427:MotorControl/encoder.cpp ****     float expected_encoder_delta = config_.calib_scan_distance / elec_rad_per_enc;
 428:MotorControl/encoder.cpp ****     calib_scan_response_ = std::abs(shadow_count_ - init_enc_val);
 429:MotorControl/encoder.cpp ****     if (std::abs(calib_scan_response_ - expected_encoder_delta) / expected_encoder_delta > config_.
 430:MotorControl/encoder.cpp ****         set_error(ERROR_CPR_POLEPAIRS_MISMATCH);
 431:MotorControl/encoder.cpp ****         axis_->motor_.disarm();
 432:MotorControl/encoder.cpp ****         return false;
 433:MotorControl/encoder.cpp ****     }
 434:MotorControl/encoder.cpp **** 
 435:MotorControl/encoder.cpp ****     CRITICAL_SECTION() {
 436:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_vel_ = -config_.calib_scan_omega;
 437:MotorControl/encoder.cpp ****     }
 438:MotorControl/encoder.cpp **** 
 439:MotorControl/encoder.cpp ****     // scan backwards
 440:MotorControl/encoder.cpp ****     while ((axis_->requested_state_ == Axis::AXIS_STATE_UNDEFINED) && axis_->motor_.is_armed_) {
 441:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(INFI
 442:MotorControl/encoder.cpp ****         if (reached_target_dist) {
 443:MotorControl/encoder.cpp ****             break;
 444:MotorControl/encoder.cpp ****         }
 445:MotorControl/encoder.cpp ****         encvaluesum += shadow_count_;
 446:MotorControl/encoder.cpp ****         num_steps++;
 447:MotorControl/encoder.cpp ****         osDelay(1);
 448:MotorControl/encoder.cpp ****     }
 449:MotorControl/encoder.cpp **** 
 450:MotorControl/encoder.cpp ****     // Motor disarmed because of an error
 451:MotorControl/encoder.cpp ****     if (!axis_->motor_.is_armed_) {
 452:MotorControl/encoder.cpp ****         return false;
 453:MotorControl/encoder.cpp ****     }
 454:MotorControl/encoder.cpp **** 
 455:MotorControl/encoder.cpp ****     axis_->motor_.disarm();
 456:MotorControl/encoder.cpp **** 
 457:MotorControl/encoder.cpp ****     config_.phase_offset = encvaluesum / num_steps;
 458:MotorControl/encoder.cpp ****     int32_t residual = encvaluesum - ((int64_t)config_.phase_offset * (int64_t)num_steps);
 459:MotorControl/encoder.cpp ****     config_.phase_offset_float = (float)residual / (float)num_steps + 0.5f;  // add 0.5 to center-a
 460:MotorControl/encoder.cpp **** 
 461:MotorControl/encoder.cpp ****     is_ready_ = true;
ARM GAS  /tmp/cc5nV8qb.s 			page 46


 462:MotorControl/encoder.cpp ****     return true;
 463:MotorControl/encoder.cpp **** }
 464:MotorControl/encoder.cpp **** 
 465:MotorControl/encoder.cpp **** static bool decode_hall(uint8_t hall_state, int32_t* hall_cnt) {
 218              		.loc 3 465 64 is_stmt 1 view -0
 219              		.cfi_startproc
 220              		@ args = 0, pretend = 0, frame = 0
 221              		@ frame_needed = 0, uses_anonymous_args = 0
 222              		@ link register save eliminated.
 466:MotorControl/encoder.cpp ****     switch (hall_state) {
 223              		.loc 3 466 5 view .LVU46
 224 0000 0138     		subs	r0, r0, #1
 225              	.LVL13:
 226              		.loc 3 466 5 is_stmt 0 view .LVU47
 227 0002 0528     		cmp	r0, #5
 228 0004 1BD8     		bhi	.L17
 229 0006 DFE800F0 		tbb	[pc, r0]
 230              	.L11:
 231 000a 03       		.byte	(.L16-.L11)/2
 232 000b 0A       		.byte	(.L15-.L11)/2
 233 000c 07       		.byte	(.L14-.L11)/2
 234 000d 12       		.byte	(.L13-.L11)/2
 235 000e 16       		.byte	(.L12-.L11)/2
 236 000f 0E       		.byte	(.L10-.L11)/2
 237              		.p2align 1
 238              	.L16:
 467:MotorControl/encoder.cpp ****         case 0b001: *hall_cnt = 0; return true;
 239              		.loc 3 467 9 is_stmt 1 view .LVU48
 240              		.loc 3 467 21 view .LVU49
 241              		.loc 3 467 31 is_stmt 0 view .LVU50
 242 0010 0023     		movs	r3, #0
 243 0012 0B60     		str	r3, [r1]
 244              		.loc 3 467 36 is_stmt 1 view .LVU51
 245              		.loc 3 467 43 is_stmt 0 view .LVU52
 246 0014 0120     		movs	r0, #1
 247 0016 7047     		bx	lr
 248              	.L14:
 468:MotorControl/encoder.cpp ****         case 0b011: *hall_cnt = 1; return true;
 249              		.loc 3 468 9 is_stmt 1 view .LVU53
 250              		.loc 3 468 21 view .LVU54
 251              		.loc 3 468 31 is_stmt 0 view .LVU55
 252 0018 0120     		movs	r0, #1
 253 001a 0860     		str	r0, [r1]
 254              		.loc 3 468 36 is_stmt 1 view .LVU56
 255              		.loc 3 468 43 is_stmt 0 view .LVU57
 256 001c 7047     		bx	lr
 257              	.L15:
 469:MotorControl/encoder.cpp ****         case 0b010: *hall_cnt = 2; return true;
 258              		.loc 3 469 9 is_stmt 1 view .LVU58
 259              		.loc 3 469 21 view .LVU59
 260              		.loc 3 469 31 is_stmt 0 view .LVU60
 261 001e 0223     		movs	r3, #2
 262 0020 0B60     		str	r3, [r1]
 263              		.loc 3 469 36 is_stmt 1 view .LVU61
 264              		.loc 3 469 43 is_stmt 0 view .LVU62
 265 0022 0120     		movs	r0, #1
 266 0024 7047     		bx	lr
ARM GAS  /tmp/cc5nV8qb.s 			page 47


 267              	.L10:
 470:MotorControl/encoder.cpp ****         case 0b110: *hall_cnt = 3; return true;
 268              		.loc 3 470 9 is_stmt 1 view .LVU63
 269              		.loc 3 470 21 view .LVU64
 270              		.loc 3 470 31 is_stmt 0 view .LVU65
 271 0026 0323     		movs	r3, #3
 272 0028 0B60     		str	r3, [r1]
 273              		.loc 3 470 36 is_stmt 1 view .LVU66
 274              		.loc 3 470 43 is_stmt 0 view .LVU67
 275 002a 0120     		movs	r0, #1
 276 002c 7047     		bx	lr
 277              	.L13:
 471:MotorControl/encoder.cpp ****         case 0b100: *hall_cnt = 4; return true;
 278              		.loc 3 471 9 is_stmt 1 view .LVU68
 279              		.loc 3 471 21 view .LVU69
 280              		.loc 3 471 31 is_stmt 0 view .LVU70
 281 002e 0423     		movs	r3, #4
 282 0030 0B60     		str	r3, [r1]
 283              		.loc 3 471 36 is_stmt 1 view .LVU71
 284              		.loc 3 471 43 is_stmt 0 view .LVU72
 285 0032 0120     		movs	r0, #1
 286 0034 7047     		bx	lr
 287              	.L12:
 472:MotorControl/encoder.cpp ****         case 0b101: *hall_cnt = 5; return true;
 288              		.loc 3 472 9 is_stmt 1 view .LVU73
 289              		.loc 3 472 21 view .LVU74
 290              		.loc 3 472 31 is_stmt 0 view .LVU75
 291 0036 0523     		movs	r3, #5
 292 0038 0B60     		str	r3, [r1]
 293              		.loc 3 472 36 is_stmt 1 view .LVU76
 294              		.loc 3 472 43 is_stmt 0 view .LVU77
 295 003a 0120     		movs	r0, #1
 296 003c 7047     		bx	lr
 297              	.L17:
 466:MotorControl/encoder.cpp ****         case 0b001: *hall_cnt = 0; return true;
 298              		.loc 3 466 5 view .LVU78
 299 003e 0020     		movs	r0, #0
 473:MotorControl/encoder.cpp ****         default: return false;
 474:MotorControl/encoder.cpp ****     }
 475:MotorControl/encoder.cpp **** }
 300              		.loc 3 475 1 view .LVU79
 301 0040 7047     		bx	lr
 302              		.cfi_endproc
 303              	.LFE5357:
 304              		.cantunwind
 305              		.fnend
 307              		.section	.text._ZNSt8functionIFbbEEC2IZN7Encoder29run_hall_polarity_calibrationEvEUlbE_vvEET_,"ax"
 308              		.align	1
 309              		.syntax unified
 310              		.thumb
 311              		.thumb_func
 313              	_ZNSt8functionIFbbEEC2IZN7Encoder29run_hall_polarity_calibrationEvEUlbE_vvEET_:
 314              		.fnstart
 315              	.LVL14:
 316              	.LFB5795:
 317              		.file 6 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // Implementation of std::function -*- C++ -*-
ARM GAS  /tmp/cc5nV8qb.s 			page 48


   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // Copyright (C) 2004-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** /** @file include/bits/std_function.h
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****  *  This is an internal header file, included by other library headers.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****  *  Do not attempt to use it directly. @headername{functional}
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****  */
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #ifndef _GLIBCXX_STD_FUNCTION_H
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #define _GLIBCXX_STD_FUNCTION_H 1
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #pragma GCC system_header
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #if __cplusplus < 201103L
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** # include <bits/c++0x_warning.h>
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #else
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #if __cpp_rtti
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** # include <typeinfo>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #endif
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #include <bits/stl_function.h>
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #include <bits/invoke.h>
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #include <bits/refwrap.h>
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #include <bits/functexcept.h>
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** namespace std _GLIBCXX_VISIBILITY(default)
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** {
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   /**
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****    *  @brief Exception class thrown when class template function's
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****    *  operator() is called with an empty target.
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****    *  @ingroup exceptions
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****    */
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   class bad_function_call : public std::exception
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   {
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   public:
ARM GAS  /tmp/cc5nV8qb.s 			page 49


  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     virtual ~bad_function_call() noexcept;
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const char* what() const noexcept;
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   };
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   /**
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****    *  Trait identifying "location-invariant" types, meaning that the
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****    *  address of the object (or any of its members) will not escape.
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****    *  Trivially copyable types are location-invariant and users can
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****    *  specialize this trait for other types.
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****    */
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   template<typename _Tp>
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     struct __is_location_invariant
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : is_trivially_copyable<_Tp>::type
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     { };
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   class _Undefined_class;
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   union _Nocopy_types
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   {
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     void*       _M_object;
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const void* _M_const_object;
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     void (*_M_function_pointer)();
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     void (_Undefined_class::*_M_member_pointer)();
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   };
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   union [[gnu::may_alias]] _Any_data
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   {
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     void*       _M_access()       { return &_M_pod_data[0]; }
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const void* _M_access() const { return &_M_pod_data[0]; }
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     template<typename _Tp>
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       _Tp&
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       _M_access()
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       { return *static_cast<_Tp*>(_M_access()); }
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     template<typename _Tp>
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       const _Tp&
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       _M_access() const
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       { return *static_cast<const _Tp*>(_M_access()); }
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     _Nocopy_types _M_unused;
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     char _M_pod_data[sizeof(_Nocopy_types)];
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   };
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   enum _Manager_operation
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   {
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     __get_type_info,
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     __get_functor_ptr,
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     __clone_functor,
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     __destroy_functor
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   };
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   template<typename _Signature>
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     class function;
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   /// Base class of all polymorphic function object wrappers.
ARM GAS  /tmp/cc5nV8qb.s 			page 50


 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   class _Function_base
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   {
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   public:
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     static const size_t _M_max_size = sizeof(_Nocopy_types);
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     static const size_t _M_max_align = __alignof__(_Nocopy_types);
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     template<typename _Functor>
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       class _Base_manager
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       {
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       protected:
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	static const bool __stored_locally =
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	(__is_location_invariant<_Functor>::value
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	 && sizeof(_Functor) <= _M_max_size
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	 && __alignof__(_Functor) <= _M_max_align
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	 && (_M_max_align % __alignof__(_Functor) == 0));
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	typedef integral_constant<bool, __stored_locally> _Local_storage;
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	// Retrieve a pointer to the function object
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	static _Functor*
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_get_pointer(const _Any_data& __source)
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  if _GLIBCXX17_CONSTEXPR (__stored_locally)
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    {
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      const _Functor& __f = __source._M_access<_Functor>();
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      return const_cast<_Functor*>(std::__addressof(__f));
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    }
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  else // have stored a pointer
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    return __source._M_access<_Functor*>();
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	}
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	// Clone a location-invariant function object that fits within
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	// an _Any_data structure.
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	static void
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	}
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	// Clone a function object that is not location-invariant or
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	// that cannot fit into an _Any_data structure.
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	static void
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  __dest._M_access<_Functor*>() =
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    new _Functor(*__source._M_access<const _Functor*>());
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	}
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	// Destroying a location-invariant object may still require
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	// destruction.
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	static void
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_destroy(_Any_data& __victim, true_type)
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  __victim._M_access<_Functor>().~_Functor();
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	}
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	// Destroying an object located on the heap.
ARM GAS  /tmp/cc5nV8qb.s 			page 51


 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	static void
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_destroy(_Any_data& __victim, false_type)
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  delete __victim._M_access<_Functor*>();
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	}
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       public:
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	static bool
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_Any_data& __dest, const _Any_data& __source,
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 		   _Manager_operation __op)
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  switch (__op)
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    {
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #if __cpp_rtti
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    case __get_type_info:
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      __dest._M_access<const type_info*>() = &typeid(_Functor);
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      break;
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #endif
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    case __get_functor_ptr:
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      break;
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    case __clone_functor:
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      _M_clone(__dest, __source, _Local_storage());
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      break;
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    case __destroy_functor:
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      _M_destroy(__dest, _Local_storage());
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      break;
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    }
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  return false;
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	}
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	static void
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_init_functor(_Any_data& __functor, _Functor&& __f)
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{ _M_init_functor(__functor, std::move(__f), _Local_storage()); }
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	template<typename _Signature>
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  static bool
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  _M_not_empty_function(const function<_Signature>& __f)
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  { return static_cast<bool>(__f); }
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	template<typename _Tp>
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  static bool
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  _M_not_empty_function(_Tp* __fp)
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  { return __fp != nullptr; }
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	template<typename _Class, typename _Tp>
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  static bool
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  _M_not_empty_function(_Tp _Class::* __mp)
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  { return __mp != nullptr; }
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	template<typename _Tp>
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  static bool
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  _M_not_empty_function(const _Tp&)
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  { return true; }
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 52


 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       private:
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	static void
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	static void
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       };
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     _Function_base() : _M_manager(nullptr) { }
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     ~_Function_base()
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     {
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       if (_M_manager)
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     bool _M_empty() const { return !_M_manager; }
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 				  _Manager_operation);
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     _Any_data     _M_functor;
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     _Manager_type _M_manager;
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   };
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   template<typename _Signature, typename _Functor>
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     class _Function_handler;
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   template<typename _Res, typename _Functor, typename... _ArgTypes>
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     class _Function_handler<_Res(_ArgTypes...), _Functor>
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Function_base::_Base_manager<_Functor>
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     {
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       typedef _Function_base::_Base_manager<_Functor> _Base;
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     public:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       static bool
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       _M_manager(_Any_data& __dest, const _Any_data& __source,
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 		 _Manager_operation __op)
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       {
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	switch (__op)
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  {
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #if __cpp_rtti
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  case __get_type_info:
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    __dest._M_access<const type_info*>() = &typeid(_Functor);
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    break;
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #endif
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  case __get_functor_ptr:
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    __dest._M_access<_Functor*>() = _Base::_M_get_pointer(__source);
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    break;
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  default:
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    _Base::_M_manager(__dest, __source, __op);
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  }
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	return false;
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       }
ARM GAS  /tmp/cc5nV8qb.s 			page 53


 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       static _Res
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       {
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	return std::__invoke_r<_Res>(*_Base::_M_get_pointer(__functor),
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 				     std::forward<_ArgTypes>(__args)...);
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       }
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     };
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   /**
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****    *  @brief Primary class template for std::function.
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****    *  @ingroup functors
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****    *
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****    *  Polymorphic function wrapper.
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****    */
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   template<typename _Res, typename... _ArgTypes>
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     class function<_Res(_ArgTypes...)>
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       private _Function_base
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     {
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       template<typename _Func,
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	       typename _Res2 = __invoke_result<_Func&, _ArgTypes...>>
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	struct _Callable
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	: __is_invocable_impl<_Res2, _Res>::type
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{ };
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       // Used so the return type convertibility checks aren't done when
 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       // performing overload resolution for copy construction/assignment.
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       template<typename _Tp>
 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	struct _Callable<function, _Tp> : false_type { };
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       template<typename _Cond, typename _Tp>
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	using _Requires = typename enable_if<_Cond::value, _Tp>::type;
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     public:
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       typedef _Res result_type;
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       // [3.7.2.1] construct/copy/destroy
 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /**
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @brief Default construct creates an empty function call wrapper.
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @post @c !(bool)*this
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        */
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       function() noexcept
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       : _Function_base() { }
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /**
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @brief Creates an empty function call wrapper.
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @post @c !(bool)*this
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        */
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       function(nullptr_t) noexcept
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       : _Function_base() { }
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /**
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @brief %Function copy constructor.
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @param __x A %function object with identical call signature.
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @post @c bool(*this) == bool(__x)
ARM GAS  /tmp/cc5nV8qb.s 			page 54


 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  The newly-created %function contains a copy of the target of @a
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  __x (if it has one).
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        */
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       function(const function& __x);
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /**
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @brief %Function move constructor.
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @param __x A %function object rvalue with identical call signature.
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  The newly-created %function contains the target of @a __x
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  (if it has one).
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        */
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       function(function&& __x) noexcept : _Function_base()
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       {
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	__x.swap(*this);
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       }
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /**
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @brief Builds a %function that targets a copy of the incoming
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  function object.
 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @param __f A %function object that is callable with parameters of
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  type @c T1, @c T2, ..., @c TN and returns a value convertible
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  to @c Res.
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  The newly-created %function object will target a copy of
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @a __f. If @a __f is @c reference_wrapper<F>, then this function
 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  object will contain a reference to the function object @c
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  __f.get(). If @a __f is a NULL function pointer or NULL
 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  pointer-to-member, the newly-created object will be empty.
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  If @a __f is a non-NULL function pointer or an object of type @c
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  reference_wrapper<F>, this function will not throw.
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        */
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       template<typename _Functor,
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	       typename = _Requires<__not_<is_same<_Functor, function>>, void>,
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	       typename = _Requires<_Callable<_Functor>, void>>
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	function(_Functor);
 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /**
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @brief %Function assignment operator.
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @param __x A %function with identical call signature.
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @post @c (bool)*this == (bool)x
 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @returns @c *this
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  The target of @a __x is copied to @c *this. If @a __x has no
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  target, then @c *this will be empty.
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  If @a __x targets a function pointer or a reference to a function
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  object, then this operation will not throw an %exception.
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        */
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       function&
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       operator=(const function& __x)
 397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       {
 398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	function(__x).swap(*this);
 399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	return *this;
 400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       }
ARM GAS  /tmp/cc5nV8qb.s 			page 55


 401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /**
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @brief %Function move-assignment operator.
 404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @param __x A %function rvalue with identical call signature.
 405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @returns @c *this
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  The target of @a __x is moved to @c *this. If @a __x has no
 408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  target, then @c *this will be empty.
 409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  If @a __x targets a function pointer or a reference to a function
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  object, then this operation will not throw an %exception.
 412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        */
 413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       function&
 414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       operator=(function&& __x) noexcept
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       {
 416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	function(std::move(__x)).swap(*this);
 417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	return *this;
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       }
 419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /**
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @brief %Function assignment to zero.
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @post @c !(bool)*this
 423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @returns @c *this
 424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  The target of @c *this is deallocated, leaving it empty.
 426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        */
 427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       function&
 428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       operator=(nullptr_t) noexcept
 429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       {
 430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	if (_M_manager)
 431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  {
 432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    _M_manager(_M_functor, _M_functor, __destroy_functor);
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    _M_manager = nullptr;
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    _M_invoker = nullptr;
 435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  }
 436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	return *this;
 437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       }
 438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /**
 440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @brief %Function assignment to a new target.
 441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @param __f A %function object that is callable with parameters of
 442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  type @c T1, @c T2, ..., @c TN and returns a value convertible
 443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  to @c Res.
 444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @return @c *this
 445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  This  %function object wrapper will target a copy of @a
 447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  __f. If @a __f is @c reference_wrapper<F>, then this function
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  object will contain a reference to the function object @c
 449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  __f.get(). If @a __f is a NULL function pointer or NULL
 450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  pointer-to-member, @c this object will be empty.
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  If @a __f is a non-NULL function pointer or an object of type @c
 453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  reference_wrapper<F>, this function will not throw.
 454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        */
 455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       template<typename _Functor>
 456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_Requires<_Callable<typename decay<_Functor>::type>, function&>
 457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	operator=(_Functor&& __f)
ARM GAS  /tmp/cc5nV8qb.s 			page 56


 458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  function(std::forward<_Functor>(__f)).swap(*this);
 460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  return *this;
 461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	}
 462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /// @overload
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       template<typename _Functor>
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	function&
 466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	operator=(reference_wrapper<_Functor> __f) noexcept
 467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  function(__f).swap(*this);
 469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  return *this;
 470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	}
 471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       // [3.7.2.2] function modifiers
 473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /**
 475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @brief Swap the targets of two %function objects.
 476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @param __x A %function with identical call signature.
 477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  Swap the targets of @c this function object and @a __f. This
 479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  function will not throw an %exception.
 480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        */
 481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       void swap(function& __x) noexcept
 482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       {
 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	std::swap(_M_functor, __x._M_functor);
 484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	std::swap(_M_manager, __x._M_manager);
 485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	std::swap(_M_invoker, __x._M_invoker);
 486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       }
 487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       // [3.7.2.3] function capacity
 489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /**
 491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @brief Determine if the %function wrapper has a target.
 492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @return @c true when this %function object contains a target,
 494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  or @c false when it is empty.
 495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  This function will not throw an %exception.
 497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        */
 498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       explicit operator bool() const noexcept
 499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       { return !_M_empty(); }
 500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       // [3.7.2.4] function invocation
 502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /**
 504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @brief Invokes the function targeted by @c *this.
 505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @returns the result of the target.
 506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @throws bad_function_call when @c !(bool)*this
 507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  The function call operator invokes the target function object
 509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  stored by @c this.
 510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        */
 511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       _Res operator()(_ArgTypes... __args) const;
 512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #if __cpp_rtti
 514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       // [3.7.2.5] function target access
ARM GAS  /tmp/cc5nV8qb.s 			page 57


 515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /**
 516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @brief Determine the type of the target of this function object
 517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  wrapper.
 518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @returns the type identifier of the target function object, or
 520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @c typeid(void) if @c !(bool)*this.
 521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  This function will not throw an %exception.
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        */
 524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       const type_info& target_type() const noexcept;
 525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /**
 527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @brief Access the stored target function object.
 528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  @return Returns a pointer to the stored target function object,
 530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  if @c typeid(_Functor).equals(target_type()); otherwise, a NULL
 531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *  pointer.
 532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        * This function does not throw exceptions.
 534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        *
 535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        * @{
 536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****        */
 537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       template<typename _Functor>       _Functor* target() noexcept;
 538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       template<typename _Functor> const _Functor* target() const noexcept;
 540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       /// @}
 541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #endif
 542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     private:
 544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);
 545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       _Invoker_type _M_invoker;
 546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   };
 547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #if __cpp_deduction_guides >= 201606
 549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   template<typename>
 550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     struct __function_guide_helper
 551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     { };
 552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
 554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     struct __function_guide_helper<
 555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       _Res (_Tp::*) (_Args...) noexcept(_Nx)
 556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     >
 557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     { using type = _Res(_Args...); };
 558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
 560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     struct __function_guide_helper<
 561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       _Res (_Tp::*) (_Args...) & noexcept(_Nx)
 562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     >
 563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     { using type = _Res(_Args...); };
 564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
 566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     struct __function_guide_helper<
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       _Res (_Tp::*) (_Args...) const noexcept(_Nx)
 568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     >
 569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     { using type = _Res(_Args...); };
 570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
ARM GAS  /tmp/cc5nV8qb.s 			page 58


 572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     struct __function_guide_helper<
 573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       _Res (_Tp::*) (_Args...) const & noexcept(_Nx)
 574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     >
 575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     { using type = _Res(_Args...); };
 576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   template<typename _Res, typename... _ArgTypes>
 578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     function(_Res(*)(_ArgTypes...)) -> function<_Res(_ArgTypes...)>;
 579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   template<typename _Functor, typename _Signature = typename
 581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	   __function_guide_helper<decltype(&_Functor::operator())>::type>
 582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     function(_Functor) -> function<_Signature>;
 583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #endif
 584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   // Out-of-line member definitions.
 586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   template<typename _Res, typename... _ArgTypes>
 587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     function<_Res(_ArgTypes...)>::
 588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     function(const function& __x)
 589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : _Function_base()
 590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     {
 591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       if (static_cast<bool>(__x))
 592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  _M_invoker = __x._M_invoker;
 595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  _M_manager = __x._M_manager;
 596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	}
 597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****   template<typename _Res, typename... _ArgTypes>
 600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     template<typename _Functor, typename, typename>
 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       function<_Res(_ArgTypes...)>::
 318              		.loc 6 601 7 is_stmt 1 view -0
 319              		.cfi_startproc
 320              		@ args = 0, pretend = 0, frame = 0
 321              		@ frame_needed = 0, uses_anonymous_args = 0
 322              		@ link register save eliminated.
 323              	.LBB1206:
 324              	.LBI1206:
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 325              		.loc 6 240 5 view .LVU81
 326              	.LBB1207:
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 327              		.loc 6 240 42 is_stmt 0 view .LVU82
 328 0000 0022     		movs	r2, #0
 329 0002 8260     		str	r2, [r0, #8]
 330              	.LVL15:
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 331              		.loc 6 240 42 view .LVU83
 332              	.LBE1207:
 333              	.LBE1206:
 334              	.LBB1208:
 335              	.LBB1209:
 336              	.LBI1209:
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  { return true; }
 337              		.loc 6 227 4 is_stmt 1 view .LVU84
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  { return true; }
 338              		.loc 6 227 4 is_stmt 0 view .LVU85
 339              	.LBE1209:
ARM GAS  /tmp/cc5nV8qb.s 			page 59


 340              	.LBB1210:
 341              	.LBI1210:
 342              		.file 7 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Move, forward and identity for C++11 + swap -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Copyright (C) 2007-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** /** @file bits/move.h
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****  *  This is an internal header file, included by other library headers.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****  *  Do not attempt to use it directly. @headername{utility}
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****  */
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #ifndef _MOVE_H
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #define _MOVE_H 1
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #include <bits/c++config.h>
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #if __cplusplus < 201103L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** # include <bits/concept_check.h>
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #endif
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** namespace std _GLIBCXX_VISIBILITY(default)
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** {
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   // Used, in C++03 mode too, by allocators, etc.
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief Same as C++11 std::addressof
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @ingroup utilities
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     inline _GLIBCXX_CONSTEXPR _Tp*
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return __builtin_addressof(__r); }
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #if __cplusplus >= 201103L
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** _GLIBCXX_END_NAMESPACE_VERSION
ARM GAS  /tmp/cc5nV8qb.s 			page 60


  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** } // namespace
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #include <type_traits> // Brings in std::declval too.
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** namespace std _GLIBCXX_VISIBILITY(default)
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** {
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @addtogroup utilities
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @{
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief  Forward an lvalue.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @return The parameter cast to the specified type.
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  This function is used to implement "perfect forwarding".
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     constexpr _Tp&&
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     forward(typename std::remove_reference<_Tp>::type& __t) noexcept
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief  Forward an rvalue.
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @return The parameter cast to the specified type.
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  This function is used to implement "perfect forwarding".
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     constexpr _Tp&&
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     {
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****       static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 		    " substituting _Tp is an lvalue reference type");
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****       return static_cast<_Tp&&>(__t);
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     }
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief  Convert a value to an rvalue.
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @param  __t  A thing of arbitrary type.
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @return The parameter cast to an rvalue-reference to allow moving it.
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   */
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     constexpr typename std::remove_reference<_Tp>::type&&
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     move(_Tp&& __t) noexcept
 343              		.loc 7 101 5 is_stmt 1 view .LVU86
 344              		.loc 7 101 5 is_stmt 0 view .LVU87
 345              	.LBE1210:
 346              	.LBB1211:
 347              	.LBI1211:
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{ _M_init_functor(__functor, std::move(__f), _Local_storage()); }
 348              		.loc 6 207 2 is_stmt 1 view .LVU88
 349              	.LBB1212:
 350              	.LBB1213:
 351              	.LBI1213:
ARM GAS  /tmp/cc5nV8qb.s 			page 61


 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
 352              		.loc 6 232 2 view .LVU89
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
 353              		.loc 6 232 2 is_stmt 0 view .LVU90
 354              	.LBE1213:
 355              	.LBE1212:
 356              	.LBE1211:
 357              	.LBE1208:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const void* _M_access() const { return &_M_pod_data[0]; }
 358              		.loc 6 87 37 is_stmt 1 view .LVU91
 359              		.file 8 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // The -*- C++ -*- dynamic memory management header.
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // Copyright (C) 1994-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // This file is part of GCC.
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** //
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // GCC is free software; you can redistribute it and/or modify
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // it under the terms of the GNU General Public License as published by
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // the Free Software Foundation; either version 3, or (at your option)
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // any later version.
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // 
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // GCC is distributed in the hope that it will be useful,
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // GNU General Public License for more details.
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // 
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // Under Section 7 of GPL version 3, you are granted additional
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // permissions described in the GCC Runtime Library Exception, version
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // 3.1, as published by the Free Software Foundation.
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // You should have received a copy of the GNU General Public License and
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // a copy of the GCC Runtime Library Exception along with this program;
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // <http://www.gnu.org/licenses/>.
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** /** @file new
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  This is a Standard C++ Library header.
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  The header @c new defines several functions to manage dynamic memory and
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  handling memory allocation errors; see
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/dynamic_memory.html
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  for more.
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  */
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #ifndef _NEW
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #define _NEW
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #pragma GCC system_header
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #include <bits/c++config.h>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #include <exception>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #pragma GCC visibility push(default)
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** extern "C++" {
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 62


  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** namespace std 
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** {
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /**
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  @brief  Exception possibly thrown by @c new.
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  @ingroup exceptions
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  @c bad_alloc (or classes derived from it) is used to report allocation
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  errors from the throwing forms of @c new.  */
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   class bad_alloc : public exception 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   {
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   public:
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_alloc() throw() { }
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_alloc(const bad_alloc&) = default;
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_alloc& operator=(const bad_alloc&) = default;
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // This declaration is not useless:
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual ~bad_alloc() throw();
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // See comment in eh_exception.cc.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual const char* what() const throw();
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   };
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   class bad_array_new_length : public bad_alloc
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   {
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   public:
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_array_new_length() throw() { }
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // This declaration is not useless:
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual ~bad_array_new_length() throw();
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // See comment in eh_exception.cc.
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual const char* what() const throw();
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   };
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_aligned_new
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   enum class align_val_t: size_t {};
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   struct nothrow_t
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   {
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     explicit nothrow_t() = default;
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   };
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   extern const nothrow_t nothrow;
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /** If you write your own error handler to be called by @c new, it must
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  be of this type.  */
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   typedef void (*new_handler)();
ARM GAS  /tmp/cc5nV8qb.s 			page 63


 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /// Takes a replacement handler as the argument, returns the
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /// previous handler.
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   new_handler set_new_handler(new_handler) throw();
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /// Return the current new handler.
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   new_handler get_new_handler() noexcept;
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** } // namespace std
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** //@{
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** /** These are replaceable signatures:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - normal array new and delete (same)
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - @c nothrow single new and delete (take a @c nothrow argument, return
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *    @c NULL on error)
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - @c nothrow array new and delete (same)
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  Placement new and delete signatures (take a memory address argument,
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  does nothing) may not be replaced by a user's program.
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** */
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t) _GLIBCXX_THROW (std::bad_alloc)
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*) _GLIBCXX_USE_NOEXCEPT
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*) _GLIBCXX_USE_NOEXCEPT
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_sized_deallocation
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__, __malloc__));
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__, __malloc__));
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_aligned_new
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t)
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __malloc__));
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::align_val_t)
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::align_val_t, const std::nothrow_t&)
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t)
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __malloc__));
ARM GAS  /tmp/cc5nV8qb.s 			page 64


 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::align_val_t)
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_sized_deallocation
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::size_t, std::align_val_t)
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::size_t, std::align_val_t)
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif // __cpp_sized_deallocation
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif // __cpp_aligned_new
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // Default placement versions of operator new.
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** { return __p; }
 360              		.loc 8 175 3 view .LVU92
 361              	.LBB1218:
 362              	.LBB1217:
 363              	.LBB1216:
 364              	.LBB1215:
 365              	.LBB1214:
 366              		.loc 8 175 3 is_stmt 0 view .LVU93
 367 0004 0160     		str	r1, [r0]
 368              	.LVL16:
 369              		.loc 8 175 3 view .LVU94
 370              	.LBE1214:
 371              	.LBE1215:
 372              	.LBE1216:
 373              	.LBE1217:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       function(_Functor __f)
 603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       : _Function_base()
 604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       {
 605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	typedef _Function_handler<_Res(_ArgTypes...), _Functor> _My_handler;
 606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	if (_My_handler::_M_not_empty_function(__f))
 608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  {
 609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    _M_invoker = &_My_handler::_M_invoke;
 374              		.loc 6 610 17 view .LVU95
 375 0006 024A     		ldr	r2, .L19
 376 0008 C260     		str	r2, [r0, #12]
 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    _M_manager = &_My_handler::_M_manager;
 377              		.loc 6 611 17 view .LVU96
 378 000a 024A     		ldr	r2, .L19+4
 379 000c 8260     		str	r2, [r0, #8]
 380              	.LBE1218:
 612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  }
 613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       }
 381              		.loc 6 613 7 view .LVU97
 382 000e 7047     		bx	lr
 383              	.L20:
 384              		.align	2
 385              	.L19:
 386 0010 00000000 		.word	_ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E9_M_invokeERK
 387 0014 00000000 		.word	_ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E10_M_managerE
 388              		.cfi_endproc
 389              	.LFE5795:
ARM GAS  /tmp/cc5nV8qb.s 			page 65


 390              		.cantunwind
 391              		.fnend
 393              		.thumb_set _ZNSt8functionIFbbEEC1IZN7Encoder29run_hall_polarity_calibrationEvEUlbE_vvEET_,_ZNSt8fu
 394              		.section	.text._ZNSt8functionIFbbEEC2IZN7Encoder26run_hall_phase_calibrationEvEUlbE_vvEET_,"ax",%p
 395              		.align	1
 396              		.syntax unified
 397              		.thumb
 398              		.thumb_func
 400              	_ZNSt8functionIFbbEEC2IZN7Encoder26run_hall_phase_calibrationEvEUlbE_vvEET_:
 401              		.fnstart
 402              	.LVL17:
 403              	.LFB5819:
 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       function(_Functor __f)
 404              		.loc 6 601 7 is_stmt 1 view -0
 405              		.cfi_startproc
 406              		@ args = 0, pretend = 0, frame = 0
 407              		@ frame_needed = 0, uses_anonymous_args = 0
 408              		@ link register save eliminated.
 409              	.LBB1219:
 410              	.LBI1219:
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 411              		.loc 6 240 5 view .LVU99
 412              	.LBB1220:
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 413              		.loc 6 240 42 is_stmt 0 view .LVU100
 414 0000 0022     		movs	r2, #0
 415 0002 8260     		str	r2, [r0, #8]
 416              	.LVL18:
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 417              		.loc 6 240 42 view .LVU101
 418              	.LBE1220:
 419              	.LBE1219:
 420              	.LBB1221:
 421              	.LBB1222:
 422              	.LBI1222:
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  { return true; }
 423              		.loc 6 227 4 is_stmt 1 view .LVU102
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  { return true; }
 424              		.loc 6 227 4 is_stmt 0 view .LVU103
 425              	.LBE1222:
 426              	.LBB1223:
 427              	.LBI1223:
 428              		.loc 7 101 5 is_stmt 1 view .LVU104
 429              		.loc 7 101 5 is_stmt 0 view .LVU105
 430              	.LBE1223:
 431              	.LBB1224:
 432              	.LBI1224:
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{ _M_init_functor(__functor, std::move(__f), _Local_storage()); }
 433              		.loc 6 207 2 is_stmt 1 view .LVU106
 434              	.LBB1225:
 435              	.LBB1226:
 436              	.LBI1226:
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
 437              		.loc 6 232 2 view .LVU107
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
 438              		.loc 6 232 2 is_stmt 0 view .LVU108
 439              	.LBE1226:
ARM GAS  /tmp/cc5nV8qb.s 			page 66


 440              	.LBE1225:
 441              	.LBE1224:
 442              	.LBE1221:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const void* _M_access() const { return &_M_pod_data[0]; }
 443              		.loc 6 87 37 is_stmt 1 view .LVU109
 444              		.loc 8 175 3 view .LVU110
 445              	.LBB1231:
 446              	.LBB1230:
 447              	.LBB1229:
 448              	.LBB1228:
 449              	.LBB1227:
 450              		.loc 8 175 3 is_stmt 0 view .LVU111
 451 0004 0160     		str	r1, [r0]
 452              	.LVL19:
 453              		.loc 8 175 3 view .LVU112
 454              	.LBE1227:
 455              	.LBE1228:
 456              	.LBE1229:
 457              	.LBE1230:
 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    _M_manager = &_My_handler::_M_manager;
 458              		.loc 6 610 17 view .LVU113
 459 0006 024A     		ldr	r2, .L22
 460 0008 C260     		str	r2, [r0, #12]
 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  }
 461              		.loc 6 611 17 view .LVU114
 462 000a 024A     		ldr	r2, .L22+4
 463 000c 8260     		str	r2, [r0, #8]
 464              	.LBE1231:
 465              		.loc 6 613 7 view .LVU115
 466 000e 7047     		bx	lr
 467              	.L23:
 468              		.align	2
 469              	.L22:
 470 0010 00000000 		.word	_ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E9_M_invokeERKSt9
 471 0014 00000000 		.word	_ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E10_M_managerERSt
 472              		.cfi_endproc
 473              	.LFE5819:
 474              		.cantunwind
 475              		.fnend
 477              		.thumb_set _ZNSt8functionIFbbEEC1IZN7Encoder26run_hall_phase_calibrationEvEUlbE_vvEET_,_ZNSt8funct
 478              		.section	.text._ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E9_M_
 479              		.align	1
 480              		.syntax unified
 481              		.thumb
 482              		.thumb_func
 484              	_ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E9_M_invokeERKSt9_Any
 485              		.fnstart
 486              	.LVL20:
 487              	.LFB6115:
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       {
 488              		.loc 6 289 7 is_stmt 1 view -0
 489              		.cfi_startproc
 490              		@ args = 0, pretend = 0, frame = 0
 491              		@ frame_needed = 0, uses_anonymous_args = 0
 492              		@ link register save eliminated.
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 493              		.loc 6 88 37 view .LVU117
ARM GAS  /tmp/cc5nV8qb.s 			page 67


 494              	.LBB1232:
 495              	.LBI1232:
 496              		.file 9 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // Implementation of INVOKE -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // Copyright (C) 2016-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** /** @file include/bits/invoke.h
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****  *  This is an internal header file, included by other library headers.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****  *  Do not attempt to use it directly. @headername{functional}
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****  */
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** #ifndef _GLIBCXX_INVOKE_H
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** #define _GLIBCXX_INVOKE_H 1
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** #pragma GCC system_header
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** #if __cplusplus < 201103L
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** # include <bits/c++0x_warning.h>
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** #else
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** #include <type_traits>
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** namespace std _GLIBCXX_VISIBILITY(default)
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** {
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   /**
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****    *  @addtogroup utilities
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****    *  @{
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****    */
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   // Used by __invoke_impl instead of std::forward<_Tp> so that a
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   // reference_wrapper is converted to an lvalue-reference.
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr _Up&&
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
ARM GAS  /tmp/cc5nV8qb.s 			page 68


  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     { return static_cast<_Up&&>(__t); }
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Res, typename _Fn, typename... _Args>
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr _Res
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr _Res
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 		  _Args&&... __args)
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr _Res
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 		  _Args&&... __args)
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     {
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****       return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     }
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Res, typename _MemPtr, typename _Tp>
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr _Res
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     { return __invfwd<_Tp>(__t).*__f; }
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Res, typename _MemPtr, typename _Tp>
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr _Res
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     { return (*std::forward<_Tp>(__t)).*__f; }
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   /// Invoke a callable object.
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Callable, typename... _Args>
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr typename __invoke_result<_Callable, _Args...>::type
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invoke(_Callable&& __fn, _Args&&... __args)
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     {
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****       using __result = __invoke_result<_Callable, _Args...>;
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****       using __type = typename __result::type;
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****       using __tag = typename __result::__invoke_type;
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****       return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 					std::forward<_Args>(__args)...);
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     }
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** #if __cplusplus >= 201703L
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   // INVOKE<R>: Invoke a callable object and convert the result to R.
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****   template<typename _Res, typename _Callable, typename... _Args>
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     constexpr enable_if_t<is_invocable_r_v<_Res, _Callable, _Args...>, _Res>
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     __invoke_r(_Callable&& __fn, _Args&&... __args)
 497              		.loc 9 103 5 view .LVU118
 498              	.LBB1233:
 499              	.LBB1234:
 500              	.LBI1234:
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }
 501              		.loc 9 59 5 view .LVU119
 502              	.LBB1235:
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 69


 503              		.loc 9 60 36 is_stmt 0 view .LVU120
 504 0000 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 505              	.LVL21:
 506              	.LBB1236:
 507              	.LBI1236:
 217:MotorControl/encoder.cpp ****         if (const_vel)
 508              		.loc 3 217 20 is_stmt 1 view .LVU121
 509              	.LBB1237:
 218:MotorControl/encoder.cpp ****             sample_hall_states_ = true;
 510              		.loc 3 218 9 view .LVU122
 511 0002 1BB1     		cbz	r3, .L25
 219:MotorControl/encoder.cpp ****         // No need to cancel early
 512              		.loc 3 219 13 view .LVU123
 217:MotorControl/encoder.cpp ****         if (const_vel)
 513              		.loc 3 217 41 is_stmt 0 view .LVU124
 514 0004 0368     		ldr	r3, [r0]
 515              	.LVL22:
 219:MotorControl/encoder.cpp ****         // No need to cancel early
 516              		.loc 3 219 33 view .LVU125
 517 0006 0122     		movs	r2, #1
 518 0008 83F8F620 		strb	r2, [r3, #246]
 519              	.LVL23:
 520              	.L25:
 221:MotorControl/encoder.cpp ****     };
 521              		.loc 3 221 9 is_stmt 1 view .LVU126
 221:MotorControl/encoder.cpp ****     };
 522              		.loc 3 221 9 is_stmt 0 view .LVU127
 523              	.LBE1237:
 524              	.LBE1236:
 525              	.LBE1235:
 526              	.LBE1234:
 527              	.LBE1233:
 528              	.LBE1232:
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     };
 529              		.loc 6 293 7 view .LVU128
 530 000c 0120     		movs	r0, #1
 531              	.LVL24:
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     };
 532              		.loc 6 293 7 view .LVU129
 533 000e 7047     		bx	lr
 534              		.cfi_endproc
 535              	.LFE6115:
 536              		.cantunwind
 537              		.fnend
 539              		.section	.text._ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E9_M_inv
 540              		.align	1
 541              		.syntax unified
 542              		.thumb
 543              		.thumb_func
 545              	_ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E9_M_invokeERKSt9_Any_da
 546              		.fnstart
 547              	.LVL25:
 548              	.LFB6126:
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       {
 549              		.loc 6 289 7 is_stmt 1 view -0
 550              		.cfi_startproc
 551              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/cc5nV8qb.s 			page 70


 552              		@ frame_needed = 0, uses_anonymous_args = 0
 553              		@ link register save eliminated.
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 554              		.loc 6 88 37 view .LVU131
 555              	.LBB1238:
 556              	.LBI1238:
 557              		.loc 9 103 5 view .LVU132
 558              	.LBB1239:
 559              	.LBB1240:
 560              	.LBI1240:
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h ****     { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }
 561              		.loc 9 59 5 view .LVU133
 562              	.LBB1241:
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/invoke.h **** 
 563              		.loc 9 60 36 is_stmt 0 view .LVU134
 564 0000 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 565              	.LVL26:
 566              	.LBB1242:
 567              	.LBI1242:
 278:MotorControl/encoder.cpp ****         if (const_vel)
 568              		.loc 3 278 20 is_stmt 1 view .LVU135
 569              	.LBB1243:
 279:MotorControl/encoder.cpp ****             sample_hall_phase_ = true;
 570              		.loc 3 279 9 view .LVU136
 571 0002 1BB1     		cbz	r3, .L27
 280:MotorControl/encoder.cpp ****         // No need to cancel early
 572              		.loc 3 280 13 view .LVU137
 278:MotorControl/encoder.cpp ****         if (const_vel)
 573              		.loc 3 278 41 is_stmt 0 view .LVU138
 574 0004 0368     		ldr	r3, [r0]
 575              	.LVL27:
 280:MotorControl/encoder.cpp ****         // No need to cancel early
 576              		.loc 3 280 32 view .LVU139
 577 0006 0122     		movs	r2, #1
 578 0008 83F8F720 		strb	r2, [r3, #247]
 579              	.LVL28:
 580              	.L27:
 282:MotorControl/encoder.cpp ****     };
 581              		.loc 3 282 9 is_stmt 1 view .LVU140
 282:MotorControl/encoder.cpp ****     };
 582              		.loc 3 282 9 is_stmt 0 view .LVU141
 583              	.LBE1243:
 584              	.LBE1242:
 585              	.LBE1241:
 586              	.LBE1240:
 587              	.LBE1239:
 588              	.LBE1238:
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     };
 589              		.loc 6 293 7 view .LVU142
 590 000c 0120     		movs	r0, #1
 591              	.LVL29:
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     };
 592              		.loc 6 293 7 view .LVU143
 593 000e 7047     		bx	lr
 594              		.cfi_endproc
 595              	.LFE6126:
 596              		.cantunwind
ARM GAS  /tmp/cc5nV8qb.s 			page 71


 597              		.fnend
 599              		.section	.text._ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E10_M
 600              		.align	1
 601              		.syntax unified
 602              		.thumb
 603              		.thumb_func
 605              	_ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E10_M_managerERSt9_An
 606              		.fnstart
 607              	.LVL30:
 608              	.LFB6118:
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 		 _Manager_operation __op)
 609              		.loc 6 268 7 is_stmt 1 view -0
 610              		.cfi_startproc
 611              		@ args = 0, pretend = 0, frame = 0
 612              		@ frame_needed = 0, uses_anonymous_args = 0
 613              		@ link register save eliminated.
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  {
 614              		.loc 6 271 2 is_stmt 0 view .LVU145
 615 0000 1346     		mov	r3, r2
 616 0002 3AB1     		cbz	r2, .L29
 617 0004 012A     		cmp	r2, #1
 618 0006 09D0     		beq	.L30
 619              	.LVL31:
 620              	.LBB1260:
 621              	.LBI1260:
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 		   _Manager_operation __op)
 622              		.loc 6 181 2 is_stmt 1 view .LVU146
 623              	.LBB1261:
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    {
 624              		.loc 6 184 4 is_stmt 0 view .LVU147
 625 0008 032B     		cmp	r3, #3
 626 000a 05D8     		bhi	.L32
 627 000c DFE803F0 		tbb	[pc, r3]
 628              	.LVL32:
 629              	.L35:
 630 0010 08       		.byte	(.L38-.L35)/2
 631 0011 0B       		.byte	(.L37-.L35)/2
 632 0012 0D       		.byte	(.L36-.L35)/2
 633 0013 04       		.byte	(.L32-.L35)/2
 634              		.p2align 1
 635              	.L29:
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    {
 636              		.loc 6 184 4 view .LVU148
 637              	.LBE1261:
 638              	.LBE1260:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const void* _M_access() const { return &_M_pod_data[0]; }
 639              		.loc 6 87 37 is_stmt 1 view .LVU149
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    break;
 640              		.loc 6 275 43 is_stmt 0 view .LVU150
 641 0014 064B     		ldr	r3, .L40
 642 0016 0360     		str	r3, [r0]
 643              	.LVL33:
 644              	.L32:
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 645              		.loc 6 286 7 view .LVU151
 646 0018 0020     		movs	r0, #0
 647              	.LVL34:
ARM GAS  /tmp/cc5nV8qb.s 			page 72


 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 648              		.loc 6 286 7 view .LVU152
 649 001a 7047     		bx	lr
 650              	.LVL35:
 651              	.L30:
 652              	.LBB1273:
 653              	.LBI1273:
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 654              		.loc 6 136 2 is_stmt 1 view .LVU153
 655              	.LBB1274:
 656              	.LBB1275:
 657              	.LBI1275:
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       { return *static_cast<const _Tp*>(_M_access()); }
 658              		.loc 6 97 7 view .LVU154
 659              	.LBB1276:
 660              	.LBI1276:
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 661              		.loc 6 88 17 view .LVU155
 662              	.LBB1277:
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 663              		.loc 6 88 37 view .LVU156
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 664              		.loc 6 88 37 is_stmt 0 view .LVU157
 665              	.LBE1277:
 666              	.LBE1276:
 667              	.LBE1275:
 668              	.LBE1274:
 669              	.LBE1273:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const void* _M_access() const { return &_M_pod_data[0]; }
 670              		.loc 6 87 37 is_stmt 1 view .LVU158
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    break;
 671              		.loc 6 279 36 is_stmt 0 view .LVU159
 672 001c 0160     		str	r1, [r0]
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 673              		.loc 6 280 6 view .LVU160
 674 001e FBE7     		b	.L32
 675              	.LVL36:
 676              	.L38:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const void* _M_access() const { return &_M_pod_data[0]; }
 677              		.loc 6 87 37 is_stmt 1 view .LVU161
 678              	.LBB1278:
 679              	.LBB1270:
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      break;
 680              		.loc 6 188 45 is_stmt 0 view .LVU162
 681 0020 034B     		ldr	r3, .L40
 682              	.LVL37:
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      break;
 683              		.loc 6 188 45 view .LVU163
 684 0022 0360     		str	r3, [r0]
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #endif
 685              		.loc 6 189 8 view .LVU164
 686 0024 F8E7     		b	.L32
 687              	.LVL38:
 688              	.L37:
 689              	.LBB1262:
 690              	.LBI1262:
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
ARM GAS  /tmp/cc5nV8qb.s 			page 73


 691              		.loc 6 136 2 is_stmt 1 view .LVU165
 692              	.LBB1263:
 693              	.LBB1264:
 694              	.LBI1264:
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       { return *static_cast<const _Tp*>(_M_access()); }
 695              		.loc 6 97 7 view .LVU166
 696              	.LBB1265:
 697              	.LBI1265:
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 698              		.loc 6 88 17 view .LVU167
 699              	.LBB1266:
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 700              		.loc 6 88 37 view .LVU168
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 701              		.loc 6 88 37 is_stmt 0 view .LVU169
 702              	.LBE1266:
 703              	.LBE1265:
 704              	.LBE1264:
 705              	.LBE1263:
 706              	.LBE1262:
 707              	.LBE1270:
 708              	.LBE1278:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const void* _M_access() const { return &_M_pod_data[0]; }
 709              		.loc 6 87 37 is_stmt 1 view .LVU170
 710              	.LBB1279:
 711              	.LBB1271:
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      break;
 712              		.loc 6 192 38 is_stmt 0 view .LVU171
 713 0026 0160     		str	r1, [r0]
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 714              		.loc 6 193 8 view .LVU172
 715 0028 F6E7     		b	.L32
 716              	.LVL39:
 717              	.L36:
 718              	.LBB1267:
 719              	.LBI1267:
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 720              		.loc 6 150 2 is_stmt 1 view .LVU173
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 721              		.loc 6 150 2 is_stmt 0 view .LVU174
 722              	.LBE1267:
 723              	.LBE1271:
 724              	.LBE1279:
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 725              		.loc 6 88 37 is_stmt 1 view .LVU175
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const void* _M_access() const { return &_M_pod_data[0]; }
 726              		.loc 6 87 37 view .LVU176
 727              		.loc 8 175 3 view .LVU177
 728              	.LBB1280:
 729              	.LBB1272:
 730              	.LBB1269:
 731              	.LBB1268:
 732              		.loc 8 175 3 is_stmt 0 view .LVU178
 733 002a 0B68     		ldr	r3, [r1]
 734              	.LVL40:
 735              		.loc 8 175 3 view .LVU179
 736 002c 0360     		str	r3, [r0]
ARM GAS  /tmp/cc5nV8qb.s 			page 74


 737              	.LVL41:
 738              		.loc 8 175 3 view .LVU180
 739              	.LBE1268:
 740              	.LBE1269:
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 741              		.loc 6 197 8 view .LVU181
 742 002e F3E7     		b	.L32
 743              	.L41:
 744              		.align	2
 745              	.L40:
 746 0030 00000000 		.word	.LANCHOR0
 747              	.LBE1272:
 748              	.LBE1280:
 749              		.cfi_endproc
 750              	.LFE6118:
 751              		.cantunwind
 752              		.fnend
 754              		.section	.text._ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E10_M_ma
 755              		.align	1
 756              		.syntax unified
 757              		.thumb
 758              		.thumb_func
 760              	_ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E10_M_managerERSt9_Any_d
 761              		.fnstart
 762              	.LVL42:
 763              	.LFB6129:
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 		 _Manager_operation __op)
 764              		.loc 6 268 7 is_stmt 1 view -0
 765              		.cfi_startproc
 766              		@ args = 0, pretend = 0, frame = 0
 767              		@ frame_needed = 0, uses_anonymous_args = 0
 768              		@ link register save eliminated.
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	  {
 769              		.loc 6 271 2 is_stmt 0 view .LVU183
 770 0000 1346     		mov	r3, r2
 771 0002 3AB1     		cbz	r2, .L43
 772 0004 012A     		cmp	r2, #1
 773 0006 09D0     		beq	.L44
 774              	.LVL43:
 775              	.LBB1297:
 776              	.LBI1297:
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 		   _Manager_operation __op)
 777              		.loc 6 181 2 is_stmt 1 view .LVU184
 778              	.LBB1298:
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    {
 779              		.loc 6 184 4 is_stmt 0 view .LVU185
 780 0008 032B     		cmp	r3, #3
 781 000a 05D8     		bhi	.L46
 782 000c DFE803F0 		tbb	[pc, r3]
 783              	.LVL44:
 784              	.L49:
 785 0010 08       		.byte	(.L52-.L49)/2
 786 0011 0B       		.byte	(.L51-.L49)/2
 787 0012 0D       		.byte	(.L50-.L49)/2
 788 0013 04       		.byte	(.L46-.L49)/2
 789              		.p2align 1
 790              	.L43:
ARM GAS  /tmp/cc5nV8qb.s 			page 75


 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    {
 791              		.loc 6 184 4 view .LVU186
 792              	.LBE1298:
 793              	.LBE1297:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const void* _M_access() const { return &_M_pod_data[0]; }
 794              		.loc 6 87 37 is_stmt 1 view .LVU187
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    break;
 795              		.loc 6 275 43 is_stmt 0 view .LVU188
 796 0014 064B     		ldr	r3, .L54
 797 0016 0360     		str	r3, [r0]
 798              	.LVL45:
 799              	.L46:
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 800              		.loc 6 286 7 view .LVU189
 801 0018 0020     		movs	r0, #0
 802              	.LVL46:
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 803              		.loc 6 286 7 view .LVU190
 804 001a 7047     		bx	lr
 805              	.LVL47:
 806              	.L44:
 807              	.LBB1310:
 808              	.LBI1310:
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 809              		.loc 6 136 2 is_stmt 1 view .LVU191
 810              	.LBB1311:
 811              	.LBB1312:
 812              	.LBI1312:
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       { return *static_cast<const _Tp*>(_M_access()); }
 813              		.loc 6 97 7 view .LVU192
 814              	.LBB1313:
 815              	.LBI1313:
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 816              		.loc 6 88 17 view .LVU193
 817              	.LBB1314:
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 818              		.loc 6 88 37 view .LVU194
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 819              		.loc 6 88 37 is_stmt 0 view .LVU195
 820              	.LBE1314:
 821              	.LBE1313:
 822              	.LBE1312:
 823              	.LBE1311:
 824              	.LBE1310:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const void* _M_access() const { return &_M_pod_data[0]; }
 825              		.loc 6 87 37 is_stmt 1 view .LVU196
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	    break;
 826              		.loc 6 279 36 is_stmt 0 view .LVU197
 827 001c 0160     		str	r1, [r0]
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 828              		.loc 6 280 6 view .LVU198
 829 001e FBE7     		b	.L46
 830              	.LVL48:
 831              	.L52:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const void* _M_access() const { return &_M_pod_data[0]; }
 832              		.loc 6 87 37 is_stmt 1 view .LVU199
 833              	.LBB1315:
ARM GAS  /tmp/cc5nV8qb.s 			page 76


 834              	.LBB1307:
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      break;
 835              		.loc 6 188 45 is_stmt 0 view .LVU200
 836 0020 034B     		ldr	r3, .L54
 837              	.LVL49:
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      break;
 838              		.loc 6 188 45 view .LVU201
 839 0022 0360     		str	r3, [r0]
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** #endif
 840              		.loc 6 189 8 view .LVU202
 841 0024 F8E7     		b	.L46
 842              	.LVL50:
 843              	.L51:
 844              	.LBB1299:
 845              	.LBI1299:
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 846              		.loc 6 136 2 is_stmt 1 view .LVU203
 847              	.LBB1300:
 848              	.LBB1301:
 849              	.LBI1301:
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       { return *static_cast<const _Tp*>(_M_access()); }
 850              		.loc 6 97 7 view .LVU204
 851              	.LBB1302:
 852              	.LBI1302:
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 853              		.loc 6 88 17 view .LVU205
 854              	.LBB1303:
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 855              		.loc 6 88 37 view .LVU206
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 856              		.loc 6 88 37 is_stmt 0 view .LVU207
 857              	.LBE1303:
 858              	.LBE1302:
 859              	.LBE1301:
 860              	.LBE1300:
 861              	.LBE1299:
 862              	.LBE1307:
 863              	.LBE1315:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const void* _M_access() const { return &_M_pod_data[0]; }
 864              		.loc 6 87 37 is_stmt 1 view .LVU208
 865              	.LBB1316:
 866              	.LBB1308:
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	      break;
 867              		.loc 6 192 38 is_stmt 0 view .LVU209
 868 0026 0160     		str	r1, [r0]
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 869              		.loc 6 193 8 view .LVU210
 870 0028 F6E7     		b	.L46
 871              	.LVL51:
 872              	.L50:
 873              	.LBB1304:
 874              	.LBI1304:
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 875              		.loc 6 150 2 is_stmt 1 view .LVU211
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	{
 876              		.loc 6 150 2 is_stmt 0 view .LVU212
 877              	.LBE1304:
ARM GAS  /tmp/cc5nV8qb.s 			page 77


 878              	.LBE1308:
 879              	.LBE1316:
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 880              		.loc 6 88 37 is_stmt 1 view .LVU213
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     const void* _M_access() const { return &_M_pod_data[0]; }
 881              		.loc 6 87 37 view .LVU214
 882              		.loc 8 175 3 view .LVU215
 883              	.LBB1317:
 884              	.LBB1309:
 885              	.LBB1306:
 886              	.LBB1305:
 887              		.loc 8 175 3 is_stmt 0 view .LVU216
 888 002a 0B68     		ldr	r3, [r1]
 889              	.LVL52:
 890              		.loc 8 175 3 view .LVU217
 891 002c 0360     		str	r3, [r0]
 892              	.LVL53:
 893              		.loc 8 175 3 view .LVU218
 894              	.LBE1305:
 895              	.LBE1306:
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 896              		.loc 6 197 8 view .LVU219
 897 002e F3E7     		b	.L46
 898              	.L55:
 899              		.align	2
 900              	.L54:
 901 0030 00000000 		.word	.LANCHOR1
 902              	.LBE1309:
 903              	.LBE1317:
 904              		.cfi_endproc
 905              	.LFE6129:
 906              		.cantunwind
 907              		.fnend
 909              		.section	.text._ZNSt18bad_variant_accessD2Ev,"axG",%progbits,_ZNSt18bad_variant_accessD5Ev,comdat
 910              		.align	1
 911              		.weak	_ZNSt18bad_variant_accessD2Ev
 912              		.syntax unified
 913              		.thumb
 914              		.thumb_func
 916              	_ZNSt18bad_variant_accessD2Ev:
 917              		.fnstart
 918              	.LVL54:
 919              	.LFB6514:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 920              		.loc 1 1264 9 is_stmt 1 view -0
 921              		.cfi_startproc
 922              		@ args = 0, pretend = 0, frame = 0
 923              		@ frame_needed = 0, uses_anonymous_args = 0
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 924              		.loc 1 1264 9 is_stmt 0 view .LVU221
 925 0000 10B5     		push	{r4, lr}
 926              	.LCFI0:
 927              		.cfi_def_cfa_offset 8
 928              		.cfi_offset 4, -8
 929              		.cfi_offset 14, -4
 930 0002 0446     		mov	r4, r0
 931              	.LBB1318:
ARM GAS  /tmp/cc5nV8qb.s 			page 78


1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 932              		.loc 1 1264 9 view .LVU222
 933 0004 024B     		ldr	r3, .L58
 934 0006 0360     		str	r3, [r0]
 935 0008 FFF7FEFF 		bl	_ZNSt9exceptionD2Ev
 936              	.LVL55:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 937              		.loc 1 1264 9 view .LVU223
 938              	.LBE1318:
 939 000c 2046     		mov	r0, r4
 940 000e 10BD     		pop	{r4, pc}
 941              	.LVL56:
 942              	.L59:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 943              		.loc 1 1264 9 view .LVU224
 944              		.align	2
 945              	.L58:
 946 0010 08000000 		.word	_ZTVSt18bad_variant_access+8
 947              		.cfi_endproc
 948              	.LFE6514:
 949              		.cantunwind
 950              		.fnend
 952              		.weak	_ZNSt18bad_variant_accessD1Ev
 953              		.thumb_set _ZNSt18bad_variant_accessD1Ev,_ZNSt18bad_variant_accessD2Ev
 954              		.section	.text._ZNSt18bad_variant_accessD0Ev,"axG",%progbits,_ZNSt18bad_variant_accessD5Ev,comdat
 955              		.align	1
 956              		.weak	_ZNSt18bad_variant_accessD0Ev
 957              		.syntax unified
 958              		.thumb
 959              		.thumb_func
 961              	_ZNSt18bad_variant_accessD0Ev:
 962              		.fnstart
 963              	.LVL57:
 964              	.LFB6516:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 965              		.loc 1 1264 9 is_stmt 1 view -0
 966              		.cfi_startproc
 967              		@ args = 0, pretend = 0, frame = 0
 968              		@ frame_needed = 0, uses_anonymous_args = 0
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 969              		.loc 1 1264 9 is_stmt 0 view .LVU226
 970 0000 10B5     		push	{r4, lr}
 971              	.LCFI1:
 972              		.cfi_def_cfa_offset 8
 973              		.cfi_offset 4, -8
 974              		.cfi_offset 14, -4
 975 0002 0446     		mov	r4, r0
 976              	.LVL58:
 977              	.LBB1319:
 978              	.LBI1319:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 979              		.loc 1 1264 9 is_stmt 1 view .LVU227
 980              	.LBB1320:
 981 0004 044B     		ldr	r3, .L62
 982 0006 0360     		str	r3, [r0]
 983 0008 FFF7FEFF 		bl	_ZNSt9exceptionD2Ev
 984              	.LVL59:
ARM GAS  /tmp/cc5nV8qb.s 			page 79


1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 985              		.loc 1 1264 9 is_stmt 0 view .LVU228
 986              	.LBE1320:
 987              	.LBE1319:
 988 000c 0821     		movs	r1, #8
 989 000e 2046     		mov	r0, r4
 990 0010 FFF7FEFF 		bl	_ZdlPvj
 991              	.LVL60:
 992 0014 2046     		mov	r0, r4
 993 0016 10BD     		pop	{r4, pc}
 994              	.LVL61:
 995              	.L63:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 996              		.loc 1 1264 9 view .LVU229
 997              		.align	2
 998              	.L62:
 999 0018 08000000 		.word	_ZTVSt18bad_variant_access+8
 1000              		.cfi_endproc
 1001              	.LFE6516:
 1002              		.cantunwind
 1003              		.fnend
 1005              		.section	.text._ZNSt14_Function_baseD2Ev,"axG",%progbits,_ZNSt14_Function_baseD5Ev,comdat
 1006              		.align	1
 1007              		.weak	_ZNSt14_Function_baseD2Ev
 1008              		.syntax unified
 1009              		.thumb
 1010              		.thumb_func
 1012              	_ZNSt14_Function_baseD2Ev:
 1013              		.fnstart
 1014              	.LVL62:
 1015              	.LFB1616:
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     {
 1016              		.loc 6 242 5 is_stmt 1 view -0
 1017              		.cfi_startproc
 1018              		@ args = 0, pretend = 0, frame = 0
 1019              		@ frame_needed = 0, uses_anonymous_args = 0
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     {
 1020              		.loc 6 242 5 is_stmt 0 view .LVU231
 1021 0000 10B5     		push	{r4, lr}
 1022              		.save {r4, lr}
 1023              	.LCFI2:
 1024              		.cfi_def_cfa_offset 8
 1025              		.cfi_offset 4, -8
 1026              		.cfi_offset 14, -4
 1027 0002 0446     		mov	r4, r0
 1028              	.LBB1322:
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 1029              		.loc 6 244 7 is_stmt 1 view .LVU232
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 1030              		.loc 6 244 11 is_stmt 0 view .LVU233
 1031 0004 8368     		ldr	r3, [r0, #8]
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 1032              		.loc 6 244 7 view .LVU234
 1033 0006 13B1     		cbz	r3, .L65
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 1034              		.loc 6 245 2 is_stmt 1 view .LVU235
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
ARM GAS  /tmp/cc5nV8qb.s 			page 80


 1035              		.loc 6 245 12 is_stmt 0 view .LVU236
 1036 0008 0322     		movs	r2, #3
 1037 000a 0146     		mov	r1, r0
 1038 000c 9847     		blx	r3
 1039              	.LVL63:
 1040              	.L65:
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 1041              		.loc 6 245 12 view .LVU237
 1042              	.LBE1322:
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 1043              		.loc 6 246 5 view .LVU238
 1044 000e 2046     		mov	r0, r4
 1045 0010 10BD     		pop	{r4, pc}
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 1046              		.loc 6 246 5 view .LVU239
 1047              		.cfi_endproc
 1048              	.LFE1616:
 1049              		.global	__gxx_personality_v0
 1050              		.personality	__gxx_personality_v0
 1051              		.handlerdata
 1052              	.LLSDA1616:
 1053 0008 FF       		.byte	0xff
 1054 0009 FF       		.byte	0xff
 1055 000a 01       		.byte	0x1
 1056 000b 00       		.uleb128 .LLSDACSE1616-.LLSDACSB1616
 1057              	.LLSDACSB1616:
 1058              	.LLSDACSE1616:
 1059              		.section	.text._ZNSt14_Function_baseD2Ev,"axG",%progbits,_ZNSt14_Function_baseD5Ev,comdat
 1060              		.fnend
 1062              		.weak	_ZNSt14_Function_baseD1Ev
 1063              		.thumb_set _ZNSt14_Function_baseD1Ev,_ZNSt14_Function_baseD2Ev
 1064              		.section	.text._ZSt26__throw_bad_variant_accessPKc,"axG",%progbits,_ZSt26__throw_bad_variant_acces
 1065              		.align	1
 1066              		.weak	_ZSt26__throw_bad_variant_accessPKc
 1067              		.syntax unified
 1068              		.thumb
 1069              		.thumb_func
 1071              	_ZSt26__throw_bad_variant_accessPKc:
 1072              		.fnstart
 1073              	.LVL64:
 1074              	.LFB3070:
1271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   private:
1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     bad_variant_access(const char* __reason) noexcept : _M_reason(__reason) { }
1274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     // Must point to a string with static storage duration:
1276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     const char* _M_reason = "bad variant access";
1277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     friend void __throw_bad_variant_access(const char* __what);
1279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   };
1280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Must only be called with a string literal
1282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   inline void
1283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   __throw_bad_variant_access(const char* __what)
1284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   { _GLIBCXX_THROW_OR_ABORT(bad_variant_access(__what)); }
 1075              		.loc 1 1284 3 is_stmt 1 view -0
 1076              		.cfi_startproc
ARM GAS  /tmp/cc5nV8qb.s 			page 81


 1077              		@ args = 0, pretend = 0, frame = 0
 1078              		@ frame_needed = 0, uses_anonymous_args = 0
 1079              		.loc 1 1284 3 is_stmt 0 view .LVU241
 1080 0000 10B5     		push	{r4, lr}
 1081              		.save {r4, lr}
 1082              	.LCFI3:
 1083              		.cfi_def_cfa_offset 8
 1084              		.cfi_offset 4, -8
 1085              		.cfi_offset 14, -4
 1086 0002 0446     		mov	r4, r0
 1087              		.loc 1 1284 5 is_stmt 1 view .LVU242
 1088 0004 0820     		movs	r0, #8
 1089              	.LVL65:
 1090              		.loc 1 1284 5 is_stmt 0 view .LVU243
 1091 0006 FFF7FEFF 		bl	__cxa_allocate_exception
 1092              	.LVL66:
 1093              	.LBB1323:
 1094              	.LBI1323:
1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 1095              		.loc 1 1273 5 is_stmt 1 view .LVU244
 1096              	.LBB1324:
 1097              	.LBB1325:
 1098              	.LBI1325:
 1099              		.file 10 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // Exception Handling support header for -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // Copyright (C) 2016-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // This file is part of GCC.
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** //
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // GCC is free software; you can redistribute it and/or modify
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // it under the terms of the GNU General Public License as published by
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // the Free Software Foundation; either version 3, or (at your option)
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // any later version.
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** //
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // GCC is distributed in the hope that it will be useful,
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // GNU General Public License for more details.
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** //
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // Under Section 7 of GPL version 3, you are granted additional
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // permissions described in the GCC Runtime Library Exception, version
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // 3.1, as published by the Free Software Foundation.
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // You should have received a copy of the GNU General Public License and
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // a copy of the GCC Runtime Library Exception along with this program;
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // <http://www.gnu.org/licenses/>.
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** /** @file bits/exception.h
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****  *  This is an internal header file, included by other library headers.
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****  *  Do not attempt to use it directly.
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****  */
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #ifndef __EXCEPTION_H
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #define __EXCEPTION_H 1
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 82


  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #pragma GCC system_header
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #pragma GCC visibility push(default)
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #include <bits/c++config.h>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** extern "C++" {
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** namespace std
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** {
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   /**
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    * @defgroup exceptions Exceptions
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    * @ingroup diagnostics
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    * Classes and functions for reporting errors via exceptions.
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    * @{
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    */
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   /**
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  @brief Base class for all library exceptions.
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  This is the base class for all exceptions thrown by the standard
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  library, and by certain language expressions.  You are free to derive
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  your own %exception classes, or use a different hierarchy, or to
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  throw non-class data (e.g., fundamental types).
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    */
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   class exception
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   {
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   public:
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****     exception() _GLIBCXX_NOTHROW { }
 1100              		.loc 10 63 5 view .LVU245
 1101              	.LBB1326:
 1102              		.loc 10 63 34 is_stmt 0 view .LVU246
 1103 000a 044A     		ldr	r2, .L69
 1104 000c 0260     		str	r2, [r0]
 1105              	.LVL67:
 1106              		.loc 10 63 34 view .LVU247
 1107              	.LBE1326:
 1108              	.LBE1325:
1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 1109              		.loc 1 1273 75 view .LVU248
 1110 000e 044A     		ldr	r2, .L69+4
 1111 0010 0260     		str	r2, [r0]
 1112 0012 4460     		str	r4, [r0, #4]
 1113              	.LVL68:
1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 1114              		.loc 1 1273 75 view .LVU249
 1115              	.LBE1324:
 1116              	.LBE1323:
 1117              		.loc 1 1284 5 view .LVU250
 1118 0014 034A     		ldr	r2, .L69+8
 1119 0016 0449     		ldr	r1, .L69+12
 1120 0018 FFF7FEFF 		bl	__cxa_throw
 1121              	.LVL69:
 1122              	.L70:
 1123              		.align	2
 1124              	.L69:
ARM GAS  /tmp/cc5nV8qb.s 			page 83


 1125 001c 08000000 		.word	_ZTVSt9exception+8
 1126 0020 08000000 		.word	_ZTVSt18bad_variant_access+8
 1127 0024 00000000 		.word	_ZNSt18bad_variant_accessD1Ev
 1128 0028 00000000 		.word	_ZTISt18bad_variant_access
 1129              		.cfi_endproc
 1130              	.LFE3070:
 1131              		.fnend
 1133              		.section	.rodata._ZSt26__throw_bad_variant_accessb.str1.4,"aMS",%progbits,1
 1134              		.align	2
 1135              	.LC0:
 1136 0000 7374643A 		.ascii	"std::get: variant is valueless\000"
 1136      3A676574 
 1136      3A207661 
 1136      7269616E 
 1136      74206973 
 1137 001f 00       		.align	2
 1138              	.LC1:
 1139 0020 7374643A 		.ascii	"std::get: wrong index for variant\000"
 1139      3A676574 
 1139      3A207772 
 1139      6F6E6720 
 1139      696E6465 
 1140              		.section	.text._ZSt26__throw_bad_variant_accessb,"axG",%progbits,_ZSt26__throw_bad_variant_accessb
 1141              		.align	1
 1142              		.weak	_ZSt26__throw_bad_variant_accessb
 1143              		.syntax unified
 1144              		.thumb
 1145              		.thumb_func
 1147              	_ZSt26__throw_bad_variant_accessb:
 1148              		.fnstart
 1149              	.LVL70:
 1150              	.LFB3071:
1285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   inline void
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   __throw_bad_variant_access(bool __valueless)
1288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 1151              		.loc 1 1288 3 is_stmt 1 view -0
 1152              		.cfi_startproc
 1153              		@ args = 0, pretend = 0, frame = 0
 1154              		@ frame_needed = 0, uses_anonymous_args = 0
 1155              		.loc 1 1288 3 is_stmt 0 view .LVU252
 1156 0000 08B5     		push	{r3, lr}
 1157              		.save {r3, lr}
 1158              	.LCFI4:
 1159              		.cfi_def_cfa_offset 8
 1160              		.cfi_offset 3, -8
 1161              		.cfi_offset 14, -4
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     if (__valueless) [[__unlikely__]]
 1162              		.loc 1 1289 5 is_stmt 1 view .LVU253
 1163 0002 10B1     		cbz	r0, .L72
1290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 1164              		.loc 1 1290 7 view .LVU254
 1165              		.loc 1 1290 33 is_stmt 0 view .LVU255
 1166 0004 0248     		ldr	r0, .L74
 1167              	.LVL71:
 1168              		.loc 1 1290 33 view .LVU256
 1169 0006 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
ARM GAS  /tmp/cc5nV8qb.s 			page 84


 1170              	.LVL72:
 1171              	.L72:
1291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     else
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: wrong index for variant");
 1172              		.loc 1 1292 7 is_stmt 1 view .LVU257
 1173              		.loc 1 1292 33 is_stmt 0 view .LVU258
 1174 000a 0248     		ldr	r0, .L74+4
 1175              	.LVL73:
 1176              		.loc 1 1292 33 view .LVU259
 1177 000c FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 1178              	.LVL74:
 1179              	.L75:
 1180              		.align	2
 1181              	.L74:
 1182 0010 00000000 		.word	.LC0
 1183 0014 20000000 		.word	.LC1
 1184              		.cfi_endproc
 1185              	.LFE3071:
 1186              		.fnend
 1188              		.section	.text._ZoRRN10ODriveIntf8AxisIntf5ErrorES1_,"axG",%progbits,_ZoRRN10ODriveIntf8AxisIntf5E
 1189              		.align	1
 1190              		.weak	_ZoRRN10ODriveIntf8AxisIntf5ErrorES1_
 1191              		.syntax unified
 1192              		.thumb
 1193              		.thumb_func
 1195              	_ZoRRN10ODriveIntf8AxisIntf5ErrorES1_:
 1196              		.fnstart
 1197              	.LVL75:
 1198              	.LFB4170:
 1199              		.file 11 "./autogen/interfaces.hpp"
   1:./autogen/interfaces.hpp **** /*
   2:./autogen/interfaces.hpp ****  * ============================ WARNING ============================
   3:./autogen/interfaces.hpp ****  * ==== This is an autogenerated file.                          ====
   4:./autogen/interfaces.hpp ****  * ==== Any changes to this file will be lost when recompiling. ====
   5:./autogen/interfaces.hpp ****  * =================================================================
   6:./autogen/interfaces.hpp ****  *
   7:./autogen/interfaces.hpp ****  * This file contains base classes that correspond to the interfaces defined in
   8:./autogen/interfaces.hpp ****  * your interface file. The objects you publish should inherit from these
   9:./autogen/interfaces.hpp ****  * interfaces.
  10:./autogen/interfaces.hpp ****  *
  11:./autogen/interfaces.hpp ****  */
  12:./autogen/interfaces.hpp **** #ifndef __FIBRE_INTERFACES_HPP
  13:./autogen/interfaces.hpp **** #define __FIBRE_INTERFACES_HPP
  14:./autogen/interfaces.hpp **** 
  15:./autogen/interfaces.hpp **** #include <tuple>
  16:./autogen/interfaces.hpp **** using float2D = std::pair<float, float>;
  17:./autogen/interfaces.hpp **** struct Iph_ABC_t { float phA; float phB; float phC; };
  18:./autogen/interfaces.hpp **** 
  19:./autogen/interfaces.hpp **** 
  20:./autogen/interfaces.hpp **** #include <fibre/../../protocol.hpp>
  21:./autogen/interfaces.hpp **** 
  22:./autogen/interfaces.hpp **** #pragma GCC push_options
  23:./autogen/interfaces.hpp **** #pragma GCC optimize ("s")
  24:./autogen/interfaces.hpp **** 
  25:./autogen/interfaces.hpp **** 
  26:./autogen/interfaces.hpp **** 
  27:./autogen/interfaces.hpp **** class ODriveIntf {
ARM GAS  /tmp/cc5nV8qb.s 			page 85


  28:./autogen/interfaces.hpp **** public:
  29:./autogen/interfaces.hpp ****     class ConfigIntf {
  30:./autogen/interfaces.hpp ****     public:
  31:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_a(T* obj) { return Property<bool>{&
  32:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_a(T* obj, void* ptr) { new (ptr) Pr
  33:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_b(T* obj) { return Property<bool>{&
  34:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_b(T* obj, void* ptr) { new (ptr) Pr
  35:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_c(T* obj) { return Property<bool>{&
  36:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_c(T* obj, void* ptr) { new (ptr) Pr
  37:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_a_baudrate(T* obj) { return Property<uint3
  38:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_a_baudrate(T* obj, void* ptr) { new (ptr) 
  39:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_b_baudrate(T* obj) { return Property<uint3
  40:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_b_baudrate(T* obj, void* ptr) { new (ptr) 
  41:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_c_baudrate(T* obj) { return Property<uint3
  42:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_c_baudrate(T* obj, void* ptr) { new (ptr) 
  43:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_can_a(T* obj) { return Property<bool>{&o
  44:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_can_a(T* obj, void* ptr) { new (ptr) Pro
  45:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_i2c_a(T* obj) { return Property<bool>{&o
  46:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_i2c_a(T* obj, void* ptr) { new (ptr) Pro
  47:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_usb_cdc_protocol(T* obj) { return Property<ODri
  48:./autogen/interfaces.hpp ****         template<typename T> static inline void get_usb_cdc_protocol(T* obj, void* ptr) { new (ptr)
  49:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart0_protocol(T* obj) { return Property<ODrive
  50:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart0_protocol(T* obj, void* ptr) { new (ptr) P
  51:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart1_protocol(T* obj) { return Property<ODrive
  52:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart1_protocol(T* obj, void* ptr) { new (ptr) P
  53:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart2_protocol(T* obj) { return Property<ODrive
  54:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart2_protocol(T* obj, void* ptr) { new (ptr) P
  55:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_regen_current(T* obj) { return Property<flo
  56:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_regen_current(T* obj, void* ptr) { new (ptr
  57:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_brake_resistance(T* obj) { return Property<floa
  58:./autogen/interfaces.hpp ****         template<typename T> static inline void get_brake_resistance(T* obj, void* ptr) { new (ptr)
  59:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_brake_resistor(T* obj) { return Property
  60:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_brake_resistor(T* obj, void* ptr) { new 
  61:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_undervoltage_trip_level(T* obj) { return
  62:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_undervoltage_trip_level(T* obj, void* pt
  63:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_trip_level(T* obj) { return 
  64:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_trip_level(T* obj, void* ptr
  65:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_dc_bus_overvoltage_ramp(T* obj) { return
  66:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_dc_bus_overvoltage_ramp(T* obj, void* pt
  67:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_ramp_start(T* obj) { return 
  68:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_ramp_start(T* obj, void* ptr
  69:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_ramp_end(T* obj) { return Pr
  70:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_ramp_end(T* obj, void* ptr) 
  71:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_max_positive_current(T* obj) { return Proper
  72:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_max_positive_current(T* obj, void* ptr) { ne
  73:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_max_negative_current(T* obj) { return Proper
  74:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_max_negative_current(T* obj, void* ptr) { ne
  75:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error_gpio_pin(T* obj) { return Property<uint32
  76:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error_gpio_pin(T* obj, void* ptr) { new (ptr) P
  77:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio3_analog_mapping(T* obj) { return &obj->ana
  78:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio4_analog_mapping(T* obj) { return &obj->ana
  79:./autogen/interfaces.hpp ****     };
  80:./autogen/interfaces.hpp ****     class CanIntf {
  81:./autogen/interfaces.hpp ****     public:
  82:./autogen/interfaces.hpp ****         class ConfigIntf {
  83:./autogen/interfaces.hpp ****         public:
  84:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_baud_rate(T* obj) { return Property<uint32_
ARM GAS  /tmp/cc5nV8qb.s 			page 86


  85:./autogen/interfaces.hpp ****             template<typename T> static inline void get_baud_rate(T* obj, void* ptr) { new (ptr) Pr
  86:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_protocol(T* obj) { return Property<ODriveIn
  87:./autogen/interfaces.hpp ****             template<typename T> static inline void get_protocol(T* obj, void* ptr) { new (ptr) Pro
  88:./autogen/interfaces.hpp ****         };
  89:./autogen/interfaces.hpp ****         enum Error {
  90:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
  91:./autogen/interfaces.hpp ****             ERROR_DUPLICATE_CAN_IDS          = 0x00000001,
  92:./autogen/interfaces.hpp ****         };
  93:./autogen/interfaces.hpp ****         enum Protocol {
  94:./autogen/interfaces.hpp ****             PROTOCOL_SIMPLE                  = 0x00000001,
  95:./autogen/interfaces.hpp ****         };
  96:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Can
  97:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
  98:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
  99:./autogen/interfaces.hpp ****     };
 100:./autogen/interfaces.hpp ****     class EndpointIntf {
 101:./autogen/interfaces.hpp ****     public:
 102:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_endpoint(T* obj) { return Property<endpoint_ref
 103:./autogen/interfaces.hpp ****         template<typename T> static inline void get_endpoint(T* obj, void* ptr) { new (ptr) Propert
 104:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_min(T* obj) { return Property<float>{&obj->min}
 105:./autogen/interfaces.hpp ****         template<typename T> static inline void get_min(T* obj, void* ptr) { new (ptr) Property<flo
 106:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max(T* obj) { return Property<float>{&obj->max}
 107:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max(T* obj, void* ptr) { new (ptr) Property<flo
 108:./autogen/interfaces.hpp ****     };
 109:./autogen/interfaces.hpp ****     class AxisIntf {
 110:./autogen/interfaces.hpp ****     public:
 111:./autogen/interfaces.hpp ****         class LockinConfigIntf {
 112:./autogen/interfaces.hpp ****         public:
 113:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current(T* obj) { return Property<float>{&o
 114:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current(T* obj, void* ptr) { new (ptr) Prop
 115:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ramp_time(T* obj) { return Property<float>{
 116:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ramp_time(T* obj, void* ptr) { new (ptr) Pr
 117:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ramp_distance(T* obj) { return Property<flo
 118:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ramp_distance(T* obj, void* ptr) { new (ptr
 119:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_accel(T* obj) { return Property<float>{&obj
 120:./autogen/interfaces.hpp ****             template<typename T> static inline void get_accel(T* obj, void* ptr) { new (ptr) Proper
 121:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel(T* obj) { return Property<float>{&obj->
 122:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel(T* obj, void* ptr) { new (ptr) Property
 123:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_distance(T* obj) { return Property<f
 124:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_distance(T* obj, void* ptr) { new (p
 125:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_vel(T* obj) { return Property<boo
 126:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_vel(T* obj, void* ptr) { new (ptr
 127:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_distance(T* obj) { return Propert
 128:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_distance(T* obj, void* ptr) { new
 129:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_enc_idx(T* obj) { return Property
 130:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_enc_idx(T* obj, void* ptr) { new 
 131:./autogen/interfaces.hpp ****         };
 132:./autogen/interfaces.hpp ****         class CanConfigIntf {
 133:./autogen/interfaces.hpp ****         public:
 134:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_node_id(T* obj) { return Property<uint32_t>
 135:./autogen/interfaces.hpp ****             template<typename T> static inline void get_node_id(T* obj, void* ptr) { new (ptr) Prop
 136:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_is_extended(T* obj) { return Property<bool>
 137:./autogen/interfaces.hpp ****             template<typename T> static inline void get_is_extended(T* obj, void* ptr) { new (ptr) 
 138:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_heartbeat_rate_ms(T* obj) { return Property
 139:./autogen/interfaces.hpp ****             template<typename T> static inline void get_heartbeat_rate_ms(T* obj, void* ptr) { new 
 140:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_rate_ms(T* obj) { return Property<u
 141:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_rate_ms(T* obj, void* ptr) { new (p
ARM GAS  /tmp/cc5nV8qb.s 			page 87


 142:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_error_rate_ms(T* obj) { return Proper
 143:./autogen/interfaces.hpp ****             template<typename T> static inline void get_motor_error_rate_ms(T* obj, void* ptr) { ne
 144:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_error_rate_ms(T* obj) { return Prop
 145:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_error_rate_ms(T* obj, void* ptr) { 
 146:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_controller_error_rate_ms(T* obj) { return P
 147:./autogen/interfaces.hpp ****             template<typename T> static inline void get_controller_error_rate_ms(T* obj, void* ptr)
 148:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_error_rate_ms(T* obj) { return P
 149:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sensorless_error_rate_ms(T* obj, void* ptr)
 150:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_count_rate_ms(T* obj) { return Prop
 151:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_count_rate_ms(T* obj, void* ptr) { 
 152:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_iq_rate_ms(T* obj) { return Property<uint32
 153:./autogen/interfaces.hpp ****             template<typename T> static inline void get_iq_rate_ms(T* obj, void* ptr) { new (ptr) P
 154:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_rate_ms(T* obj) { return Propert
 155:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sensorless_rate_ms(T* obj, void* ptr) { new
 156:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bus_vi_rate_ms(T* obj) { return Property<ui
 157:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bus_vi_rate_ms(T* obj, void* ptr) { new (pt
 158:./autogen/interfaces.hpp ****         };
 159:./autogen/interfaces.hpp ****         class ConfigIntf {
 160:./autogen/interfaces.hpp ****         public:
 161:./autogen/interfaces.hpp ****             class CalibrationLockinIntf {
 162:./autogen/interfaces.hpp ****             public:
 163:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_current(T* obj) { return Property<float
 164:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_current(T* obj, void* ptr) { new (ptr) 
 165:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_ramp_time(T* obj) { return Property<flo
 166:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_ramp_time(T* obj, void* ptr) { new (ptr
 167:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_ramp_distance(T* obj) { return Property
 168:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_ramp_distance(T* obj, void* ptr) { new 
 169:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_accel(T* obj) { return Property<float>{
 170:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_accel(T* obj, void* ptr) { new (ptr) Pr
 171:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_vel(T* obj) { return Property<float>{&o
 172:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_vel(T* obj, void* ptr) { new (ptr) Prop
 173:./autogen/interfaces.hpp ****             };
 174:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_motor_calibration(T* obj) { return 
 175:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_motor_calibration(T* obj, void* ptr
 176:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_encoder_index_search(T* obj) { retu
 177:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_encoder_index_search(T* obj, void* 
 178:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_encoder_offset_calibration(T* obj) 
 179:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_encoder_offset_calibration(T* obj, 
 180:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_closed_loop_control(T* obj) { retur
 181:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_closed_loop_control(T* obj, void* p
 182:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_homing(T* obj) { return Property<bo
 183:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_homing(T* obj, void* ptr) { new (pt
 184:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_step_dir(T* obj) { return Property<b
 185:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_step_dir(T* obj, void* ptr) { new (p
 186:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_step_dir_always_on(T* obj) { return Propert
 187:./autogen/interfaces.hpp ****             template<typename T> static inline void get_step_dir_always_on(T* obj, void* ptr) { new
 188:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_sensorless_mode(T* obj) { return Pro
 189:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_sensorless_mode(T* obj, void* ptr) {
 190:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_watchdog_timeout(T* obj) { return Property<
 191:./autogen/interfaces.hpp ****             template<typename T> static inline void get_watchdog_timeout(T* obj, void* ptr) { new (
 192:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_watchdog(T* obj) { return Property<b
 193:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_watchdog(T* obj, void* ptr) { new (p
 194:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_step_gpio_pin(T* obj) { return Property<uin
 195:./autogen/interfaces.hpp ****             template<typename T> static inline void get_step_gpio_pin(T* obj, void* ptr) { new (ptr
 196:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dir_gpio_pin(T* obj) { return Property<uint
 197:./autogen/interfaces.hpp ****             template<typename T> static inline void get_dir_gpio_pin(T* obj, void* ptr) { new (ptr)
 198:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calibration_lockin(T* obj) { return &obj->c
ARM GAS  /tmp/cc5nV8qb.s 			page 88


 199:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_ramp(T* obj) { return &obj->sens
 200:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_general_lockin(T* obj) { return &obj->gener
 201:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_can(T* obj) { return &obj->can; }
 202:./autogen/interfaces.hpp ****         };
 203:./autogen/interfaces.hpp ****         class TaskTimesIntf {
 204:./autogen/interfaces.hpp ****         public:
 205:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_thermistor_update(T* obj) { return &obj->th
 206:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_update(T* obj) { return &obj->encod
 207:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_estimator_update(T* obj) { retur
 208:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_endstop_update(T* obj) { return &obj->endst
 209:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_can_heartbeat(T* obj) { return &obj->can_he
 210:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_controller_update(T* obj) { return &obj->co
 211:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_open_loop_controller_update(T* obj) { retur
 212:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_estimator_update(T* obj) { return &obj
 213:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_update(T* obj) { return &obj->motor_u
 214:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_controller_update(T* obj) { return 
 215:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dc_calib(T* obj) { return &obj->dc_calib; }
 216:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_sense(T* obj) { return &obj->curren
 217:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pwm_update(T* obj) { return &obj->pwm_updat
 218:./autogen/interfaces.hpp ****         };
 219:./autogen/interfaces.hpp ****         enum Error {
 220:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 221:./autogen/interfaces.hpp ****             ERROR_INVALID_STATE              = 0x00000001,
 222:./autogen/interfaces.hpp ****             ERROR_MOTOR_FAILED               = 0x00000040,
 223:./autogen/interfaces.hpp ****             ERROR_SENSORLESS_ESTIMATOR_FAILED = 0x00000080,
 224:./autogen/interfaces.hpp ****             ERROR_ENCODER_FAILED             = 0x00000100,
 225:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_FAILED          = 0x00000200,
 226:./autogen/interfaces.hpp ****             ERROR_WATCHDOG_TIMER_EXPIRED     = 0x00000800,
 227:./autogen/interfaces.hpp ****             ERROR_MIN_ENDSTOP_PRESSED        = 0x00001000,
 228:./autogen/interfaces.hpp ****             ERROR_MAX_ENDSTOP_PRESSED        = 0x00002000,
 229:./autogen/interfaces.hpp ****             ERROR_ESTOP_REQUESTED            = 0x00004000,
 230:./autogen/interfaces.hpp ****             ERROR_HOMING_WITHOUT_ENDSTOP     = 0x00020000,
 231:./autogen/interfaces.hpp ****             ERROR_OVER_TEMP                  = 0x00040000,
 232:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_POSITION           = 0x00080000,
 233:./autogen/interfaces.hpp ****         };
 234:./autogen/interfaces.hpp ****         enum AxisState {
 235:./autogen/interfaces.hpp ****             AXIS_STATE_UNDEFINED             = 0,
 236:./autogen/interfaces.hpp ****             AXIS_STATE_IDLE                  = 1,
 237:./autogen/interfaces.hpp ****             AXIS_STATE_STARTUP_SEQUENCE      = 2,
 238:./autogen/interfaces.hpp ****             AXIS_STATE_FULL_CALIBRATION_SEQUENCE = 3,
 239:./autogen/interfaces.hpp ****             AXIS_STATE_MOTOR_CALIBRATION     = 4,
 240:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_INDEX_SEARCH  = 6,
 241:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_OFFSET_CALIBRATION = 7,
 242:./autogen/interfaces.hpp ****             AXIS_STATE_CLOSED_LOOP_CONTROL   = 8,
 243:./autogen/interfaces.hpp ****             AXIS_STATE_LOCKIN_SPIN           = 9,
 244:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_DIR_FIND      = 10,
 245:./autogen/interfaces.hpp ****             AXIS_STATE_HOMING                = 11,
 246:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_HALL_POLARITY_CALIBRATION = 12,
 247:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_HALL_PHASE_CALIBRATION = 13,
 248:./autogen/interfaces.hpp ****         };
 249:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Axi
 250:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 251:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_step_dir_active(T* obj) { return Property<const
 252:./autogen/interfaces.hpp ****         template<typename T> static inline void get_step_dir_active(T* obj, void* ptr) { new (ptr) 
 253:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_drv_fault(T* obj) { return Property<const 
 254:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_drv_fault(T* obj, void* ptr) { new (ptr) P
 255:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_steps(T* obj) { return Property<const int64_t>{
ARM GAS  /tmp/cc5nV8qb.s 			page 89


 256:./autogen/interfaces.hpp ****         template<typename T> static inline void get_steps(T* obj, void* ptr) { new (ptr) Property<c
 257:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_state(T* obj) { return Property<const O
 258:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_state(T* obj, void* ptr) { new (ptr) Pr
 259:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_requested_state(T* obj) { return Property<ODriv
 260:./autogen/interfaces.hpp ****         template<typename T> static inline void get_requested_state(T* obj, void* ptr) { new (ptr) 
 261:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_homed(T* obj) { return Property<bool>{&obj->
 262:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_homed(T* obj, void* ptr) { new (ptr) Propert
 263:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 264:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_motor(T* obj) { return &obj->motor_; }
 265:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_controller(T* obj) { return &obj->controller_; 
 266:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_encoder(T* obj) { return &obj->encoder_; }
 267:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_acim_estimator(T* obj) { return &obj->acim_esti
 268:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_sensorless_estimator(T* obj) { return &obj->sen
 269:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_trap_traj(T* obj) { return &obj->trap_traj_; }
 270:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_min_endstop(T* obj) { return &obj->min_endstop_
 271:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_endstop(T* obj) { return &obj->max_endstop_
 272:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_mechanical_brake(T* obj) { return &obj->mechani
 273:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_task_times(T* obj) { return &obj->task_times_; 
 274:./autogen/interfaces.hpp ****         virtual void watchdog_feed() = 0;
 275:./autogen/interfaces.hpp ****     };
 276:./autogen/interfaces.hpp ****     class ThermistorCurrentLimiterIntf {
 277:./autogen/interfaces.hpp ****     public:
 278:./autogen/interfaces.hpp ****     };
 279:./autogen/interfaces.hpp ****     class OnboardThermistorCurrentLimiterIntf {
 280:./autogen/interfaces.hpp ****     public:
 281:./autogen/interfaces.hpp ****         class ConfigIntf {
 282:./autogen/interfaces.hpp ****         public:
 283:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_lower(T* obj) { return Property<
 284:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_lower(T* obj, void* ptr) { new (
 285:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_upper(T* obj) { return Property<
 286:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_upper(T* obj, void* ptr) { new (
 287:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{&ob
 288:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
 289:./autogen/interfaces.hpp ****         };
 290:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_temperature(T* obj) { return Property<const flo
 291:./autogen/interfaces.hpp ****         template<typename T> static inline void get_temperature(T* obj, void* ptr) { new (ptr) Prop
 292:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 293:./autogen/interfaces.hpp ****     };
 294:./autogen/interfaces.hpp ****     class OffboardThermistorCurrentLimiterIntf {
 295:./autogen/interfaces.hpp ****     public:
 296:./autogen/interfaces.hpp ****         class ConfigIntf {
 297:./autogen/interfaces.hpp ****         public:
 298:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gpio_pin(T* obj) { return Property<uint16_t
 299:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gpio_pin(T* obj, void* ptr) { new (ptr) Pro
 300:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_0(T* obj) { return Propert
 301:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_0(T* obj, void* ptr) { new
 302:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_1(T* obj) { return Propert
 303:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_1(T* obj, void* ptr) { new
 304:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_2(T* obj) { return Propert
 305:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_2(T* obj, void* ptr) { new
 306:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_3(T* obj) { return Propert
 307:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_3(T* obj, void* ptr) { new
 308:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_lower(T* obj) { return Property<
 309:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_lower(T* obj, void* ptr) { new (
 310:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_upper(T* obj) { return Property<
 311:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_upper(T* obj, void* ptr) { new (
 312:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{&ob
ARM GAS  /tmp/cc5nV8qb.s 			page 90


 313:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
 314:./autogen/interfaces.hpp ****         };
 315:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_temperature(T* obj) { return Property<const flo
 316:./autogen/interfaces.hpp ****         template<typename T> static inline void get_temperature(T* obj, void* ptr) { new (ptr) Prop
 317:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 318:./autogen/interfaces.hpp ****     };
 319:./autogen/interfaces.hpp ****     class MotorIntf {
 320:./autogen/interfaces.hpp ****     public:
 321:./autogen/interfaces.hpp ****         class CurrentControlIntf {
 322:./autogen/interfaces.hpp ****         public:
 323:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_p_gain(T* obj) { return Property<const floa
 324:./autogen/interfaces.hpp ****             template<typename T> static inline void get_p_gain(T* obj, void* ptr) { new (ptr) Prope
 325:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_i_gain(T* obj) { return Property<const floa
 326:./autogen/interfaces.hpp ****             template<typename T> static inline void get_i_gain(T* obj, void* ptr) { new (ptr) Prope
 327:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_measured_report_filter_k(T* obj) { return
 328:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_measured_report_filter_k(T* obj, void* pt
 329:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Id_setpoint(T* obj) { return Property<const
 330:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Id_setpoint(T* obj, void* ptr) { new (ptr) 
 331:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Iq_setpoint(T* obj) { return Property<const
 332:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Iq_setpoint(T* obj, void* ptr) { new (ptr) 
 333:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Vd_setpoint(T* obj) { return Property<const
 334:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Vd_setpoint(T* obj, void* ptr) { new (ptr) 
 335:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Vq_setpoint(T* obj) { return Property<const
 336:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Vq_setpoint(T* obj, void* ptr) { new (ptr) 
 337:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase(T* obj) { return Property<const float
 338:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Proper
 339:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_vel(T* obj) { return Property<const f
 340:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_vel(T* obj, void* ptr) { new (ptr) Pr
 341:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Ialpha_measured(T* obj) { return Property<c
 342:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Ialpha_measured(T* obj, void* ptr) { new (p
 343:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Ibeta_measured(T* obj) { return Property<co
 344:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Ibeta_measured(T* obj, void* ptr) { new (pt
 345:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Id_measured(T* obj) { return Property<const
 346:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Id_measured(T* obj, void* ptr) { new (ptr) 
 347:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Iq_measured(T* obj) { return Property<const
 348:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Iq_measured(T* obj, void* ptr) { new (ptr) 
 349:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_power(T* obj) { return Property<const float
 350:./autogen/interfaces.hpp ****             template<typename T> static inline void get_power(T* obj, void* ptr) { new (ptr) Proper
 351:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_v_current_control_integral_d(T* obj) { retu
 352:./autogen/interfaces.hpp ****             template<typename T> static inline void get_v_current_control_integral_d(T* obj, void* 
 353:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_v_current_control_integral_q(T* obj) { retu
 354:./autogen/interfaces.hpp ****             template<typename T> static inline void get_v_current_control_integral_q(T* obj, void* 
 355:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_final_v_alpha(T* obj) { return Property<con
 356:./autogen/interfaces.hpp ****             template<typename T> static inline void get_final_v_alpha(T* obj, void* ptr) { new (ptr
 357:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_final_v_beta(T* obj) { return Property<cons
 358:./autogen/interfaces.hpp ****             template<typename T> static inline void get_final_v_beta(T* obj, void* ptr) { new (ptr)
 359:./autogen/interfaces.hpp ****         };
 360:./autogen/interfaces.hpp ****         class ConfigIntf {
 361:./autogen/interfaces.hpp ****         public:
 362:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bo
 363:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (pt
 364:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pole_pairs(T* obj) { return Property<int32_
 365:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pole_pairs(T* obj, void* ptr) { new (ptr) P
 366:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calibration_current(T* obj) { return Proper
 367:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calibration_current(T* obj, void* ptr) { ne
 368:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_resistance_calib_max_voltage(T* obj) { retu
 369:./autogen/interfaces.hpp ****             template<typename T> static inline void get_resistance_calib_max_voltage(T* obj, void* 
ARM GAS  /tmp/cc5nV8qb.s 			page 91


 370:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_inductance(T* obj) { return Property<
 371:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_inductance(T* obj, void* ptr) { new (
 372:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_resistance(T* obj) { return Property<
 373:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_resistance(T* obj, void* ptr) { new (
 374:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_constant(T* obj) { return Property<f
 375:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_constant(T* obj, void* ptr) { new (p
 376:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_type(T* obj) { return Property<ODrive
 377:./autogen/interfaces.hpp ****             template<typename T> static inline void get_motor_type(T* obj, void* ptr) { new (ptr) P
 378:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_lim(T* obj) { return Property<float
 379:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_lim(T* obj, void* ptr) { new (ptr) 
 380:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_lim_margin(T* obj) { return Propert
 381:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_lim_margin(T* obj, void* ptr) { new
 382:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_lim(T* obj) { return Property<float>
 383:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_lim(T* obj, void* ptr) { new (ptr) P
 384:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inverter_temp_limit_lower(T* obj) { return 
 385:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inverter_temp_limit_lower(T* obj, void* ptr
 386:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inverter_temp_limit_upper(T* obj) { return 
 387:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inverter_temp_limit_upper(T* obj, void* ptr
 388:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_requested_current_range(T* obj) { return Pr
 389:./autogen/interfaces.hpp ****             template<typename T> static inline void get_requested_current_range(T* obj, void* ptr) 
 390:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_control_bandwidth(T* obj) { return 
 391:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_control_bandwidth(T* obj, void* ptr
 392:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_gain_min_flux(T* obj) { return Propert
 393:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_gain_min_flux(T* obj, void* ptr) { new
 394:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_min_Id(T* obj) { return Prope
 395:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_min_Id(T* obj, void* ptr) { n
 396:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_enable(T* obj) { return Prope
 397:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_enable(T* obj, void* ptr) { n
 398:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_attack_gain(T* obj) { return 
 399:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_attack_gain(T* obj, void* ptr
 400:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_decay_gain(T* obj) { return P
 401:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_decay_gain(T* obj, void* ptr)
 402:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_R_wL_FF_enable(T* obj) { return Property<bo
 403:./autogen/interfaces.hpp ****             template<typename T> static inline void get_R_wL_FF_enable(T* obj, void* ptr) { new (pt
 404:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bEMF_FF_enable(T* obj) { return Property<bo
 405:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bEMF_FF_enable(T* obj, void* ptr) { new (pt
 406:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_bus_hard_min(T* obj) { return Property<fl
 407:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_bus_hard_min(T* obj, void* ptr) { new (pt
 408:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_bus_hard_max(T* obj) { return Property<fl
 409:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_bus_hard_max(T* obj, void* ptr) { new (pt
 410:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_leak_max(T* obj) { return Property<float>
 411:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_leak_max(T* obj, void* ptr) { new (ptr) P
 412:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dc_calib_tau(T* obj) { return Property<floa
 413:./autogen/interfaces.hpp ****             template<typename T> static inline void get_dc_calib_tau(T* obj, void* ptr) { new (ptr)
 414:./autogen/interfaces.hpp ****         };
 415:./autogen/interfaces.hpp ****         enum Error {
 416:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 417:./autogen/interfaces.hpp ****             ERROR_PHASE_RESISTANCE_OUT_OF_RANGE = 0x00000001,
 418:./autogen/interfaces.hpp ****             ERROR_PHASE_INDUCTANCE_OUT_OF_RANGE = 0x00000002,
 419:./autogen/interfaces.hpp ****             ERROR_DRV_FAULT                  = 0x00000008,
 420:./autogen/interfaces.hpp ****             ERROR_CONTROL_DEADLINE_MISSED    = 0x00000010,
 421:./autogen/interfaces.hpp ****             ERROR_MODULATION_MAGNITUDE       = 0x00000080,
 422:./autogen/interfaces.hpp ****             ERROR_CURRENT_SENSE_SATURATION   = 0x00000400,
 423:./autogen/interfaces.hpp ****             ERROR_CURRENT_LIMIT_VIOLATION    = 0x00001000,
 424:./autogen/interfaces.hpp ****             ERROR_MODULATION_IS_NAN          = 0x00010000,
 425:./autogen/interfaces.hpp ****             ERROR_MOTOR_THERMISTOR_OVER_TEMP = 0x00020000,
 426:./autogen/interfaces.hpp ****             ERROR_FET_THERMISTOR_OVER_TEMP   = 0x00040000,
ARM GAS  /tmp/cc5nV8qb.s 			page 92


 427:./autogen/interfaces.hpp ****             ERROR_TIMER_UPDATE_MISSED        = 0x00080000,
 428:./autogen/interfaces.hpp ****             ERROR_CURRENT_MEASUREMENT_UNAVAILABLE = 0x00100000,
 429:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_FAILED          = 0x00200000,
 430:./autogen/interfaces.hpp ****             ERROR_I_BUS_OUT_OF_RANGE         = 0x00400000,
 431:./autogen/interfaces.hpp ****             ERROR_BRAKE_RESISTOR_DISARMED    = 0x00800000,
 432:./autogen/interfaces.hpp ****             ERROR_SYSTEM_LEVEL               = 0x01000000,
 433:./autogen/interfaces.hpp ****             ERROR_BAD_TIMING                 = 0x02000000,
 434:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_PHASE_ESTIMATE     = 0x04000000,
 435:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_PHASE_VEL          = 0x08000000,
 436:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_TORQUE             = 0x10000000,
 437:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_COMMAND    = 0x20000000,
 438:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x40000000,
 439:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_VBUS_VOLTAGE       = 0x80000000,
 440:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_VOLTAGE_COMMAND    = 0x100000000,
 441:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_GAINS              = 0x200000000,
 442:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_INITIALIZING    = 0x400000000,
 443:./autogen/interfaces.hpp ****             ERROR_UNBALANCED_PHASES          = 0x800000000,
 444:./autogen/interfaces.hpp ****         };
 445:./autogen/interfaces.hpp ****         enum MotorType {
 446:./autogen/interfaces.hpp ****             MOTOR_TYPE_HIGH_CURRENT          = 0,
 447:./autogen/interfaces.hpp ****             MOTOR_TYPE_GIMBAL                = 2,
 448:./autogen/interfaces.hpp ****             MOTOR_TYPE_ACIM                  = 3,
 449:./autogen/interfaces.hpp ****         };
 450:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_error_time(T* obj) { return Property<float
 451:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_error_time(T* obj, void* ptr) { new (ptr) 
 452:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Mot
 453:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 454:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_armed(T* obj) { return Property<const bool>{
 455:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_armed(T* obj, void* ptr) { new (ptr) Propert
 456:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_calibrated(T* obj) { return Property<const b
 457:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_calibrated(T* obj, void* ptr) { new (ptr) Pr
 458:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phA(T* obj) { return Property<cons
 459:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phA(T* obj, void* ptr) { new (ptr)
 460:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phB(T* obj) { return Property<cons
 461:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phB(T* obj, void* ptr) { new (ptr)
 462:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phC(T* obj) { return Property<cons
 463:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phC(T* obj, void* ptr) { new (ptr)
 464:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phA(T* obj) { return Property<float>{&
 465:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phA(T* obj, void* ptr) { new (ptr) Pro
 466:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phB(T* obj) { return Property<float>{&
 467:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phB(T* obj, void* ptr) { new (ptr) Pro
 468:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phC(T* obj) { return Property<float>{&
 469:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phC(T* obj, void* ptr) { new (ptr) Pro
 470:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_I_bus(T* obj) { return Property<const float>{&o
 471:./autogen/interfaces.hpp ****         template<typename T> static inline void get_I_bus(T* obj, void* ptr) { new (ptr) Property<c
 472:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_current_rev_gain(T* obj) { return Propert
 473:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_current_rev_gain(T* obj, void* ptr) { new
 474:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_effective_current_lim(T* obj) { return Property
 475:./autogen/interfaces.hpp ****         template<typename T> static inline void get_effective_current_lim(T* obj, void* ptr) { new 
 476:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_allowed_current(T* obj) { return Property<c
 477:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_allowed_current(T* obj, void* ptr) { new (p
 478:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_dc_calib(T* obj) { return Property<const fl
 479:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_dc_calib(T* obj, void* ptr) { new (ptr) Pro
 480:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_fet_thermistor(T* obj) { return &obj->fet_therm
 481:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_motor_thermistor(T* obj) { return &obj->motor_t
 482:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_control(T* obj) { return &obj->current_
 483:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_n_evt_current_measurement(T* obj) { return Prop
ARM GAS  /tmp/cc5nV8qb.s 			page 93


 484:./autogen/interfaces.hpp ****         template<typename T> static inline void get_n_evt_current_measurement(T* obj, void* ptr) { 
 485:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_n_evt_pwm_update(T* obj) { return Property<cons
 486:./autogen/interfaces.hpp ****         template<typename T> static inline void get_n_evt_pwm_update(T* obj, void* ptr) { new (ptr)
 487:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 488:./autogen/interfaces.hpp ****     };
 489:./autogen/interfaces.hpp ****     class OscilloscopeIntf {
 490:./autogen/interfaces.hpp ****     public:
 491:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_size(T* obj) { return Property<const uint32_t>{
 492:./autogen/interfaces.hpp ****         template<typename T> static inline void get_size(T* obj, void* ptr) { new (ptr) Property<co
 493:./autogen/interfaces.hpp ****         virtual float get_val(uint32_t index) = 0;
 494:./autogen/interfaces.hpp ****         uint32_t get_val_in_index_; // for internal use by Fibre
 495:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_val_in_index_(T* obj) { return Property<uint32_t>{
 496:./autogen/interfaces.hpp ****         template<typename T> static void get_get_val_in_index_(T* obj, void* ptr) { new (ptr) Prope
 497:./autogen/interfaces.hpp ****         float get_val_out_val_; // for internal use by Fibre
 498:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_val_out_val_(T* obj) { return Property<const float
 499:./autogen/interfaces.hpp ****         template<typename T> static void get_get_val_out_val_(T* obj, void* ptr) { new (ptr) Proper
 500:./autogen/interfaces.hpp ****     };
 501:./autogen/interfaces.hpp ****     class AcimEstimatorIntf {
 502:./autogen/interfaces.hpp ****     public:
 503:./autogen/interfaces.hpp ****         class ConfigIntf {
 504:./autogen/interfaces.hpp ****         public:
 505:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_slip_velocity(T* obj) { return Property<flo
 506:./autogen/interfaces.hpp ****             template<typename T> static inline void get_slip_velocity(T* obj, void* ptr) { new (ptr
 507:./autogen/interfaces.hpp ****         };
 508:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_rotor_flux(T* obj) { return Property<const floa
 509:./autogen/interfaces.hpp ****         template<typename T> static inline void get_rotor_flux(T* obj, void* ptr) { new (ptr) Prope
 510:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_slip_vel(T* obj) { return Property<const float>
 511:./autogen/interfaces.hpp ****         template<typename T> static inline void get_slip_vel(T* obj, void* ptr) { new (ptr) Propert
 512:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_offset(T* obj) { return Property<const fl
 513:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_offset(T* obj, void* ptr) { new (ptr) Pro
 514:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stator_phase_vel(T* obj) { return Property<cons
 515:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stator_phase_vel(T* obj, void* ptr) { new (ptr)
 516:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stator_phase(T* obj) { return Property<const fl
 517:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stator_phase(T* obj, void* ptr) { new (ptr) Pro
 518:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 519:./autogen/interfaces.hpp ****     };
 520:./autogen/interfaces.hpp ****     class ControllerIntf {
 521:./autogen/interfaces.hpp ****     public:
 522:./autogen/interfaces.hpp ****         class ConfigIntf {
 523:./autogen/interfaces.hpp ****         public:
 524:./autogen/interfaces.hpp ****             class AnticoggingIntf {
 525:./autogen/interfaces.hpp ****             public:
 526:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_index(T* obj) { return Property<const u
 527:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_index(T* obj, void* ptr) { new (ptr) Pr
 528:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_pre_calibrated(T* obj) { return Propert
 529:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new
 530:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_anticogging(T* obj) { return Prop
 531:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_anticogging(T* obj, void* ptr) { 
 532:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_pos_threshold(T* obj) { return Pr
 533:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_pos_threshold(T* obj, void* ptr) 
 534:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_vel_threshold(T* obj) { return Pr
 535:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_vel_threshold(T* obj, void* ptr) 
 536:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_cogging_ratio(T* obj) { return Property
 537:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_cogging_ratio(T* obj, void* ptr) { new 
 538:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_anticogging_enabled(T* obj) { return Pr
 539:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_anticogging_enabled(T* obj, void* ptr) 
 540:./autogen/interfaces.hpp ****             };
ARM GAS  /tmp/cc5nV8qb.s 			page 94


 541:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gain_scheduling_width(T* obj) { return Prop
 542:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gain_scheduling_width(T* obj, void* ptr) { 
 543:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_vel_limit(T* obj) { return Property<
 544:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_vel_limit(T* obj, void* ptr) { new (
 545:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_torque_mode_vel_limit(T* obj) { retu
 546:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_torque_mode_vel_limit(T* obj, void* 
 547:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_gain_scheduling(T* obj) { return Pro
 548:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_gain_scheduling(T* obj, void* ptr) {
 549:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_overspeed_error(T* obj) { return Pro
 550:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_overspeed_error(T* obj, void* ptr) {
 551:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_control_mode(T* obj) { return Property<ODri
 552:./autogen/interfaces.hpp ****             template<typename T> static inline void get_control_mode(T* obj, void* ptr) { new (ptr)
 553:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_input_mode(T* obj) { return Property<ODrive
 554:./autogen/interfaces.hpp ****             template<typename T> static inline void get_input_mode(T* obj, void* ptr) { new (ptr) P
 555:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pos_gain(T* obj) { return Property<float>{&
 556:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pos_gain(T* obj, void* ptr) { new (ptr) Pro
 557:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_gain(T* obj) { return Property<float>{&
 558:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_gain(T* obj, void* ptr) { new (ptr) Pro
 559:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_integrator_gain(T* obj) { return Proper
 560:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_integrator_gain(T* obj, void* ptr) { ne
 561:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_integrator_limit(T* obj) { return Prope
 562:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_integrator_limit(T* obj, void* ptr) { n
 563:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit(T* obj) { return Property<float>{
 564:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit(T* obj, void* ptr) { new (ptr) Pr
 565:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit_tolerance(T* obj) { return Proper
 566:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit_tolerance(T* obj, void* ptr) { ne
 567:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_ramp_rate(T* obj) { return Property<flo
 568:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_ramp_rate(T* obj, void* ptr) { new (ptr
 569:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_ramp_rate(T* obj) { return Property<
 570:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_ramp_rate(T* obj, void* ptr) { new (
 571:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_circular_setpoints(T* obj) { return Propert
 572:./autogen/interfaces.hpp ****             template<typename T> static inline void get_circular_setpoints(T* obj, void* ptr) { new
 573:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_circular_setpoint_range(T* obj) { return Pr
 574:./autogen/interfaces.hpp ****             template<typename T> static inline void get_circular_setpoint_range(T* obj, void* ptr) 
 575:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_steps_per_circular_range(T* obj) { return P
 576:./autogen/interfaces.hpp ****             template<typename T> static inline void get_steps_per_circular_range(T* obj, void* ptr)
 577:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_homing_speed(T* obj) { return Property<floa
 578:./autogen/interfaces.hpp ****             template<typename T> static inline void get_homing_speed(T* obj, void* ptr) { new (ptr)
 579:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inertia(T* obj) { return Property<float>{&o
 580:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inertia(T* obj, void* ptr) { new (ptr) Prop
 581:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_axis_to_mirror(T* obj) { return Property<ui
 582:./autogen/interfaces.hpp ****             template<typename T> static inline void get_axis_to_mirror(T* obj, void* ptr) { new (pt
 583:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mirror_ratio(T* obj) { return Property<floa
 584:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mirror_ratio(T* obj, void* ptr) { new (ptr)
 585:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_mirror_ratio(T* obj) { return Proper
 586:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_mirror_ratio(T* obj, void* ptr) { ne
 587:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_load_encoder_axis(T* obj) { return Property
 588:./autogen/interfaces.hpp ****             template<typename T> static inline void get_load_encoder_axis(T* obj, void* ptr) { new 
 589:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_input_filter_bandwidth(T* obj) { return Pro
 590:./autogen/interfaces.hpp ****             template<typename T> static inline void get_input_filter_bandwidth(T* obj, void* ptr) {
 591:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_anticogging(T* obj) { return &obj->anticogg
 592:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mechanical_power_bandwidth(T* obj) { return
 593:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mechanical_power_bandwidth(T* obj, void* pt
 594:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_electrical_power_bandwidth(T* obj) { return
 595:./autogen/interfaces.hpp ****             template<typename T> static inline void get_electrical_power_bandwidth(T* obj, void* pt
 596:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_spinout_mechanical_power_threshold(T* obj) 
 597:./autogen/interfaces.hpp ****             template<typename T> static inline void get_spinout_mechanical_power_threshold(T* obj, 
ARM GAS  /tmp/cc5nV8qb.s 			page 95


 598:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_spinout_electrical_power_threshold(T* obj) 
 599:./autogen/interfaces.hpp ****             template<typename T> static inline void get_spinout_electrical_power_threshold(T* obj, 
 600:./autogen/interfaces.hpp ****         };
 601:./autogen/interfaces.hpp ****         class AutotuningIntf {
 602:./autogen/interfaces.hpp ****         public:
 603:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_frequency(T* obj) { return Property<float>{
 604:./autogen/interfaces.hpp ****             template<typename T> static inline void get_frequency(T* obj, void* ptr) { new (ptr) Pr
 605:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pos_amplitude(T* obj) { return Property<flo
 606:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pos_amplitude(T* obj, void* ptr) { new (ptr
 607:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_amplitude(T* obj) { return Property<flo
 608:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_amplitude(T* obj, void* ptr) { new (ptr
 609:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_amplitude(T* obj) { return Property<
 610:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_amplitude(T* obj, void* ptr) { new (
 611:./autogen/interfaces.hpp ****         };
 612:./autogen/interfaces.hpp ****         enum Error {
 613:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 614:./autogen/interfaces.hpp ****             ERROR_OVERSPEED                  = 0x00000001,
 615:./autogen/interfaces.hpp ****             ERROR_INVALID_INPUT_MODE         = 0x00000002,
 616:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000004,
 617:./autogen/interfaces.hpp ****             ERROR_INVALID_MIRROR_AXIS        = 0x00000008,
 618:./autogen/interfaces.hpp ****             ERROR_INVALID_LOAD_ENCODER       = 0x00000010,
 619:./autogen/interfaces.hpp ****             ERROR_INVALID_ESTIMATE           = 0x00000020,
 620:./autogen/interfaces.hpp ****             ERROR_INVALID_CIRCULAR_RANGE     = 0x00000040,
 621:./autogen/interfaces.hpp ****             ERROR_SPINOUT_DETECTED           = 0x00000080,
 622:./autogen/interfaces.hpp ****         };
 623:./autogen/interfaces.hpp ****         enum ControlMode {
 624:./autogen/interfaces.hpp ****             CONTROL_MODE_VOLTAGE_CONTROL     = 0,
 625:./autogen/interfaces.hpp ****             CONTROL_MODE_TORQUE_CONTROL      = 1,
 626:./autogen/interfaces.hpp ****             CONTROL_MODE_VELOCITY_CONTROL    = 2,
 627:./autogen/interfaces.hpp ****             CONTROL_MODE_POSITION_CONTROL    = 3,
 628:./autogen/interfaces.hpp ****         };
 629:./autogen/interfaces.hpp ****         enum InputMode {
 630:./autogen/interfaces.hpp ****             INPUT_MODE_INACTIVE              = 0,
 631:./autogen/interfaces.hpp ****             INPUT_MODE_PASSTHROUGH           = 1,
 632:./autogen/interfaces.hpp ****             INPUT_MODE_VEL_RAMP              = 2,
 633:./autogen/interfaces.hpp ****             INPUT_MODE_POS_FILTER            = 3,
 634:./autogen/interfaces.hpp ****             INPUT_MODE_MIX_CHANNELS          = 4,
 635:./autogen/interfaces.hpp ****             INPUT_MODE_TRAP_TRAJ             = 5,
 636:./autogen/interfaces.hpp ****             INPUT_MODE_TORQUE_RAMP           = 6,
 637:./autogen/interfaces.hpp ****             INPUT_MODE_MIRROR                = 7,
 638:./autogen/interfaces.hpp ****             INPUT_MODE_TUNING                = 8,
 639:./autogen/interfaces.hpp ****         };
 640:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Con
 641:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 642:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_error_time(T* obj) { return Property<float
 643:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_error_time(T* obj, void* ptr) { new (ptr) 
 644:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_pos(T* obj) { return Property<float>{obj,
 645:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_pos(T* obj, void* ptr) { new (ptr) Proper
 646:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_vel(T* obj) { return Property<float>{&obj
 647:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_vel(T* obj, void* ptr) { new (ptr) Proper
 648:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_torque(T* obj) { return Property<float>{&
 649:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_torque(T* obj, void* ptr) { new (ptr) Pro
 650:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_setpoint(T* obj) { return Property<const fl
 651:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_setpoint(T* obj, void* ptr) { new (ptr) Pro
 652:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_setpoint(T* obj) { return Property<const fl
 653:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_setpoint(T* obj, void* ptr) { new (ptr) Pro
 654:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_torque_setpoint(T* obj) { return Property<const
ARM GAS  /tmp/cc5nV8qb.s 			page 96


 655:./autogen/interfaces.hpp ****         template<typename T> static inline void get_torque_setpoint(T* obj, void* ptr) { new (ptr) 
 656:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_trajectory_done(T* obj) { return Property<const
 657:./autogen/interfaces.hpp ****         template<typename T> static inline void get_trajectory_done(T* obj, void* ptr) { new (ptr) 
 658:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_integrator_torque(T* obj) { return Property
 659:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_integrator_torque(T* obj, void* ptr) { new 
 660:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_anticogging_valid(T* obj) { return Property<boo
 661:./autogen/interfaces.hpp ****         template<typename T> static inline void get_anticogging_valid(T* obj, void* ptr) { new (ptr
 662:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_autotuning_phase(T* obj) { return Property<floa
 663:./autogen/interfaces.hpp ****         template<typename T> static inline void get_autotuning_phase(T* obj, void* ptr) { new (ptr)
 664:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 665:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_autotuning(T* obj) { return &obj->autotuning_; 
 666:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_mechanical_power(T* obj) { return Property<cons
 667:./autogen/interfaces.hpp ****         template<typename T> static inline void get_mechanical_power(T* obj, void* ptr) { new (ptr)
 668:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_electrical_power(T* obj) { return Property<cons
 669:./autogen/interfaces.hpp ****         template<typename T> static inline void get_electrical_power(T* obj, void* ptr) { new (ptr)
 670:./autogen/interfaces.hpp ****         virtual void move_incremental(float displacement, bool from_input_pos) = 0;
 671:./autogen/interfaces.hpp ****         virtual void start_anticogging_calibration() = 0;
 672:./autogen/interfaces.hpp ****         virtual float remove_anticogging_bias() = 0;
 673:./autogen/interfaces.hpp ****         virtual float get_anticogging_value(uint32_t index) = 0;
 674:./autogen/interfaces.hpp ****         float move_incremental_in_displacement_; // for internal use by Fibre
 675:./autogen/interfaces.hpp ****         template<typename T> static auto get_move_incremental_in_displacement_(T* obj) { return Pro
 676:./autogen/interfaces.hpp ****         template<typename T> static void get_move_incremental_in_displacement_(T* obj, void* ptr) {
 677:./autogen/interfaces.hpp ****         bool move_incremental_in_from_input_pos_; // for internal use by Fibre
 678:./autogen/interfaces.hpp ****         template<typename T> static auto get_move_incremental_in_from_input_pos_(T* obj) { return P
 679:./autogen/interfaces.hpp ****         template<typename T> static void get_move_incremental_in_from_input_pos_(T* obj, void* ptr)
 680:./autogen/interfaces.hpp ****         float remove_anticogging_bias_out_val_; // for internal use by Fibre
 681:./autogen/interfaces.hpp ****         template<typename T> static auto get_remove_anticogging_bias_out_val_(T* obj) { return Prop
 682:./autogen/interfaces.hpp ****         template<typename T> static void get_remove_anticogging_bias_out_val_(T* obj, void* ptr) { 
 683:./autogen/interfaces.hpp ****         uint32_t get_anticogging_value_in_index_; // for internal use by Fibre
 684:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_anticogging_value_in_index_(T* obj) { return Prope
 685:./autogen/interfaces.hpp ****         template<typename T> static void get_get_anticogging_value_in_index_(T* obj, void* ptr) { n
 686:./autogen/interfaces.hpp ****         float get_anticogging_value_out_val_; // for internal use by Fibre
 687:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_anticogging_value_out_val_(T* obj) { return Proper
 688:./autogen/interfaces.hpp ****         template<typename T> static void get_get_anticogging_value_out_val_(T* obj, void* ptr) { ne
 689:./autogen/interfaces.hpp ****     };
 690:./autogen/interfaces.hpp ****     class EncoderIntf {
 691:./autogen/interfaces.hpp ****     public:
 692:./autogen/interfaces.hpp ****         class ConfigIntf {
 693:./autogen/interfaces.hpp ****         public:
 694:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mode(T* obj) { return Property<ODriveIntf::
 695:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mode(T* obj, void* ptr) { new (ptr) Propert
 696:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_use_index(T* obj) { return Property<bool>{o
 697:./autogen/interfaces.hpp ****             template<typename T> static inline void get_use_index(T* obj, void* ptr) { new (ptr) Pr
 698:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_index_offset(T* obj) { return Property<floa
 699:./autogen/interfaces.hpp ****             template<typename T> static inline void get_index_offset(T* obj, void* ptr) { new (ptr)
 700:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_use_index_offset(T* obj) { return Property<
 701:./autogen/interfaces.hpp ****             template<typename T> static inline void get_use_index_offset(T* obj, void* ptr) { new (
 702:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_find_idx_on_lockin_only(T* obj) { return Pr
 703:./autogen/interfaces.hpp ****             template<typename T> static inline void get_find_idx_on_lockin_only(T* obj, void* ptr) 
 704:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_abs_spi_cs_gpio_pin(T* obj) { return Proper
 705:./autogen/interfaces.hpp ****             template<typename T> static inline void get_abs_spi_cs_gpio_pin(T* obj, void* ptr) { ne
 706:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_cpr(T* obj) { return Property<int32_t>{&obj
 707:./autogen/interfaces.hpp ****             template<typename T> static inline void get_cpr(T* obj, void* ptr) { new (ptr) Property
 708:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_offset(T* obj) { return Property<int3
 709:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_offset(T* obj, void* ptr) { new (ptr)
 710:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_offset_float(T* obj) { return Propert
 711:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_offset_float(T* obj, void* ptr) { new
ARM GAS  /tmp/cc5nV8qb.s 			page 97


 712:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_direction(T* obj) { return Property<int32_t
 713:./autogen/interfaces.hpp ****             template<typename T> static inline void get_direction(T* obj, void* ptr) { new (ptr) Pr
 714:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bo
 715:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (pt
 716:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_phase_interpolation(T* obj) { return
 717:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_phase_interpolation(T* obj, void* pt
 718:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bandwidth(T* obj) { return Property<float>{
 719:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bandwidth(T* obj, void* ptr) { new (ptr) Pr
 720:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_range(T* obj) { return Property<float
 721:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_range(T* obj, void* ptr) { new (ptr) 
 722:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_scan_distance(T* obj) { return Proper
 723:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_scan_distance(T* obj, void* ptr) { ne
 724:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_scan_omega(T* obj) { return Property<
 725:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_scan_omega(T* obj, void* ptr) { new (
 726:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ignore_illegal_hall_state(T* obj) { return 
 727:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ignore_illegal_hall_state(T* obj, void* ptr
 728:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_hall_polarity(T* obj) { return Property<uin
 729:./autogen/interfaces.hpp ****             template<typename T> static inline void get_hall_polarity(T* obj, void* ptr) { new (ptr
 730:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_hall_polarity_calibrated(T* obj) { return P
 731:./autogen/interfaces.hpp ****             template<typename T> static inline void get_hall_polarity_calibrated(T* obj, void* ptr)
 732:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sincos_gpio_pin_sin(T* obj) { return Proper
 733:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sincos_gpio_pin_sin(T* obj, void* ptr) { ne
 734:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sincos_gpio_pin_cos(T* obj) { return Proper
 735:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sincos_gpio_pin_cos(T* obj, void* ptr) { ne
 736:./autogen/interfaces.hpp ****         };
 737:./autogen/interfaces.hpp ****         enum Error {
 738:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 739:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000001,
 740:./autogen/interfaces.hpp ****             ERROR_CPR_POLEPAIRS_MISMATCH     = 0x00000002,
 741:./autogen/interfaces.hpp ****             ERROR_NO_RESPONSE                = 0x00000004,
 742:./autogen/interfaces.hpp ****             ERROR_UNSUPPORTED_ENCODER_MODE   = 0x00000008,
 743:./autogen/interfaces.hpp ****             ERROR_ILLEGAL_HALL_STATE         = 0x00000010,
 744:./autogen/interfaces.hpp ****             ERROR_INDEX_NOT_FOUND_YET        = 0x00000020,
 745:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_TIMEOUT            = 0x00000040,
 746:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_COM_FAIL           = 0x00000080,
 747:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_NOT_READY          = 0x00000100,
 748:./autogen/interfaces.hpp ****             ERROR_HALL_NOT_CALIBRATED_YET    = 0x00000200,
 749:./autogen/interfaces.hpp ****         };
 750:./autogen/interfaces.hpp ****         enum Mode {
 751:./autogen/interfaces.hpp ****             MODE_INCREMENTAL                 = 0,
 752:./autogen/interfaces.hpp ****             MODE_HALL                        = 1,
 753:./autogen/interfaces.hpp ****             MODE_SINCOS                      = 2,
 754:./autogen/interfaces.hpp ****             MODE_SPI_ABS_CUI                 = 256,
 755:./autogen/interfaces.hpp ****             MODE_SPI_ABS_AMS                 = 257,
 756:./autogen/interfaces.hpp ****             MODE_SPI_ABS_AEAT                = 258,
 757:./autogen/interfaces.hpp ****             MODE_SPI_ABS_RLS                 = 259,
 758:./autogen/interfaces.hpp ****             MODE_SPI_ABS_MA732               = 260,
 759:./autogen/interfaces.hpp ****         };
 760:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Enc
 761:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 762:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_ready(T* obj) { return Property<const bool>{
 763:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_ready(T* obj, void* ptr) { new (ptr) Propert
 764:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_index_found(T* obj) { return Property<const boo
 765:./autogen/interfaces.hpp ****         template<typename T> static inline void get_index_found(T* obj, void* ptr) { new (ptr) Prop
 766:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_shadow_count(T* obj) { return Property<const in
 767:./autogen/interfaces.hpp ****         template<typename T> static inline void get_shadow_count(T* obj, void* ptr) { new (ptr) Pro
 768:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_count_in_cpr(T* obj) { return Property<const in
ARM GAS  /tmp/cc5nV8qb.s 			page 98


 769:./autogen/interfaces.hpp ****         template<typename T> static inline void get_count_in_cpr(T* obj, void* ptr) { new (ptr) Pro
 770:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_interpolation(T* obj) { return Property<const f
 771:./autogen/interfaces.hpp ****         template<typename T> static inline void get_interpolation(T* obj, void* ptr) { new (ptr) Pr
 772:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase(T* obj) { return Property<const float>{ob
 773:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<c
 774:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_estimate(T* obj) { return Property<const fl
 775:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_estimate(T* obj, void* ptr) { new (ptr) Pro
 776:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_estimate_counts(T* obj) { return Property<c
 777:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_estimate_counts(T* obj, void* ptr) { new (p
 778:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_circular(T* obj) { return Property<const fl
 779:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_circular(T* obj, void* ptr) { new (ptr) Pro
 780:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_cpr_counts(T* obj) { return Property<const 
 781:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_cpr_counts(T* obj, void* ptr) { new (ptr) P
 782:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_delta_pos_cpr_counts(T* obj) { return Property<
 783:./autogen/interfaces.hpp ****         template<typename T> static inline void get_delta_pos_cpr_counts(T* obj, void* ptr) { new (
 784:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_hall_state(T* obj) { return Property<const uint
 785:./autogen/interfaces.hpp ****         template<typename T> static inline void get_hall_state(T* obj, void* ptr) { new (ptr) Prope
 786:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate(T* obj) { return Property<const fl
 787:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate(T* obj, void* ptr) { new (ptr) Pro
 788:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate_counts(T* obj) { return Property<c
 789:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate_counts(T* obj, void* ptr) { new (p
 790:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_calib_scan_response(T* obj) { return Property<c
 791:./autogen/interfaces.hpp ****         template<typename T> static inline void get_calib_scan_response(T* obj, void* ptr) { new (p
 792:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_abs(T* obj) { return Property<int32_t>{&obj
 793:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_abs(T* obj, void* ptr) { new (ptr) Property
 794:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_spi_error_rate(T* obj) { return Property<const 
 795:./autogen/interfaces.hpp ****         template<typename T> static inline void get_spi_error_rate(T* obj, void* ptr) { new (ptr) P
 796:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 797:./autogen/interfaces.hpp ****         virtual void set_linear_count(int32_t count) = 0;
 798:./autogen/interfaces.hpp ****         int32_t set_linear_count_in_count_; // for internal use by Fibre
 799:./autogen/interfaces.hpp ****         template<typename T> static auto get_set_linear_count_in_count_(T* obj) { return Property<i
 800:./autogen/interfaces.hpp ****         template<typename T> static void get_set_linear_count_in_count_(T* obj, void* ptr) { new (p
 801:./autogen/interfaces.hpp ****     };
 802:./autogen/interfaces.hpp ****     class SensorlessEstimatorIntf {
 803:./autogen/interfaces.hpp ****     public:
 804:./autogen/interfaces.hpp ****         class ConfigIntf {
 805:./autogen/interfaces.hpp ****         public:
 806:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_observer_gain(T* obj) { return Property<flo
 807:./autogen/interfaces.hpp ****             template<typename T> static inline void get_observer_gain(T* obj, void* ptr) { new (ptr
 808:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pll_bandwidth(T* obj) { return Property<flo
 809:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pll_bandwidth(T* obj, void* ptr) { new (ptr
 810:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pm_flux_linkage(T* obj) { return Property<f
 811:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pm_flux_linkage(T* obj, void* ptr) { new (p
 812:./autogen/interfaces.hpp ****         };
 813:./autogen/interfaces.hpp ****         enum Error {
 814:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 815:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000001,
 816:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x00000002,
 817:./autogen/interfaces.hpp ****         };
 818:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Sen
 819:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 820:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase(T* obj) { return Property<const float>{ob
 821:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<c
 822:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pll_pos(T* obj) { return Property<const float>{
 823:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pll_pos(T* obj, void* ptr) { new (ptr) Property
 824:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_vel(T* obj) { return Property<const float
 825:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_vel(T* obj, void* ptr) { new (ptr) Proper
ARM GAS  /tmp/cc5nV8qb.s 			page 99


 826:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate(T* obj) { return Property<const fl
 827:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate(T* obj, void* ptr) { new (ptr) Pro
 828:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 829:./autogen/interfaces.hpp ****     };
 830:./autogen/interfaces.hpp ****     class TrapezoidalTrajectoryIntf {
 831:./autogen/interfaces.hpp ****     public:
 832:./autogen/interfaces.hpp ****         class ConfigIntf {
 833:./autogen/interfaces.hpp ****         public:
 834:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit(T* obj) { return Property<float>{
 835:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit(T* obj, void* ptr) { new (ptr) Pr
 836:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_accel_limit(T* obj) { return Property<float
 837:./autogen/interfaces.hpp ****             template<typename T> static inline void get_accel_limit(T* obj, void* ptr) { new (ptr) 
 838:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_decel_limit(T* obj) { return Property<float
 839:./autogen/interfaces.hpp ****             template<typename T> static inline void get_decel_limit(T* obj, void* ptr) { new (ptr) 
 840:./autogen/interfaces.hpp ****         };
 841:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 842:./autogen/interfaces.hpp ****     };
 843:./autogen/interfaces.hpp ****     class EndstopIntf {
 844:./autogen/interfaces.hpp ****     public:
 845:./autogen/interfaces.hpp ****         class ConfigIntf {
 846:./autogen/interfaces.hpp ****         public:
 847:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gpio_num(T* obj) { return Property<uint16_t
 848:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gpio_num(T* obj, void* ptr) { new (ptr) Pro
 849:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{obj
 850:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
 851:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_offset(T* obj) { return Property<float>{&ob
 852:./autogen/interfaces.hpp ****             template<typename T> static inline void get_offset(T* obj, void* ptr) { new (ptr) Prope
 853:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_is_active_high(T* obj) { return Property<bo
 854:./autogen/interfaces.hpp ****             template<typename T> static inline void get_is_active_high(T* obj, void* ptr) { new (pt
 855:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_debounce_ms(T* obj) { return Property<uint3
 856:./autogen/interfaces.hpp ****             template<typename T> static inline void get_debounce_ms(T* obj, void* ptr) { new (ptr) 
 857:./autogen/interfaces.hpp ****         };
 858:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_endstop_state(T* obj) { return Property<const b
 859:./autogen/interfaces.hpp ****         template<typename T> static inline void get_endstop_state(T* obj, void* ptr) { new (ptr) Pr
 860:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 861:./autogen/interfaces.hpp ****     };
 862:./autogen/interfaces.hpp ****     class MechanicalBrakeIntf {
 863:./autogen/interfaces.hpp ****     public:
 864:./autogen/interfaces.hpp ****         class ConfigIntf {
 865:./autogen/interfaces.hpp ****         public:
 866:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gpio_num(T* obj) { return Property<uint16_t
 867:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gpio_num(T* obj, void* ptr) { new (ptr) Pro
 868:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_is_active_low(T* obj) { return Property<boo
 869:./autogen/interfaces.hpp ****             template<typename T> static inline void get_is_active_low(T* obj, void* ptr) { new (ptr
 870:./autogen/interfaces.hpp ****         };
 871:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 872:./autogen/interfaces.hpp ****         virtual void engage() = 0;
 873:./autogen/interfaces.hpp ****         virtual void release() = 0;
 874:./autogen/interfaces.hpp ****     };
 875:./autogen/interfaces.hpp ****     class TaskTimerIntf {
 876:./autogen/interfaces.hpp ****     public:
 877:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_start_time(T* obj) { return Property<const uint
 878:./autogen/interfaces.hpp ****         template<typename T> static inline void get_start_time(T* obj, void* ptr) { new (ptr) Prope
 879:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_end_time(T* obj) { return Property<const uint32
 880:./autogen/interfaces.hpp ****         template<typename T> static inline void get_end_time(T* obj, void* ptr) { new (ptr) Propert
 881:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_length(T* obj) { return Property<const uint32_t
 882:./autogen/interfaces.hpp ****         template<typename T> static inline void get_length(T* obj, void* ptr) { new (ptr) Property<
ARM GAS  /tmp/cc5nV8qb.s 			page 100


 883:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_length(T* obj) { return Property<uint32_t>{
 884:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_length(T* obj, void* ptr) { new (ptr) Prope
 885:./autogen/interfaces.hpp ****     };
 886:./autogen/interfaces.hpp ****     class TaskTimesIntf {
 887:./autogen/interfaces.hpp ****     public:
 888:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_sampling(T* obj) { return &obj->sampling; }
 889:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_control_loop_misc(T* obj) { return &obj->contro
 890:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_control_loop_checks(T* obj) { return &obj->cont
 891:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_calib_wait(T* obj) { return &obj->dc_calib_w
 892:./autogen/interfaces.hpp ****     };
 893:./autogen/interfaces.hpp ****     class SystemStatsIntf {
 894:./autogen/interfaces.hpp ****     public:
 895:./autogen/interfaces.hpp ****         class UsbIntf {
 896:./autogen/interfaces.hpp ****         public:
 897:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_rx_cnt(T* obj) { return Property<const uint
 898:./autogen/interfaces.hpp ****             template<typename T> static inline void get_rx_cnt(T* obj, void* ptr) { new (ptr) Prope
 899:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_tx_cnt(T* obj) { return Property<const uint
 900:./autogen/interfaces.hpp ****             template<typename T> static inline void get_tx_cnt(T* obj, void* ptr) { new (ptr) Prope
 901:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_tx_overrun_cnt(T* obj) { return Property<co
 902:./autogen/interfaces.hpp ****             template<typename T> static inline void get_tx_overrun_cnt(T* obj, void* ptr) { new (pt
 903:./autogen/interfaces.hpp ****         };
 904:./autogen/interfaces.hpp ****         class I2CIntf {
 905:./autogen/interfaces.hpp ****         public:
 906:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_addr(T* obj) { return Property<const uint8_
 907:./autogen/interfaces.hpp ****             template<typename T> static inline void get_addr(T* obj, void* ptr) { new (ptr) Propert
 908:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_addr_match_cnt(T* obj) { return Property<co
 909:./autogen/interfaces.hpp ****             template<typename T> static inline void get_addr_match_cnt(T* obj, void* ptr) { new (pt
 910:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_rx_cnt(T* obj) { return Property<const uint
 911:./autogen/interfaces.hpp ****             template<typename T> static inline void get_rx_cnt(T* obj, void* ptr) { new (ptr) Prope
 912:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_error_cnt(T* obj) { return Property<const u
 913:./autogen/interfaces.hpp ****             template<typename T> static inline void get_error_cnt(T* obj, void* ptr) { new (ptr) Pr
 914:./autogen/interfaces.hpp ****         };
 915:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uptime(T* obj) { return Property<const uint32_t
 916:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uptime(T* obj, void* ptr) { new (ptr) Property<
 917:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_min_heap_space(T* obj) { return Property<const 
 918:./autogen/interfaces.hpp ****         template<typename T> static inline void get_min_heap_space(T* obj, void* ptr) { new (ptr) P
 919:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_axis(T* obj) { return Property<
 920:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_axis(T* obj, void* ptr) { new (
 921:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_usb(T* obj) { return Property<c
 922:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_usb(T* obj, void* ptr) { new (p
 923:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_uart(T* obj) { return Property<
 924:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_uart(T* obj, void* ptr) { new (
 925:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_can(T* obj) { return Property<c
 926:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_can(T* obj, void* ptr) { new (p
 927:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_startup(T* obj) { return Proper
 928:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_startup(T* obj, void* ptr) { ne
 929:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_analog(T* obj) { return Propert
 930:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_analog(T* obj, void* ptr) { new
 931:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_axis(T* obj) { return Property<const
 932:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_axis(T* obj, void* ptr) { new (ptr) 
 933:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_usb(T* obj) { return Property<const 
 934:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_usb(T* obj, void* ptr) { new (ptr) P
 935:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_uart(T* obj) { return Property<const
 936:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_uart(T* obj, void* ptr) { new (ptr) 
 937:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_startup(T* obj) { return Property<co
 938:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_startup(T* obj, void* ptr) { new (pt
 939:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_can(T* obj) { return Property<const 
ARM GAS  /tmp/cc5nV8qb.s 			page 101


 940:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_can(T* obj, void* ptr) { new (ptr) P
 941:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_analog(T* obj) { return Property<con
 942:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_analog(T* obj, void* ptr) { new (ptr
 943:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_axis(T* obj) { return Property<const int32
 944:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_axis(T* obj, void* ptr) { new (ptr) Proper
 945:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_usb(T* obj) { return Property<const int32_
 946:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_usb(T* obj, void* ptr) { new (ptr) Propert
 947:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_uart(T* obj) { return Property<const int32
 948:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_uart(T* obj, void* ptr) { new (ptr) Proper
 949:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_startup(T* obj) { return Property<const in
 950:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_startup(T* obj, void* ptr) { new (ptr) Pro
 951:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_can(T* obj) { return Property<const int32_
 952:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_can(T* obj, void* ptr) { new (ptr) Propert
 953:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_analog(T* obj) { return Property<const int
 954:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_analog(T* obj, void* ptr) { new (ptr) Prop
 955:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_usb(T* obj) { return &obj->usb; }
 956:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_i2c(T* obj) { return &obj->i2c; }
 957:./autogen/interfaces.hpp ****     };
 958:./autogen/interfaces.hpp ****     enum Error {
 959:./autogen/interfaces.hpp ****         ERROR_NONE                       = 0x00000000,
 960:./autogen/interfaces.hpp ****         ERROR_CONTROL_ITERATION_MISSED   = 0x00000001,
 961:./autogen/interfaces.hpp ****         ERROR_DC_BUS_UNDER_VOLTAGE       = 0x00000002,
 962:./autogen/interfaces.hpp ****         ERROR_DC_BUS_OVER_VOLTAGE        = 0x00000004,
 963:./autogen/interfaces.hpp ****         ERROR_DC_BUS_OVER_REGEN_CURRENT  = 0x00000008,
 964:./autogen/interfaces.hpp ****         ERROR_DC_BUS_OVER_CURRENT        = 0x00000010,
 965:./autogen/interfaces.hpp ****         ERROR_BRAKE_DEADTIME_VIOLATION   = 0x00000020,
 966:./autogen/interfaces.hpp ****         ERROR_BRAKE_DUTY_CYCLE_NAN       = 0x00000040,
 967:./autogen/interfaces.hpp ****         ERROR_INVALID_BRAKE_RESISTANCE   = 0x00000080,
 968:./autogen/interfaces.hpp ****     };
 969:./autogen/interfaces.hpp ****     enum GpioMode {
 970:./autogen/interfaces.hpp ****         GPIO_MODE_DIGITAL                = 0,
 971:./autogen/interfaces.hpp ****         GPIO_MODE_DIGITAL_PULL_UP        = 1,
 972:./autogen/interfaces.hpp ****         GPIO_MODE_DIGITAL_PULL_DOWN      = 2,
 973:./autogen/interfaces.hpp ****         GPIO_MODE_ANALOG_IN              = 3,
 974:./autogen/interfaces.hpp ****         GPIO_MODE_UART_A                 = 4,
 975:./autogen/interfaces.hpp ****         GPIO_MODE_UART_B                 = 5,
 976:./autogen/interfaces.hpp ****         GPIO_MODE_UART_C                 = 6,
 977:./autogen/interfaces.hpp ****         GPIO_MODE_CAN_A                  = 7,
 978:./autogen/interfaces.hpp ****         GPIO_MODE_I2C_A                  = 8,
 979:./autogen/interfaces.hpp ****         GPIO_MODE_SPI_A                  = 9,
 980:./autogen/interfaces.hpp ****         GPIO_MODE_PWM                    = 10,
 981:./autogen/interfaces.hpp ****         GPIO_MODE_ENC0                   = 11,
 982:./autogen/interfaces.hpp ****         GPIO_MODE_ENC1                   = 12,
 983:./autogen/interfaces.hpp ****         GPIO_MODE_ENC2                   = 13,
 984:./autogen/interfaces.hpp ****         GPIO_MODE_MECH_BRAKE             = 14,
 985:./autogen/interfaces.hpp ****         GPIO_MODE_STATUS                 = 15,
 986:./autogen/interfaces.hpp ****     };
 987:./autogen/interfaces.hpp ****     enum StreamProtocolType {
 988:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_FIBRE       = 0,
 989:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_ASCII       = 1,
 990:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_STDOUT      = 2,
 991:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_ASCII_AND_STDOUT = 3,
 992:./autogen/interfaces.hpp ****     };
 993:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Error>{
 994:./autogen/interfaces.hpp ****     template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriv
 995:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_vbus_voltage(T* obj) { return Property<const float>
 996:./autogen/interfaces.hpp ****     template<typename T> static inline void get_vbus_voltage(T* obj, void* ptr) { new (ptr) Propert
ARM GAS  /tmp/cc5nV8qb.s 			page 102


 997:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_ibus(T* obj) { return Property<const float>{&obj->i
 998:./autogen/interfaces.hpp ****     template<typename T> static inline void get_ibus(T* obj, void* ptr) { new (ptr) Property<const 
 999:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_ibus_report_filter_k(T* obj) { return Property<floa
1000:./autogen/interfaces.hpp ****     template<typename T> static inline void get_ibus_report_filter_k(T* obj, void* ptr) { new (ptr)
1001:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_serial_number(T* obj) { return Property<const uint6
1002:./autogen/interfaces.hpp ****     template<typename T> static inline void get_serial_number(T* obj, void* ptr) { new (ptr) Proper
1003:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_hw_version_major(T* obj) { return Property<const ui
1004:./autogen/interfaces.hpp ****     template<typename T> static inline void get_hw_version_major(T* obj, void* ptr) { new (ptr) Pro
1005:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_hw_version_minor(T* obj) { return Property<const ui
1006:./autogen/interfaces.hpp ****     template<typename T> static inline void get_hw_version_minor(T* obj, void* ptr) { new (ptr) Pro
1007:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_hw_version_variant(T* obj) { return Property<const 
1008:./autogen/interfaces.hpp ****     template<typename T> static inline void get_hw_version_variant(T* obj, void* ptr) { new (ptr) P
1009:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_major(T* obj) { return Property<const ui
1010:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_major(T* obj, void* ptr) { new (ptr) Pro
1011:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_minor(T* obj) { return Property<const ui
1012:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_minor(T* obj, void* ptr) { new (ptr) Pro
1013:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_revision(T* obj) { return Property<const
1014:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_revision(T* obj, void* ptr) { new (ptr) 
1015:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_unreleased(T* obj) { return Property<con
1016:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_unreleased(T* obj, void* ptr) { new (ptr
1017:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_brake_resistor_armed(T* obj) { return Property<cons
1018:./autogen/interfaces.hpp ****     template<typename T> static inline void get_brake_resistor_armed(T* obj, void* ptr) { new (ptr)
1019:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_brake_resistor_saturated(T* obj) { return Property<
1020:./autogen/interfaces.hpp ****     template<typename T> static inline void get_brake_resistor_saturated(T* obj, void* ptr) { new (
1021:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_brake_resistor_current(T* obj) { return Property<co
1022:./autogen/interfaces.hpp ****     template<typename T> static inline void get_brake_resistor_current(T* obj, void* ptr) { new (pt
1023:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_n_evt_sampling(T* obj) { return Property<const uint
1024:./autogen/interfaces.hpp ****     template<typename T> static inline void get_n_evt_sampling(T* obj, void* ptr) { new (ptr) Prope
1025:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_n_evt_control_loop(T* obj) { return Property<const 
1026:./autogen/interfaces.hpp ****     template<typename T> static inline void get_n_evt_control_loop(T* obj, void* ptr) { new (ptr) P
1027:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_task_timers_armed(T* obj) { return Property<bool>{&
1028:./autogen/interfaces.hpp ****     template<typename T> static inline void get_task_timers_armed(T* obj, void* ptr) { new (ptr) Pr
1029:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_task_times(T* obj) { return &obj->task_times_; }
1030:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_system_stats(T* obj) { return &obj->system_stats_; 
1031:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_user_config_loaded(T* obj) { return Property<const 
1032:./autogen/interfaces.hpp ****     template<typename T> static inline void get_user_config_loaded(T* obj, void* ptr) { new (ptr) P
1033:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_misconfigured(T* obj) { return Property<const bool>
1034:./autogen/interfaces.hpp ****     template<typename T> static inline void get_misconfigured(T* obj, void* ptr) { new (ptr) Proper
1035:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_oscilloscope(T* obj) { return &obj->oscilloscope_; 
1036:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_can(T* obj) { return &obj->can_; }
1037:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_test_property(T* obj) { return Property<uint32_t>{&
1038:./autogen/interfaces.hpp ****     template<typename T> static inline void get_test_property(T* obj, void* ptr) { new (ptr) Proper
1039:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_otp_valid(T* obj) { return Property<const bool>{&ob
1040:./autogen/interfaces.hpp ****     template<typename T> static inline void get_otp_valid(T* obj, void* ptr) { new (ptr) Property<c
1041:./autogen/interfaces.hpp ****     virtual int32_t test_function(int32_t delta) = 0;
1042:./autogen/interfaces.hpp ****     virtual float get_adc_voltage(uint32_t gpio) = 0;
1043:./autogen/interfaces.hpp ****     virtual bool save_configuration() = 0;
1044:./autogen/interfaces.hpp ****     virtual void erase_configuration() = 0;
1045:./autogen/interfaces.hpp ****     virtual void reboot() = 0;
1046:./autogen/interfaces.hpp ****     virtual void enter_dfu_mode() = 0;
1047:./autogen/interfaces.hpp ****     virtual uint32_t get_interrupt_status(int32_t irqn) = 0;
1048:./autogen/interfaces.hpp ****     virtual uint32_t get_dma_status(uint8_t stream_num) = 0;
1049:./autogen/interfaces.hpp ****     virtual uint32_t get_gpio_states() = 0;
1050:./autogen/interfaces.hpp ****     virtual uint64_t get_drv_fault() = 0;
1051:./autogen/interfaces.hpp ****     virtual void clear_errors() = 0;
1052:./autogen/interfaces.hpp ****     int32_t test_function_in_delta_; // for internal use by Fibre
1053:./autogen/interfaces.hpp ****     template<typename T> static auto get_test_function_in_delta_(T* obj) { return Property<int32_t>
ARM GAS  /tmp/cc5nV8qb.s 			page 103


1054:./autogen/interfaces.hpp ****     template<typename T> static void get_test_function_in_delta_(T* obj, void* ptr) { new (ptr) Pro
1055:./autogen/interfaces.hpp ****     int32_t test_function_out_cnt_; // for internal use by Fibre
1056:./autogen/interfaces.hpp ****     template<typename T> static auto get_test_function_out_cnt_(T* obj) { return Property<const int
1057:./autogen/interfaces.hpp ****     template<typename T> static void get_test_function_out_cnt_(T* obj, void* ptr) { new (ptr) Prop
1058:./autogen/interfaces.hpp ****     uint32_t get_adc_voltage_in_gpio_; // for internal use by Fibre
1059:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_adc_voltage_in_gpio_(T* obj) { return Property<uint32_
1060:./autogen/interfaces.hpp ****     template<typename T> static void get_get_adc_voltage_in_gpio_(T* obj, void* ptr) { new (ptr) Pr
1061:./autogen/interfaces.hpp ****     float get_adc_voltage_out_voltage_; // for internal use by Fibre
1062:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_adc_voltage_out_voltage_(T* obj) { return Property<con
1063:./autogen/interfaces.hpp ****     template<typename T> static void get_get_adc_voltage_out_voltage_(T* obj, void* ptr) { new (ptr
1064:./autogen/interfaces.hpp ****     bool save_configuration_out_success_; // for internal use by Fibre
1065:./autogen/interfaces.hpp ****     template<typename T> static auto get_save_configuration_out_success_(T* obj) { return Property<
1066:./autogen/interfaces.hpp ****     template<typename T> static void get_save_configuration_out_success_(T* obj, void* ptr) { new (
1067:./autogen/interfaces.hpp ****     int32_t get_interrupt_status_in_irqn_; // for internal use by Fibre
1068:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_interrupt_status_in_irqn_(T* obj) { return Property<in
1069:./autogen/interfaces.hpp ****     template<typename T> static void get_get_interrupt_status_in_irqn_(T* obj, void* ptr) { new (pt
1070:./autogen/interfaces.hpp ****     uint32_t get_interrupt_status_out_status_; // for internal use by Fibre
1071:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_interrupt_status_out_status_(T* obj) { return Property
1072:./autogen/interfaces.hpp ****     template<typename T> static void get_get_interrupt_status_out_status_(T* obj, void* ptr) { new 
1073:./autogen/interfaces.hpp ****     uint8_t get_dma_status_in_stream_num_; // for internal use by Fibre
1074:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_dma_status_in_stream_num_(T* obj) { return Property<ui
1075:./autogen/interfaces.hpp ****     template<typename T> static void get_get_dma_status_in_stream_num_(T* obj, void* ptr) { new (pt
1076:./autogen/interfaces.hpp ****     uint32_t get_dma_status_out_status_; // for internal use by Fibre
1077:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_dma_status_out_status_(T* obj) { return Property<const
1078:./autogen/interfaces.hpp ****     template<typename T> static void get_get_dma_status_out_status_(T* obj, void* ptr) { new (ptr) 
1079:./autogen/interfaces.hpp ****     uint32_t get_gpio_states_out_status_; // for internal use by Fibre
1080:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_gpio_states_out_status_(T* obj) { return Property<cons
1081:./autogen/interfaces.hpp ****     template<typename T> static void get_get_gpio_states_out_status_(T* obj, void* ptr) { new (ptr)
1082:./autogen/interfaces.hpp ****     uint64_t get_drv_fault_out_drv_fault_; // for internal use by Fibre
1083:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_drv_fault_out_drv_fault_(T* obj) { return Property<con
1084:./autogen/interfaces.hpp ****     template<typename T> static void get_get_drv_fault_out_drv_fault_(T* obj, void* ptr) { new (ptr
1085:./autogen/interfaces.hpp **** };
1086:./autogen/interfaces.hpp **** 
1087:./autogen/interfaces.hpp **** 
1088:./autogen/interfaces.hpp **** class ODrive3Intf : public ODriveIntf {
1089:./autogen/interfaces.hpp **** public:
1090:./autogen/interfaces.hpp ****     class ConfigIntf : public ODriveIntf::ConfigIntf {
1091:./autogen/interfaces.hpp ****     public:
1092:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio1_mode(T* obj) { return Property<ODriveIntf
1093:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio1_mode(T* obj, void* ptr) { new (ptr) Prope
1094:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio2_mode(T* obj) { return Property<ODriveIntf
1095:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio2_mode(T* obj, void* ptr) { new (ptr) Prope
1096:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio3_mode(T* obj) { return Property<ODriveIntf
1097:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio3_mode(T* obj, void* ptr) { new (ptr) Prope
1098:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio4_mode(T* obj) { return Property<ODriveIntf
1099:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio4_mode(T* obj, void* ptr) { new (ptr) Prope
1100:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio5_mode(T* obj) { return Property<ODriveIntf
1101:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio5_mode(T* obj, void* ptr) { new (ptr) Prope
1102:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio6_mode(T* obj) { return Property<ODriveIntf
1103:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio6_mode(T* obj, void* ptr) { new (ptr) Prope
1104:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio7_mode(T* obj) { return Property<ODriveIntf
1105:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio7_mode(T* obj, void* ptr) { new (ptr) Prope
1106:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio8_mode(T* obj) { return Property<ODriveIntf
1107:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio8_mode(T* obj, void* ptr) { new (ptr) Prope
1108:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio9_mode(T* obj) { return Property<ODriveIntf
1109:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio9_mode(T* obj, void* ptr) { new (ptr) Prope
1110:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio10_mode(T* obj) { return Property<ODriveInt
ARM GAS  /tmp/cc5nV8qb.s 			page 104


1111:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio10_mode(T* obj, void* ptr) { new (ptr) Prop
1112:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio11_mode(T* obj) { return Property<ODriveInt
1113:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio11_mode(T* obj, void* ptr) { new (ptr) Prop
1114:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio12_mode(T* obj) { return Property<ODriveInt
1115:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio12_mode(T* obj, void* ptr) { new (ptr) Prop
1116:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio13_mode(T* obj) { return Property<ODriveInt
1117:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio13_mode(T* obj, void* ptr) { new (ptr) Prop
1118:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio14_mode(T* obj) { return Property<ODriveInt
1119:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio14_mode(T* obj, void* ptr) { new (ptr) Prop
1120:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio15_mode(T* obj) { return Property<ODriveInt
1121:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio15_mode(T* obj, void* ptr) { new (ptr) Prop
1122:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio16_mode(T* obj) { return Property<ODriveInt
1123:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio16_mode(T* obj, void* ptr) { new (ptr) Prop
1124:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio1_pwm_mapping(T* obj) { return &obj->pwm_ma
1125:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio2_pwm_mapping(T* obj) { return &obj->pwm_ma
1126:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio3_pwm_mapping(T* obj) { return &obj->pwm_ma
1127:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio4_pwm_mapping(T* obj) { return &obj->pwm_ma
1128:./autogen/interfaces.hpp ****     };
1129:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
1130:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_axis0(T* obj) { return &obj->get_axis(0); }
1131:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_axis1(T* obj) { return &obj->get_axis(1); }
1132:./autogen/interfaces.hpp **** };
1133:./autogen/interfaces.hpp **** 
1134:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1135:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator | (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIn
1136:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator & (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIn
1137:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator ^ (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIn
1138:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol& operator |= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::Ca
1139:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol& operator &= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::Ca
1140:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol& operator ^= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::Ca
1141:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator ~ (ODriveIntf::CanIntf::Protocol a) { return static_c
1142:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1143:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator | (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast
1144:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator & (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast
1145:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator ^ (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast
1146:./autogen/interfaces.hpp **** inline ODriveIntf::Error& operator |= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterp
1147:./autogen/interfaces.hpp **** inline ODriveIntf::Error& operator &= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterp
1148:./autogen/interfaces.hpp **** inline ODriveIntf::Error& operator ^= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterp
1149:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator ~ (ODriveIntf::Error a) { return static_cast<ODriveIntf::Error>(~
1150:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1151:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator | (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Er
1152:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator & (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Er
1153:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator ^ (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Er
1154:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error& operator |= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf:
1155:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error& operator &= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf:
1156:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error& operator ^= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf:
1157:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator ~ (ODriveIntf::CanIntf::Error a) { return static_cast<OD
1158:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1159:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator | (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf:
1160:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator & (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf:
1161:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator ^ (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf:
1162:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error& operator |= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIn
 1200              		.loc 11 1162 113 is_stmt 1 view -0
 1201              		.cfi_startproc
 1202              		@ args = 0, pretend = 0, frame = 0
 1203              		@ frame_needed = 0, uses_anonymous_args = 0
 1204              		@ link register save eliminated.
ARM GAS  /tmp/cc5nV8qb.s 			page 105


 1205              		.loc 11 1162 115 view .LVU261
 1206              		.loc 11 1162 243 is_stmt 0 view .LVU262
 1207 0000 0268     		ldr	r2, [r0]
 1208 0002 1143     		orrs	r1, r1, r2
 1209              	.LVL76:
 1210              		.loc 11 1162 243 view .LVU263
 1211 0004 0160     		str	r1, [r0]
 1212              		.loc 11 1162 316 view .LVU264
 1213 0006 7047     		bx	lr
 1214              		.cfi_endproc
 1215              	.LFE4170:
 1216              		.cantunwind
 1217              		.fnend
 1219              		.section	.text._ZanN10ODriveIntf11EncoderIntf5ErrorES1_,"axG",%progbits,_ZanN10ODriveIntf11Encoder
 1220              		.align	1
 1221              		.weak	_ZanN10ODriveIntf11EncoderIntf5ErrorES1_
 1222              		.syntax unified
 1223              		.thumb
 1224              		.thumb_func
 1226              	_ZanN10ODriveIntf11EncoderIntf5ErrorES1_:
 1227              		.fnstart
 1228              	.LVL77:
 1229              	.LFB4189:
1163:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error& operator &= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIn
1164:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error& operator ^= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIn
1165:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator ~ (ODriveIntf::AxisIntf::Error a) { return static_cast<
1166:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1167:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error operator | (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIn
1168:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error operator & (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIn
1169:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error operator ^ (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIn
1170:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error& operator |= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::Moto
1171:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error& operator &= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::Moto
1172:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error& operator ^= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::Moto
1173:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error operator ~ (ODriveIntf::MotorIntf::Error a) { return static_cas
1174:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1175:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error operator | (ODriveIntf::ControllerIntf::Error a, ODriveInt
1176:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error operator & (ODriveIntf::ControllerIntf::Error a, ODriveInt
1177:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error operator ^ (ODriveIntf::ControllerIntf::Error a, ODriveInt
1178:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error& operator |= (ODriveIntf::ControllerIntf::Error &a, ODrive
1179:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error& operator &= (ODriveIntf::ControllerIntf::Error &a, ODrive
1180:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error& operator ^= (ODriveIntf::ControllerIntf::Error &a, ODrive
1181:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error operator ~ (ODriveIntf::ControllerIntf::Error a) { return 
1182:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1183:./autogen/interfaces.hpp **** inline ODriveIntf::EncoderIntf::Error operator | (ODriveIntf::EncoderIntf::Error a, ODriveIntf::Enc
1184:./autogen/interfaces.hpp **** inline ODriveIntf::EncoderIntf::Error operator & (ODriveIntf::EncoderIntf::Error a, ODriveIntf::Enc
 1230              		.loc 11 1184 119 is_stmt 1 view -0
 1231              		.cfi_startproc
 1232              		@ args = 0, pretend = 0, frame = 0
 1233              		@ frame_needed = 0, uses_anonymous_args = 0
 1234              		@ link register save eliminated.
 1235              		.loc 11 1184 121 view .LVU266
 1236              		.loc 11 1184 318 is_stmt 0 view .LVU267
 1237 0000 0840     		ands	r0, r0, r1
 1238              	.LVL78:
 1239              		.loc 11 1184 318 view .LVU268
 1240 0002 7047     		bx	lr
 1241              		.cfi_endproc
ARM GAS  /tmp/cc5nV8qb.s 			page 106


 1242              	.LFE4189:
 1243              		.cantunwind
 1244              		.fnend
 1246              		.section	.text._ZoRRN10ODriveIntf11EncoderIntf5ErrorES1_,"axG",%progbits,_ZoRRN10ODriveIntf11Encod
 1247              		.align	1
 1248              		.weak	_ZoRRN10ODriveIntf11EncoderIntf5ErrorES1_
 1249              		.syntax unified
 1250              		.thumb
 1251              		.thumb_func
 1253              	_ZoRRN10ODriveIntf11EncoderIntf5ErrorES1_:
 1254              		.fnstart
 1255              	.LVL79:
 1256              	.LFB4191:
1185:./autogen/interfaces.hpp **** inline ODriveIntf::EncoderIntf::Error operator ^ (ODriveIntf::EncoderIntf::Error a, ODriveIntf::Enc
1186:./autogen/interfaces.hpp **** inline ODriveIntf::EncoderIntf::Error& operator |= (ODriveIntf::EncoderIntf::Error &a, ODriveIntf::
 1257              		.loc 11 1186 122 is_stmt 1 view -0
 1258              		.cfi_startproc
 1259              		@ args = 0, pretend = 0, frame = 0
 1260              		@ frame_needed = 0, uses_anonymous_args = 0
 1261              		@ link register save eliminated.
 1262              		.loc 11 1186 124 view .LVU270
 1263              		.loc 11 1186 258 is_stmt 0 view .LVU271
 1264 0000 0288     		ldrh	r2, [r0]
 1265 0002 1143     		orrs	r1, r1, r2
 1266              	.LVL80:
 1267              		.loc 11 1186 258 view .LVU272
 1268 0004 0180     		strh	r1, [r0]	@ movhi
 1269              		.loc 11 1186 334 view .LVU273
 1270 0006 7047     		bx	lr
 1271              		.cfi_endproc
 1272              	.LFE4191:
 1273              		.cantunwind
 1274              		.fnend
 1276              		.section	.text._ZN7EncoderC2EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter,"ax",%progb
 1277              		.align	1
 1278              		.global	_ZN7EncoderC2EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter
 1279              		.syntax unified
 1280              		.thumb
 1281              		.thumb_func
 1283              	_ZN7EncoderC2EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter:
 1284              		.fnstart
 1285              	.LVL81:
 1286              	.LFB5328:
   6:MotorControl/encoder.cpp ****                  Stm32Gpio hallA_gpio, Stm32Gpio hallB_gpio, Stm32Gpio hallC_gpio,
 1287              		.loc 3 6 1 is_stmt 1 view -0
 1288              		.cfi_startproc
 1289              		@ args = 28, pretend = 0, frame = 8
 1290              		@ frame_needed = 0, uses_anonymous_args = 0
   6:MotorControl/encoder.cpp ****                  Stm32Gpio hallA_gpio, Stm32Gpio hallB_gpio, Stm32Gpio hallC_gpio,
 1291              		.loc 3 6 1 is_stmt 0 view .LVU275
 1292 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1293              	.LCFI5:
 1294              		.cfi_def_cfa_offset 20
 1295              		.cfi_offset 4, -20
 1296              		.cfi_offset 5, -16
 1297              		.cfi_offset 6, -12
 1298              		.cfi_offset 7, -8
ARM GAS  /tmp/cc5nV8qb.s 			page 107


 1299              		.cfi_offset 14, -4
 1300 0002 83B0     		sub	sp, sp, #12
 1301              	.LCFI6:
 1302              		.cfi_def_cfa_offset 32
 1303 0004 8446     		mov	ip, r0
 1304 0006 6846     		mov	r0, sp
 1305              	.LVL82:
   6:MotorControl/encoder.cpp ****                  Stm32Gpio hallA_gpio, Stm32Gpio hallB_gpio, Stm32Gpio hallC_gpio,
 1306              		.loc 3 6 1 view .LVU276
 1307 0008 80E80C00 		stm	r0, {r2, r3}
 1308              	.LVL83:
 1309              	.LBB1364:
 1310              	.LBB1365:
 1311              	.LBI1365:
 690:./autogen/interfaces.hpp ****     public:
 1312              		.loc 11 690 11 is_stmt 1 view .LVU277
 1313              	.LBB1366:
 1314 000c 624A     		ldr	r2, .L81
 1315 000e CCF80020 		str	r2, [ip]
 1316              	.LVL84:
 690:./autogen/interfaces.hpp ****     public:
 1317              		.loc 11 690 11 is_stmt 0 view .LVU278
 1318              	.LBE1366:
 1319              	.LBE1365:
  11:MotorControl/encoder.cpp **** {
 1320              		.loc 3 11 33 view .LVU279
 1321 0012 624A     		ldr	r2, .L81+4
 1322 0014 CCF80020 		str	r2, [ip]
 1323 0018 CCF80810 		str	r1, [ip, #8]
 1324 001c 0CF10C02 		add	r2, ip, #12
 1325 0020 03C8     		ldm	r0, {r0, r1}
 1326              	.LVL85:
  11:MotorControl/encoder.cpp **** {
 1327              		.loc 3 11 33 view .LVU280
 1328 0022 82E80900 		stm	r2, {r0, r3}
 1329 0026 0CF11403 		add	r3, ip, #20
 1330 002a 08AA     		add	r2, sp, #32
 1331              	.LVL86:
  11:MotorControl/encoder.cpp **** {
 1332              		.loc 3 11 33 view .LVU281
 1333 002c 92E80300 		ldm	r2, {r0, r1}
 1334 0030 83E80300 		stm	r3, {r0, r1}
 1335 0034 0CF11C03 		add	r3, ip, #28
 1336 0038 0AAA     		add	r2, sp, #40
 1337              	.LVL87:
  11:MotorControl/encoder.cpp **** {
 1338              		.loc 3 11 33 view .LVU282
 1339 003a 92E80300 		ldm	r2, {r0, r1}
 1340 003e 83E80300 		stm	r3, {r0, r1}
 1341 0042 0CF12403 		add	r3, ip, #36
 1342 0046 0CAA     		add	r2, sp, #48
 1343 0048 92E80300 		ldm	r2, {r0, r1}
 1344 004c 83E80300 		stm	r3, {r0, r1}
 1345 0050 0E9B     		ldr	r3, [sp, #56]
 1346 0052 CCF82C30 		str	r3, [ip, #44]
 1347 0056 0024     		movs	r4, #0
 1348 0058 CCF83040 		str	r4, [ip, #48]
ARM GAS  /tmp/cc5nV8qb.s 			page 108


 1349 005c 0CF1340E 		add	lr, ip, #52
 1350              	.LVL88:
 1351              	.LBB1367:
 1352              	.LBI1367:
 1353              		.file 12 "./MotorControl/encoder.hpp"
   1:./MotorControl/encoder.hpp **** #ifndef __ENCODER_HPP
   2:./MotorControl/encoder.hpp **** #define __ENCODER_HPP
   3:./MotorControl/encoder.hpp **** 
   4:./MotorControl/encoder.hpp **** class Encoder;
   5:./MotorControl/encoder.hpp **** 
   6:./MotorControl/encoder.hpp **** #include <board.h> // needed for arm_math.h
   7:./MotorControl/encoder.hpp **** #include <Drivers/STM32/stm32_spi_arbiter.hpp>
   8:./MotorControl/encoder.hpp **** #include "utils.hpp"
   9:./MotorControl/encoder.hpp **** #include <autogen/interfaces.hpp>
  10:./MotorControl/encoder.hpp **** #include "component.hpp"
  11:./MotorControl/encoder.hpp **** 
  12:./MotorControl/encoder.hpp **** 
  13:./MotorControl/encoder.hpp **** class Encoder : public ODriveIntf::EncoderIntf {
  14:./MotorControl/encoder.hpp **** public:
  15:./MotorControl/encoder.hpp ****     static constexpr uint32_t MODE_FLAG_ABS = 0x100;
  16:./MotorControl/encoder.hpp ****     static constexpr std::array<float, 6> hall_edge_defaults = 
  17:./MotorControl/encoder.hpp ****         {0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f};
  18:./MotorControl/encoder.hpp **** 
  19:./MotorControl/encoder.hpp ****     struct Config_t {
 1354              		.loc 12 19 12 is_stmt 1 view .LVU283
 1355              	.LBB1368:
 1356 0060 ACF83440 		strh	r4, [ip, #52]	@ movhi
 1357 0064 4E4B     		ldr	r3, .L81+8
 1358 0066 CEF80430 		str	r3, [lr, #4]	@ float
 1359 006a 4E4B     		ldr	r3, .L81+12
 1360 006c CEF80830 		str	r3, [lr, #8]	@ float
 1361 0070 4D4B     		ldr	r3, .L81+16
 1362 0072 CEF80C30 		str	r3, [lr, #12]	@ float
 1363 0076 4D4B     		ldr	r3, .L81+20
 1364 0078 CEF81030 		str	r3, [lr, #16]	@ float
 1365 007c CEF81440 		str	r4, [lr, #20]
 1366 0080 DFED4B7A 		vldr.32	s15, .L81+24
 1367 0084 CEED067A 		vstr.32	s15, [lr, #24]
 1368 0088 4FF40053 		mov	r3, #8192
 1369 008c CEF81C30 		str	r3, [lr, #28]
 1370 0090 CEED087A 		vstr.32	s15, [lr, #32]
 1371 0094 8EF82440 		strb	r4, [lr, #36]
 1372 0098 8EF82540 		strb	r4, [lr, #37]
 1373 009c CEF82840 		str	r4, [lr, #40]
 1374 00a0 0127     		movs	r7, #1
 1375 00a2 8EF82C70 		strb	r7, [lr, #44]
 1376 00a6 8EF82D70 		strb	r7, [lr, #45]
 1377 00aa 8EF82E40 		strb	r4, [lr, #46]
 1378 00ae 8EF82F40 		strb	r4, [lr, #47]
 1379 00b2 8EF83040 		strb	r4, [lr, #48]
 1380 00b6 8EF83140 		strb	r4, [lr, #49]
 1381 00ba 0CF16805 		add	r5, ip, #104
 1382 00be 3D4E     		ldr	r6, .L81+28
 1383 00c0 0FCE     		ldmia	r6!, {r0, r1, r2, r3}
 1384 00c2 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 1385 00c4 96E80300 		ldm	r6, {r0, r1}
 1386 00c8 85E80300 		stm	r5, {r0, r1}
ARM GAS  /tmp/cc5nV8qb.s 			page 109


 1387 00cc AEF84C70 		strh	r7, [lr, #76]	@ movhi
 1388 00d0 0323     		movs	r3, #3
 1389 00d2 AEF84E30 		strh	r3, [lr, #78]	@ movhi
 1390 00d6 0423     		movs	r3, #4
 1391 00d8 AEF85030 		strh	r3, [lr, #80]	@ movhi
 1392 00dc CEF85440 		str	r4, [lr, #84]
 1393              	.LVL89:
 1394              		.loc 12 19 12 is_stmt 0 view .LVU284
 1395              	.LBE1368:
 1396              	.LBE1367:
  11:MotorControl/encoder.cpp **** {
 1397              		.loc 3 11 33 view .LVU285
 1398 00e0 ACF88C40 		strh	r4, [ip, #140]	@ movhi
 1399 00e4 8CF88E40 		strb	r4, [ip, #142]
 1400 00e8 8CF88F40 		strb	r4, [ip, #143]
 1401 00ec CCF89040 		str	r4, [ip, #144]
 1402 00f0 CCF89440 		str	r4, [ip, #148]
 1403 00f4 CCED267A 		vstr.32	s15, [ip, #152]
 1404              	.LVL90:
 1405              	.LBB1369:
 1406              	.LBI1369:
 1407              		.file 13 "./MotorControl/component.hpp"
   1:./MotorControl/component.hpp **** #ifndef __COMPONENT_HPP
   2:./MotorControl/component.hpp **** #define __COMPONENT_HPP
   3:./MotorControl/component.hpp **** 
   4:./MotorControl/component.hpp **** #include <stdint.h>
   5:./MotorControl/component.hpp **** #include <optional>
   6:./MotorControl/component.hpp **** #include <variant>
   7:./MotorControl/component.hpp **** 
   8:./MotorControl/component.hpp **** class ComponentBase {
   9:./MotorControl/component.hpp **** public:
  10:./MotorControl/component.hpp ****     /**
  11:./MotorControl/component.hpp ****      * @brief Shall run the update action of this component.
  12:./MotorControl/component.hpp ****      * 
  13:./MotorControl/component.hpp ****      * This function gets called in a low priority interrupt context and is
  14:./MotorControl/component.hpp ****      * allowed to call CMSIS functions.
  15:./MotorControl/component.hpp ****      * 
  16:./MotorControl/component.hpp ****      * @param timestamp: The timestamp (in HCLK ticks) for which this update
  17:./MotorControl/component.hpp ****      * is run.
  18:./MotorControl/component.hpp ****      */
  19:./MotorControl/component.hpp ****     virtual void update(uint32_t timestamp) = 0;
  20:./MotorControl/component.hpp **** };
  21:./MotorControl/component.hpp **** 
  22:./MotorControl/component.hpp **** 
  23:./MotorControl/component.hpp **** template<typename T>
  24:./MotorControl/component.hpp **** class InputPort;
  25:./MotorControl/component.hpp **** 
  26:./MotorControl/component.hpp **** /**
  27:./MotorControl/component.hpp ****  * @brief An output port stores a value for consumption by a connecting input
  28:./MotorControl/component.hpp ****  * port.
  29:./MotorControl/component.hpp ****  * 
  30:./MotorControl/component.hpp ****  * Output ports are supposed to be reset at the beginning of a control loop
  31:./MotorControl/component.hpp ****  * iteration. This ensures that connecting input ports don't use an outdated
  32:./MotorControl/component.hpp ****  * value and, more importantly, ensures proper handling if the producer of the
  33:./MotorControl/component.hpp ****  * value is incapable of producing the value for any reason.
  34:./MotorControl/component.hpp ****  * 
  35:./MotorControl/component.hpp ****  * Member functions of this class are not thread-safe unless noted otherwise.
ARM GAS  /tmp/cc5nV8qb.s 			page 110


  36:./MotorControl/component.hpp ****  */
  37:./MotorControl/component.hpp **** template<typename T>
  38:./MotorControl/component.hpp **** class OutputPort {
  39:./MotorControl/component.hpp **** public:
  40:./MotorControl/component.hpp ****     /**
  41:./MotorControl/component.hpp ****      * @brief Initializes the output port with the specified value.
  42:./MotorControl/component.hpp ****      * 
  43:./MotorControl/component.hpp ****      * An initialization value is required for any() to work properly.
  44:./MotorControl/component.hpp ****      * present() and previous() cannot be used to fetch the
  45:./MotorControl/component.hpp ****      * initialization value.
  46:./MotorControl/component.hpp ****      */
  47:./MotorControl/component.hpp ****     OutputPort(T val) : content_(val) {}
 1408              		.loc 13 47 5 is_stmt 1 view .LVU286
 1409              	.LBB1370:
 1410              		.loc 13 47 37 is_stmt 0 view .LVU287
 1411 00f8 0223     		movs	r3, #2
 1412 00fa CCF89C30 		str	r3, [ip, #156]
 1413 00fe CCED287A 		vstr.32	s15, [ip, #160]
 1414              	.LVL91:
 1415              		.loc 13 47 37 view .LVU288
 1416              	.LBE1370:
 1417              	.LBE1369:
 1418              	.LBB1371:
 1419              	.LBI1371:
 1420              		.loc 13 47 5 is_stmt 1 view .LVU289
 1421              	.LBB1372:
 1422              		.loc 13 47 37 is_stmt 0 view .LVU290
 1423 0102 CCF8A430 		str	r3, [ip, #164]
 1424 0106 CCED2A7A 		vstr.32	s15, [ip, #168]
 1425              	.LVL92:
 1426              		.loc 13 47 37 view .LVU291
 1427              	.LBE1372:
 1428              	.LBE1371:
  11:MotorControl/encoder.cpp **** {
 1429              		.loc 3 11 33 view .LVU292
 1430 010a CCED2B7A 		vstr.32	s15, [ip, #172]
 1431 010e CCED2C7A 		vstr.32	s15, [ip, #176]
 1432 0112 CCED2D7A 		vstr.32	s15, [ip, #180]
 1433 0116 CCED2E7A 		vstr.32	s15, [ip, #184]
 1434 011a CCED2F7A 		vstr.32	s15, [ip, #188]
 1435 011e CCED307A 		vstr.32	s15, [ip, #192]
 1436 0122 CCED317A 		vstr.32	s15, [ip, #196]
 1437 0126 CCF8C840 		str	r4, [ip, #200]
 1438 012a CCED337A 		vstr.32	s15, [ip, #204]
 1439              	.LVL93:
 1440              	.LBB1373:
 1441              	.LBI1373:
 1442              		.loc 13 47 5 is_stmt 1 view .LVU293
 1443              	.LBB1374:
 1444              		.loc 13 47 37 is_stmt 0 view .LVU294
 1445 012e CCF8D030 		str	r3, [ip, #208]
 1446 0132 CCED357A 		vstr.32	s15, [ip, #212]
 1447              	.LVL94:
 1448              		.loc 13 47 37 view .LVU295
 1449              	.LBE1374:
 1450              	.LBE1373:
 1451              	.LBB1375:
ARM GAS  /tmp/cc5nV8qb.s 			page 111


 1452              	.LBI1375:
 1453              		.loc 13 47 5 is_stmt 1 view .LVU296
 1454              	.LBB1376:
 1455              		.loc 13 47 37 is_stmt 0 view .LVU297
 1456 0136 CCF8D830 		str	r3, [ip, #216]
 1457 013a CCED377A 		vstr.32	s15, [ip, #220]
 1458              	.LVL95:
 1459              		.loc 13 47 37 view .LVU298
 1460              	.LBE1376:
 1461              	.LBE1375:
 1462              	.LBB1377:
 1463              	.LBI1377:
 1464              		.loc 13 47 5 is_stmt 1 view .LVU299
 1465              	.LBB1378:
 1466              		.loc 13 47 37 is_stmt 0 view .LVU300
 1467 013e CCF8E030 		str	r3, [ip, #224]
 1468 0142 CCED397A 		vstr.32	s15, [ip, #228]
 1469              	.LVL96:
 1470              		.loc 13 47 37 view .LVU301
 1471              	.LBE1378:
 1472              	.LBE1377:
  11:MotorControl/encoder.cpp **** {
 1473              		.loc 3 11 33 view .LVU302
 1474 0146 8CF8E840 		strb	r4, [ip, #232]
 1475 014a 8CF8E940 		strb	r4, [ip, #233]
 1476 014e ACF8EA40 		strh	r4, [ip, #234]	@ movhi
 1477 0152 8CF8F240 		strb	r4, [ip, #242]
 1478              	.LVL97:
 1479              	.LBB1379:
 1480              	.LBI1379:
 1481              		.file 14 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // <optional> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Copyright (C) 2013-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** /** @file include/optional
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****  *  This is a Standard C++ Library header.
ARM GAS  /tmp/cc5nV8qb.s 			page 112


  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****  */
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #ifndef _GLIBCXX_OPTIONAL
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #define _GLIBCXX_OPTIONAL 1
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #pragma GCC system_header
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #if __cplusplus >= 201703L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <utility>
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <type_traits>
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <exception>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <new>
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <initializer_list>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/exception_defines.h>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/functional_hash.h>
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/enable_special_members.h>
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #if __cplusplus > 201703L
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** # include <compare>
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #endif
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** namespace std _GLIBCXX_VISIBILITY(default)
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** {
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @addtogroup utilities
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @{
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    */
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #define __cpp_lib_optional 201606L
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class optional;
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /// Tag type to disengage optional objects.
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   struct nullopt_t
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   {
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Do not user-declare default constructor at all for
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // optional_value = {} syntax to work.
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // nullopt_t() = delete;
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Used for constructing nullopt.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     enum class _Construct { _Token };
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Must be constexpr for nullopt_t to be literal.
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     explicit constexpr nullopt_t(_Construct) { }
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   };
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /// Tag to disengage optional objects.
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   inline constexpr nullopt_t nullopt { nullopt_t::_Construct::_Token };
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @brief Exception class thrown when a disengaged optional object is
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  dereferenced.
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @ingroup exceptions
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    */
ARM GAS  /tmp/cc5nV8qb.s 			page 113


  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   class bad_optional_access : public exception
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   {
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   public:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     bad_optional_access() = default;
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     virtual ~bad_optional_access() = default;
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     const char* what() const noexcept override
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return "bad optional access"; }
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   };
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   void
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __throw_bad_optional_access()
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __attribute__((__noreturn__));
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // XXX Does not belong here.
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   inline void
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __throw_bad_optional_access()
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   { _GLIBCXX_THROW_OR_ABORT(bad_optional_access()); }
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // This class template manages construction/destruction of
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // the contained value for a std::optional.
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload_base
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Stored_type = remove_const_t<_Tp>;
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base() = default;
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_Optional_payload_base(in_place_t __tag, _Args&&... __args)
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_engaged(true)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args>
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_Optional_payload_base(std::initializer_list<_Up> __il,
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			       _Args&&... __args)
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__il, std::forward<_Args>(__args)...),
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_engaged(true)
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructor used by _Optional_base copy constructor when the
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // contained value is not trivially copy constructible.
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(bool __engaged,
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			     const _Optional_payload_base& __other)
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (__other._M_engaged)
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(__other._M_get());
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructor used by _Optional_base move constructor when the
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // contained value is not trivially move constructible.
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
ARM GAS  /tmp/cc5nV8qb.s 			page 114


 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(bool __engaged,
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			     _Optional_payload_base&& __other)
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (__other._M_engaged)
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(std::move(__other._M_get()));
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy constructor is only used to when the contained value is
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // trivially copy constructible.
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(const _Optional_payload_base&) = default;
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Move constructor is only used to when the contained value is
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // trivially copy constructible.
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(_Optional_payload_base&&) = default;
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base&
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload_base&) = default;
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base&
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload_base&&) = default;
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // used to perform non-trivial copy assignment.
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_copy_assign(const _Optional_payload_base& __other)
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         if (this->_M_engaged && __other._M_engaged)
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           this->_M_get() = __other._M_get();
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         else
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    if (__other._M_engaged)
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_construct(__other._M_get());
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    else
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // used to perform non-trivial move assignment.
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_move_assign(_Optional_payload_base&& __other)
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_engaged && __other._M_engaged)
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_get() = std::move(__other._M_get());
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    if (__other._M_engaged)
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_construct(std::move(__other._M_get()));
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    else
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       struct _Empty_byte { };
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, bool = is_trivially_destructible_v<_Up>>
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	union _Storage
ARM GAS  /tmp/cc5nV8qb.s 			page 115


 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  constexpr _Storage() noexcept : _M_empty() { }
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename... _Args>
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(in_place_t, _Args&&... __args)
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename _Vp, typename... _Args>
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(__il, std::forward<_Args>(__args)...)
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _Empty_byte _M_empty;
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           _Up _M_value;
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	};
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	union _Storage<_Up, false>
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  constexpr _Storage() noexcept : _M_empty() { }
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename... _Args>
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(in_place_t, _Args&&... __args)
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename _Vp, typename... _Args>
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(__il, std::forward<_Args>(__args)...)
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  // User-provided destructor is needed when _Up has non-trivial dtor.
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ~_Storage() { }
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _Empty_byte _M_empty;
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           _Up _M_value;
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	};
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Storage<_Stored_type> _M_payload;
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       bool _M_engaged = false;
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         void
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         _M_construct(_Args&&... __args)
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         {
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           ::new ((void *) std::__addressof(this->_M_payload))
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****             _Stored_type(std::forward<_Args>(__args)...);
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           this->_M_engaged = true;
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         }
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 116


 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_destroy() noexcept
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_engaged = false;
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_payload._M_value.~_Stored_type();
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_get() operations have _M_engaged as a precondition.
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // They exist to access the contained value with the appropriate
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // const-qualification, because _M_payload has had the const removed.
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() noexcept
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_payload._M_value; }
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() const noexcept
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_payload._M_value; }
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // _M_reset is a 'safe' operation with no precondition.
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_reset() noexcept
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_engaged)
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_destroy();
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Class template that manages the payload for optionals.
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp,
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialDestructor*/ =
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_destructible_v<_Tp>,
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialCopy */ =
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_copy_assignable_v<_Tp>
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      && is_trivially_copy_constructible_v<_Tp>,
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialMove */ =
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_move_assignable_v<_Tp>
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      && is_trivially_move_constructible_v<_Tp>>
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload;
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for potentially-constexpr optionals (trivial copy/move/destroy).
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, true, true>
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial copy construction/assignment.
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, false, true>
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 117


 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(_Optional_payload&&) = default;
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial copy assignment.
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload& __other)
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_copy_assign(__other);
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial move construction/assignment.
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, true, false>
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(const _Optional_payload&) = default;
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial move assignment.
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload&& __other)
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_move_assign(std::move(__other));
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial copy and move assignment.
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, false, false>
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial copy assignment.
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload& __other)
ARM GAS  /tmp/cc5nV8qb.s 			page 118


 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_copy_assign(__other);
 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial move assignment.
 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload&& __other)
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_move_assign(std::move(__other));
 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial destructors.
 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp, bool _Copy, bool _Move>
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, false, _Copy, _Move>
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload<_Tp, true, false, false>
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Base class implements all the constructors and assignment operators:
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload<_Tp, true, false, false>::_Optional_payload;
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(const _Optional_payload&) = default;
 397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(_Optional_payload&&) = default;
 398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Destructor needs to destroy the contained value:
 400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() { this->_M_reset(); }
 401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Common base class for _Optional_base<T> to avoid repeating these
 404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // member functions in each specialization.
 405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Dp>
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class _Optional_base_impl
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     protected:
 409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Stored_type = remove_const_t<_Tp>;
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_construct operation has !_M_engaged as a precondition
 412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // while _M_destruct has _M_engaged as a precondition.
 413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	void
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_construct(_Args&&... __args)
 416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ::new
 419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    (std::__addressof(static_cast<_Dp*>(this)->_M_payload._M_payload))
 420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Stored_type(std::forward<_Args>(__args)...);
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_cast<_Dp*>(this)->_M_payload._M_engaged = true;
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       void
 425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_destruct() noexcept
ARM GAS  /tmp/cc5nV8qb.s 			page 119


 426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { static_cast<_Dp*>(this)->_M_payload._M_destroy(); }
 427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // _M_reset is a 'safe' operation with no precondition.
 429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_reset() noexcept
 431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { static_cast<_Dp*>(this)->_M_payload._M_reset(); }
 432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr bool _M_is_engaged() const noexcept
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_get operations have _M_engaged as a precondition.
 437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() noexcept
 439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__glibcxx_assert(this->_M_is_engaged());
 441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return static_cast<_Dp*>(this)->_M_payload._M_get();
 442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() const noexcept
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__glibcxx_assert(this->_M_is_engaged());
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return static_cast<const _Dp*>(this)->_M_payload._M_get();
 449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
 453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @brief Class template that provides copy/move constructors of optional.
 454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * Such a separate base class template is necessary in order to
 456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * conditionally make copy/move constructors trivial.
 457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * When the contained value is trivially copy/move constructible,
 459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * the copy/move constructors of _Optional_base will invoke the
 460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * trivial copy/move constructor of _Optional_payload. Otherwise,
 461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * they will invoke _Optional_payload(bool, const _Optional_payload&)
 462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * or _Optional_payload(bool, _Optional_payload&&) to initialize
 463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * the contained value, if copying/moving an engaged optional.
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * Whether the other special members are trivial is determined by the
 466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * _Optional_payload<_Tp> specialization used for the _M_payload member.
 467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @see optional, _Enable_special_members
 469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     */
 470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp,
 471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	   bool = is_trivially_copy_constructible_v<_Tp>,
 472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	   bool = is_trivially_move_constructible_v<_Tp>>
 473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base
 474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
ARM GAS  /tmp/cc5nV8qb.s 			page 120


 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other)
 499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __other._M_payload)
 501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other)
 504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>)
 505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::move(__other._M_payload))
 507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, false, true>
 518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
ARM GAS  /tmp/cc5nV8qb.s 			page 121


 540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other)
 543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __other._M_payload)
 545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other) = default;
 548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, true, false>
 558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other) = default;
 583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other)
 585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>)
 586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::move(__other._M_payload))
 588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 122


 597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, true, true>
 599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other) = default;
 624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other) = default;
 625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   class optional;
 635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __converts_from_optional =
 638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       __or_<is_constructible<_Tp, const optional<_Up>&>,
 639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, optional<_Up>&>,
 640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, const optional<_Up>&&>,
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, optional<_Up>&&>,
 642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<const optional<_Up>&, _Tp>,
 643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<optional<_Up>&, _Tp>,
 644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<const optional<_Up>&&, _Tp>,
 645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<optional<_Up>&&, _Tp>>;
 646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __assigns_from_optional =
 649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       __or_<is_assignable<_Tp&, const optional<_Up>&>,
 650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, optional<_Up>&>,
 651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, const optional<_Up>&&>,
 652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, optional<_Up>&&>>;
 653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 123


 654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
 655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @brief Class template for optional values.
 656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     */
 657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class optional
 659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : private _Optional_base<_Tp>,
 660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       private _Enable_copy_move<
 661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Copy constructor.
 662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	is_copy_constructible_v<_Tp>,
 663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Copy assignment.
 664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__and_v<is_copy_constructible<_Tp>, is_copy_assignable<_Tp>>,
 665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Move constructor.
 666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	is_move_constructible_v<_Tp>,
 667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Move assignment.
 668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__and_v<is_move_constructible<_Tp>, is_move_assignable<_Tp>>,
 669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Unique tag type.
 670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional<_Tp>>
 671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_same_v<remove_cv_t<_Tp>, nullopt_t>);
 673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_same_v<remove_cv_t<_Tp>, in_place_t>);
 674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_reference_v<_Tp>);
 675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     private:
 677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Base = _Optional_base<_Tp>;
 678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // SFINAE helpers
 680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using __not_self = __not_<is_same<optional, __remove_cvref_t<_Up>>>;
 682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using __not_tag = __not_<is_same<in_place_t, __remove_cvref_t<_Up>>>;
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Cond>
 685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using _Requires = enable_if_t<__and_v<_Cond...>, bool>;
 686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     public:
 688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using value_type = _Tp;
 689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr optional() = default;
 691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr optional(nullopt_t) noexcept { }
 1482              		.loc 14 692 17 is_stmt 1 view .LVU303
 1483              	.LBB1380:
 1484              	.LBI1380:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1485              		.loc 14 602 17 view .LVU304
 1486              	.LBB1381:
 1487              	.LBI1381:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 1488              		.loc 14 302 7 view .LVU305
 1489              	.LBB1382:
 1490              	.LBI1382:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 1491              		.loc 14 110 7 view .LVU306
 1492              	.LBB1383:
 1493              	.LBB1384:
 1494              	.LBI1384:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1495              		.loc 14 199 14 view .LVU307
ARM GAS  /tmp/cc5nV8qb.s 			page 124


 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1496              		.loc 14 199 14 is_stmt 0 view .LVU308
 1497              	.LBE1384:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 1498              		.loc 14 110 7 view .LVU309
 1499 0156 8CF8F440 		strb	r4, [ip, #244]
 1500              	.LVL98:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 1501              		.loc 14 110 7 view .LVU310
 1502              	.LBE1383:
 1503              	.LBE1382:
 1504              	.LBE1381:
 1505              	.LBE1380:
 1506              	.LBE1379:
  11:MotorControl/encoder.cpp **** {
 1507              		.loc 3 11 33 view .LVU311
 1508 015a 8CF8F540 		strb	r4, [ip, #245]
 1509 015e 8CF8F640 		strb	r4, [ip, #246]
 1510 0162 8CF8F740 		strb	r4, [ip, #247]
 1511 0166 CCED4C7A 		vstr.32	s15, [ip, #304]
 1512 016a CCED4D7A 		vstr.32	s15, [ip, #308]
 1513 016e 8CF83841 		strb	r4, [ip, #312]
 1514 0172 ACF83A41 		strh	r4, [ip, #314]	@ movhi
 1515              	.LVL99:
 1516              	.LBB1385:
 1517              	.LBI1385:
 1518              		.file 15 "./Drivers/STM32/stm32_gpio.hpp"
   1:./Drivers/STM32/stm32_gpio.hpp **** #ifndef __STM32_GPIO_HPP
   2:./Drivers/STM32/stm32_gpio.hpp **** #define __STM32_GPIO_HPP
   3:./Drivers/STM32/stm32_gpio.hpp **** 
   4:./Drivers/STM32/stm32_gpio.hpp **** #include <gpio.h>
   5:./Drivers/STM32/stm32_gpio.hpp **** 
   6:./Drivers/STM32/stm32_gpio.hpp **** class Stm32Gpio {
   7:./Drivers/STM32/stm32_gpio.hpp **** public:
   8:./Drivers/STM32/stm32_gpio.hpp ****     static const Stm32Gpio none;
   9:./Drivers/STM32/stm32_gpio.hpp **** 
  10:./Drivers/STM32/stm32_gpio.hpp ****     Stm32Gpio() : port_(nullptr), pin_mask_(0) {}
 1519              		.loc 15 10 5 is_stmt 1 view .LVU312
 1520              	.LBB1386:
 1521              		.loc 15 10 46 is_stmt 0 view .LVU313
 1522 0176 CCF83C41 		str	r4, [ip, #316]
 1523 017a ACF84041 		strh	r4, [ip, #320]	@ movhi
 1524              	.LVL100:
 1525              		.loc 15 10 46 view .LVU314
 1526              	.LBE1386:
 1527              	.LBE1385:
  11:MotorControl/encoder.cpp **** {
 1528              		.loc 3 11 33 view .LVU315
 1529 017e 4FF6FF73 		movw	r3, #65535
 1530 0182 ACF84C31 		strh	r3, [ip, #332]	@ movhi
 1531              	.LVL101:
 1532              	.LBB1387:
 1533              	.LBI1387:
 1534              		.file 16 "./Drivers/STM32/stm32_spi_arbiter.hpp"
   1:./Drivers/STM32/stm32_spi_arbiter.hpp **** #ifndef __STM32_SPI_ARBITER_HPP
   2:./Drivers/STM32/stm32_spi_arbiter.hpp **** #define __STM32_SPI_ARBITER_HPP
   3:./Drivers/STM32/stm32_spi_arbiter.hpp **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 125


   4:./Drivers/STM32/stm32_spi_arbiter.hpp **** #include "stm32_gpio.hpp"
   5:./Drivers/STM32/stm32_spi_arbiter.hpp **** 
   6:./Drivers/STM32/stm32_spi_arbiter.hpp **** #include <spi.h>
   7:./Drivers/STM32/stm32_spi_arbiter.hpp **** 
   8:./Drivers/STM32/stm32_spi_arbiter.hpp **** class Stm32SpiArbiter {
   9:./Drivers/STM32/stm32_spi_arbiter.hpp **** public:
  10:./Drivers/STM32/stm32_spi_arbiter.hpp ****     struct SpiTask {
 1535              		.loc 16 10 12 is_stmt 1 view .LVU316
 1536              	.LBB1388:
 1537              	.LBB1389:
 1538              	.LBI1389:
 1539              		.loc 15 10 5 view .LVU317
 1540              	.LBB1390:
 1541              		.loc 15 10 46 is_stmt 0 view .LVU318
 1542 0186 CCF87C41 		str	r4, [ip, #380]
 1543 018a ACF88041 		strh	r4, [ip, #384]	@ movhi
 1544              	.LVL102:
 1545              		.loc 15 10 46 view .LVU319
 1546              	.LBE1390:
 1547              	.LBE1389:
 1548              		.loc 16 10 12 view .LVU320
 1549 018e 8CF89841 		strb	r4, [ip, #408]
 1550              	.LVL103:
 1551              		.loc 16 10 12 view .LVU321
 1552              	.LBE1388:
 1553              	.LBE1387:
 1554              	.LBE1364:
  13:MotorControl/encoder.cpp **** 
 1555              		.loc 3 13 1 view .LVU322
 1556 0192 6046     		mov	r0, ip
 1557 0194 03B0     		add	sp, sp, #12
 1558              	.LCFI7:
 1559              		.cfi_def_cfa_offset 20
 1560              		@ sp needed
 1561 0196 F0BD     		pop	{r4, r5, r6, r7, pc}
 1562              	.LVL104:
 1563              	.L82:
  13:MotorControl/encoder.cpp **** 
 1564              		.loc 3 13 1 view .LVU323
 1565              		.align	2
 1566              	.L81:
 1567 0198 08000000 		.word	_ZTVN10ODriveIntf11EncoderIntfE+8
 1568 019c 08000000 		.word	.LANCHOR2+8
 1569 01a0 0AD7A33C 		.word	1017370378
 1570 01a4 DB0F4942 		.word	1112084443
 1571 01a8 DB0F4941 		.word	1095307227
 1572 01ac 00007A44 		.word	1148846080
 1573 01b0 00000000 		.word	0
 1574 01b4 00000000 		.word	_ZN7Encoder18hall_edge_defaultsE
 1575              		.cfi_endproc
 1576              	.LFE5328:
 1577              		.cantunwind
 1578              		.fnend
 1580              		.global	_ZN7EncoderC1EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter
 1581              		.thumb_set _ZN7EncoderC1EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter,_ZN7EncoderC2EP
 1582              		.section	.text._ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE,"ax",%progbits
 1583              		.align	1
ARM GAS  /tmp/cc5nV8qb.s 			page 126


 1584              		.global	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
 1585              		.syntax unified
 1586              		.thumb
 1587              		.thumb_func
 1589              	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE:
 1590              		.fnstart
 1591              	.LVL105:
 1592              	.LFB5333:
  69:MotorControl/encoder.cpp ****     vel_estimate_valid_ = false;
 1593              		.loc 3 69 38 is_stmt 1 view -0
 1594              		.cfi_startproc
 1595              		@ args = 0, pretend = 0, frame = 0
 1596              		@ frame_needed = 0, uses_anonymous_args = 0
  69:MotorControl/encoder.cpp ****     vel_estimate_valid_ = false;
 1597              		.loc 3 69 38 is_stmt 0 view .LVU325
 1598 0000 10B5     		push	{r4, lr}
 1599              	.LCFI8:
 1600              		.cfi_def_cfa_offset 8
 1601              		.cfi_offset 4, -8
 1602              		.cfi_offset 14, -4
 1603 0002 0446     		mov	r4, r0
  70:MotorControl/encoder.cpp ****     pos_estimate_valid_ = false;
 1604              		.loc 3 70 5 is_stmt 1 view .LVU326
  70:MotorControl/encoder.cpp ****     pos_estimate_valid_ = false;
 1605              		.loc 3 70 25 is_stmt 0 view .LVU327
 1606 0004 0023     		movs	r3, #0
 1607 0006 80F8E930 		strb	r3, [r0, #233]
  71:MotorControl/encoder.cpp ****     error_ |= error;
 1608              		.loc 3 71 5 is_stmt 1 view .LVU328
  71:MotorControl/encoder.cpp ****     error_ |= error;
 1609              		.loc 3 71 25 is_stmt 0 view .LVU329
 1610 000a 80F8E830 		strb	r3, [r0, #232]
  72:MotorControl/encoder.cpp ****     axis_->error_ |= Axis::ERROR_ENCODER_FAILED;
 1611              		.loc 3 72 5 is_stmt 1 view .LVU330
  72:MotorControl/encoder.cpp ****     axis_->error_ |= Axis::ERROR_ENCODER_FAILED;
 1612              		.loc 3 72 15 is_stmt 0 view .LVU331
 1613 000e 8C30     		adds	r0, r0, #140
 1614              	.LVL106:
  72:MotorControl/encoder.cpp ****     axis_->error_ |= Axis::ERROR_ENCODER_FAILED;
 1615              		.loc 3 72 15 view .LVU332
 1616 0010 FFF7FEFF 		bl	_ZoRRN10ODriveIntf11EncoderIntf5ErrorES1_
 1617              	.LVL107:
  73:MotorControl/encoder.cpp **** }
 1618              		.loc 3 73 5 is_stmt 1 view .LVU333
 1619 0014 206B     		ldr	r0, [r4, #48]
  73:MotorControl/encoder.cpp **** }
 1620              		.loc 3 73 28 is_stmt 0 view .LVU334
 1621 0016 4FF48071 		mov	r1, #256
 1622 001a 00F51270 		add	r0, r0, #584
 1623 001e FFF7FEFF 		bl	_ZoRRN10ODriveIntf8AxisIntf5ErrorES1_
 1624              	.LVL108:
  74:MotorControl/encoder.cpp **** 
 1625              		.loc 3 74 1 view .LVU335
 1626 0022 10BD     		pop	{r4, pc}
  74:MotorControl/encoder.cpp **** 
 1627              		.loc 3 74 1 view .LVU336
 1628              		.cfi_endproc
ARM GAS  /tmp/cc5nV8qb.s 			page 127


 1629              	.LFE5333:
 1630              		.cantunwind
 1631              		.fnend
 1633              		.section	.text._ZN7Encoder9do_checksEv,"ax",%progbits
 1634              		.align	1
 1635              		.global	_ZN7Encoder9do_checksEv
 1636              		.syntax unified
 1637              		.thumb
 1638              		.thumb_func
 1640              	_ZN7Encoder9do_checksEv:
 1641              		.fnstart
 1642              	.LVL109:
 1643              	.LFB5334:
  76:MotorControl/encoder.cpp ****     return error_ == ERROR_NONE;
 1644              		.loc 3 76 26 is_stmt 1 view -0
 1645              		.cfi_startproc
 1646              		@ args = 0, pretend = 0, frame = 0
 1647              		@ frame_needed = 0, uses_anonymous_args = 0
 1648              		@ link register save eliminated.
  77:MotorControl/encoder.cpp **** }
 1649              		.loc 3 77 5 view .LVU338
  77:MotorControl/encoder.cpp **** }
 1650              		.loc 3 77 12 is_stmt 0 view .LVU339
 1651 0000 B0F88C00 		ldrh	r0, [r0, #140]
 1652              	.LVL110:
  78:MotorControl/encoder.cpp **** 
 1653              		.loc 3 78 1 view .LVU340
 1654 0004 B0FA80F0 		clz	r0, r0
 1655 0008 4009     		lsrs	r0, r0, #5
 1656 000a 7047     		bx	lr
 1657              		.cfi_endproc
 1658              	.LFE5334:
 1659              		.cantunwind
 1660              		.fnend
 1662              		.section	.text._ZN7Encoder17set_idx_subscribeEb,"ax",%progbits
 1663              		.align	1
 1664              		.global	_ZN7Encoder17set_idx_subscribeEb
 1665              		.syntax unified
 1666              		.thumb
 1667              		.thumb_func
 1669              	_ZN7Encoder17set_idx_subscribeEb:
 1670              		.fnstart
 1671              	.LVL111:
 1672              	.LFB5336:
 110:MotorControl/encoder.cpp ****     if (config_.use_index && (override_enable || !config_.find_idx_on_lockin_only)) {
 1673              		.loc 3 110 55 is_stmt 1 view -0
 1674              		.cfi_startproc
 1675              		@ args = 0, pretend = 0, frame = 0
 1676              		@ frame_needed = 0, uses_anonymous_args = 0
 110:MotorControl/encoder.cpp ****     if (config_.use_index && (override_enable || !config_.find_idx_on_lockin_only)) {
 1677              		.loc 3 110 55 is_stmt 0 view .LVU342
 1678 0000 00B5     		push	{lr}
 1679              		.save {lr}
 1680              	.LCFI9:
 1681              		.cfi_def_cfa_offset 4
 1682              		.cfi_offset 14, -4
 1683              		.pad #12
ARM GAS  /tmp/cc5nV8qb.s 			page 128


 1684 0002 83B0     		sub	sp, sp, #12
 1685              	.LCFI10:
 1686              		.cfi_def_cfa_offset 16
 111:MotorControl/encoder.cpp ****         if (!index_gpio_.subscribe(true, false, enc_index_cb_wrapper, this)) {
 1687              		.loc 3 111 5 is_stmt 1 view .LVU343
 111:MotorControl/encoder.cpp ****         if (!index_gpio_.subscribe(true, false, enc_index_cb_wrapper, this)) {
 1688              		.loc 3 111 17 is_stmt 0 view .LVU344
 1689 0004 90F85830 		ldrb	r3, [r0, #88]	@ zero_extendqisi2
 111:MotorControl/encoder.cpp ****         if (!index_gpio_.subscribe(true, false, enc_index_cb_wrapper, this)) {
 1690              		.loc 3 111 5 view .LVU345
 1691 0008 83B1     		cbz	r3, .L87
 111:MotorControl/encoder.cpp ****         if (!index_gpio_.subscribe(true, false, enc_index_cb_wrapper, this)) {
 1692              		.loc 3 111 27 discriminator 1 view .LVU346
 1693 000a 11B9     		cbnz	r1, .L88
 111:MotorControl/encoder.cpp ****         if (!index_gpio_.subscribe(true, false, enc_index_cb_wrapper, this)) {
 1694              		.loc 3 111 59 discriminator 2 view .LVU347
 1695 000c 90F86220 		ldrb	r2, [r0, #98]	@ zero_extendqisi2
 111:MotorControl/encoder.cpp ****         if (!index_gpio_.subscribe(true, false, enc_index_cb_wrapper, this)) {
 1696              		.loc 3 111 47 discriminator 2 view .LVU348
 1697 0010 62B9     		cbnz	r2, .L87
 1698              	.L88:
 112:MotorControl/encoder.cpp ****             odrv.misconfigured_ = true;
 1699              		.loc 3 112 9 is_stmt 1 view .LVU349
 112:MotorControl/encoder.cpp ****             odrv.misconfigured_ = true;
 1700              		.loc 3 112 35 is_stmt 0 view .LVU350
 1701 0012 0090     		str	r0, [sp]
 1702 0014 0A4B     		ldr	r3, .L92
 1703 0016 0022     		movs	r2, #0
 1704 0018 0121     		movs	r1, #1
 1705              	.LVL112:
 112:MotorControl/encoder.cpp ****             odrv.misconfigured_ = true;
 1706              		.loc 3 112 35 view .LVU351
 1707 001a 0C30     		adds	r0, r0, #12
 1708              	.LVL113:
 112:MotorControl/encoder.cpp ****             odrv.misconfigured_ = true;
 1709              		.loc 3 112 35 view .LVU352
 1710 001c FFF7FEFF 		bl	_ZN9Stm32Gpio9subscribeEbbPFvPvES0_
 1711              	.LVL114:
 112:MotorControl/encoder.cpp ****             odrv.misconfigured_ = true;
 1712              		.loc 3 112 9 view .LVU353
 1713 0020 58B9     		cbnz	r0, .L86
 113:MotorControl/encoder.cpp ****         }
 1714              		.loc 3 113 13 is_stmt 1 view .LVU354
 113:MotorControl/encoder.cpp ****         }
 1715              		.loc 3 113 33 is_stmt 0 view .LVU355
 1716 0022 084B     		ldr	r3, .L92+4
 1717 0024 0122     		movs	r2, #1
 1718 0026 83F8CC22 		strb	r2, [r3, #716]
 1719 002a 06E0     		b	.L86
 1720              	.LVL115:
 1721              	.L87:
 115:MotorControl/encoder.cpp ****         index_gpio_.unsubscribe();
 1722              		.loc 3 115 12 is_stmt 1 view .LVU356
 1723 002c 13B1     		cbz	r3, .L90
 115:MotorControl/encoder.cpp ****         index_gpio_.unsubscribe();
 1724              		.loc 3 115 46 is_stmt 0 discriminator 1 view .LVU357
 1725 002e 90F86230 		ldrb	r3, [r0, #98]	@ zero_extendqisi2
ARM GAS  /tmp/cc5nV8qb.s 			page 129


 115:MotorControl/encoder.cpp ****         index_gpio_.unsubscribe();
 1726              		.loc 3 115 35 discriminator 1 view .LVU358
 1727 0032 13B1     		cbz	r3, .L86
 1728              	.L90:
 116:MotorControl/encoder.cpp ****     }
 1729              		.loc 3 116 9 is_stmt 1 view .LVU359
 116:MotorControl/encoder.cpp ****     }
 1730              		.loc 3 116 32 is_stmt 0 view .LVU360
 1731 0034 0C30     		adds	r0, r0, #12
 1732              	.LVL116:
 116:MotorControl/encoder.cpp ****     }
 1733              		.loc 3 116 32 view .LVU361
 1734 0036 FFF7FEFF 		bl	_ZN9Stm32Gpio11unsubscribeEv
 1735              	.LVL117:
 1736              	.L86:
 118:MotorControl/encoder.cpp **** 
 1737              		.loc 3 118 1 view .LVU362
 1738 003a 03B0     		add	sp, sp, #12
 1739              	.LCFI11:
 1740              		.cfi_def_cfa_offset 4
 1741              		@ sp needed
 1742 003c 5DF804FB 		ldr	pc, [sp], #4
 1743              	.L93:
 1744              		.align	2
 1745              	.L92:
 1746 0040 00000000 		.word	_ZL20enc_index_cb_wrapperPv
 1747 0044 00400000 		.word	odrv+16384
 1748              		.cfi_endproc
 1749              	.LFE5336:
 1750              		.fnend
 1752              		.section	.text._ZN7Encoder16update_pll_gainsEv,"ax",%progbits
 1753              		.align	1
 1754              		.global	_ZN7Encoder16update_pll_gainsEv
 1755              		.syntax unified
 1756              		.thumb
 1757              		.thumb_func
 1759              	_ZN7Encoder16update_pll_gainsEv:
 1760              		.fnstart
 1761              	.LVL118:
 1762              	.LFB5337:
 120:MotorControl/encoder.cpp ****     pll_kp_ = 2.0f * config_.bandwidth;  // basic conversion to discrete time
 1763              		.loc 3 120 34 is_stmt 1 view -0
 1764              		.cfi_startproc
 1765              		@ args = 0, pretend = 0, frame = 0
 1766              		@ frame_needed = 0, uses_anonymous_args = 0
 121:MotorControl/encoder.cpp ****     pll_ki_ = 0.25f * (pll_kp_ * pll_kp_); // Critically damped
 1767              		.loc 3 121 5 view .LVU364
 121:MotorControl/encoder.cpp ****     pll_ki_ = 0.25f * (pll_kp_ * pll_kp_); // Critically damped
 1768              		.loc 3 121 30 is_stmt 0 view .LVU365
 1769 0000 D0ED117A 		vldr.32	s15, [r0, #68]
 121:MotorControl/encoder.cpp ****     pll_ki_ = 0.25f * (pll_kp_ * pll_kp_); // Critically damped
 1770              		.loc 3 121 20 view .LVU366
 1771 0004 77EEA77A 		vadd.f32	s15, s15, s15
 121:MotorControl/encoder.cpp ****     pll_ki_ = 0.25f * (pll_kp_ * pll_kp_); // Critically damped
 1772              		.loc 3 121 13 view .LVU367
 1773 0008 C0ED2F7A 		vstr.32	s15, [r0, #188]
 122:MotorControl/encoder.cpp **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 130


 1774              		.loc 3 122 5 is_stmt 1 view .LVU368
 122:MotorControl/encoder.cpp **** 
 1775              		.loc 3 122 32 is_stmt 0 view .LVU369
 1776 000c 27EEA77A 		vmul.f32	s14, s15, s15
 122:MotorControl/encoder.cpp **** 
 1777              		.loc 3 122 21 view .LVU370
 1778 0010 F5EE006A 		vmov.f32	s13, #2.5e-1
 1779 0014 27EE267A 		vmul.f32	s14, s14, s13
 122:MotorControl/encoder.cpp **** 
 1780              		.loc 3 122 13 view .LVU371
 1781 0018 80ED307A 		vstr.32	s14, [r0, #192]
 125:MotorControl/encoder.cpp ****         set_error(ERROR_UNSTABLE_GAIN);
 1782              		.loc 3 125 5 is_stmt 1 view .LVU372
 125:MotorControl/encoder.cpp ****         set_error(ERROR_UNSTABLE_GAIN);
 1783              		.loc 3 125 31 is_stmt 0 view .LVU373
 1784 001c 9FED087A 		vldr.32	s14, .L101
 1785 0020 67EE877A 		vmul.f32	s15, s15, s14
 125:MotorControl/encoder.cpp ****         set_error(ERROR_UNSTABLE_GAIN);
 1786              		.loc 3 125 5 view .LVU374
 1787 0024 B7EE007A 		vmov.f32	s14, #1.0e+0
 1788 0028 F4EEC77A 		vcmpe.f32	s15, s14
 1789 002c F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 1790 0030 00D5     		bpl	.L100
 1791 0032 7047     		bx	lr
 1792              	.L100:
 120:MotorControl/encoder.cpp ****     pll_kp_ = 2.0f * config_.bandwidth;  // basic conversion to discrete time
 1793              		.loc 3 120 34 view .LVU375
 1794 0034 08B5     		push	{r3, lr}
 1795              	.LCFI12:
 1796              		.cfi_def_cfa_offset 8
 1797              		.cfi_offset 3, -8
 1798              		.cfi_offset 14, -4
 126:MotorControl/encoder.cpp ****     }
 1799              		.loc 3 126 9 is_stmt 1 view .LVU376
 126:MotorControl/encoder.cpp ****     }
 1800              		.loc 3 126 18 is_stmt 0 view .LVU377
 1801 0036 0121     		movs	r1, #1
 1802 0038 FFF7FEFF 		bl	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
 1803              	.LVL119:
 128:MotorControl/encoder.cpp **** 
 1804              		.loc 3 128 1 view .LVU378
 1805 003c 08BD     		pop	{r3, pc}
 1806              	.L102:
 1807 003e 00BF     		.align	2
 1808              	.L101:
 1809 0040 6F120339 		.word	956502639
 1810              		.cfi_endproc
 1811              	.LFE5337:
 1812              		.cantunwind
 1813              		.fnend
 1815              		.section	.text._ZN7Encoder12apply_configEN10ODriveIntf9MotorIntf9MotorTypeE,"ax",%progbits
 1816              		.align	1
 1817              		.global	_ZN7Encoder12apply_configEN10ODriveIntf9MotorIntf9MotorTypeE
 1818              		.syntax unified
 1819              		.thumb
 1820              		.thumb_func
 1822              	_ZN7Encoder12apply_configEN10ODriveIntf9MotorIntf9MotorTypeE:
ARM GAS  /tmp/cc5nV8qb.s 			page 131


 1823              		.fnstart
 1824              	.LVL120:
 1825              	.LFB5331:
  19:MotorControl/encoder.cpp ****     config_.parent = this;
 1826              		.loc 3 19 73 is_stmt 1 view -0
 1827              		.cfi_startproc
 1828              		@ args = 0, pretend = 0, frame = 0
 1829              		@ frame_needed = 0, uses_anonymous_args = 0
  19:MotorControl/encoder.cpp ****     config_.parent = this;
 1830              		.loc 3 19 73 is_stmt 0 view .LVU380
 1831 0000 38B5     		push	{r3, r4, r5, lr}
 1832              	.LCFI13:
 1833              		.cfi_def_cfa_offset 16
 1834              		.cfi_offset 3, -16
 1835              		.cfi_offset 4, -12
 1836              		.cfi_offset 5, -8
 1837              		.cfi_offset 14, -4
 1838 0002 0446     		mov	r4, r0
 1839 0004 0D46     		mov	r5, r1
  20:MotorControl/encoder.cpp **** 
 1840              		.loc 3 20 5 is_stmt 1 view .LVU381
  20:MotorControl/encoder.cpp **** 
 1841              		.loc 3 20 20 is_stmt 0 view .LVU382
 1842 0006 C0F88800 		str	r0, [r0, #136]
  22:MotorControl/encoder.cpp **** 
 1843              		.loc 3 22 5 is_stmt 1 view .LVU383
  22:MotorControl/encoder.cpp **** 
 1844              		.loc 3 22 21 is_stmt 0 view .LVU384
 1845 000a FFF7FEFF 		bl	_ZN7Encoder16update_pll_gainsEv
 1846              	.LVL121:
  24:MotorControl/encoder.cpp ****         if (config_.mode == Encoder::MODE_HALL && config_.hall_polarity_calibrated)
 1847              		.loc 3 24 5 is_stmt 1 view .LVU385
  24:MotorControl/encoder.cpp ****         if (config_.mode == Encoder::MODE_HALL && config_.hall_polarity_calibrated)
 1848              		.loc 3 24 17 is_stmt 0 view .LVU386
 1849 000e 94F85930 		ldrb	r3, [r4, #89]	@ zero_extendqisi2
  24:MotorControl/encoder.cpp ****         if (config_.mode == Encoder::MODE_HALL && config_.hall_polarity_calibrated)
 1850              		.loc 3 24 5 view .LVU387
 1851 0012 33B1     		cbz	r3, .L104
  25:MotorControl/encoder.cpp ****             is_ready_ = true;
 1852              		.loc 3 25 9 is_stmt 1 view .LVU388
  25:MotorControl/encoder.cpp ****             is_ready_ = true;
 1853              		.loc 3 25 21 is_stmt 0 view .LVU389
 1854 0014 A38E     		ldrh	r3, [r4, #52]
  25:MotorControl/encoder.cpp ****             is_ready_ = true;
 1855              		.loc 3 25 9 view .LVU390
 1856 0016 012B     		cmp	r3, #1
 1857 0018 05D0     		beq	.L108
 1858              	.L105:
  27:MotorControl/encoder.cpp ****             is_ready_ = true;
 1859              		.loc 3 27 9 is_stmt 1 view .LVU391
 1860 001a 022B     		cmp	r3, #2
 1861 001c 0BD0     		beq	.L109
 1862              	.L106:
  29:MotorControl/encoder.cpp ****             is_ready_ = true;
 1863              		.loc 3 29 9 view .LVU392
 1864 001e 032D     		cmp	r5, #3
 1865 0020 0DD0     		beq	.L110
ARM GAS  /tmp/cc5nV8qb.s 			page 132


 1866              	.L104:
  33:MotorControl/encoder.cpp **** }
 1867              		.loc 3 33 5 view .LVU393
  34:MotorControl/encoder.cpp **** 
 1868              		.loc 3 34 1 is_stmt 0 view .LVU394
 1869 0022 0120     		movs	r0, #1
 1870 0024 38BD     		pop	{r3, r4, r5, pc}
 1871              	.LVL122:
 1872              	.L108:
  25:MotorControl/encoder.cpp ****             is_ready_ = true;
 1873              		.loc 3 25 59 discriminator 1 view .LVU395
 1874 0026 94F86520 		ldrb	r2, [r4, #101]	@ zero_extendqisi2
  25:MotorControl/encoder.cpp ****             is_ready_ = true;
 1875              		.loc 3 25 48 discriminator 1 view .LVU396
 1876 002a 002A     		cmp	r2, #0
 1877 002c F5D0     		beq	.L105
  26:MotorControl/encoder.cpp ****         if (config_.mode == Encoder::MODE_SINCOS)
 1878              		.loc 3 26 13 is_stmt 1 view .LVU397
  26:MotorControl/encoder.cpp ****         if (config_.mode == Encoder::MODE_SINCOS)
 1879              		.loc 3 26 23 is_stmt 0 view .LVU398
 1880 002e 0122     		movs	r2, #1
 1881 0030 84F88F20 		strb	r2, [r4, #143]
 1882 0034 F1E7     		b	.L105
 1883              	.L109:
  28:MotorControl/encoder.cpp ****         if (motor_type == Motor::MOTOR_TYPE_ACIM)
 1884              		.loc 3 28 13 is_stmt 1 view .LVU399
  28:MotorControl/encoder.cpp ****         if (motor_type == Motor::MOTOR_TYPE_ACIM)
 1885              		.loc 3 28 23 is_stmt 0 view .LVU400
 1886 0036 0123     		movs	r3, #1
 1887 0038 84F88F30 		strb	r3, [r4, #143]
 1888 003c EFE7     		b	.L106
 1889              	.L110:
  30:MotorControl/encoder.cpp ****     }
 1890              		.loc 3 30 13 is_stmt 1 view .LVU401
  30:MotorControl/encoder.cpp ****     }
 1891              		.loc 3 30 23 is_stmt 0 view .LVU402
 1892 003e 0123     		movs	r3, #1
 1893 0040 84F88F30 		strb	r3, [r4, #143]
 1894 0044 EDE7     		b	.L104
 1895              		.cfi_endproc
 1896              	.LFE5331:
 1897              		.cantunwind
 1898              		.fnend
 1900              		.section	.text._ZN7Encoder20check_pre_calibratedEv,"ax",%progbits
 1901              		.align	1
 1902              		.global	_ZN7Encoder20check_pre_calibratedEv
 1903              		.syntax unified
 1904              		.thumb
 1905              		.thumb_func
 1907              	_ZN7Encoder20check_pre_calibratedEv:
 1908              		.fnstart
 1909              	.LVL123:
 1910              	.LFB5338:
 130:MotorControl/encoder.cpp ****     // TODO: restoring config from python backup is fragile here (ACIM motor type must be set first
 1911              		.loc 3 130 38 is_stmt 1 view -0
 1912              		.cfi_startproc
 1913              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/cc5nV8qb.s 			page 133


 1914              		@ frame_needed = 0, uses_anonymous_args = 0
 1915              		@ link register save eliminated.
 132:MotorControl/encoder.cpp ****         if (!is_ready_)
 1916              		.loc 3 132 5 view .LVU404
 132:MotorControl/encoder.cpp ****         if (!is_ready_)
 1917              		.loc 3 132 9 is_stmt 0 view .LVU405
 1918 0000 036B     		ldr	r3, [r0, #48]
 132:MotorControl/encoder.cpp ****         if (!is_ready_)
 1919              		.loc 3 132 16 view .LVU406
 1920 0002 D3F85831 		ldr	r3, [r3, #344]
 132:MotorControl/encoder.cpp ****         if (!is_ready_)
 1921              		.loc 3 132 31 view .LVU407
 1922 0006 93F83830 		ldrb	r3, [r3, #56]	@ zero_extendqisi2
 132:MotorControl/encoder.cpp ****         if (!is_ready_)
 1923              		.loc 3 132 5 view .LVU408
 1924 000a 032B     		cmp	r3, #3
 1925 000c 0CD0     		beq	.L111
 133:MotorControl/encoder.cpp ****             config_.pre_calibrated = false;
 1926              		.loc 3 133 9 is_stmt 1 view .LVU409
 133:MotorControl/encoder.cpp ****             config_.pre_calibrated = false;
 1927              		.loc 3 133 14 is_stmt 0 view .LVU410
 1928 000e 90F88F30 		ldrb	r3, [r0, #143]	@ zero_extendqisi2
 133:MotorControl/encoder.cpp ****             config_.pre_calibrated = false;
 1929              		.loc 3 133 9 view .LVU411
 1930 0012 0BB9     		cbnz	r3, .L113
 134:MotorControl/encoder.cpp ****         if (mode_ == MODE_INCREMENTAL && !index_found_)
 1931              		.loc 3 134 13 is_stmt 1 view .LVU412
 134:MotorControl/encoder.cpp ****         if (mode_ == MODE_INCREMENTAL && !index_found_)
 1932              		.loc 3 134 36 is_stmt 0 view .LVU413
 1933 0014 80F85930 		strb	r3, [r0, #89]
 1934              	.L113:
 135:MotorControl/encoder.cpp ****             config_.pre_calibrated = false;
 1935              		.loc 3 135 9 is_stmt 1 view .LVU414
 135:MotorControl/encoder.cpp ****             config_.pre_calibrated = false;
 1936              		.loc 3 135 13 is_stmt 0 view .LVU415
 1937 0018 B0F83A31 		ldrh	r3, [r0, #314]
 135:MotorControl/encoder.cpp ****             config_.pre_calibrated = false;
 1938              		.loc 3 135 9 view .LVU416
 1939 001c 23B9     		cbnz	r3, .L111
 135:MotorControl/encoder.cpp ****             config_.pre_calibrated = false;
 1940              		.loc 3 135 43 discriminator 1 view .LVU417
 1941 001e 90F88E30 		ldrb	r3, [r0, #142]	@ zero_extendqisi2
 135:MotorControl/encoder.cpp ****             config_.pre_calibrated = false;
 1942              		.loc 3 135 39 discriminator 1 view .LVU418
 1943 0022 0BB9     		cbnz	r3, .L111
 136:MotorControl/encoder.cpp ****     }
 1944              		.loc 3 136 13 is_stmt 1 view .LVU419
 136:MotorControl/encoder.cpp ****     }
 1945              		.loc 3 136 36 is_stmt 0 view .LVU420
 1946 0024 80F85930 		strb	r3, [r0, #89]
 1947              	.L111:
 138:MotorControl/encoder.cpp **** 
 1948              		.loc 3 138 1 view .LVU421
 1949 0028 7047     		bx	lr
 1950              		.cfi_endproc
 1951              	.LFE5338:
 1952              		.cantunwind
ARM GAS  /tmp/cc5nV8qb.s 			page 134


 1953              		.fnend
 1955              		.section	.text._ZN7Encoder18set_circular_countElb,"ax",%progbits
 1956              		.align	1
 1957              		.global	_ZN7Encoder18set_circular_countElb
 1958              		.syntax unified
 1959              		.thumb
 1960              		.thumb_func
 1962              	_ZN7Encoder18set_circular_countElb:
 1963              		.fnstart
 1964              	.LVL124:
 1965              	.LFB5340:
 158:MotorControl/encoder.cpp ****     // Disable interrupts to make a critical section to avoid race condition
 1966              		.loc 3 158 69 is_stmt 1 view -0
 1967              		.cfi_startproc
 1968              		@ args = 0, pretend = 0, frame = 0
 1969              		@ frame_needed = 0, uses_anonymous_args = 0
 158:MotorControl/encoder.cpp ****     // Disable interrupts to make a critical section to avoid race condition
 1970              		.loc 3 158 69 is_stmt 0 view .LVU423
 1971 0000 00B5     		push	{lr}
 1972              	.LCFI14:
 1973              		.cfi_def_cfa_offset 4
 1974              		.cfi_offset 14, -4
 160:MotorControl/encoder.cpp **** 
 1975              		.loc 3 160 5 is_stmt 1 view .LVU424
 1976              	.LBB1391:
 1977              	.LBI1391:
  31:./Drivers/STM32/stm32_system.h ****     uint32_t primask = __get_PRIMASK();
 1978              		.loc 4 31 24 view .LVU425
 1979              	.LBB1392:
  32:./Drivers/STM32/stm32_system.h ****     __disable_irq();
 1980              		.loc 4 32 5 view .LVU426
 1981              	.LBB1393:
 1982              	.LBI1393:
 382:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 1983              		.loc 5 382 31 view .LVU427
 1984              	.LBB1394:
 384:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 1985              		.loc 5 384 3 view .LVU428
 386:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 1986              		.loc 5 386 3 view .LVU429
 1987              		.syntax unified
 1988              	@ 386 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 1989 0002 EFF3108C 		MRS ip, primask
 1990              	@ 0 "" 2
 1991              	.LVL125:
 387:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 1992              		.loc 5 387 3 view .LVU430
 387:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 1993              		.loc 5 387 3 is_stmt 0 view .LVU431
 1994              		.thumb
 1995              		.syntax unified
 1996              	.LBE1394:
 1997              	.LBE1393:
  33:./Drivers/STM32/stm32_system.h ****     return primask;
 1998              		.loc 4 33 5 is_stmt 1 view .LVU432
 1999              	.LBB1395:
 2000              	.LBI1395:
ARM GAS  /tmp/cc5nV8qb.s 			page 135


 140:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 2001              		.loc 5 140 27 view .LVU433
 2002              	.LBB1396:
 142:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 2003              		.loc 5 142 3 view .LVU434
 2004              		.syntax unified
 2005              	@ 142 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 2006 0006 72B6     		cpsid i
 2007              	@ 0 "" 2
 2008              		.thumb
 2009              		.syntax unified
 2010              	.LBE1396:
 2011              	.LBE1395:
  34:./Drivers/STM32/stm32_system.h **** }
 2012              		.loc 4 34 5 view .LVU435
 2013              	.LVL126:
  34:./Drivers/STM32/stm32_system.h **** }
 2014              		.loc 4 34 5 is_stmt 0 view .LVU436
 2015              	.LBE1392:
 2016              	.LBE1391:
 162:MotorControl/encoder.cpp ****         config_.phase_offset += count - count_in_cpr_;
 2017              		.loc 3 162 5 is_stmt 1 view .LVU437
 2018 0008 6AB1     		cbz	r2, .L115
 163:MotorControl/encoder.cpp ****         config_.phase_offset = mod(config_.phase_offset, config_.cpr);
 2019              		.loc 3 163 9 view .LVU438
 163:MotorControl/encoder.cpp ****         config_.phase_offset = mod(config_.phase_offset, config_.cpr);
 2020              		.loc 3 163 41 is_stmt 0 view .LVU439
 2021 000a D0F89430 		ldr	r3, [r0, #148]
 163:MotorControl/encoder.cpp ****         config_.phase_offset = mod(config_.phase_offset, config_.cpr);
 2022              		.loc 3 163 39 view .LVU440
 2023 000e CB1A     		subs	r3, r1, r3
 163:MotorControl/encoder.cpp ****         config_.phase_offset = mod(config_.phase_offset, config_.cpr);
 2024              		.loc 3 163 30 view .LVU441
 2025 0010 826C     		ldr	r2, [r0, #72]
 2026              	.LVL127:
 163:MotorControl/encoder.cpp ****         config_.phase_offset = mod(config_.phase_offset, config_.cpr);
 2027              		.loc 3 163 30 view .LVU442
 2028 0012 1344     		add	r3, r3, r2
 2029 0014 8364     		str	r3, [r0, #72]
 164:MotorControl/encoder.cpp ****     }
 2030              		.loc 3 164 9 is_stmt 1 view .LVU443
 164:MotorControl/encoder.cpp ****     }
 2031              		.loc 3 164 66 is_stmt 0 view .LVU444
 2032 0016 026D     		ldr	r2, [r0, #80]
 2033              	.LVL128:
 2034              	.LBB1397:
 2035              	.LBI1397:
 2036              		.file 17 "./MotorControl/utils.hpp"
   1:./MotorControl/utils.hpp **** #pragma once
   2:./MotorControl/utils.hpp **** 
   3:./MotorControl/utils.hpp **** #include <stdint.h>
   4:./MotorControl/utils.hpp **** #include <limits>
   5:./MotorControl/utils.hpp **** #include <algorithm>
   6:./MotorControl/utils.hpp **** #include <array>
   7:./MotorControl/utils.hpp **** #include <tuple>
   8:./MotorControl/utils.hpp **** #include <cmath>
   9:./MotorControl/utils.hpp **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 136


  10:./MotorControl/utils.hpp **** /**
  11:./MotorControl/utils.hpp ****  * @brief Flash size register address
  12:./MotorControl/utils.hpp ****  */
  13:./MotorControl/utils.hpp **** #define ID_FLASH_ADDRESS (0x1FFF7A22)
  14:./MotorControl/utils.hpp **** 
  15:./MotorControl/utils.hpp **** /**
  16:./MotorControl/utils.hpp ****  * @brief Device ID register address
  17:./MotorControl/utils.hpp ****  */
  18:./MotorControl/utils.hpp **** #define ID_DBGMCU_IDCODE (0xE0042000)
  19:./MotorControl/utils.hpp **** 
  20:./MotorControl/utils.hpp **** /**
  21:./MotorControl/utils.hpp ****  * "Returns" the device signature
  22:./MotorControl/utils.hpp ****  *
  23:./MotorControl/utils.hpp ****  * Possible returns:
  24:./MotorControl/utils.hpp ****  *    - 0x0413: STM32F405xx/07xx and STM32F415xx/17xx)
  25:./MotorControl/utils.hpp ****  *    - 0x0419: STM32F42xxx and STM32F43xxx
  26:./MotorControl/utils.hpp ****  *    - 0x0423: STM32F401xB/C
  27:./MotorControl/utils.hpp ****  *    - 0x0433: STM32F401xD/E
  28:./MotorControl/utils.hpp ****  *    - 0x0431: STM32F411xC/E
  29:./MotorControl/utils.hpp ****  *
  30:./MotorControl/utils.hpp ****  * Returned data is in 16-bit mode, but only bits 11:0 are valid, bits 15:12 are always 0.
  31:./MotorControl/utils.hpp ****  * Defined as macro
  32:./MotorControl/utils.hpp ****  */
  33:./MotorControl/utils.hpp **** #define STM_ID_GetSignature() ((*(uint16_t *)(ID_DBGMCU_IDCODE)) & 0x0FFF)
  34:./MotorControl/utils.hpp **** 
  35:./MotorControl/utils.hpp **** /**
  36:./MotorControl/utils.hpp ****  * "Returns" the device revision
  37:./MotorControl/utils.hpp ****  *
  38:./MotorControl/utils.hpp ****  * Revisions possible:
  39:./MotorControl/utils.hpp ****  *    - 0x1000: Revision A
  40:./MotorControl/utils.hpp ****  *    - 0x1001: Revision Z
  41:./MotorControl/utils.hpp ****  *    - 0x1003: Revision Y
  42:./MotorControl/utils.hpp ****  *    - 0x1007: Revision 1
  43:./MotorControl/utils.hpp ****  *    - 0x2001: Revision 3
  44:./MotorControl/utils.hpp ****  *
  45:./MotorControl/utils.hpp ****  * Returned data is in 16-bit mode.
  46:./MotorControl/utils.hpp ****  */
  47:./MotorControl/utils.hpp **** #define STM_ID_GetRevision() (*(uint16_t *)(ID_DBGMCU_IDCODE + 2))
  48:./MotorControl/utils.hpp **** 
  49:./MotorControl/utils.hpp **** /**
  50:./MotorControl/utils.hpp **** * "Returns" the Flash size
  51:./MotorControl/utils.hpp **** *
  52:./MotorControl/utils.hpp **** * Returned data is in 16-bit mode, returned value is flash size in kB (kilo bytes).
  53:./MotorControl/utils.hpp **** */
  54:./MotorControl/utils.hpp **** #define STM_ID_GetFlashSize() (*(uint16_t *)(ID_FLASH_ADDRESS))
  55:./MotorControl/utils.hpp **** 
  56:./MotorControl/utils.hpp **** #ifdef M_PI
  57:./MotorControl/utils.hpp **** #undef M_PI
  58:./MotorControl/utils.hpp **** #endif
  59:./MotorControl/utils.hpp **** 
  60:./MotorControl/utils.hpp **** // Math Constants
  61:./MotorControl/utils.hpp **** constexpr float M_PI = 3.14159265358979323846f;
  62:./MotorControl/utils.hpp **** constexpr float one_by_sqrt3 = 0.57735026919f;
  63:./MotorControl/utils.hpp **** constexpr float two_by_sqrt3 = 1.15470053838f;
  64:./MotorControl/utils.hpp **** constexpr float sqrt3_by_2 = 0.86602540378f;
  65:./MotorControl/utils.hpp **** 
  66:./MotorControl/utils.hpp **** // Function prototypes for implementations in utils.cpp
ARM GAS  /tmp/cc5nV8qb.s 			page 137


  67:./MotorControl/utils.hpp **** std::tuple<float, float, float, bool> SVM(float alpha, float beta);
  68:./MotorControl/utils.hpp **** float fast_atan2(float y, float x);
  69:./MotorControl/utils.hpp **** uint32_t deadline_to_timeout(uint32_t deadline_ms);
  70:./MotorControl/utils.hpp **** uint32_t timeout_to_deadline(uint32_t timeout_ms);
  71:./MotorControl/utils.hpp **** int is_in_the_future(uint32_t time_ms);
  72:./MotorControl/utils.hpp **** uint32_t micros(void);
  73:./MotorControl/utils.hpp **** void delay_us(uint32_t us);
  74:./MotorControl/utils.hpp **** 
  75:./MotorControl/utils.hpp **** extern "C" {
  76:./MotorControl/utils.hpp **** float our_arm_sin_f32(float x);
  77:./MotorControl/utils.hpp **** float our_arm_cos_f32(float x);
  78:./MotorControl/utils.hpp **** }
  79:./MotorControl/utils.hpp **** 
  80:./MotorControl/utils.hpp **** // ----------------
  81:./MotorControl/utils.hpp **** // Inline functions
  82:./MotorControl/utils.hpp **** 
  83:./MotorControl/utils.hpp **** template<typename T>
  84:./MotorControl/utils.hpp **** constexpr T SQ(const T& x){
  85:./MotorControl/utils.hpp ****     return x * x;
  86:./MotorControl/utils.hpp **** }
  87:./MotorControl/utils.hpp **** 
  88:./MotorControl/utils.hpp **** /**
  89:./MotorControl/utils.hpp ****  * @brief Small helper to make array with known size
  90:./MotorControl/utils.hpp ****  * in contrast to initializer lists the number of arguments
  91:./MotorControl/utils.hpp ****  * has to match exactly. Whereas initializer lists allow
  92:./MotorControl/utils.hpp ****  * less arguments.
  93:./MotorControl/utils.hpp ****  */
  94:./MotorControl/utils.hpp **** template <class T, class... Tail>
  95:./MotorControl/utils.hpp **** std::array<T, 1 + sizeof...(Tail)> make_array(T head, Tail... tail) {
  96:./MotorControl/utils.hpp ****     return std::array<T, 1 + sizeof...(Tail)>({head, tail...});
  97:./MotorControl/utils.hpp **** }
  98:./MotorControl/utils.hpp **** 
  99:./MotorControl/utils.hpp **** // To allow use of -ffast-math we need to have a special check for nan
 100:./MotorControl/utils.hpp **** // that bypasses the "ignore nan" flag
 101:./MotorControl/utils.hpp **** __attribute__((optimize("-fno-finite-math-only")))
 102:./MotorControl/utils.hpp **** inline bool is_nan(float x) {
 103:./MotorControl/utils.hpp ****     return __builtin_isnan(x);
 104:./MotorControl/utils.hpp **** }
 105:./MotorControl/utils.hpp **** 
 106:./MotorControl/utils.hpp **** // Round to integer
 107:./MotorControl/utils.hpp **** // Default rounding mode: round to nearest
 108:./MotorControl/utils.hpp **** inline int round_int(float x) {
 109:./MotorControl/utils.hpp **** #ifdef __arm__
 110:./MotorControl/utils.hpp ****     int res;
 111:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 112:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 113:./MotorControl/utils.hpp ****         : [x] "w" (x) );
 114:./MotorControl/utils.hpp ****     return res;
 115:./MotorControl/utils.hpp **** #else
 116:./MotorControl/utils.hpp ****     return (int)nearbyint(x);
 117:./MotorControl/utils.hpp **** #endif
 118:./MotorControl/utils.hpp **** }
 119:./MotorControl/utils.hpp **** 
 120:./MotorControl/utils.hpp **** // Wrap value to range.
 121:./MotorControl/utils.hpp **** // With default rounding mode (round to nearest),
 122:./MotorControl/utils.hpp **** // the result will be in range -y/2 to y/2
 123:./MotorControl/utils.hpp **** inline float wrap_pm(float x, float y) {
ARM GAS  /tmp/cc5nV8qb.s 			page 138


 124:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 125:./MotorControl/utils.hpp ****     float intval = (float)round_int(x / y);
 126:./MotorControl/utils.hpp **** #else
 127:./MotorControl/utils.hpp ****     float intval = nearbyintf(x / y);
 128:./MotorControl/utils.hpp **** #endif
 129:./MotorControl/utils.hpp ****     return x - intval * y;
 130:./MotorControl/utils.hpp **** }
 131:./MotorControl/utils.hpp **** 
 132:./MotorControl/utils.hpp **** // Same as fmodf but result is positive and y must be positive
 133:./MotorControl/utils.hpp **** inline float fmodf_pos(float x, float y) {
 134:./MotorControl/utils.hpp ****     float res = wrap_pm(x, y);
 135:./MotorControl/utils.hpp ****     if (res < 0) res += y;
 136:./MotorControl/utils.hpp ****     return res;
 137:./MotorControl/utils.hpp **** }
 138:./MotorControl/utils.hpp **** 
 139:./MotorControl/utils.hpp **** inline float wrap_pm_pi(float x) {
 140:./MotorControl/utils.hpp ****     return wrap_pm(x, 2 * M_PI);
 141:./MotorControl/utils.hpp **** }
 142:./MotorControl/utils.hpp **** 
 143:./MotorControl/utils.hpp **** // Evaluate polynomials in an efficient way
 144:./MotorControl/utils.hpp **** // coeffs[0] is highest order, as per numpy.polyfit
 145:./MotorControl/utils.hpp **** // p(x) = coeffs[0] * x^deg + ... + coeffs[deg], for some degree "deg"
 146:./MotorControl/utils.hpp **** inline float horner_poly_eval(float x, const float *coeffs, size_t count) {
 147:./MotorControl/utils.hpp ****     float result = 0.0f;
 148:./MotorControl/utils.hpp ****     for (size_t idx = 0; idx < count; ++idx)
 149:./MotorControl/utils.hpp ****         result = (result * x) + coeffs[idx];
 150:./MotorControl/utils.hpp ****     return result;
 151:./MotorControl/utils.hpp **** }
 152:./MotorControl/utils.hpp **** 
 153:./MotorControl/utils.hpp **** // Modulo (as opposed to remainder), per https://stackoverflow.com/a/19288271
 154:./MotorControl/utils.hpp **** inline int mod(const int dividend, const int divisor){
 2037              		.loc 17 154 12 is_stmt 1 view .LVU445
 2038              	.LBB1398:
 155:./MotorControl/utils.hpp ****     int r = dividend % divisor;
 2039              		.loc 17 155 5 view .LVU446
 2040              		.loc 17 155 9 is_stmt 0 view .LVU447
 2041 0018 93FBF2FE 		sdiv	lr, r3, r2
 2042 001c 02FB1E33 		mls	r3, r2, lr, r3
 2043              	.LVL129:
 156:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 2044              		.loc 17 156 5 is_stmt 1 view .LVU448
 2045 0020 002B     		cmp	r3, #0
 2046 0022 13DB     		blt	.L119
 2047              	.L116:
 157:./MotorControl/utils.hpp ****     return r;
 2048              		.loc 17 157 5 view .LVU449
 2049              	.LVL130:
 2050              		.loc 17 157 5 is_stmt 0 view .LVU450
 2051              	.LBE1398:
 2052              	.LBE1397:
 164:MotorControl/encoder.cpp ****     }
 2053              		.loc 3 164 30 view .LVU451
 2054 0024 8364     		str	r3, [r0, #72]
 2055              	.L115:
 168:MotorControl/encoder.cpp ****     pos_cpr_counts_ = (float)count_in_cpr_;
 2056              		.loc 3 168 5 is_stmt 1 view .LVU452
 168:MotorControl/encoder.cpp ****     pos_cpr_counts_ = (float)count_in_cpr_;
ARM GAS  /tmp/cc5nV8qb.s 			page 139


 2057              		.loc 3 168 40 is_stmt 0 view .LVU453
 2058 0026 036D     		ldr	r3, [r0, #80]
 2059              	.LVL131:
 2060              	.LBB1400:
 2061              	.LBI1400:
 154:./MotorControl/utils.hpp ****     int r = dividend % divisor;
 2062              		.loc 17 154 12 is_stmt 1 view .LVU454
 2063              	.LBB1401:
 155:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 2064              		.loc 17 155 5 view .LVU455
 155:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 2065              		.loc 17 155 9 is_stmt 0 view .LVU456
 2066 0028 91FBF3F2 		sdiv	r2, r1, r3
 2067 002c 03FB1211 		mls	r1, r3, r2, r1
 2068              	.LVL132:
 156:./MotorControl/utils.hpp ****     return r;
 2069              		.loc 17 156 5 is_stmt 1 view .LVU457
 2070 0030 0029     		cmp	r1, #0
 2071 0032 0DDB     		blt	.L120
 2072              	.L117:
 2073              		.loc 17 157 5 view .LVU458
 2074              	.LVL133:
 2075              		.loc 17 157 5 is_stmt 0 view .LVU459
 2076              	.LBE1401:
 2077              	.LBE1400:
 168:MotorControl/encoder.cpp ****     pos_cpr_counts_ = (float)count_in_cpr_;
 2078              		.loc 3 168 19 view .LVU460
 2079 0034 C0F89410 		str	r1, [r0, #148]
 169:MotorControl/encoder.cpp **** 
 2080              		.loc 3 169 5 is_stmt 1 view .LVU461
 169:MotorControl/encoder.cpp **** 
 2081              		.loc 3 169 23 is_stmt 0 view .LVU462
 2082 0038 07EE901A 		vmov	s15, r1	@ int
 2083 003c F8EEE77A 		vcvt.f32.s32	s15, s15
 169:MotorControl/encoder.cpp **** 
 2084              		.loc 3 169 21 view .LVU463
 2085 0040 C0ED2C7A 		vstr.32	s15, [r0, #176]
 171:MotorControl/encoder.cpp **** }
 2086              		.loc 3 171 5 is_stmt 1 view .LVU464
 2087              	.LVL134:
 2088              	.LBB1403:
 2089              	.LBI1403:
  37:./Drivers/STM32/stm32_system.h ****     __set_PRIMASK(priority_mask);
 2090              		.loc 4 37 20 view .LVU465
 2091              	.LBE1403:
 2092              		.loc 4 38 5 view .LVU466
 2093              	.LBB1406:
 2094              	.LBB1404:
 2095              	.LBI1404:
 412:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 2096              		.loc 5 412 27 view .LVU467
 2097              	.LBB1405:
 2098              		.loc 5 414 3 view .LVU468
 2099              		.syntax unified
 2100              	@ 414 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 2101 0044 8CF31088 		MSR primask, ip
 2102              	@ 0 "" 2
ARM GAS  /tmp/cc5nV8qb.s 			page 140


 2103              	.LVL135:
 2104              		.loc 5 414 3 is_stmt 0 view .LVU469
 2105              		.thumb
 2106              		.syntax unified
 2107              	.LBE1405:
 2108              	.LBE1404:
 2109              	.LBE1406:
 172:MotorControl/encoder.cpp **** 
 2110              		.loc 3 172 1 view .LVU470
 2111 0048 5DF804FB 		ldr	pc, [sp], #4
 2112              	.LVL136:
 2113              	.L119:
 2114              	.LBB1407:
 2115              	.LBB1399:
 156:./MotorControl/utils.hpp ****     return r;
 2116              		.loc 17 156 16 is_stmt 1 view .LVU471
 156:./MotorControl/utils.hpp ****     return r;
 2117              		.loc 17 156 18 is_stmt 0 view .LVU472
 2118 004c 1344     		add	r3, r3, r2
 2119              	.LVL137:
 156:./MotorControl/utils.hpp ****     return r;
 2120              		.loc 17 156 18 view .LVU473
 2121 004e E9E7     		b	.L116
 2122              	.LVL138:
 2123              	.L120:
 156:./MotorControl/utils.hpp ****     return r;
 2124              		.loc 17 156 18 view .LVU474
 2125              	.LBE1399:
 2126              	.LBE1407:
 2127              	.LBB1408:
 2128              	.LBB1402:
 156:./MotorControl/utils.hpp ****     return r;
 2129              		.loc 17 156 16 is_stmt 1 view .LVU475
 156:./MotorControl/utils.hpp ****     return r;
 2130              		.loc 17 156 18 is_stmt 0 view .LVU476
 2131 0050 1944     		add	r1, r1, r3
 2132              	.LVL139:
 156:./MotorControl/utils.hpp ****     return r;
 2133              		.loc 17 156 18 view .LVU477
 2134 0052 EFE7     		b	.L117
 2135              	.LBE1402:
 2136              	.LBE1408:
 2137              		.cfi_endproc
 2138              	.LFE5340:
 2139              		.cantunwind
 2140              		.fnend
 2142              		.section	.text._ZN7Encoder12enc_index_cbEv,"ax",%progbits
 2143              		.align	1
 2144              		.global	_ZN7Encoder12enc_index_cbEv
 2145              		.syntax unified
 2146              		.thumb
 2147              		.thumb_func
 2149              	_ZN7Encoder12enc_index_cbEv:
 2150              		.fnstart
 2151              	.LVL140:
 2152              	.LFB5335:
  87:MotorControl/encoder.cpp ****     if (config_.use_index) {
ARM GAS  /tmp/cc5nV8qb.s 			page 141


 2153              		.loc 3 87 30 is_stmt 1 view -0
 2154              		.cfi_startproc
 2155              		@ args = 0, pretend = 0, frame = 0
 2156              		@ frame_needed = 0, uses_anonymous_args = 0
  87:MotorControl/encoder.cpp ****     if (config_.use_index) {
 2157              		.loc 3 87 30 is_stmt 0 view .LVU479
 2158 0000 10B5     		push	{r4, lr}
 2159              		.save {r4, lr}
 2160              	.LCFI15:
 2161              		.cfi_def_cfa_offset 8
 2162              		.cfi_offset 4, -8
 2163              		.cfi_offset 14, -4
 2164 0002 0446     		mov	r4, r0
  88:MotorControl/encoder.cpp ****         set_circular_count(0, false);
 2165              		.loc 3 88 5 is_stmt 1 view .LVU480
  88:MotorControl/encoder.cpp ****         set_circular_count(0, false);
 2166              		.loc 3 88 17 is_stmt 0 view .LVU481
 2167 0004 90F85830 		ldrb	r3, [r0, #88]	@ zero_extendqisi2
  88:MotorControl/encoder.cpp ****         set_circular_count(0, false);
 2168              		.loc 3 88 5 view .LVU482
 2169 0008 23B9     		cbnz	r3, .L127
 2170              	.LVL141:
 2171              	.L122:
 107:MotorControl/encoder.cpp **** }
 2172              		.loc 3 107 5 is_stmt 1 view .LVU483
 107:MotorControl/encoder.cpp **** }
 2173              		.loc 3 107 28 is_stmt 0 view .LVU484
 2174 000a 04F10C00 		add	r0, r4, #12
 2175 000e FFF7FEFF 		bl	_ZN9Stm32Gpio11unsubscribeEv
 2176              	.LVL142:
 108:MotorControl/encoder.cpp **** 
 2177              		.loc 3 108 1 view .LVU485
 2178 0012 10BD     		pop	{r4, pc}
 2179              	.LVL143:
 2180              	.L127:
  89:MotorControl/encoder.cpp ****         if (config_.use_index_offset)
 2181              		.loc 3 89 9 is_stmt 1 view .LVU486
  89:MotorControl/encoder.cpp ****         if (config_.use_index_offset)
 2182              		.loc 3 89 27 is_stmt 0 view .LVU487
 2183 0014 0022     		movs	r2, #0
 2184 0016 1146     		mov	r1, r2
 2185 0018 FFF7FEFF 		bl	_ZN7Encoder18set_circular_countElb
 2186              	.LVL144:
  90:MotorControl/encoder.cpp ****             set_linear_count((int32_t)(config_.index_offset * config_.cpr));
 2187              		.loc 3 90 9 is_stmt 1 view .LVU488
  90:MotorControl/encoder.cpp ****             set_linear_count((int32_t)(config_.index_offset * config_.cpr));
 2188              		.loc 3 90 21 is_stmt 0 view .LVU489
 2189 001c 94F86030 		ldrb	r3, [r4, #96]	@ zero_extendqisi2
  90:MotorControl/encoder.cpp ****             set_linear_count((int32_t)(config_.index_offset * config_.cpr));
 2190              		.loc 3 90 9 view .LVU490
 2191 0020 7BB1     		cbz	r3, .L123
  91:MotorControl/encoder.cpp ****         if (config_.pre_calibrated) {
 2192              		.loc 3 91 13 is_stmt 1 view .LVU491
  91:MotorControl/encoder.cpp ****         if (config_.pre_calibrated) {
 2193              		.loc 3 91 75 is_stmt 0 view .LVU492
 2194 0022 2368     		ldr	r3, [r4]
 2195 0024 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/cc5nV8qb.s 			page 142


  91:MotorControl/encoder.cpp ****         if (config_.pre_calibrated) {
 2196              		.loc 3 91 48 view .LVU493
 2197 0026 94ED157A 		vldr.32	s14, [r4, #84]
  91:MotorControl/encoder.cpp ****         if (config_.pre_calibrated) {
 2198              		.loc 3 91 61 view .LVU494
 2199 002a D4ED147A 		vldr.32	s15, [r4, #80]	@ int
 2200 002e F8EEE77A 		vcvt.f32.s32	s15, s15
 2201 0032 67EE877A 		vmul.f32	s15, s15, s14
  91:MotorControl/encoder.cpp ****         if (config_.pre_calibrated) {
 2202              		.loc 3 91 29 view .LVU495
 2203 0036 FDEEE77A 		vcvt.s32.f32	s15, s15
 2204 003a 17EE901A 		vmov	r1, s15	@ int
 2205 003e 2046     		mov	r0, r4
 2206 0040 9847     		blx	r3
 2207              	.LVL145:
 2208              	.L123:
  92:MotorControl/encoder.cpp ****             is_ready_ = true;
 2209              		.loc 3 92 9 is_stmt 1 view .LVU496
  92:MotorControl/encoder.cpp ****             is_ready_ = true;
 2210              		.loc 3 92 21 is_stmt 0 view .LVU497
 2211 0042 94F85930 		ldrb	r3, [r4, #89]	@ zero_extendqisi2
  92:MotorControl/encoder.cpp ****             is_ready_ = true;
 2212              		.loc 3 92 9 view .LVU498
 2213 0046 83B1     		cbz	r3, .L124
  93:MotorControl/encoder.cpp ****             if(axis_->controller_.config_.anticogging.pre_calibrated){
 2214              		.loc 3 93 13 is_stmt 1 view .LVU499
  93:MotorControl/encoder.cpp ****             if(axis_->controller_.config_.anticogging.pre_calibrated){
 2215              		.loc 3 93 23 is_stmt 0 view .LVU500
 2216 0048 0123     		movs	r3, #1
 2217 004a 84F88F30 		strb	r3, [r4, #143]
  94:MotorControl/encoder.cpp ****                 axis_->controller_.anticogging_valid_ = true;
 2218              		.loc 3 94 13 is_stmt 1 view .LVU501
  94:MotorControl/encoder.cpp ****                 axis_->controller_.anticogging_valid_ = true;
 2219              		.loc 3 94 16 is_stmt 0 view .LVU502
 2220 004e 236B     		ldr	r3, [r4, #48]
  94:MotorControl/encoder.cpp ****                 axis_->controller_.anticogging_valid_ = true;
 2221              		.loc 3 94 23 view .LVU503
 2222 0050 D3F80031 		ldr	r3, [r3, #256]
  94:MotorControl/encoder.cpp ****                 axis_->controller_.anticogging_valid_ = true;
 2223              		.loc 3 94 55 view .LVU504
 2224 0054 03F54052 		add	r2, r3, #12288
 2225 0058 92F89828 		ldrb	r2, [r2, #2200]	@ zero_extendqisi2
  94:MotorControl/encoder.cpp ****                 axis_->controller_.anticogging_valid_ = true;
 2226              		.loc 3 94 13 view .LVU505
 2227 005c 42B1     		cbz	r2, .L125
  95:MotorControl/encoder.cpp ****             }
 2228              		.loc 3 95 17 is_stmt 1 view .LVU506
  95:MotorControl/encoder.cpp ****             }
 2229              		.loc 3 95 55 is_stmt 0 view .LVU507
 2230 005e 03F54053 		add	r3, r3, #12288
 2231 0062 0122     		movs	r2, #1
 2232 0064 83F83E29 		strb	r2, [r3, #2366]
 2233 0068 02E0     		b	.L125
 2234              	.L124:
 101:MotorControl/encoder.cpp ****         }
 2235              		.loc 3 101 13 is_stmt 1 view .LVU508
 101:MotorControl/encoder.cpp ****         }
ARM GAS  /tmp/cc5nV8qb.s 			page 143


 2236              		.loc 3 101 23 is_stmt 0 view .LVU509
 2237 006a 0023     		movs	r3, #0
 2238 006c 84F88F30 		strb	r3, [r4, #143]
 2239              	.L125:
 103:MotorControl/encoder.cpp ****     }
 2240              		.loc 3 103 9 is_stmt 1 view .LVU510
 103:MotorControl/encoder.cpp ****     }
 2241              		.loc 3 103 22 is_stmt 0 view .LVU511
 2242 0070 0123     		movs	r3, #1
 2243 0072 84F88E30 		strb	r3, [r4, #142]
 2244 0076 C8E7     		b	.L122
 2245              		.cfi_endproc
 2246              	.LFE5335:
 2247              		.fnend
 2249              		.section	.text._ZL20enc_index_cb_wrapperPv,"ax",%progbits
 2250              		.align	1
 2251              		.syntax unified
 2252              		.thumb
 2253              		.thumb_func
 2255              	_ZL20enc_index_cb_wrapperPv:
 2256              		.fnstart
 2257              	.LVL146:
 2258              	.LFB5330:
  15:MotorControl/encoder.cpp ****     reinterpret_cast<Encoder*>(ctx)->enc_index_cb();
 2259              		.loc 3 15 45 is_stmt 1 view -0
 2260              		.cfi_startproc
 2261              		@ args = 0, pretend = 0, frame = 0
 2262              		@ frame_needed = 0, uses_anonymous_args = 0
  15:MotorControl/encoder.cpp ****     reinterpret_cast<Encoder*>(ctx)->enc_index_cb();
 2263              		.loc 3 15 45 is_stmt 0 view .LVU513
 2264 0000 08B5     		push	{r3, lr}
 2265              		.save {r3, lr}
 2266              	.LCFI16:
 2267              		.cfi_def_cfa_offset 8
 2268              		.cfi_offset 3, -8
 2269              		.cfi_offset 14, -4
  16:MotorControl/encoder.cpp **** }
 2270              		.loc 3 16 5 is_stmt 1 view .LVU514
  16:MotorControl/encoder.cpp **** }
 2271              		.loc 3 16 50 is_stmt 0 view .LVU515
 2272 0002 FFF7FEFF 		bl	_ZN7Encoder12enc_index_cbEv
 2273              	.LVL147:
  17:MotorControl/encoder.cpp **** 
 2274              		.loc 3 17 1 view .LVU516
 2275 0006 08BD     		pop	{r3, pc}
 2276              		.cfi_endproc
 2277              	.LFE5330:
 2278              		.fnend
 2280              		.section	.text._ZN7Encoder16run_index_searchEv,"ax",%progbits
 2281              		.align	1
 2282              		.global	_ZN7Encoder16run_index_searchEv
 2283              		.syntax unified
 2284              		.thumb
 2285              		.thumb_func
 2287              	_ZN7Encoder16run_index_searchEv:
 2288              		.fnstart
 2289              	.LVL148:
ARM GAS  /tmp/cc5nV8qb.s 			page 144


 2290              	.LFB5341:
 174:MotorControl/encoder.cpp ****     config_.use_index = true;
 2291              		.loc 3 174 34 is_stmt 1 view -0
 2292              		.cfi_startproc
 2293              		@ args = 0, pretend = 0, frame = 16
 2294              		@ frame_needed = 0, uses_anonymous_args = 0
 174:MotorControl/encoder.cpp ****     config_.use_index = true;
 2295              		.loc 3 174 34 is_stmt 0 view .LVU518
 2296 0000 30B5     		push	{r4, r5, lr}
 2297              		.save {r4, r5, lr}
 2298              	.LCFI17:
 2299              		.cfi_def_cfa_offset 12
 2300              		.cfi_offset 4, -12
 2301              		.cfi_offset 5, -8
 2302              		.cfi_offset 14, -4
 2303              		.pad #20
 2304 0002 85B0     		sub	sp, sp, #20
 2305              	.LCFI18:
 2306              		.cfi_def_cfa_offset 32
 2307 0004 0446     		mov	r4, r0
 175:MotorControl/encoder.cpp ****     index_found_ = false;
 2308              		.loc 3 175 5 is_stmt 1 view .LVU519
 175:MotorControl/encoder.cpp ****     index_found_ = false;
 2309              		.loc 3 175 23 is_stmt 0 view .LVU520
 2310 0006 0123     		movs	r3, #1
 2311 0008 80F85830 		strb	r3, [r0, #88]
 176:MotorControl/encoder.cpp ****     set_idx_subscribe();
 2312              		.loc 3 176 5 is_stmt 1 view .LVU521
 176:MotorControl/encoder.cpp ****     set_idx_subscribe();
 2313              		.loc 3 176 18 is_stmt 0 view .LVU522
 2314 000c 0025     		movs	r5, #0
 2315 000e 80F88E50 		strb	r5, [r0, #142]
 177:MotorControl/encoder.cpp **** 
 2316              		.loc 3 177 5 is_stmt 1 view .LVU523
 177:MotorControl/encoder.cpp **** 
 2317              		.loc 3 177 22 is_stmt 0 view .LVU524
 2318 0012 2946     		mov	r1, r5
 2319              	.LEHB0:
 2320 0014 FFF7FEFF 		bl	_ZN7Encoder17set_idx_subscribeEb
 2321              	.LVL149:
 2322              	.LEHE0:
 179:MotorControl/encoder.cpp ****     return success;
 2323              		.loc 3 179 5 is_stmt 1 view .LVU525
 179:MotorControl/encoder.cpp ****     return success;
 2324              		.loc 3 179 20 is_stmt 0 view .LVU526
 2325 0018 206B     		ldr	r0, [r4, #48]
 2326              	.LVL150:
 2327              	.LBB1421:
 2328              	.LBI1421:
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       : _Function_base() { }
 2329              		.loc 6 330 7 is_stmt 1 view .LVU527
 2330              	.LBB1422:
 2331              	.LBB1423:
 2332              	.LBI1423:
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 2333              		.loc 6 240 5 view .LVU528
 2334              	.LBB1424:
ARM GAS  /tmp/cc5nV8qb.s 			page 145


 2335              	.LBB1425:
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 2336              		.loc 6 240 42 is_stmt 0 view .LVU529
 2337 001a 0295     		str	r5, [sp, #8]
 2338              	.LVL151:
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 2339              		.loc 6 240 42 view .LVU530
 2340              	.LBE1425:
 2341              	.LBE1424:
 2342              	.LBE1423:
 2343              	.LBE1422:
 2344              	.LBE1421:
 179:MotorControl/encoder.cpp ****     return success;
 2345              		.loc 3 179 42 view .LVU531
 2346 001c 6B46     		mov	r3, sp
 2347 001e 2A46     		mov	r2, r5
 2348 0020 00F12401 		add	r1, r0, #36
 2349              	.LEHB1:
 2350 0024 FFF7FEFF 		bl	_ZN4Axis15run_lockin_spinERKNS_14LockinConfig_tEbSt8functionIFbbEE
 2351              	.LVL152:
 2352              	.LEHE1:
 2353 0028 0446     		mov	r4, r0
 2354              	.LVL153:
 2355              	.LBB1426:
 2356              	.LBI1426:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 2357              		.loc 6 303 11 is_stmt 1 view .LVU532
 2358              	.LBB1427:
 2359              	.LBB1428:
 2360              	.LBI1428:
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     {
 2361              		.loc 6 242 5 view .LVU533
 2362              	.LBB1429:
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 2363              		.loc 6 244 7 view .LVU534
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 2364              		.loc 6 244 11 is_stmt 0 view .LVU535
 2365 002a 029B     		ldr	r3, [sp, #8]
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 2366              		.loc 6 244 7 view .LVU536
 2367 002c 1BB1     		cbz	r3, .L134
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 2368              		.loc 6 245 2 is_stmt 1 view .LVU537
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 2369              		.loc 6 245 12 is_stmt 0 view .LVU538
 2370 002e 0322     		movs	r2, #3
 2371 0030 6946     		mov	r1, sp
 2372 0032 6846     		mov	r0, sp
 2373 0034 9847     		blx	r3
 2374              	.LVL154:
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 2375              		.loc 6 245 12 view .LVU539
 2376              	.LBE1429:
 2377              	.LBE1428:
 2378              	.LBE1427:
 2379              	.LBE1426:
 180:MotorControl/encoder.cpp **** }
ARM GAS  /tmp/cc5nV8qb.s 			page 146


 2380              		.loc 3 180 5 is_stmt 1 view .LVU540
 2381              	.L134:
 181:MotorControl/encoder.cpp **** 
 2382              		.loc 3 181 1 is_stmt 0 view .LVU541
 2383 0036 2046     		mov	r0, r4
 2384 0038 05B0     		add	sp, sp, #20
 2385              	.LCFI19:
 2386              		.cfi_remember_state
 2387              		.cfi_def_cfa_offset 12
 2388              		@ sp needed
 2389 003a 30BD     		pop	{r4, r5, pc}
 2390              	.LVL155:
 2391              	.L133:
 2392              	.LCFI20:
 2393              		.cfi_restore_state
 2394              	.LBB1430:
 2395              	.LBI1430:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 2396              		.loc 6 303 11 is_stmt 1 view .LVU542
 2397              	.LBB1431:
 2398 003c 6846     		mov	r0, sp
 2399 003e FFF7FEFF 		bl	_ZNSt14_Function_baseD2Ev
 2400              	.LVL156:
 2401              	.LEHB2:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 2402              		.loc 6 303 11 is_stmt 0 view .LVU543
 2403 0042 FFF7FEFF 		bl	__cxa_end_cleanup
 2404              	.LVL157:
 2405              	.LEHE2:
 2406              	.LBE1431:
 2407              	.LBE1430:
 2408              		.cfi_endproc
 2409              	.LFE5341:
 2410              		.personality	__gxx_personality_v0
 2411              		.handlerdata
 2412              	.LLSDA5341:
 2413 0008 FF       		.byte	0xff
 2414 0009 FF       		.byte	0xff
 2415 000a 01       		.byte	0x1
 2416 000b 0C       		.uleb128 .LLSDACSE5341-.LLSDACSB5341
 2417              	.LLSDACSB5341:
 2418 000c 14       		.uleb128 .LEHB0-.LFB5341
 2419 000d 04       		.uleb128 .LEHE0-.LEHB0
 2420 000e 00       		.uleb128 0
 2421 000f 00       		.uleb128 0
 2422 0010 24       		.uleb128 .LEHB1-.LFB5341
 2423 0011 04       		.uleb128 .LEHE1-.LEHB1
 2424 0012 3C       		.uleb128 .L133-.LFB5341
 2425 0013 00       		.uleb128 0
 2426 0014 42       		.uleb128 .LEHB2-.LFB5341
 2427 0015 04       		.uleb128 .LEHE2-.LEHB2
 2428 0016 00       		.uleb128 0
 2429 0017 00       		.uleb128 0
 2430              	.LLSDACSE5341:
 2431              		.section	.text._ZN7Encoder16run_index_searchEv
 2432              		.fnend
 2434              		.section	.text._ZN7Encoder18run_direction_findEv,"ax",%progbits
ARM GAS  /tmp/cc5nV8qb.s 			page 147


 2435              		.align	1
 2436              		.global	_ZN7Encoder18run_direction_findEv
 2437              		.syntax unified
 2438              		.thumb
 2439              		.thumb_func
 2441              	_ZN7Encoder18run_direction_findEv:
 2442              		.fnstart
 2443              	.LVL158:
 2444              	.LFB5345:
 183:MotorControl/encoder.cpp ****     int32_t init_enc_val = shadow_count_;
 2445              		.loc 3 183 36 is_stmt 1 view -0
 2446              		.cfi_startproc
 2447              		@ args = 0, pretend = 0, frame = 48
 2448              		@ frame_needed = 0, uses_anonymous_args = 0
 183:MotorControl/encoder.cpp ****     int32_t init_enc_val = shadow_count_;
 2449              		.loc 3 183 36 is_stmt 0 view .LVU545
 2450 0000 70B5     		push	{r4, r5, r6, lr}
 2451              		.save {r4, r5, r6, lr}
 2452              	.LCFI21:
 2453              		.cfi_def_cfa_offset 16
 2454              		.cfi_offset 4, -16
 2455              		.cfi_offset 5, -12
 2456              		.cfi_offset 6, -8
 2457              		.cfi_offset 14, -4
 2458              		.pad #48
 2459 0002 8CB0     		sub	sp, sp, #48
 2460              	.LCFI22:
 2461              		.cfi_def_cfa_offset 64
 2462 0004 0446     		mov	r4, r0
 184:MotorControl/encoder.cpp **** 
 2463              		.loc 3 184 5 is_stmt 1 view .LVU546
 184:MotorControl/encoder.cpp **** 
 2464              		.loc 3 184 13 is_stmt 0 view .LVU547
 2465 0006 D0F89060 		ldr	r6, [r0, #144]
 2466              	.LVL159:
 186:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 3.0f; // run for 3 seconds
 2467              		.loc 3 186 5 is_stmt 1 view .LVU548
 186:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 3.0f; // run for 3 seconds
 2468              		.loc 3 186 42 is_stmt 0 view .LVU549
 2469 000a 056B     		ldr	r5, [r0, #48]
 186:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 3.0f; // run for 3 seconds
 2470              		.loc 3 186 26 view .LVU550
 2471 000c 0DF1040C 		add	ip, sp, #4
 2472 0010 05F1240E 		add	lr, r5, #36
 2473 0014 BEE80F00 		ldmia	lr!, {r0, r1, r2, r3}
 2474              	.LVL160:
 186:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 3.0f; // run for 3 seconds
 2475              		.loc 3 186 26 view .LVU551
 2476 0018 ACE80F00 		stmia	ip!, {r0, r1, r2, r3}
 2477 001c 9EE80700 		ldm	lr, {r0, r1, r2}
 2478 0020 8CE80700 		stm	ip, {r0, r1, r2}
 187:MotorControl/encoder.cpp ****     lockin_config.finish_on_distance = true;
 2479              		.loc 3 187 5 is_stmt 1 view .LVU552
 187:MotorControl/encoder.cpp ****     lockin_config.finish_on_distance = true;
 2480              		.loc 3 187 55 is_stmt 0 view .LVU553
 2481 0024 DDED057A 		vldr.32	s15, [sp, #20]
 2482 0028 B0EE087A 		vmov.f32	s14, #3.0e+0
ARM GAS  /tmp/cc5nV8qb.s 			page 148


 2483 002c 67EE877A 		vmul.f32	s15, s15, s14
 187:MotorControl/encoder.cpp ****     lockin_config.finish_on_distance = true;
 2484              		.loc 3 187 35 view .LVU554
 2485 0030 CDED067A 		vstr.32	s15, [sp, #24]
 188:MotorControl/encoder.cpp ****     lockin_config.finish_on_enc_idx = false;
 2486              		.loc 3 188 5 is_stmt 1 view .LVU555
 188:MotorControl/encoder.cpp ****     lockin_config.finish_on_enc_idx = false;
 2487              		.loc 3 188 38 is_stmt 0 view .LVU556
 2488 0034 0123     		movs	r3, #1
 2489 0036 8DF81D30 		strb	r3, [sp, #29]
 189:MotorControl/encoder.cpp ****     lockin_config.finish_on_vel = false;
 2490              		.loc 3 189 5 is_stmt 1 view .LVU557
 189:MotorControl/encoder.cpp ****     lockin_config.finish_on_vel = false;
 2491              		.loc 3 189 37 is_stmt 0 view .LVU558
 2492 003a 0022     		movs	r2, #0
 2493 003c 8DF81E20 		strb	r2, [sp, #30]
 190:MotorControl/encoder.cpp ****     bool success = axis_->run_lockin_spin(lockin_config, false);
 2494              		.loc 3 190 5 is_stmt 1 view .LVU559
 190:MotorControl/encoder.cpp ****     bool success = axis_->run_lockin_spin(lockin_config, false);
 2495              		.loc 3 190 33 is_stmt 0 view .LVU560
 2496 0040 8DF81C20 		strb	r2, [sp, #28]
 191:MotorControl/encoder.cpp **** 
 2497              		.loc 3 191 5 is_stmt 1 view .LVU561
 2498              	.LVL161:
 2499              	.LBB1444:
 2500              	.LBI1444:
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****       : _Function_base() { }
 2501              		.loc 6 330 7 view .LVU562
 2502              	.LBB1445:
 2503              	.LBB1446:
 2504              	.LBI1446:
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 2505              		.loc 6 240 5 view .LVU563
 2506              	.LBB1447:
 2507              	.LBB1448:
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 2508              		.loc 6 240 42 is_stmt 0 view .LVU564
 2509 0044 0A92     		str	r2, [sp, #40]
 2510              	.LVL162:
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 
 2511              		.loc 6 240 42 view .LVU565
 2512              	.LBE1448:
 2513              	.LBE1447:
 2514              	.LBE1446:
 2515              	.LBE1445:
 2516              	.LBE1444:
 191:MotorControl/encoder.cpp **** 
 2517              		.loc 3 191 42 view .LVU566
 2518 0046 08AB     		add	r3, sp, #32
 2519 0048 01A9     		add	r1, sp, #4
 2520 004a 2846     		mov	r0, r5
 2521              	.LEHB3:
 2522 004c FFF7FEFF 		bl	_ZN4Axis15run_lockin_spinERKNS_14LockinConfig_tEbSt8functionIFbbEE
 2523              	.LVL163:
 2524              	.LEHE3:
 2525 0050 0546     		mov	r5, r0
 2526              	.LVL164:
ARM GAS  /tmp/cc5nV8qb.s 			page 149


 2527              	.LBB1449:
 2528              	.LBI1449:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 2529              		.loc 6 303 11 is_stmt 1 view .LVU567
 2530              	.LBB1450:
 2531              	.LBB1451:
 2532              	.LBI1451:
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     {
 2533              		.loc 6 242 5 view .LVU568
 2534              	.LBB1452:
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 2535              		.loc 6 244 7 view .LVU569
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 2536              		.loc 6 244 11 is_stmt 0 view .LVU570
 2537 0052 0A9B     		ldr	r3, [sp, #40]
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 2538              		.loc 6 244 7 view .LVU571
 2539 0054 1BB1     		cbz	r3, .L137
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 2540              		.loc 6 245 2 is_stmt 1 view .LVU572
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 2541              		.loc 6 245 12 is_stmt 0 view .LVU573
 2542 0056 0322     		movs	r2, #3
 2543 0058 08A9     		add	r1, sp, #32
 2544              	.LVL165:
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 2545              		.loc 6 245 12 view .LVU574
 2546 005a 0846     		mov	r0, r1
 2547 005c 9847     		blx	r3
 2548              	.LVL166:
 2549              	.L137:
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 2550              		.loc 6 245 12 view .LVU575
 2551              	.LBE1452:
 2552              	.LBE1451:
 2553              	.LBE1450:
 2554              	.LBE1449:
 193:MotorControl/encoder.cpp ****         // Check response and direction
 2555              		.loc 3 193 5 is_stmt 1 view .LVU576
 2556 005e 3DB1     		cbz	r5, .L143
 195:MotorControl/encoder.cpp ****             // motor same dir as encoder
 2557              		.loc 3 195 9 view .LVU577
 195:MotorControl/encoder.cpp ****             // motor same dir as encoder
 2558              		.loc 3 195 13 is_stmt 0 view .LVU578
 2559 0060 D4F89030 		ldr	r3, [r4, #144]
 195:MotorControl/encoder.cpp ****             // motor same dir as encoder
 2560              		.loc 3 195 42 view .LVU579
 2561 0064 06F10802 		add	r2, r6, #8
 195:MotorControl/encoder.cpp ****             // motor same dir as encoder
 2562              		.loc 3 195 9 view .LVU580
 2563 0068 9342     		cmp	r3, r2
 2564 006a 04DD     		ble	.L139
 197:MotorControl/encoder.cpp ****         } else if (shadow_count_ < init_enc_val - 8) {
 2565              		.loc 3 197 13 is_stmt 1 view .LVU581
 197:MotorControl/encoder.cpp ****         } else if (shadow_count_ < init_enc_val - 8) {
 2566              		.loc 3 197 31 is_stmt 0 view .LVU582
 2567 006c 0123     		movs	r3, #1
ARM GAS  /tmp/cc5nV8qb.s 			page 150


 2568 006e E365     		str	r3, [r4, #92]
 2569              	.LVL167:
 2570              	.L143:
 207:MotorControl/encoder.cpp **** 
 2571              		.loc 3 207 1 view .LVU583
 2572 0070 2846     		mov	r0, r5
 2573 0072 0CB0     		add	sp, sp, #48
 2574              	.LCFI23:
 2575              		.cfi_remember_state
 2576              		.cfi_def_cfa_offset 16
 2577              		@ sp needed
 2578 0074 70BD     		pop	{r4, r5, r6, pc}
 2579              	.LVL168:
 2580              	.L139:
 2581              	.LCFI24:
 2582              		.cfi_restore_state
 198:MotorControl/encoder.cpp ****             // motor opposite dir as encoder
 2583              		.loc 3 198 16 is_stmt 1 view .LVU584
 198:MotorControl/encoder.cpp ****             // motor opposite dir as encoder
 2584              		.loc 3 198 49 is_stmt 0 view .LVU585
 2585 0076 083E     		subs	r6, r6, #8
 2586              	.LVL169:
 198:MotorControl/encoder.cpp ****             // motor opposite dir as encoder
 2587              		.loc 3 198 16 view .LVU586
 2588 0078 B342     		cmp	r3, r6
 2589 007a 03DA     		bge	.L140
 200:MotorControl/encoder.cpp ****         } else {
 2590              		.loc 3 200 13 is_stmt 1 view .LVU587
 200:MotorControl/encoder.cpp ****         } else {
 2591              		.loc 3 200 31 is_stmt 0 view .LVU588
 2592 007c 4FF0FF33 		mov	r3, #-1
 2593 0080 E365     		str	r3, [r4, #92]
 2594 0082 F5E7     		b	.L143
 2595              	.L140:
 202:MotorControl/encoder.cpp ****         }
 2596              		.loc 3 202 13 is_stmt 1 view .LVU589
 202:MotorControl/encoder.cpp ****         }
 2597              		.loc 3 202 31 is_stmt 0 view .LVU590
 2598 0084 0023     		movs	r3, #0
 2599 0086 E365     		str	r3, [r4, #92]
 206:MotorControl/encoder.cpp **** }
 2600              		.loc 3 206 5 is_stmt 1 view .LVU591
 206:MotorControl/encoder.cpp **** }
 2601              		.loc 3 206 12 is_stmt 0 view .LVU592
 2602 0088 F2E7     		b	.L143
 2603              	.LVL170:
 2604              	.L142:
 2605              	.LBB1453:
 2606              	.LBI1453:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 2607              		.loc 6 303 11 is_stmt 1 view .LVU593
 2608              	.LBB1454:
 2609 008a 08A8     		add	r0, sp, #32
 2610              	.LVL171:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 2611              		.loc 6 303 11 is_stmt 0 view .LVU594
 2612 008c FFF7FEFF 		bl	_ZNSt14_Function_baseD2Ev
ARM GAS  /tmp/cc5nV8qb.s 			page 151


 2613              	.LVL172:
 2614              	.LEHB4:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 2615              		.loc 6 303 11 view .LVU595
 2616 0090 FFF7FEFF 		bl	__cxa_end_cleanup
 2617              	.LVL173:
 2618              	.LEHE4:
 2619              	.LBE1454:
 2620              	.LBE1453:
 2621              		.cfi_endproc
 2622              	.LFE5345:
 2623              		.personality	__gxx_personality_v0
 2624              		.handlerdata
 2625              	.LLSDA5345:
 2626 0008 FF       		.byte	0xff
 2627 0009 FF       		.byte	0xff
 2628 000a 01       		.byte	0x1
 2629 000b 0A       		.uleb128 .LLSDACSE5345-.LLSDACSB5345
 2630              	.LLSDACSB5345:
 2631 000c 4C       		.uleb128 .LEHB3-.LFB5345
 2632 000d 04       		.uleb128 .LEHE3-.LEHB3
 2633 000e 8A01     		.uleb128 .L142-.LFB5345
 2634 0010 00       		.uleb128 0
 2635 0011 9001     		.uleb128 .LEHB4-.LFB5345
 2636 0013 04       		.uleb128 .LEHE4-.LEHB4
 2637 0014 00       		.uleb128 0
 2638 0015 00       		.uleb128 0
 2639              	.LLSDACSE5345:
 2640              		.section	.text._ZN7Encoder18run_direction_findEv
 2641              		.fnend
 2643              		.section	.text._ZN7Encoder29run_hall_polarity_calibrationEv,"ax",%progbits
 2644              		.align	1
 2645              		.global	_ZN7Encoder29run_hall_polarity_calibrationEv
 2646              		.syntax unified
 2647              		.thumb
 2648              		.thumb_func
 2650              	_ZN7Encoder29run_hall_polarity_calibrationEv:
 2651              		.fnstart
 2652              	.LVL174:
 2653              	.LFB5346:
 210:MotorControl/encoder.cpp ****     Axis::LockinConfig_t lockin_config = axis_->config_.calibration_lockin;
 2654              		.loc 3 210 47 is_stmt 1 view -0
 2655              		.cfi_startproc
 2656              		@ args = 0, pretend = 0, frame = 72
 2657              		@ frame_needed = 0, uses_anonymous_args = 0
 210:MotorControl/encoder.cpp ****     Axis::LockinConfig_t lockin_config = axis_->config_.calibration_lockin;
 2658              		.loc 3 210 47 is_stmt 0 view .LVU597
 2659 0000 70B5     		push	{r4, r5, r6, lr}
 2660              		.save {r4, r5, r6, lr}
 2661              	.LCFI25:
 2662              		.cfi_def_cfa_offset 16
 2663              		.cfi_offset 4, -16
 2664              		.cfi_offset 5, -12
 2665              		.cfi_offset 6, -8
 2666              		.cfi_offset 14, -4
 2667              		.pad #72
 2668 0002 92B0     		sub	sp, sp, #72
ARM GAS  /tmp/cc5nV8qb.s 			page 152


 2669              	.LCFI26:
 2670              		.cfi_def_cfa_offset 88
 2671 0004 0446     		mov	r4, r0
 211:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 3.0f; // run for 3 seconds
 2672              		.loc 3 211 5 is_stmt 1 view .LVU598
 211:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 3.0f; // run for 3 seconds
 2673              		.loc 3 211 42 is_stmt 0 view .LVU599
 2674 0006 036B     		ldr	r3, [r0, #48]
 211:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 3.0f; // run for 3 seconds
 2675              		.loc 3 211 26 view .LVU600
 2676 0008 0DF10C0E 		add	lr, sp, #12
 2677 000c 03F1240C 		add	ip, r3, #36
 2678 0010 BCE80F00 		ldmia	ip!, {r0, r1, r2, r3}
 2679              	.LVL175:
 211:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 3.0f; // run for 3 seconds
 2680              		.loc 3 211 26 view .LVU601
 2681 0014 AEE80F00 		stmia	lr!, {r0, r1, r2, r3}
 2682 0018 9CE80700 		ldm	ip, {r0, r1, r2}
 2683 001c 8EE80700 		stm	lr, {r0, r1, r2}
 212:MotorControl/encoder.cpp ****     lockin_config.finish_on_distance = true;
 2684              		.loc 3 212 5 is_stmt 1 view .LVU602
 212:MotorControl/encoder.cpp ****     lockin_config.finish_on_distance = true;
 2685              		.loc 3 212 55 is_stmt 0 view .LVU603
 2686 0020 DDED077A 		vldr.32	s15, [sp, #28]
 2687 0024 B0EE087A 		vmov.f32	s14, #3.0e+0
 2688 0028 67EE877A 		vmul.f32	s15, s15, s14
 212:MotorControl/encoder.cpp ****     lockin_config.finish_on_distance = true;
 2689              		.loc 3 212 35 view .LVU604
 2690 002c CDED087A 		vstr.32	s15, [sp, #32]
 213:MotorControl/encoder.cpp ****     lockin_config.finish_on_enc_idx = false;
 2691              		.loc 3 213 5 is_stmt 1 view .LVU605
 213:MotorControl/encoder.cpp ****     lockin_config.finish_on_enc_idx = false;
 2692              		.loc 3 213 38 is_stmt 0 view .LVU606
 2693 0030 0123     		movs	r3, #1
 2694 0032 8DF82530 		strb	r3, [sp, #37]
 214:MotorControl/encoder.cpp ****     lockin_config.finish_on_vel = false;
 2695              		.loc 3 214 5 is_stmt 1 view .LVU607
 214:MotorControl/encoder.cpp ****     lockin_config.finish_on_vel = false;
 2696              		.loc 3 214 37 is_stmt 0 view .LVU608
 2697 0036 0023     		movs	r3, #0
 2698 0038 8DF82630 		strb	r3, [sp, #38]
 215:MotorControl/encoder.cpp **** 
 2699              		.loc 3 215 5 is_stmt 1 view .LVU609
 215:MotorControl/encoder.cpp **** 
 2700              		.loc 3 215 33 is_stmt 0 view .LVU610
 2701 003c 8DF82430 		strb	r3, [sp, #36]
 217:MotorControl/encoder.cpp ****         if (const_vel)
 2702              		.loc 3 217 5 is_stmt 1 view .LVU611
 224:MotorControl/encoder.cpp ****     states_seen_count_.fill(0);
 2703              		.loc 3 224 5 view .LVU612
 224:MotorControl/encoder.cpp ****     states_seen_count_.fill(0);
 2704              		.loc 3 224 38 is_stmt 0 view .LVU613
 2705 0040 84F86530 		strb	r3, [r4, #101]
 225:MotorControl/encoder.cpp ****     bool success = axis_->run_lockin_spin(lockin_config, false, loop_cb);
 2706              		.loc 3 225 5 is_stmt 1 view .LVU614
 2707              	.LVL176:
 2708              	.LBB1508:
ARM GAS  /tmp/cc5nV8qb.s 			page 153


 2709              	.LBI1508:
 2710              		.file 18 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // <array> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // Copyright (C) 2007-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** /** @file include/array
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****  *  This is a Standard C++ Library header.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****  */
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #ifndef _GLIBCXX_ARRAY
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #define _GLIBCXX_ARRAY 1
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #pragma GCC system_header
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #if __cplusplus < 201103L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** # include <bits/c++0x_warning.h>
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #else
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <utility>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <bits/functexcept.h>
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <bits/stl_algobase.h>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <bits/range_access.h>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** namespace std _GLIBCXX_VISIBILITY(default)
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** {
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   template<typename _Tp, std::size_t _Nm>
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     struct __array_traits
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     {
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef _Tp _Type[_Nm];
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef __is_swappable<_Tp> _Is_swappable;
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       static constexpr _Tp&
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _S_ref(const _Type& __t, std::size_t __n) noexcept
ARM GAS  /tmp/cc5nV8qb.s 			page 154


  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       static constexpr _Tp*
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _S_ptr(const _Type& __t) noexcept
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp*>(__t); }
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     };
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****  template<typename _Tp>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    struct __array_traits<_Tp, 0>
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    {
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      struct _Type { };
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      typedef true_type _Is_swappable;
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      typedef true_type _Is_nothrow_swappable;
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      static constexpr _Tp&
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      _S_ref(const _Type&, std::size_t) noexcept
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      { return *static_cast<_Tp*>(nullptr); }
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      static constexpr _Tp*
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      _S_ptr(const _Type&) noexcept
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      { return nullptr; }
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    };
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   /**
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @brief A standard container for storing a fixed size sequence of elements.
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @ingroup sequences
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  Meets the requirements of a <a href="tables.html#65">container</a>, a
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  <a href="tables.html#66">reversible container</a>, and a
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  <a href="tables.html#67">sequence</a>.
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  Sets support random access iterators.
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @tparam  Tp  Type of element. Required to be a complete type.
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @tparam  Nm  Number of elements.
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   */
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   template<typename _Tp, std::size_t _Nm>
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     struct array
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     {
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef _Tp 	    			      value_type;
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef value_type*			      pointer;
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef const value_type*                       const_pointer;
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef value_type&                   	      reference;
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef const value_type&             	      const_reference;
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef value_type*          		      iterator;
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef const value_type*			      const_iterator;
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::size_t                    	      size_type;
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::ptrdiff_t                   	      difference_type;
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::reverse_iterator<iterator>	      reverse_iterator;
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::reverse_iterator<const_iterator>   const_reverse_iterator;
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Support for zero-sized arrays mandatory.
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef _GLIBCXX_STD_C::__array_traits<_Tp, _Nm> _AT_Type;
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typename _AT_Type::_Type                         _M_elems;
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // No explicit construct/copy/destroy for aggregate type.
ARM GAS  /tmp/cc5nV8qb.s 			page 155


 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // DR 776.
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX20_CONSTEXPR void
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       fill(const value_type& __u)
 2711              		.loc 18 116 7 view .LVU615
 2712              	.LBB1509:
 2713              	.LBI1509:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { std::fill_n(begin(), size(), __u); }
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX20_CONSTEXPR void
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       swap(array& __other)
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       noexcept(_AT_Type::_Is_nothrow_swappable::value)
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { std::swap_ranges(begin(), end(), __other.begin()); }
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Iterators.
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR iterator
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       begin() noexcept
 2714              		.loc 18 126 7 view .LVU616
 2715              	.LBB1510:
 2716              	.LBI1510:
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return iterator(data()); }
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       begin() const noexcept
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data()); }
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR iterator
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       end() noexcept
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return iterator(data() + _Nm); }
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       end() const noexcept
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data() + _Nm); }
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reverse_iterator
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rbegin() noexcept
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return reverse_iterator(end()); }
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rbegin() const noexcept
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(end()); }
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reverse_iterator
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rend() noexcept
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return reverse_iterator(begin()); }
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rend() const noexcept
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(begin()); }
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       cbegin() const noexcept
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data()); }
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       cend() const noexcept
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data() + _Nm); }
ARM GAS  /tmp/cc5nV8qb.s 			page 156


 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       crbegin() const noexcept
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(end()); }
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       crend() const noexcept
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(begin()); }
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Capacity.
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       constexpr size_type
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       size() const noexcept { return _Nm; }
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       constexpr size_type
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       max_size() const noexcept { return _Nm; }
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX_NODISCARD constexpr bool
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       empty() const noexcept { return size() == 0; }
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Element access.
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reference
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       operator[](size_type __n) noexcept
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       constexpr const_reference
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       operator[](size_type __n) const noexcept
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reference
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       at(size_type __n)
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       {
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 	if (__n >= _Nm)
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 	  std::__throw_out_of_range_fmt(__N("array::at: __n (which is %zu) "
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 					    ">= _Nm (which is %zu)"),
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 					__n, _Nm);
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 	return _AT_Type::_S_ref(_M_elems, __n);
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       }
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       constexpr const_reference
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       at(size_type __n) const
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       {
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 	// Result of conditional expression must be an lvalue so use
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 	// boolean ? lvalue : (throw-expr, lvalue)
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 	return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 	  : (std::__throw_out_of_range_fmt(__N("array::at: __n (which is %zu) "
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 					       ">= _Nm (which is %zu)"),
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 					   __n, _Nm),
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 	     _AT_Type::_S_ref(_M_elems, 0));
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       }
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reference
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       front() noexcept
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return *begin(); }
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       constexpr const_reference
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       front() const noexcept
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, 0); }
ARM GAS  /tmp/cc5nV8qb.s 			page 157


 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reference
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       back() noexcept
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _Nm ? *(end() - 1) : *end(); }
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       constexpr const_reference
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       back() const noexcept
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       {
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 	return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****  	           : _AT_Type::_S_ref(_M_elems, 0);
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       }
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR pointer
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       data() noexcept
 2717              		.loc 18 234 7 view .LVU617
 2718              	.LBB1511:
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ptr(_M_elems); }
 2719              		.loc 18 235 33 is_stmt 0 view .LVU618
 2720 0044 04F1F803 		add	r3, r4, #248
 2721              	.LVL177:
 2722              		.loc 18 235 33 view .LVU619
 2723              	.LBE1511:
 2724              	.LBE1510:
 2725              	.LBE1509:
 2726              	.LBB1512:
 2727              	.LBI1512:
 2728              		.file 19 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Core algorithmic facilities -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Copyright (C) 2001-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** /*
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Copyright (c) 1994
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Hewlett-Packard Company
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Permission to use, copy, modify, distribute and sell this software
ARM GAS  /tmp/cc5nV8qb.s 			page 158


  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * and its documentation for any purpose is hereby granted without fee,
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * provided that the above copyright notice appear in all copies and
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * that both that copyright notice and this permission notice appear
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * in supporting documentation.  Hewlett-Packard Company makes no
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * representations about the suitability of this software for any
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Copyright (c) 1996-1998
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Silicon Graphics Computer Systems, Inc.
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Permission to use, copy, modify, distribute and sell this software
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * and its documentation for any purpose is hereby granted without fee,
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * provided that the above copyright notice appear in all copies and
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * that both that copyright notice and this permission notice appear
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * in supporting documentation.  Silicon Graphics makes no
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * representations about the suitability of this software for any
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  */
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** /** @file bits/stl_algobase.h
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *  This is an internal header file, included by other library headers.
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *  Do not attempt to use it directly. @headername{algorithm}
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  */
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #ifndef _STL_ALGOBASE_H
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #define _STL_ALGOBASE_H 1
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/c++config.h>
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/functexcept.h>
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/cpp_type_traits.h>
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <ext/type_traits.h>
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <ext/numeric_traits.h>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_pair.h>
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator_base_types.h>
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator_base_funcs.h>
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator.h>
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/concept_check.h>
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <debug/debug.h>
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/move.h> // For std::swap
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/predefined_ops.h>
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** # include <type_traits>
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus > 201703L
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** # include <compare>
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** namespace std _GLIBCXX_VISIBILITY(default)
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** {
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /*
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    * A constexpr wrapper for __builtin_memcmp.
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    * @param __num The number of elements of type _Tp (not bytes).
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    */
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp, typename _Up>
ARM GAS  /tmp/cc5nV8qb.s 			page 159


  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline int
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #ifdef __cpp_lib_is_constant_evaluated
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (std::is_constant_evaluated())
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  for(; __num > 0; ++__first1, ++__first2, --__num)
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    if (*__first1 != *__first2)
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      return *__first1 < *__first2 ? -1 : 1;
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return 0;
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       else
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus < 201103L
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // nutshell, we are partially implementing the resolution of DR 187,
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // when it's safe, i.e., the value_types are equal.
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _BoolType>
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __iter_swap
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _ForwardIterator1, typename _ForwardIterator2>
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static void
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  typedef typename iterator_traits<_ForwardIterator1>::value_type
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    _ValueType1;
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  _ValueType1 __tmp = *__a;
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  *__a = *__b;
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  *__b = __tmp;
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<>
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __iter_swap<true>
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _ForwardIterator1, typename _ForwardIterator2>
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static void
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  swap(*__a, *__b);
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif // C++03
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Swaps the contents of two iterators.
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  An iterator.
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another iterator.
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   Nothing.
ARM GAS  /tmp/cc5nV8qb.s 			page 160


 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This function swaps the values pointed to by two iterators, not the
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  iterators themselves.
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2>
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline void
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator1>)
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator2>)
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus < 201103L
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator1>::value_type
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ValueType1;
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator2>::value_type
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ValueType2;
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ValueType2>)
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ValueType1>)
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator1>::reference
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ReferenceType1;
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator2>::reference
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ReferenceType2;
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	&& __are_same<_ValueType1&, _ReferenceType1>::__value
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	&& __are_same<_ValueType2&, _ReferenceType2>::__value>::
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(__a, __b);
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #else
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // _GLIBCXX_RESOLVE_LIB_DEFECTS
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // 187. iter_swap underspecified
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       swap(*__a, *__b);
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Swap the elements of two sequences.
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first1  A forward iterator.
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __last1   A forward iterator.
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first2  A forward iterator.
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   An iterator equal to @p first2+(last1-first1).
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  Swaps each element in the range @p [first1,last1) with the
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  corresponding element in the range @p [first2,(last1-first1)).
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  The ranges must not overlap.
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2>
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _ForwardIterator2
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
ARM GAS  /tmp/cc5nV8qb.s 			page 161


 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		_ForwardIterator2 __first2)
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator1>)
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator2>)
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_requires_valid_range(__first1, __last1);
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       for (; __first1 != __last1; ++__first1, (void)++__first2)
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	std::iter_swap(__first1, __first2);
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __first2;
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief This does what you think it does.
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup sorting_algorithms
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  A thing of arbitrary type.
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another thing of arbitrary type.
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   The lesser of the parameters.
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This is the simple classic generic implementation.  It will work on
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  temporary expressions, since they are only evaluated once, unlike a
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  preprocessor macro.
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp>
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline const _Tp&
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     min(const _Tp& __a, const _Tp& __b)
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       //return __b < __a ? __b : __a;
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (__b < __a)
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief This does what you think it does.
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup sorting_algorithms
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  A thing of arbitrary type.
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another thing of arbitrary type.
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   The greater of the parameters.
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This is the simple classic generic implementation.  It will work on
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  temporary expressions, since they are only evaluated once, unlike a
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  preprocessor macro.
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp>
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline const _Tp&
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     max(const _Tp& __a, const _Tp& __b)
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       //return  __a < __b ? __b : __a;
ARM GAS  /tmp/cc5nV8qb.s 			page 162


 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (__a < __b)
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief This does what you think it does.
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup sorting_algorithms
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  A thing of arbitrary type.
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another thing of arbitrary type.
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __comp  A @link comparison_functors comparison functor@endlink.
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   The lesser of the parameters.
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This will work on temporary expressions, since they are only evaluated
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  once, unlike a preprocessor macro.
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp, typename _Compare>
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline const _Tp&
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     min(const _Tp& __a, const _Tp& __b, _Compare __comp)
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       //return __comp(__b, __a) ? __b : __a;
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (__comp(__b, __a))
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief This does what you think it does.
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup sorting_algorithms
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  A thing of arbitrary type.
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another thing of arbitrary type.
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __comp  A @link comparison_functors comparison functor@endlink.
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   The greater of the parameters.
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This will work on temporary expressions, since they are only evaluated
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  once, unlike a preprocessor macro.
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp, typename _Compare>
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline const _Tp&
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     max(const _Tp& __a, const _Tp& __b, _Compare __comp)
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       //return __comp(__a, __b) ? __b : __a;
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (__comp(__a, __b))
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // Fallback implementation of the function in bits/stl_iterator.h used to
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // remove the __normal_iterator wrapper. See copy, fill, ...
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Iterator>
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _Iterator
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __niter_base(_Iterator __it)
 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     { return __it; }
ARM GAS  /tmp/cc5nV8qb.s 			page 163


 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // Reverse the __niter_base transformation to get a
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // __normal_iterator back again (this assumes that __normal_iterator
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // is only used to wrap random access iterators, like pointers).
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _From, typename _To>
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _From
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __niter_wrap(_From __from, _To __res)
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     { return __from + (__res - std::__niter_base(__from)); }
 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // No need to wrap, iterator already has the right type.
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Iterator>
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _Iterator
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __niter_wrap(const _Iterator&, _Iterator __res)
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     { return __res; }
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // All of these auxiliary structs serve two purposes.  (1) Replace
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // because the input and output ranges are permitted to overlap.)
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // (2) If we're using random access iterators, then write the loop as
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // a for loop with an explicit count.
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove, bool _IsSimple, typename _Category>
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __copy_move
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _II, typename _OI>
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_GLIBCXX20_CONSTEXPR
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static _OI
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	__copy_m(_II __first, _II __last, _OI __result)
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  for (; __first != __last; ++__result, (void)++__first)
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    *__result = *__first;
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return __result;
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Category>
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __copy_move<true, false, _Category>
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _II, typename _OI>
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_GLIBCXX20_CONSTEXPR
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static _OI
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	__copy_m(_II __first, _II __last, _OI __result)
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  for (; __first != __last; ++__result, (void)++__first)
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    *__result = std::move(*__first);
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return __result;
 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<>
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __copy_move<false, false, random_access_iterator_tag>
 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _II, typename _OI>
ARM GAS  /tmp/cc5nV8qb.s 			page 164


 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_GLIBCXX20_CONSTEXPR
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static _OI
 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	__copy_m(_II __first, _II __last, _OI __result)
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  typedef typename iterator_traits<_II>::difference_type _Distance;
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  for(_Distance __n = __last - __first; __n > 0; --__n)
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    {
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      *__result = *__first;
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      ++__first;
 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      ++__result;
 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    }
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return __result;
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<>
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __copy_move<true, false, random_access_iterator_tag>
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _II, typename _OI>
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_GLIBCXX20_CONSTEXPR
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static _OI
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	__copy_m(_II __first, _II __last, _OI __result)
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  typedef typename iterator_traits<_II>::difference_type _Distance;
 398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  for(_Distance __n = __last - __first; __n > 0; --__n)
 399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    {
 400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      *__result = std::move(*__first);
 401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      ++__first;
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      ++__result;
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    }
 404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return __result;
 405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove>
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __copy_move<_IsMove, true, random_access_iterator_tag>
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _Tp>
 413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_GLIBCXX20_CONSTEXPR
 414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static _Tp*
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	__copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
 416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  using __assignable = conditional<_IsMove,
 419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 					   is_move_assignable<_Tp>,
 420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 					   is_copy_assignable<_Tp>>;
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  // trivial types can have deleted assignment
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  static_assert( __assignable::type::value, "type is not assignable" );
 423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  const ptrdiff_t _Num = __last - __first;
 425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  if (_Num)
 426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
 427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return __result + _Num;
 428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
ARM GAS  /tmp/cc5nV8qb.s 			page 165


 430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // Helpers for streambuf iterators (either istream or ostream).
 432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // NB: avoid including <iosfwd>, relatively large.
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _CharT>
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct char_traits;
 435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _CharT, typename _Traits>
 437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     class istreambuf_iterator;
 438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _CharT, typename _Traits>
 440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     class ostreambuf_iterator;
 441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove, typename _CharT>
 443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
 444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
 445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_a2(_CharT*, _CharT*,
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
 447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove, typename _CharT>
 449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
 450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_a2(const _CharT*, const _CharT*,
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
 453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove, typename _CharT>
 455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
 456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				    _CharT*>::__type
 457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
 458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		   istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);
 459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove, typename _II, typename _OI>
 461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _OI
 463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_a2(_II __first, _II __last, _OI __result)
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_II>::iterator_category _Category;
 466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #ifdef __cpp_lib_is_constant_evaluated
 467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (std::is_constant_evaluated())
 468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return std::__copy_move<_IsMove, false, _Category>::
 469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  __copy_m(__first, __last, __result);
 470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
 472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 			      _Category>::__copy_m(__first, __last, __result);
 473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp, typename _Ref, typename _Ptr>
 478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct _Deque_iterator;
 479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** _GLIBCXX_END_NAMESPACE_CONTAINER
 481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove,
 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	   typename _Tp, typename _Ref, typename _Ptr, typename _OI>
 484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _OI
 485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_a1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
 486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		   _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
ARM GAS  /tmp/cc5nV8qb.s 			page 166


 487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		   _OI);
 488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove,
 490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	   typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
 491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>
 492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_a1(_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,
 493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		   _GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,
 494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		   _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>);
 495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove, typename _II, typename _Tp>
 497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     typename __gnu_cxx::__enable_if<
 498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __is_random_access_iter<_II>::__value,
 499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
 500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_a1(_II, _II, _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>);
 501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove, typename _II, typename _OI>
 503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _OI
 505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_a1(_II __first, _II __last, _OI __result)
 506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }
 507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove, typename _II, typename _OI>
 509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _OI
 511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_a(_II __first, _II __last, _OI __result)
 512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return std::__niter_wrap(__result,
 514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
 515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 					     std::__niter_base(__last),
 516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 					     std::__niter_base(__result)));
 517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove,
 520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	   typename _Ite, typename _Seq, typename _Cat, typename _OI>
 521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _OI
 522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
 524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		  _OI);
 525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove,
 527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	   typename _II, typename _Ite, typename _Seq, typename _Cat>
 528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
 529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_a(_II, _II,
 530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);
 531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove,
 533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	   typename _IIte, typename _ISeq, typename _ICat,
 534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	   typename _OIte, typename _OSeq, typename _OCat>
 535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
 536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
 537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
 538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
 539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Copies the range [first,last) into result.
 542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first  An input iterator.
ARM GAS  /tmp/cc5nV8qb.s 			page 167


 544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __last   An input iterator.
 545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __result An output iterator.
 546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   result + (last - first)
 547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This inline function will boil down to a call to @c memmove whenever
 549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  possible.  Failing that, if random access iterators are passed, then the
 550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  loop count will be known (and therefore a candidate for compiler
 551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  optimizations such as unrolling).  Result may not be contained within
 552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  [first,last); the copy_backward function should be used instead.
 553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  Note that the end of the output range is permitted to be contained
 555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  within [first,last).
 556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _II, typename _OI>
 558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _OI
 560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     copy(_II __first, _II __last, _OI __result)
 561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_InputIteratorConcept<_II>)
 564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OI,
 565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    typename iterator_traits<_II>::value_type>)
 566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_requires_can_increment_range(__first, __last, __result);
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return std::__copy_move_a<__is_move_iterator<_II>::__value>
 569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	     (std::__miter_base(__first), std::__miter_base(__last), __result);
 570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
 573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Moves the range [first,last) into result.
 575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first  An input iterator.
 577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __last   An input iterator.
 578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __result An output iterator.
 579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   result + (last - first)
 580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This inline function will boil down to a call to @c memmove whenever
 582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  possible.  Failing that, if random access iterators are passed, then the
 583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  loop count will be known (and therefore a candidate for compiler
 584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  optimizations such as unrolling).  Result may not be contained within
 585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  [first,last); the move_backward function should be used instead.
 586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  Note that the end of the output range is permitted to be contained
 588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  within [first,last).
 589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _II, typename _OI>
 591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _OI
 593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     move(_II __first, _II __last, _OI __result)
 594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_InputIteratorConcept<_II>)
 597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OI,
 598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    typename iterator_traits<_II>::value_type>)
 599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_requires_can_increment_range(__first, __last, __result);
 600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 168


 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return std::__copy_move_a<true>(std::__miter_base(__first),
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				      std::__miter_base(__last), __result);
 603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::move(_Tp, _Up, _Vp)
 606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #else
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::copy(_Tp, _Up, _Vp)
 608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove, bool _IsSimple, typename _Category>
 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __copy_move_backward
 612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _BI1, typename _BI2>
 614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_GLIBCXX20_CONSTEXPR
 615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static _BI2
 616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  while (__first != __last)
 619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    *--__result = *--__last;
 620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return __result;
 621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
 625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Category>
 626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __copy_move_backward<true, false, _Category>
 627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _BI1, typename _BI2>
 629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_GLIBCXX20_CONSTEXPR
 630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static _BI2
 631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  while (__first != __last)
 634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    *--__result = std::move(*--__last);
 635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return __result;
 636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<>
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __copy_move_backward<false, false, random_access_iterator_tag>
 642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _BI1, typename _BI2>
 644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_GLIBCXX20_CONSTEXPR
 645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static _BI2
 646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  typename iterator_traits<_BI1>::difference_type
 649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    __n = __last - __first;
 650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  for (; __n > 0; --__n)
 651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    *--__result = *--__last;
 652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return __result;
 653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
 657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<>
ARM GAS  /tmp/cc5nV8qb.s 			page 169


 658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __copy_move_backward<true, false, random_access_iterator_tag>
 659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _BI1, typename _BI2>
 661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_GLIBCXX20_CONSTEXPR
 662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static _BI2
 663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  typename iterator_traits<_BI1>::difference_type
 666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    __n = __last - __first;
 667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  for (; __n > 0; --__n)
 668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    *--__result = std::move(*--__last);
 669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return __result;
 670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove>
 675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
 676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _Tp>
 678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_GLIBCXX20_CONSTEXPR
 679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static _Tp*
 680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	__copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
 681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
 683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  using __assignable = conditional<_IsMove,
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 					   is_move_assignable<_Tp>,
 685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 					   is_copy_assignable<_Tp>>;
 686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  // trivial types can have deleted assignment
 687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  static_assert( __assignable::type::value, "type is not assignable" );
 688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  const ptrdiff_t _Num = __last - __first;
 690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  if (_Num)
 691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return __result - _Num;
 693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove, typename _BI1, typename _BI2>
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _BI2
 699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_BI1>::iterator_category _Category;
 702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #ifdef __cpp_lib_is_constant_evaluated
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (std::is_constant_evaluated())
 704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return std::__copy_move_backward<_IsMove, false, _Category>::
 705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  __copy_move_b(__first, __last, __result);
 706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return std::__copy_move_backward<_IsMove,
 708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				       __memcpyable<_BI2, _BI1>::__value,
 709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				       _Category>::__copy_move_b(__first,
 710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 								 __last,
 711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 								 __result);
 712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove, typename _BI1, typename _BI2>
ARM GAS  /tmp/cc5nV8qb.s 			page 170


 715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _BI2
 717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
 718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }
 719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove,
 721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	   typename _Tp, typename _Ref, typename _Ptr, typename _OI>
 722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _OI
 723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_backward_a1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
 724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 			    _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
 725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 			    _OI);
 726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove,
 728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	   typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
 729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>
 730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_backward_a1(
 731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 			_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,
 732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 			_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,
 733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 			_GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>);
 734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove, typename _II, typename _Tp>
 736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     typename __gnu_cxx::__enable_if<
 737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __is_random_access_iter<_II>::__value,
 738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
 739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_backward_a1(_II, _II,
 740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 			    _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>);
 741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove, typename _II, typename _OI>
 743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _OI
 745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_backward_a(_II __first, _II __last, _OI __result)
 746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return std::__niter_wrap(__result,
 748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		std::__copy_move_backward_a1<_IsMove>
 749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		  (std::__niter_base(__first), std::__niter_base(__last),
 750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		   std::__niter_base(__result)));
 751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove,
 754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	   typename _Ite, typename _Seq, typename _Cat, typename _OI>
 755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _OI
 756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_backward_a(
 757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
 758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
 759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		_OI);
 760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove,
 762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	   typename _II, typename _Ite, typename _Seq, typename _Cat>
 763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
 764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_backward_a(_II, _II,
 765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);
 766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _IsMove,
 768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	   typename _IIte, typename _ISeq, typename _ICat,
 769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	   typename _OIte, typename _OSeq, typename _OCat>
 770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
 771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __copy_move_backward_a(
ARM GAS  /tmp/cc5nV8qb.s 			page 171


 772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
 773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
 774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
 775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Copies the range [first,last) into result.
 778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first  A bidirectional iterator.
 780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __last   A bidirectional iterator.
 781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __result A bidirectional iterator.
 782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   result - (last - first)
 783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  The function has the same effect as copy, but starts at the end of the
 785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  range and works its way to the start, returning the start of the result.
 786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This inline function will boil down to a call to @c memmove whenever
 787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  possible.  Failing that, if random access iterators are passed, then the
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  loop count will be known (and therefore a candidate for compiler
 789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  optimizations such as unrolling).
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  Result may not be in the range (first,last].  Use copy instead.  Note
 792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  that the start of the output range may overlap [first,last).
 793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _BI1, typename _BI2>
 795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _BI2
 797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
 798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
 801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
 802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_ConvertibleConcept<
 803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    typename iterator_traits<_BI1>::value_type,
 804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    typename iterator_traits<_BI2>::value_type>)
 805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_requires_can_decrement_range(__first, __last, __result);
 806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
 808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	     (std::__miter_base(__first), std::__miter_base(__last), __result);
 809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
 812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Moves the range [first,last) into result.
 814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first  A bidirectional iterator.
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __last   A bidirectional iterator.
 817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __result A bidirectional iterator.
 818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   result - (last - first)
 819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  The function has the same effect as move, but starts at the end of the
 821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  range and works its way to the start, returning the start of the result.
 822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This inline function will boil down to a call to @c memmove whenever
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  possible.  Failing that, if random access iterators are passed, then the
 824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  loop count will be known (and therefore a candidate for compiler
 825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  optimizations such as unrolling).
 826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  Result may not be in the range (first,last].  Use move instead.  Note
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  that the start of the output range may overlap [first,last).
ARM GAS  /tmp/cc5nV8qb.s 			page 172


 829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _BI1, typename _BI2>
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _BI2
 833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
 834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
 837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
 838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_ConvertibleConcept<
 839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    typename iterator_traits<_BI1>::value_type,
 840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    typename iterator_traits<_BI2>::value_type>)
 841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_requires_can_decrement_range(__first, __last, __result);
 842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return std::__copy_move_backward_a<true>(std::__miter_base(__first),
 844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 					       std::__miter_base(__last),
 845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 					       __result);
 846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::move_backward(_Tp, _Up, _Vp)
 849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #else
 850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::copy_backward(_Tp, _Up, _Vp)
 851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _ForwardIterator, typename _Tp>
 854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline typename
 856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
 857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
 858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      const _Tp& __value)
 859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       for (; __first != __last; ++__first)
 861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	*__first = __value;
 862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _ForwardIterator, typename _Tp>
 865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline typename
 867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
 869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      const _Tp& __value)
 870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       const _Tp __tmp = __value;
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       for (; __first != __last; ++__first)
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	*__first = __tmp;
 874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // Specialization: for char types we can use memset.
 877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp>
 878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline typename
 880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
 881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
 882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       const _Tp __tmp = __c;
 884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cpp_lib_is_constant_evaluated
 885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (std::is_constant_evaluated())
ARM GAS  /tmp/cc5nV8qb.s 			page 173


 886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  for (; __first != __last; ++__first)
 888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    *__first = __tmp;
 889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return;
 890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (const size_t __len = __last - __first)
 893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	__builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
 894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Ite, typename _Cont, typename _Tp>
 897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline void
 899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
 900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
 901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      const _Tp& __value)
 902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     { std::__fill_a1(__first.base(), __last.base(), __value); }
 903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp, typename _VTp>
 905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     void
 906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __fill_a1(const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
 907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
 908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      const _VTp&);
 909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _FIte, typename _Tp>
 911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline void
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
 914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     { std::__fill_a1(__first, __last, __value); }
 915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
 917:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     void
 918:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
 919:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	     const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
 920:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	     const _Tp&);
 921:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 922:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 923:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Fills the range [first,last) with copies of value.
 924:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 925:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first  A forward iterator.
 926:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __last   A forward iterator.
 927:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __value  A reference-to-const of arbitrary type.
 928:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   Nothing.
 929:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 930:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This function fills a range with copies of the same value.  For char
 931:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  types filling contiguous areas of memory, this becomes an inline call
 932:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  to @c memset or @c wmemset.
 933:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 934:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _ForwardIterator, typename _Tp>
 935:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 936:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline void
 937:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
 938:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 939:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 940:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 941:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator>)
 942:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_requires_valid_range(__first, __last);
ARM GAS  /tmp/cc5nV8qb.s 			page 174


 943:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 944:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       std::__fill_a(__first, __last, __value);
 945:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 946:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 947:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // Used by fill_n, generate_n, etc. to convert _Size to an integral type:
 948:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR int
 949:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(int __n) { return __n; }
 950:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR unsigned
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(unsigned __n) { return __n; }
 952:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR long
 953:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(long __n) { return __n; }
 954:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR unsigned long
 955:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(unsigned long __n) { return __n; }
 956:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR long long
 957:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(long long __n) { return __n; }
 958:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR unsigned long long
 959:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(unsigned long long __n) { return __n; }
 960:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 961:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if defined(__GLIBCXX_TYPE_INT_N_0)
 962:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_0
 963:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(__GLIBCXX_TYPE_INT_N_0 __n) { return __n; }
 964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_0
 965:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_0 __n) { return __n; }
 966:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 967:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if defined(__GLIBCXX_TYPE_INT_N_1)
 968:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_1
 969:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(__GLIBCXX_TYPE_INT_N_1 __n) { return __n; }
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_1
 971:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_1 __n) { return __n; }
 972:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 973:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if defined(__GLIBCXX_TYPE_INT_N_2)
 974:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_2
 975:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(__GLIBCXX_TYPE_INT_N_2 __n) { return __n; }
 976:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_2
 977:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_2 __n) { return __n; }
 978:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 979:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if defined(__GLIBCXX_TYPE_INT_N_3)
 980:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_3
 981:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(__GLIBCXX_TYPE_INT_N_3 __n) { return __n; }
 982:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_3
 983:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_3 __n) { return __n; }
 984:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 985:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 986:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR long long
 987:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(float __n) { return (long long)__n; }
 988:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR long long
 989:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(double __n) { return (long long)__n; }
 990:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR long long
 991:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(long double __n) { return (long long)__n; }
 992:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128)
 993:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR long long
 994:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   __size_to_integer(__float128 __n) { return (long long)__n; }
 995:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 996:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 997:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _OutputIterator, typename _Size, typename _Tp>
 998:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 999:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline typename
ARM GAS  /tmp/cc5nV8qb.s 			page 175


1000:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
1001:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
1002:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
1003:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       for (; __n > 0; --__n, (void) ++__first)
1004:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	*__first = __value;
1005:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __first;
1006:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
1007:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
1008:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _OutputIterator, typename _Size, typename _Tp>
1009:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
1010:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline typename
1011:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
1012:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
1013:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
1014:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       const _Tp __tmp = __value;
1015:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       for (; __n > 0; --__n, (void) ++__first)
1016:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	*__first = __tmp;
1017:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __first;
1018:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
1019:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
1020:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
1021:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	   typename _Tp>
1022:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
1023:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
1024:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	       _Size __n, const _Tp& __value,
1025:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	       std::input_iterator_tag);
1026:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
1027:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _OutputIterator, typename _Size, typename _Tp>
1028:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
1029:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _OutputIterator
1030:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
1031:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	       std::output_iterator_tag)
1032:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
1033:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
1034:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
1035:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
1036:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __fill_n_a1(__first, __n, __value);
1037:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
1038:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
1039:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _OutputIterator, typename _Size, typename _Tp>
1040:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
1041:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _OutputIterator
1042:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
1043:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	       std::input_iterator_tag)
1044:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
1045:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
1046:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
1047:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
1048:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __fill_n_a1(__first, __n, __value);
1049:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
1050:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
1051:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _OutputIterator, typename _Size, typename _Tp>
1052:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
1053:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _OutputIterator
1054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
1055:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	       std::random_access_iterator_tag)
1056:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
ARM GAS  /tmp/cc5nV8qb.s 			page 176


1057:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
1058:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
1059:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
1060:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (__n <= 0)
1061:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __first;
1062:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
1063:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_requires_can_increment(__first, __n);
1064:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
1065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       std::__fill_a(__first, __first + __n, __value);
1066:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __first + __n;
1067:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
1068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
1069:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
1070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Fills the range [first,first+n) with copies of value.
1071:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first  An output iterator.
1073:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __n      The count of copies to perform.
1074:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __value  A reference-to-const of arbitrary type.
1075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   The iterator at first+n.
1076:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
1077:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This function fills a range with copies of the same value.  For char
1078:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  types filling contiguous areas of memory, this becomes an inline call
1079:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  to @c memset or @c wmemset.
1080:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
1081:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  If @p __n is negative, the function does nothing.
1082:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
1083:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // _GLIBCXX_RESOLVE_LIB_DEFECTS
1084:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // DR 865. More algorithms that throw away information
1085:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // DR 426. search_n(), fill_n(), and generate_n() with negative n
1086:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _OI, typename _Size, typename _Tp>
1087:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
1088:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline _OI
1089:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     fill_n(_OI __first, _Size __n, const _Tp& __value)
 2729              		.loc 19 1089 5 is_stmt 1 view .LVU620
 2730              		.loc 19 1089 5 is_stmt 0 view .LVU621
 2731              	.LBE1512:
 2732              	.LBE1508:
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR long
 2733              		.loc 19 951 37 is_stmt 1 view .LVU622
 2734              	.LBB1520:
 2735              	.LBB1519:
 2736              	.LBB1513:
 2737              	.LBB1514:
 2738              	.LBI1514:
1054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	       std::random_access_iterator_tag)
 2739              		.loc 19 1054 5 view .LVU623
 2740              	.LBB1515:
1065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __first + __n;
 2741              		.loc 19 1065 20 is_stmt 0 view .LVU624
 2742 0048 04F58C71 		add	r1, r4, #280
 2743              	.LVL178:
 2744              	.LBB1516:
 2745              	.LBI1516:
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     { std::__fill_a1(__first, __last, __value); }
 2746              		.loc 19 913 5 is_stmt 1 view .LVU625
 2747              	.LBB1517:
 2748              	.LBI1517:
ARM GAS  /tmp/cc5nV8qb.s 			page 177


 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      const _Tp& __value)
 2749              		.loc 19 868 5 view .LVU626
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      const _Tp& __value)
 2750              		.loc 19 868 5 is_stmt 0 view .LVU627
 2751 004c 02E0     		b	.L147
 2752              	.LVL179:
 2753              	.L165:
 2754              	.LBB1518:
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 2755              		.loc 19 873 11 view .LVU628
 2756 004e 0022     		movs	r2, #0
 2757 0050 43F8042B 		str	r2, [r3], #4
 2758              	.LVL180:
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	*__first = __tmp;
 2759              		.loc 19 872 7 is_stmt 1 view .LVU629
 2760              	.L147:
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	*__first = __tmp;
 2761              		.loc 19 872 22 view .LVU630
 2762 0054 9942     		cmp	r1, r3
 2763 0056 FAD1     		bne	.L165
 2764              	.LVL181:
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	*__first = __tmp;
 2765              		.loc 19 872 22 is_stmt 0 view .LVU631
 2766              	.LBE1518:
 2767              	.LBE1517:
 2768              	.LBE1516:
 2769              	.LBE1515:
 2770              	.LBE1514:
 2771              	.LBE1513:
 2772              	.LBE1519:
 2773              	.LBE1520:
 226:MotorControl/encoder.cpp ****     sample_hall_states_ = false;
 2774              		.loc 3 226 5 is_stmt 1 view .LVU632
 226:MotorControl/encoder.cpp ****     sample_hall_states_ = false;
 2775              		.loc 3 226 20 is_stmt 0 view .LVU633
 2776 0058 256B     		ldr	r5, [r4, #48]
 226:MotorControl/encoder.cpp ****     sample_hall_states_ = false;
 2777              		.loc 3 226 42 view .LVU634
 2778 005a 2146     		mov	r1, r4
 2779 005c 0AA8     		add	r0, sp, #40
 2780 005e FFF7FEFF 		bl	_ZNSt8functionIFbbEEC1IZN7Encoder29run_hall_polarity_calibrationEvEUlbE_vvEET_
 2781              	.LVL182:
 2782 0062 0AAB     		add	r3, sp, #40
 2783 0064 0022     		movs	r2, #0
 2784 0066 03A9     		add	r1, sp, #12
 2785 0068 2846     		mov	r0, r5
 2786              	.LEHB5:
 2787 006a FFF7FEFF 		bl	_ZN4Axis15run_lockin_spinERKNS_14LockinConfig_tEbSt8functionIFbbEE
 2788              	.LVL183:
 2789              	.LEHE5:
 2790 006e 0646     		mov	r6, r0
 2791              	.LVL184:
 2792              	.LBB1521:
 2793              	.LBI1521:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 2794              		.loc 6 303 11 is_stmt 1 view .LVU635
 2795              	.LBB1522:
ARM GAS  /tmp/cc5nV8qb.s 			page 178


 2796              	.LBB1523:
 2797              	.LBI1523:
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     {
 2798              		.loc 6 242 5 view .LVU636
 2799              	.LBB1524:
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 2800              		.loc 6 244 7 view .LVU637
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 2801              		.loc 6 244 11 is_stmt 0 view .LVU638
 2802 0070 0C9B     		ldr	r3, [sp, #48]
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 2803              		.loc 6 244 7 view .LVU639
 2804 0072 1BB1     		cbz	r3, .L148
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 2805              		.loc 6 245 2 is_stmt 1 view .LVU640
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 2806              		.loc 6 245 12 is_stmt 0 view .LVU641
 2807 0074 0322     		movs	r2, #3
 2808 0076 0AA9     		add	r1, sp, #40
 2809              	.LVL185:
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 2810              		.loc 6 245 12 view .LVU642
 2811 0078 0846     		mov	r0, r1
 2812 007a 9847     		blx	r3
 2813              	.LVL186:
 2814              	.L148:
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 2815              		.loc 6 245 12 view .LVU643
 2816              	.LBE1524:
 2817              	.LBE1523:
 2818              	.LBE1522:
 2819              	.LBE1521:
 227:MotorControl/encoder.cpp **** 
 2820              		.loc 3 227 5 is_stmt 1 view .LVU644
 227:MotorControl/encoder.cpp **** 
 2821              		.loc 3 227 25 is_stmt 0 view .LVU645
 2822 007c 0023     		movs	r3, #0
 2823 007e 84F8F630 		strb	r3, [r4, #246]
 229:MotorControl/encoder.cpp ****         std::bitset<8> state_seen;
 2824              		.loc 3 229 5 is_stmt 1 view .LVU646
 2825              	.LBB1525:
 2826 0082 002E     		cmp	r6, #0
 2827 0084 46D0     		beq	.L163
 2828              	.LBB1526:
 230:MotorControl/encoder.cpp ****         std::bitset<8> state_confirmed;
 2829              		.loc 3 230 9 view .LVU647
 230:MotorControl/encoder.cpp ****         std::bitset<8> state_confirmed;
 2830              		.loc 3 230 24 is_stmt 0 view .LVU648
 2831 0086 0193     		str	r3, [sp, #4]
 231:MotorControl/encoder.cpp ****         for (int i = 0; i < 8; i++) {
 2832              		.loc 3 231 9 is_stmt 1 view .LVU649
 231:MotorControl/encoder.cpp ****         for (int i = 0; i < 8; i++) {
 2833              		.loc 3 231 24 is_stmt 0 view .LVU650
 2834 0088 0293     		str	r3, [sp, #8]
 232:MotorControl/encoder.cpp ****             if (states_seen_count_[i] > 0)
 2835              		.loc 3 232 9 is_stmt 1 view .LVU651
 2836              	.LVL187:
ARM GAS  /tmp/cc5nV8qb.s 			page 179


 232:MotorControl/encoder.cpp ****             if (states_seen_count_[i] > 0)
 2837              		.loc 3 232 9 is_stmt 0 view .LVU652
 2838 008a 00E0     		b	.L153
 2839              	.LVL188:
 2840              	.L152:
 2841              	.LBB1527:
 232:MotorControl/encoder.cpp ****             if (states_seen_count_[i] > 0)
 2842              		.loc 3 232 9 is_stmt 1 discriminator 2 view .LVU653
 2843 008c 0133     		adds	r3, r3, #1
 2844              	.LVL189:
 2845              	.L153:
 232:MotorControl/encoder.cpp ****             if (states_seen_count_[i] > 0)
 2846              		.loc 3 232 27 discriminator 1 view .LVU654
 2847 008e 072B     		cmp	r3, #7
 2848 0090 1EDC     		bgt	.L150
 233:MotorControl/encoder.cpp ****                 state_seen[i] = true;
 2849              		.loc 3 233 13 view .LVU655
 233:MotorControl/encoder.cpp ****                 state_seen[i] = true;
 2850              		.loc 3 233 37 is_stmt 0 view .LVU656
 2851 0092 1A46     		mov	r2, r3
 2852              	.LVL190:
 2853              	.LBB1528:
 2854              	.LBI1528:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 2855              		.loc 18 185 7 is_stmt 1 view .LVU657
 2856              	.LBB1529:
 2857              	.LBI1529:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 2858              		.loc 18 55 7 view .LVU658
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 2859              		.loc 18 55 7 is_stmt 0 view .LVU659
 2860              	.LBE1529:
 2861              	.LBE1528:
 233:MotorControl/encoder.cpp ****                 state_seen[i] = true;
 2862              		.loc 3 233 39 view .LVU660
 2863 0094 04EB8301 		add	r1, r4, r3, lsl #2
 2864 0098 D1F8F810 		ldr	r1, [r1, #248]
 233:MotorControl/encoder.cpp ****                 state_seen[i] = true;
 2865              		.loc 3 233 13 view .LVU661
 2866 009c 0029     		cmp	r1, #0
 2867 009e 09DD     		ble	.L151
 234:MotorControl/encoder.cpp ****             if (states_seen_count_[i] > 50)
 2868              		.loc 3 234 17 is_stmt 1 view .LVU662
 2869              	.LVL191:
 2870              	.LBB1530:
 2871              	.LBI1530:
 2872              		.file 20 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // <bitset> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // Copyright (C) 2001-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 180


  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** /*
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****  * Copyright (c) 1998
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****  * Silicon Graphics Computer Systems, Inc.
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****  *
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****  * Permission to use, copy, modify, distribute and sell this software
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****  * and its documentation for any purpose is hereby granted without fee,
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****  * provided that the above copyright notice appear in all copies and
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****  * that both that copyright notice and this permission notice appear
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****  * in supporting documentation.  Silicon Graphics makes no
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****  * representations about the suitability of this software for any
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****  * purpose.  It is provided "as is" without express or implied warranty.
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****  */
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** /** @file include/bitset
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****  *  This is a Standard C++ Library header.
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****  */
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #ifndef _GLIBCXX_BITSET
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #define _GLIBCXX_BITSET 1
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #pragma GCC system_header
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #include <string>
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #include <bits/functexcept.h>   // For invalid_argument, out_of_range,
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****                                 // overflow_error
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #include <iosfwd>
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #include <bits/cxxabi_forced.h>
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** # include <bits/functional_hash.h>
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #define _GLIBCXX_BITSET_BITS_PER_WORD  (__CHAR_BIT__ * __SIZEOF_LONG__)
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #define _GLIBCXX_BITSET_WORDS(__n) \
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   ((__n) / _GLIBCXX_BITSET_BITS_PER_WORD + \
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    ((__n) % _GLIBCXX_BITSET_BITS_PER_WORD == 0 ? 0 : 1))
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #define _GLIBCXX_BITSET_BITS_PER_ULL (__CHAR_BIT__ * __SIZEOF_LONG_LONG__)
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** namespace std _GLIBCXX_VISIBILITY(default)
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** {
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 181


  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   /**
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  Base class, general case.  It is a class invariant that _Nw will be
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  nonnegative.
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  See documentation for bitset.
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   */
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   template<size_t _Nw>
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     struct _Base_bitset
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     {
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       typedef unsigned long _WordT;
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /// 0 is the least significant word.
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _WordT 		_M_w[_Nw];
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _GLIBCXX_CONSTEXPR _Base_bitset() _GLIBCXX_NOEXCEPT
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       : _M_w() { }
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       constexpr _Base_bitset(unsigned long long __val) noexcept
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       : _M_w{ _WordT(__val)
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __SIZEOF_LONG_LONG__ > __SIZEOF_LONG__
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	       , _WordT(__val >> _GLIBCXX_BITSET_BITS_PER_WORD)
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        } { }
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #else
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _Base_bitset(unsigned long __val)
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       : _M_w()
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { _M_w[0] = __val; }
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static _GLIBCXX_CONSTEXPR size_t
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_whichword(size_t __pos) _GLIBCXX_NOEXCEPT
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return __pos / _GLIBCXX_BITSET_BITS_PER_WORD; }
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static _GLIBCXX_CONSTEXPR size_t
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_whichbyte(size_t __pos) _GLIBCXX_NOEXCEPT
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return (__pos % _GLIBCXX_BITSET_BITS_PER_WORD) / __CHAR_BIT__; }
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static _GLIBCXX_CONSTEXPR size_t
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_whichbit(size_t __pos) _GLIBCXX_NOEXCEPT
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static _GLIBCXX_CONSTEXPR _WordT
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_maskbit(size_t __pos) _GLIBCXX_NOEXCEPT
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _WordT&
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_getword(size_t __pos) _GLIBCXX_NOEXCEPT
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w[_S_whichword(__pos)]; }
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _GLIBCXX_CONSTEXPR _WordT
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_getword(size_t __pos) const _GLIBCXX_NOEXCEPT
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w[_S_whichword(__pos)]; }
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       const _WordT*
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_getdata() const noexcept
ARM GAS  /tmp/cc5nV8qb.s 			page 182


 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w; }
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _WordT&
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_hiword() _GLIBCXX_NOEXCEPT
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w[_Nw - 1]; }
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _GLIBCXX_CONSTEXPR _WordT
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_hiword() const _GLIBCXX_NOEXCEPT
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w[_Nw - 1]; }
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_and(const _Base_bitset<_Nw>& __x) _GLIBCXX_NOEXCEPT
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	for (size_t __i = 0; __i < _Nw; __i++)
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_w[__i] &= __x._M_w[__i];
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_or(const _Base_bitset<_Nw>& __x) _GLIBCXX_NOEXCEPT
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	for (size_t __i = 0; __i < _Nw; __i++)
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_w[__i] |= __x._M_w[__i];
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_xor(const _Base_bitset<_Nw>& __x) _GLIBCXX_NOEXCEPT
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	for (size_t __i = 0; __i < _Nw; __i++)
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_w[__i] ^= __x._M_w[__i];
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_left_shift(size_t __shift) _GLIBCXX_NOEXCEPT;
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_right_shift(size_t __shift) _GLIBCXX_NOEXCEPT;
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_flip() _GLIBCXX_NOEXCEPT
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	for (size_t __i = 0; __i < _Nw; __i++)
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_w[__i] = ~_M_w[__i];
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_set() _GLIBCXX_NOEXCEPT
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	for (size_t __i = 0; __i < _Nw; __i++)
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_w[__i] = ~static_cast<_WordT>(0);
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_reset() _GLIBCXX_NOEXCEPT
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { __builtin_memset(_M_w, 0, _Nw * sizeof(_WordT)); }
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bool
ARM GAS  /tmp/cc5nV8qb.s 			page 183


 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_is_equal(const _Base_bitset<_Nw>& __x) const _GLIBCXX_NOEXCEPT
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	for (size_t __i = 0; __i < _Nw; ++__i)
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  if (_M_w[__i] != __x._M_w[__i])
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    return false;
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return true;
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<size_t _Nb>
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         bool
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         _M_are_all() const _GLIBCXX_NOEXCEPT
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         {
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  for (size_t __i = 0; __i < _Nw - 1; __i++)
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    if (_M_w[__i] != ~static_cast<_WordT>(0))
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	      return false;
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  return _M_hiword() == (~static_cast<_WordT>(0)
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 				 >> (_Nw * _GLIBCXX_BITSET_BITS_PER_WORD
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 				     - _Nb));
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bool
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_is_any() const _GLIBCXX_NOEXCEPT
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	for (size_t __i = 0; __i < _Nw; __i++)
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  if (_M_w[__i] != static_cast<_WordT>(0))
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    return true;
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return false;
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       size_t
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_count() const _GLIBCXX_NOEXCEPT
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	size_t __result = 0;
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	for (size_t __i = 0; __i < _Nw; __i++)
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  __result += __builtin_popcountl(_M_w[__i]);
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return __result;
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       unsigned long
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_to_ulong() const;
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       unsigned long long
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_to_ullong() const;
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // find first "on" bit
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       size_t
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_find_first(size_t) const _GLIBCXX_NOEXCEPT;
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // find the next "on" bit that follows "prev"
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       size_t
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_find_next(size_t, size_t) const _GLIBCXX_NOEXCEPT;
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     };
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   // Definitions of non-inline functions from _Base_bitset.
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   template<size_t _Nw>
ARM GAS  /tmp/cc5nV8qb.s 			page 184


 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     void
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) _GLIBCXX_NOEXCEPT
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     {
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       if (__builtin_expect(__shift != 0, 1))
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  const size_t __wshift = __shift / _GLIBCXX_BITSET_BITS_PER_WORD;
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  const size_t __offset = __shift % _GLIBCXX_BITSET_BITS_PER_WORD;
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  if (__offset == 0)
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    for (size_t __n = _Nw - 1; __n >= __wshift; --__n)
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	      _M_w[__n] = _M_w[__n - __wshift];
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  else
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    {
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	      const size_t __sub_offset = (_GLIBCXX_BITSET_BITS_PER_WORD
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 					   - __offset);
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	      for (size_t __n = _Nw - 1; __n > __wshift; --__n)
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 		_M_w[__n] = ((_M_w[__n - __wshift] << __offset)
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 			     | (_M_w[__n - __wshift - 1] >> __sub_offset));
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	      _M_w[__wshift] = _M_w[0] << __offset;
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    }
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  std::fill(_M_w + 0, _M_w + __wshift, static_cast<_WordT>(0));
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     }
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   template<size_t _Nw>
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     void
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift) _GLIBCXX_NOEXCEPT
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     {
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       if (__builtin_expect(__shift != 0, 1))
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  const size_t __wshift = __shift / _GLIBCXX_BITSET_BITS_PER_WORD;
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  const size_t __offset = __shift % _GLIBCXX_BITSET_BITS_PER_WORD;
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  const size_t __limit = _Nw - __wshift - 1;
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  if (__offset == 0)
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    for (size_t __n = 0; __n <= __limit; ++__n)
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	      _M_w[__n] = _M_w[__n + __wshift];
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  else
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    {
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	      const size_t __sub_offset = (_GLIBCXX_BITSET_BITS_PER_WORD
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 					   - __offset);
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	      for (size_t __n = 0; __n < __limit; ++__n)
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 		_M_w[__n] = ((_M_w[__n + __wshift] >> __offset)
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 			     | (_M_w[__n + __wshift + 1] << __sub_offset));
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	      _M_w[__limit] = _M_w[_Nw-1] >> __offset;
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    }
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  std::fill(_M_w + __limit + 1, _M_w + _Nw, static_cast<_WordT>(0));
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     }
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   template<size_t _Nw>
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     unsigned long
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     _Base_bitset<_Nw>::_M_do_to_ulong() const
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     {
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       for (size_t __i = 1; __i < _Nw; ++__i)
ARM GAS  /tmp/cc5nV8qb.s 			page 185


 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	if (_M_w[__i])
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  __throw_overflow_error(__N("_Base_bitset::_M_do_to_ulong"));
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       return _M_w[0];
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     }
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   template<size_t _Nw>
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     unsigned long long
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     _Base_bitset<_Nw>::_M_do_to_ullong() const
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     {
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       const bool __dw = sizeof(unsigned long long) > sizeof(unsigned long);
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       for (size_t __i = 1 + __dw; __i < _Nw; ++__i)
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	if (_M_w[__i])
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  __throw_overflow_error(__N("_Base_bitset::_M_do_to_ullong"));
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       if (__dw)
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return _M_w[0] + (static_cast<unsigned long long>(_M_w[1])
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 			  << _GLIBCXX_BITSET_BITS_PER_WORD);
 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       return _M_w[0];
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     }
 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   template<size_t _Nw>
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     size_t
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     _Base_bitset<_Nw>::
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     _M_do_find_first(size_t __not_found) const _GLIBCXX_NOEXCEPT
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     {
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       for (size_t __i = 0; __i < _Nw; __i++)
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _WordT __thisword = _M_w[__i];
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  if (__thisword != static_cast<_WordT>(0))
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    return (__i * _GLIBCXX_BITSET_BITS_PER_WORD
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 		    + __builtin_ctzl(__thisword));
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // not found, so return an indication of failure.
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       return __not_found;
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     }
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   template<size_t _Nw>
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     size_t
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     _Base_bitset<_Nw>::
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     _M_do_find_next(size_t __prev, size_t __not_found) const _GLIBCXX_NOEXCEPT
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     {
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // make bound inclusive
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       ++__prev;
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // check out of bounds
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       if (__prev >= _Nw * _GLIBCXX_BITSET_BITS_PER_WORD)
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return __not_found;
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // search first word
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       size_t __i = _S_whichword(__prev);
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _WordT __thisword = _M_w[__i];
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // mask off bits below bound
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 186


 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       if (__thisword != static_cast<_WordT>(0))
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return (__i * _GLIBCXX_BITSET_BITS_PER_WORD
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 		+ __builtin_ctzl(__thisword));
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // check subsequent words
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       __i++;
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       for (; __i < _Nw; __i++)
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  __thisword = _M_w[__i];
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  if (__thisword != static_cast<_WordT>(0))
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    return (__i * _GLIBCXX_BITSET_BITS_PER_WORD
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 		    + __builtin_ctzl(__thisword));
 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // not found, so return an indication of failure.
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       return __not_found;
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     } // end _M_do_find_next
 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   /**
 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  Base class, specialization for a single word.
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  See documentation for bitset.
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   */
 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   template<>
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     struct _Base_bitset<1>
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     {
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       typedef unsigned long _WordT;
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _WordT _M_w;
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _GLIBCXX_CONSTEXPR _Base_bitset() _GLIBCXX_NOEXCEPT
 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       : _M_w(0)
 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { }
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       constexpr _Base_bitset(unsigned long long __val) noexcept
 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #else
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _Base_bitset(unsigned long __val)
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       : _M_w(__val)
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { }
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static _GLIBCXX_CONSTEXPR size_t
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_whichword(size_t __pos) _GLIBCXX_NOEXCEPT
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return __pos / _GLIBCXX_BITSET_BITS_PER_WORD; }
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static _GLIBCXX_CONSTEXPR size_t
 398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_whichbyte(size_t __pos) _GLIBCXX_NOEXCEPT
 399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return (__pos % _GLIBCXX_BITSET_BITS_PER_WORD) / __CHAR_BIT__; }
 400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static _GLIBCXX_CONSTEXPR size_t
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_whichbit(size_t __pos) _GLIBCXX_NOEXCEPT
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {  return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }
 404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static _GLIBCXX_CONSTEXPR _WordT
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_maskbit(size_t __pos) _GLIBCXX_NOEXCEPT
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
 408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _WordT&
ARM GAS  /tmp/cc5nV8qb.s 			page 187


 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_getword(size_t) _GLIBCXX_NOEXCEPT
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w; }
 412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _GLIBCXX_CONSTEXPR _WordT
 414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_getword(size_t) const _GLIBCXX_NOEXCEPT
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w; }
 416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       const _WordT*
 419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_getdata() const noexcept
 420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return &_M_w; }
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _WordT&
 424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_hiword() _GLIBCXX_NOEXCEPT
 425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w; }
 426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _GLIBCXX_CONSTEXPR _WordT
 428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_hiword() const _GLIBCXX_NOEXCEPT
 429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w; }
 430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_and(const _Base_bitset<1>& __x) _GLIBCXX_NOEXCEPT
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { _M_w &= __x._M_w; }
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_or(const _Base_bitset<1>& __x) _GLIBCXX_NOEXCEPT
 437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { _M_w |= __x._M_w; }
 438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_xor(const _Base_bitset<1>& __x) _GLIBCXX_NOEXCEPT
 441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { _M_w ^= __x._M_w; }
 442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_left_shift(size_t __shift) _GLIBCXX_NOEXCEPT
 445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { _M_w <<= __shift; }
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_right_shift(size_t __shift) _GLIBCXX_NOEXCEPT
 449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { _M_w >>= __shift; }
 450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_flip() _GLIBCXX_NOEXCEPT
 453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { _M_w = ~_M_w; }
 454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_set() _GLIBCXX_NOEXCEPT
 457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { _M_w = ~static_cast<_WordT>(0); }
 458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_reset() _GLIBCXX_NOEXCEPT
 461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { _M_w = 0; }
 462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bool
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_is_equal(const _Base_bitset<1>& __x) const _GLIBCXX_NOEXCEPT
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w == __x._M_w; }
 466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 188


 467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<size_t _Nb>
 468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         bool
 469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         _M_are_all() const _GLIBCXX_NOEXCEPT
 470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         { return _M_w == (~static_cast<_WordT>(0)
 471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 			  >> (_GLIBCXX_BITSET_BITS_PER_WORD - _Nb)); }
 472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bool
 474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_is_any() const _GLIBCXX_NOEXCEPT
 475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w != 0; }
 476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       size_t
 478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_count() const _GLIBCXX_NOEXCEPT
 479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return __builtin_popcountl(_M_w); }
 480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       unsigned long
 482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_to_ulong() const _GLIBCXX_NOEXCEPT
 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w; }
 484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
 486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       unsigned long long
 487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_to_ullong() const noexcept
 488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w; }
 489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
 490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       size_t
 492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_find_first(size_t __not_found) const _GLIBCXX_NOEXCEPT
 493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         if (_M_w != 0)
 495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****           return __builtin_ctzl(_M_w);
 496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         else
 497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****           return __not_found;
 498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // find the next "on" bit that follows "prev"
 501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       size_t
 502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_find_next(size_t __prev, size_t __not_found) const
 503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	_GLIBCXX_NOEXCEPT
 504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	++__prev;
 506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	if (__prev >= ((size_t) _GLIBCXX_BITSET_BITS_PER_WORD))
 507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  return __not_found;
 508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	_WordT __x = _M_w >> __prev;
 510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	if (__x != 0)
 511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  return __builtin_ctzl(__x) + __prev;
 512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	else
 513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  return __not_found;
 514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     };
 516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   /**
 518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  Base class, specialization for no storage (zero-length %bitset).
 519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  See documentation for bitset.
 521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   */
 522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   template<>
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     struct _Base_bitset<0>
ARM GAS  /tmp/cc5nV8qb.s 			page 189


 524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     {
 525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       typedef unsigned long _WordT;
 526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _GLIBCXX_CONSTEXPR _Base_bitset() _GLIBCXX_NOEXCEPT
 528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { }
 529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
 531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       constexpr _Base_bitset(unsigned long long) noexcept
 532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #else
 533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _Base_bitset(unsigned long)
 534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
 535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { }
 536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static _GLIBCXX_CONSTEXPR size_t
 538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_whichword(size_t __pos) _GLIBCXX_NOEXCEPT
 539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return __pos / _GLIBCXX_BITSET_BITS_PER_WORD; }
 540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static _GLIBCXX_CONSTEXPR size_t
 542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_whichbyte(size_t __pos) _GLIBCXX_NOEXCEPT
 543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return (__pos % _GLIBCXX_BITSET_BITS_PER_WORD) / __CHAR_BIT__; }
 544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static _GLIBCXX_CONSTEXPR size_t
 546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_whichbit(size_t __pos) _GLIBCXX_NOEXCEPT
 547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {  return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }
 548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static _GLIBCXX_CONSTEXPR _WordT
 550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_maskbit(size_t __pos) _GLIBCXX_NOEXCEPT
 551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
 552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // This would normally give access to the data.  The bounds-checking
 554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // in the bitset class will prevent the user from getting this far,
 555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // but (1) it must still return an lvalue to compile, and (2) the
 556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // user might call _Unchecked_set directly, in which case this /needs/
 557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // to fail.  Let's not penalize zero-length users unless they actually
 558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // make an unchecked call; all the memory ugliness is therefore
 559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // localized to this single should-never-get-this-far function.
 560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _WordT&
 561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_getword(size_t) _GLIBCXX_NOEXCEPT
 562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	__throw_out_of_range(__N("_Base_bitset::_M_getword"));
 564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return *new _WordT;
 565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _GLIBCXX_CONSTEXPR _WordT
 568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_getword(size_t) const _GLIBCXX_NOEXCEPT
 569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return 0; }
 570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _GLIBCXX_CONSTEXPR _WordT
 572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_hiword() const _GLIBCXX_NOEXCEPT
 573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return 0; }
 574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_and(const _Base_bitset<0>&) _GLIBCXX_NOEXCEPT
 577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { }
 578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_or(const _Base_bitset<0>&) _GLIBCXX_NOEXCEPT
ARM GAS  /tmp/cc5nV8qb.s 			page 190


 581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { }
 582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_xor(const _Base_bitset<0>&) _GLIBCXX_NOEXCEPT
 585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { }
 586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_left_shift(size_t) _GLIBCXX_NOEXCEPT
 589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { }
 590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_right_shift(size_t) _GLIBCXX_NOEXCEPT
 593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { }
 594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_flip() _GLIBCXX_NOEXCEPT
 597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { }
 598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_set() _GLIBCXX_NOEXCEPT
 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { }
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_reset() _GLIBCXX_NOEXCEPT
 605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { }
 606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // Are all empty bitsets equal to each other?  Are they equal to
 608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // themselves?  How to compare a thing which has no state?  What is
 609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // the sound of one zero-length bitset clapping?
 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bool
 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_is_equal(const _Base_bitset<0>&) const _GLIBCXX_NOEXCEPT
 612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return true; }
 613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<size_t _Nb>
 615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         bool
 616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         _M_are_all() const _GLIBCXX_NOEXCEPT
 617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         { return true; }
 618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bool
 620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_is_any() const _GLIBCXX_NOEXCEPT
 621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return false; }
 622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       size_t
 624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_count() const _GLIBCXX_NOEXCEPT
 625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return 0; }
 626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       unsigned long
 628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_to_ulong() const _GLIBCXX_NOEXCEPT
 629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return 0; }
 630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
 632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       unsigned long long
 633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_to_ullong() const noexcept
 634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return 0; }
 635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
 636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // Normally "not found" is the size, but that could also be
ARM GAS  /tmp/cc5nV8qb.s 			page 191


 638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // misinterpreted as an index in this corner case.  Oh well.
 639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       size_t
 640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_find_first(size_t) const _GLIBCXX_NOEXCEPT
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return 0; }
 642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       size_t
 644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_find_next(size_t, size_t) const _GLIBCXX_NOEXCEPT
 645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return 0; }
 646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     };
 647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   // Helper class to zero out the unused high-order bits in the highest word.
 650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   template<size_t _Extrabits>
 651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     struct _Sanitize
 652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     {
 653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       typedef unsigned long _WordT;
 654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static void
 656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_do_sanitize(_WordT& __val) _GLIBCXX_NOEXCEPT
 657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }
 658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     };
 659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   template<>
 661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     struct _Sanitize<0>
 662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     {
 663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       typedef unsigned long _WordT;
 664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static void
 666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_do_sanitize(_WordT) _GLIBCXX_NOEXCEPT { }
 667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     };
 668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
 670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   template<size_t _Nb, bool = (_Nb < _GLIBCXX_BITSET_BITS_PER_ULL)>
 671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     struct _Sanitize_val
 672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     {
 673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static constexpr unsigned long long
 674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_do_sanitize_val(unsigned long long __val)
 675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return __val; }
 676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     };
 677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   template<size_t _Nb>
 679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     struct _Sanitize_val<_Nb, true>
 680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     {
 681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       static constexpr unsigned long long
 682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _S_do_sanitize_val(unsigned long long __val)
 683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return __val & ~((~static_cast<unsigned long long>(0)) << _Nb); }
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     };
 685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
 686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   /**
 688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  @brief The %bitset class represents a @e fixed-size sequence of bits.
 689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  @ingroup utilities
 690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  (Note that %bitset does @e not meet the formal requirements of a
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  <a href="tables.html#65">container</a>.  Mainly, it lacks iterators.)
 693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  The template argument, @a Nb, may be any non-negative number,
ARM GAS  /tmp/cc5nV8qb.s 			page 192


 695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  specifying the number of bits (e.g., "0", "12", "1024*1024").
 696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  In the general unoptimized case, storage is allocated in word-sized
 698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  blocks.  Let B be the number of bits in a word, then (Nb+(B-1))/B
 699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  words will be used for storage.  B - Nb%B bits are unused.  (They are
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  the high-order bits in the highest word.)  It is a class invariant
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  that those unused bits are always zero.
 702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  If you think of %bitset as <em>a simple array of bits</em>, be
 704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  aware that your mental picture is reversed: a %bitset behaves
 705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  the same way as bits in integers do, with the bit at index 0 in
 706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  the <em>least significant / right-hand</em> position, and the bit at
 707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  index Nb-1 in the <em>most significant / left-hand</em> position.
 708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  Thus, unlike other containers, a %bitset's index <em>counts from
 709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  right to left</em>, to put it very loosely.
 710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  This behavior is preserved when translating to and from strings.  For
 712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  example, the first line of the following program probably prints
 713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  <em>b(&apos;a&apos;) is 0001100001</em> on a modern ASCII system.
 714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  @code
 716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *     #include <bitset>
 717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *     #include <iostream>
 718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *     #include <sstream>
 719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *     using namespace std;
 721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *     int main()
 723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *     {
 724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *         long         a = 'a';
 725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *         bitset<10>   b(a);
 726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *         cout << "b('a') is " << b << endl;
 728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *         ostringstream s;
 730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *         s << b;
 731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *         string  str = s.str();
 732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *         cout << "index 3 in the string is " << str[3] << " but\n"
 733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *              << "index 3 in the bitset is " << b[3] << endl;
 734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *     }
 735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  @endcode
 736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  Also see:
 738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_containers.html
 739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  for a description of extensions.
 740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  Most of the actual code isn't contained in %bitset<> itself, but in the
 742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  base class _Base_bitset.  The base class works with whole words, not with
 743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  individual bits.  This allows us to specialize _Base_bitset for the
 744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  important special case where the %bitset is only a single word.
 745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *
 746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  Extra confusion can result due to the fact that the storage for
 747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  _Base_bitset @e is a regular array, and is indexed as such.  This is
 748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****    *  carefully encapsulated.
 749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   */
 750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****   template<size_t _Nb>
 751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     class bitset
ARM GAS  /tmp/cc5nV8qb.s 			page 193


 752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     : private _Base_bitset<_GLIBCXX_BITSET_WORDS(_Nb)>
 753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     {
 754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     private:
 755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       typedef _Base_bitset<_GLIBCXX_BITSET_WORDS(_Nb)> _Base;
 756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       typedef unsigned long _WordT;
 757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT, class _Traits, class _Alloc>
 759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_check_initial_position(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
 761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 				size_t __position) const
 762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	if (__position > __s.size())
 764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  __throw_out_of_range_fmt(__N("bitset::bitset: __position "
 765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 				       "(which is %zu) > __s.size() "
 766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 				       "(which is %zu)"),
 767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 				   __position, __s.size());
 768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void _M_check(size_t __position, const char *__s) const
 771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	if (__position >= _Nb)
 773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  __throw_out_of_range_fmt(__N("%s: __position (which is %zu) "
 774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 				       ">= _Nb (which is %zu)"),
 775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 				   __s, __position, _Nb);
 776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       void
 779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _M_do_sanitize() _GLIBCXX_NOEXCEPT
 780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	typedef _Sanitize<_Nb % _GLIBCXX_BITSET_BITS_PER_WORD> __sanitize_type;
 782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	__sanitize_type::_S_do_sanitize(this->_M_hiword());
 783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
 786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       friend struct std::hash<bitset>;
 787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****     public:
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  This encapsulates the concept of a single bit.  An instance of this
 792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  class is a proxy for an actual bit; this way the individual bit
 793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  operations are done as faster word-size bitwise instructions.
 794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *
 795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  Most users will never need to use this class directly; conversions
 796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  to and from bool are automatic and should be transparent.  Overloaded
 797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  operators help to preserve the illusion.
 798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *
 799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  (On a typical system, this <em>bit %reference</em> is 64
 800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  times the size of an actual bit.  Ha.)
 801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
 802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       class reference
 803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	friend class bitset;
 805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	_WordT*	_M_wp;
 807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	size_t 	_M_bpos;
 808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 194


 809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	// left undefined
 810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	reference();
 811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       public:
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	reference(bitset& __b, size_t __pos) _GLIBCXX_NOEXCEPT
 814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_wp = &__b._M_getword(__pos);
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_bpos = _Base::_S_whichbit(__pos);
 817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
 820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	reference(const reference&) = default;
 821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
 822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	~reference() _GLIBCXX_NOEXCEPT
 824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{ }
 825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	// For b[i] = __x;
 827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	reference&
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	operator=(bool __x) _GLIBCXX_NOEXCEPT
 829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  if (__x)
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    *_M_wp |= _Base::_S_maskbit(_M_bpos);
 832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  else
 833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
 834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  return *this;
 835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	// For b[i] = b[__j];
 838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	reference&
 839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	operator=(const reference& __j) _GLIBCXX_NOEXCEPT
 840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))
 842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    *_M_wp |= _Base::_S_maskbit(_M_bpos);
 843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  else
 844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
 845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  return *this;
 846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	// Flips the bit
 849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	bool
 850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	operator~() const _GLIBCXX_NOEXCEPT
 851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{ return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }
 852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	// For __x = b[i];
 854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	operator bool() const _GLIBCXX_NOEXCEPT
 855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{ return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }
 856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	// For b[i].flip();
 858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	reference&
 859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	flip() _GLIBCXX_NOEXCEPT
 860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  *_M_wp ^= _Base::_S_maskbit(_M_bpos);
 862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  return *this;
 863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       };
 865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       friend class reference;
ARM GAS  /tmp/cc5nV8qb.s 			page 195


 866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // 23.3.5.1 constructors:
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /// All bits set to zero.
 869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _GLIBCXX_CONSTEXPR bitset() _GLIBCXX_NOEXCEPT
 870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { }
 871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /// Initial bits bitwise-copied from a single word (others set to zero).
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
 874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       constexpr bitset(unsigned long long __val) noexcept
 875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       : _Base(_Sanitize_val<_Nb>::_S_do_sanitize_val(__val)) { }
 876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #else
 877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset(unsigned long __val)
 878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       : _Base(__val)
 879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { _M_do_sanitize(); }
 880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
 881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
 883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  Use a subset of a string.
 884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __s  A string of @a 0 and @a 1 characters.
 885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __position  Index of the first character in @a __s to use;
 886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *                    defaults to zero.
 887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @throw  std::out_of_range  If @a pos is bigger the size of @a __s.
 888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @throw  std::invalid_argument  If a character appears in the string
 889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *                                 which is neither @a 0 nor @a 1.
 890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
 891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT, class _Traits, class _Alloc>
 892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	explicit
 893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
 894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	       size_t __position = 0)
 895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	: _Base()
 896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_check_initial_position(__s, __position);
 898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_copy_from_string(__s, __position,
 899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 			      std::basic_string<_CharT, _Traits, _Alloc>::npos,
 900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 			      _CharT('0'), _CharT('1'));
 901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
 904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  Use a subset of a string.
 905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __s  A string of @a 0 and @a 1 characters.
 906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __position  Index of the first character in @a __s to use.
 907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __n    The number of characters to copy.
 908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @throw std::out_of_range If @a __position is bigger the size
 909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  of @a __s.
 910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @throw  std::invalid_argument  If a character appears in the string
 911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *                                 which is neither @a 0 nor @a 1.
 912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT, class _Traits, class _Alloc>
 914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
 915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	       size_t __position, size_t __n)
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	: _Base()
 917:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 918:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_check_initial_position(__s, __position);
 919:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_copy_from_string(__s, __position, __n, _CharT('0'), _CharT('1'));
 920:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 921:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 922:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // _GLIBCXX_RESOLVE_LIB_DEFECTS
ARM GAS  /tmp/cc5nV8qb.s 			page 196


 923:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // 396. what are characters zero and one.
 924:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT, class _Traits, class _Alloc>
 925:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
 926:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	       size_t __position, size_t __n,
 927:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	       _CharT __zero, _CharT __one = _CharT('1'))
 928:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	: _Base()
 929:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 930:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_check_initial_position(__s, __position);
 931:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_copy_from_string(__s, __position, __n, __zero, __one);
 932:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 933:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 934:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
 935:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
 936:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  Construct from a character %array.
 937:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __str  An %array of characters @a zero and @a one.
 938:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __n    The number of characters to use.
 939:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __zero The character corresponding to the value 0.
 940:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __one  The character corresponding to the value 1.
 941:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @throw  std::invalid_argument If a character appears in the string
 942:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *                                which is neither @a __zero nor @a __one.
 943:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
 944:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<typename _CharT>
 945:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         explicit
 946:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         bitset(const _CharT* __str,
 947:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	       typename std::basic_string<_CharT>::size_type __n
 948:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	       = std::basic_string<_CharT>::npos,
 949:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	       _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'))
 950:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         : _Base()
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         {
 952:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  if (!__str)
 953:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    __throw_logic_error(__N("bitset::bitset(const _CharT*, ...)"));
 954:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 955:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  if (__n == std::basic_string<_CharT>::npos)
 956:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    __n = std::char_traits<_CharT>::length(__str);
 957:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_copy_from_ptr<_CharT, std::char_traits<_CharT>>(__str, __n, 0,
 958:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 							     __n, __zero,
 959:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 							     __one);
 960:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 961:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
 962:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 963:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // 23.3.5.2 bitset operations:
 964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       ///@{
 965:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
 966:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  Operations on bitsets.
 967:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __rhs  A same-sized bitset.
 968:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *
 969:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  These should be self-explanatory.
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
 971:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
 972:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       operator&=(const bitset<_Nb>& __rhs) _GLIBCXX_NOEXCEPT
 973:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 974:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	this->_M_do_and(__rhs);
 975:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return *this;
 976:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 977:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 978:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
 979:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       operator|=(const bitset<_Nb>& __rhs) _GLIBCXX_NOEXCEPT
ARM GAS  /tmp/cc5nV8qb.s 			page 197


 980:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 981:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	this->_M_do_or(__rhs);
 982:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return *this;
 983:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 984:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 985:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
 986:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       operator^=(const bitset<_Nb>& __rhs) _GLIBCXX_NOEXCEPT
 987:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
 988:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	this->_M_do_xor(__rhs);
 989:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return *this;
 990:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
 991:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       ///@}
 992:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 993:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       ///@{
 994:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
 995:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  Operations on bitsets.
 996:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __position  The number of places to shift.
 997:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *
 998:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  These should be self-explanatory.
 999:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
1000:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
1001:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       operator<<=(size_t __position) _GLIBCXX_NOEXCEPT
1002:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
1003:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	if (__builtin_expect(__position < _Nb, 1))
1004:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  {
1005:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    this->_M_do_left_shift(__position);
1006:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    this->_M_do_sanitize();
1007:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  }
1008:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	else
1009:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  this->_M_do_reset();
1010:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return *this;
1011:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
1012:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1013:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
1014:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       operator>>=(size_t __position) _GLIBCXX_NOEXCEPT
1015:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
1016:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	if (__builtin_expect(__position < _Nb, 1))
1017:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  {
1018:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    this->_M_do_right_shift(__position);
1019:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	    this->_M_do_sanitize();
1020:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  }
1021:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	else
1022:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  this->_M_do_reset();
1023:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return *this;
1024:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
1025:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       ///@}
1026:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1027:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       ///@{
1028:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
1029:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  These versions of single-bit set, reset, flip, and test are
1030:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  extensions from the SGI version.  They do no range checking.
1031:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @ingroup SGIextensions
1032:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
1033:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
1034:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _Unchecked_set(size_t __pos) _GLIBCXX_NOEXCEPT
1035:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
1036:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
ARM GAS  /tmp/cc5nV8qb.s 			page 198


1037:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return *this;
1038:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
1039:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1040:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
1041:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _Unchecked_set(size_t __pos, int __val) _GLIBCXX_NOEXCEPT
1042:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
1043:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	if (__val)
1044:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
1045:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	else
1046:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
1047:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return *this;
1048:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
1049:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1050:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
1051:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _Unchecked_reset(size_t __pos) _GLIBCXX_NOEXCEPT
1052:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
1053:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
1054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return *this;
1055:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
1056:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1057:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
1058:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _Unchecked_flip(size_t __pos) _GLIBCXX_NOEXCEPT
1059:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
1060:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);
1061:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return *this;
1062:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
1063:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1064:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _GLIBCXX_CONSTEXPR bool
1065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _Unchecked_test(size_t __pos) const _GLIBCXX_NOEXCEPT
1066:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))
1067:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 		!= static_cast<_WordT>(0)); }
1068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       ///@}
1069:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // Set, reset, and flip.
1071:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @brief Sets every bit to true.
1073:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
1074:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
1075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       set() _GLIBCXX_NOEXCEPT
1076:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
1077:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	this->_M_do_set();
1078:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	this->_M_do_sanitize();
1079:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return *this;
1080:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
1081:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1082:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
1083:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @brief Sets a given bit to a particular value.
1084:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __position  The index of the bit.
1085:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __val  Either true or false, defaults to true.
1086:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.
1087:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
1088:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
1089:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       set(size_t __position, bool __val = true)
1090:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
1091:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	this->_M_check(__position, __N("bitset::set"));
1092:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return _Unchecked_set(__position, __val);
1093:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
ARM GAS  /tmp/cc5nV8qb.s 			page 199


1094:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1095:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
1096:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @brief Sets every bit to false.
1097:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
1098:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
1099:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       reset() _GLIBCXX_NOEXCEPT
1100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
1101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	this->_M_do_reset();
1102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return *this;
1103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
1104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
1106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @brief Sets a given bit to false.
1107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __position  The index of the bit.
1108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.
1109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *
1110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  Same as writing @c set(pos,false).
1111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
1112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
1113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       reset(size_t __position)
1114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
1115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	this->_M_check(__position, __N("bitset::reset"));
1116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return _Unchecked_reset(__position);
1117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
1118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
1120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @brief Toggles every bit to its opposite value.
1121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
1122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
1123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       flip() _GLIBCXX_NOEXCEPT
1124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
1125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	this->_M_do_flip();
1126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	this->_M_do_sanitize();
1127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return *this;
1128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
1129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
1131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @brief Toggles a given bit to its opposite value.
1132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __position  The index of the bit.
1133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.
1134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
1135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>&
1136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       flip(size_t __position)
1137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
1138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	this->_M_check(__position, __N("bitset::flip"));
1139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return _Unchecked_flip(__position);
1140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
1141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /// See the no-argument flip().
1143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bitset<_Nb>
1144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       operator~() const _GLIBCXX_NOEXCEPT
1145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return bitset<_Nb>(*this).flip(); }
1146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       ///@{
1148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
1149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @brief  Array-indexing support.
1150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @param  __position  Index into the %bitset.
ARM GAS  /tmp/cc5nV8qb.s 			page 200


1151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @return A bool for a <em>const %bitset</em>.  For non-const
1152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *           bitsets, an instance of the reference proxy class.
1153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @note  These operators do no range checking and throw no exceptions,
1154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *         as required by DR 11 to the standard.
1155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *
1156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  _GLIBCXX_RESOLVE_LIB_DEFECTS Note that this implementation already
1157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  resolves DR 11 (items 1 and 2), but does not do the range-checking
1158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  required by that DR's resolution.  -pme
1159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  The DR has since been changed:  range-checking is a precondition
1160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  (users' responsibility), and these functions must not throw.  -pme
1161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
1162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       reference
1163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       operator[](size_t __position)
 2873              		.loc 20 1163 7 view .LVU663
 2874              	.LBB1531:
 2875              	.LBI1531:
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 2876              		.loc 20 813 2 view .LVU664
 2877              	.LBB1532:
 2878              	.LBB1533:
 2879              	.LBI1533:
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w; }
 2880              		.loc 20 410 7 view .LVU665
 2881              	.LBE1533:
 2882              	.LBE1532:
 2883              	.LBE1531:
 2884              	.LBE1530:
 2885              	.LBE1527:
 2886              	.LBE1526:
 2887              	.LBE1525:
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 2888              		.loc 20 411 9 view .LVU666
 2889              	.LBB1584:
 2890              	.LBB1575:
 2891              	.LBB1566:
 2892              	.LBB1538:
 2893              	.LBB1537:
 2894              	.LBB1536:
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_bpos = _Base::_S_whichbit(__pos);
 2895              		.loc 20 815 10 is_stmt 0 view .LVU667
 2896 00a0 01A8     		add	r0, sp, #4
 2897              	.LVL192:
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_bpos = _Base::_S_whichbit(__pos);
 2898              		.loc 20 815 10 view .LVU668
 2899 00a2 0E90     		str	r0, [sp, #56]
 2900              	.LVL193:
 2901              	.LBB1534:
 2902              	.LBI1534:
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {  return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }
 2903              		.loc 20 402 7 is_stmt 1 view .LVU669
 2904              	.LBB1535:
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 2905              		.loc 20 403 10 view .LVU670
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 2906              		.loc 20 403 25 is_stmt 0 view .LVU671
 2907 00a4 03F01F00 		and	r0, r3, #31
 2908              	.LVL194:
ARM GAS  /tmp/cc5nV8qb.s 			page 201


 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 2909              		.loc 20 403 25 view .LVU672
 2910              	.LBE1535:
 2911              	.LBE1534:
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 2912              		.loc 20 816 12 view .LVU673
 2913 00a8 0F90     		str	r0, [sp, #60]
 2914              	.LVL195:
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 2915              		.loc 20 816 12 view .LVU674
 2916              	.LBE1536:
 2917              	.LBE1537:
 2918              	.LBE1538:
 2919              	.LBB1539:
 2920              	.LBI1539:
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 2921              		.loc 20 828 2 is_stmt 1 view .LVU675
 2922              	.LBB1540:
 2923              	.LBB1541:
 2924              	.LBI1541:
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
 2925              		.loc 20 406 7 view .LVU676
 2926              	.LBB1542:
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 2927              		.loc 20 407 9 view .LVU677
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 2928              		.loc 20 407 9 is_stmt 0 view .LVU678
 2929              	.LBE1542:
 2930              	.LBE1541:
 2931              	.LBE1540:
 2932              	.LBE1539:
 2933              	.LBE1566:
 2934              	.LBE1575:
 2935              	.LBE1584:
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 2936              		.loc 20 403 10 is_stmt 1 view .LVU679
 2937              	.LBB1585:
 2938              	.LBB1576:
 2939              	.LBB1567:
 2940              	.LBB1546:
 2941              	.LBB1545:
 2942              	.LBB1544:
 2943              	.LBB1543:
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 2944              		.loc 20 407 61 is_stmt 0 view .LVU680
 2945 00aa 0125     		movs	r5, #1
 2946 00ac 8540     		lsls	r5, r5, r0
 2947              	.LVL196:
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 2948              		.loc 20 407 61 view .LVU681
 2949              	.LBE1543:
 2950              	.LBE1544:
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  else
 2951              		.loc 20 831 13 view .LVU682
 2952 00ae 0198     		ldr	r0, [sp, #4]
 2953 00b0 0543     		orrs	r5, r5, r0
 2954 00b2 0195     		str	r5, [sp, #4]
ARM GAS  /tmp/cc5nV8qb.s 			page 202


 2955              	.LVL197:
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  else
 2956              		.loc 20 831 13 view .LVU683
 2957              	.LBE1545:
 2958              	.LBE1546:
 2959              	.LBB1547:
 2960              	.LBI1547:
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{ }
 2961              		.loc 20 823 2 is_stmt 1 view .LVU684
 2962              	.L151:
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{ }
 2963              		.loc 20 823 2 is_stmt 0 view .LVU685
 2964              	.LBE1547:
 235:MotorControl/encoder.cpp ****                 state_confirmed[i] = true;
 2965              		.loc 3 235 13 is_stmt 1 view .LVU686
 2966 00b4 3229     		cmp	r1, #50
 2967 00b6 E9DD     		ble	.L152
 236:MotorControl/encoder.cpp ****         }
 2968              		.loc 3 236 17 view .LVU687
 2969              	.LVL198:
 2970              	.LBB1548:
 2971              	.LBI1548:
 2972              		.loc 20 1163 7 view .LVU688
 2973              	.LBB1549:
 2974              	.LBI1549:
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 2975              		.loc 20 813 2 view .LVU689
 2976              	.LBB1550:
 2977              	.LBB1551:
 2978              	.LBI1551:
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w; }
 2979              		.loc 20 410 7 view .LVU690
 2980              	.LBE1551:
 2981              	.LBE1550:
 2982              	.LBE1549:
 2983              	.LBE1548:
 2984              	.LBE1567:
 2985              	.LBE1576:
 2986              	.LBE1585:
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 2987              		.loc 20 411 9 view .LVU691
 2988              	.LBB1586:
 2989              	.LBB1577:
 2990              	.LBB1568:
 2991              	.LBB1556:
 2992              	.LBB1555:
 2993              	.LBB1554:
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_bpos = _Base::_S_whichbit(__pos);
 2994              		.loc 20 815 10 is_stmt 0 view .LVU692
 2995 00b8 02A9     		add	r1, sp, #8
 2996              	.LVL199:
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_bpos = _Base::_S_whichbit(__pos);
 2997              		.loc 20 815 10 view .LVU693
 2998 00ba 1091     		str	r1, [sp, #64]
 2999              	.LVL200:
 3000              	.LBB1552:
 3001              	.LBI1552:
ARM GAS  /tmp/cc5nV8qb.s 			page 203


 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {  return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }
 3002              		.loc 20 402 7 is_stmt 1 view .LVU694
 3003              	.LBB1553:
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 3004              		.loc 20 403 10 view .LVU695
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 3005              		.loc 20 403 25 is_stmt 0 view .LVU696
 3006 00bc 02F01F02 		and	r2, r2, #31
 3007              	.LVL201:
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 3008              		.loc 20 403 25 view .LVU697
 3009              	.LBE1553:
 3010              	.LBE1552:
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 3011              		.loc 20 816 12 view .LVU698
 3012 00c0 1192     		str	r2, [sp, #68]
 3013              	.LVL202:
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
 3014              		.loc 20 816 12 view .LVU699
 3015              	.LBE1554:
 3016              	.LBE1555:
 3017              	.LBE1556:
 3018              	.LBB1557:
 3019              	.LBI1557:
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
 3020              		.loc 20 828 2 is_stmt 1 view .LVU700
 3021              	.LBB1558:
 3022              	.LBB1559:
 3023              	.LBI1559:
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
 3024              		.loc 20 406 7 view .LVU701
 3025              	.LBB1560:
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 3026              		.loc 20 407 9 view .LVU702
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 3027              		.loc 20 407 9 is_stmt 0 view .LVU703
 3028              	.LBE1560:
 3029              	.LBE1559:
 3030              	.LBE1558:
 3031              	.LBE1557:
 3032              	.LBE1568:
 3033              	.LBE1577:
 3034              	.LBE1586:
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 3035              		.loc 20 403 10 is_stmt 1 view .LVU704
 3036              	.LBB1587:
 3037              	.LBB1578:
 3038              	.LBB1569:
 3039              	.LBB1564:
 3040              	.LBB1563:
 3041              	.LBB1562:
 3042              	.LBB1561:
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 3043              		.loc 20 407 61 is_stmt 0 view .LVU705
 3044 00c2 0121     		movs	r1, #1
 3045 00c4 01FA02F2 		lsl	r2, r1, r2
 3046              	.LVL203:
ARM GAS  /tmp/cc5nV8qb.s 			page 204


 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 3047              		.loc 20 407 61 view .LVU706
 3048              	.LBE1561:
 3049              	.LBE1562:
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  else
 3050              		.loc 20 831 13 view .LVU707
 3051 00c8 0299     		ldr	r1, [sp, #8]
 3052 00ca 1143     		orrs	r1, r1, r2
 3053 00cc 0291     		str	r1, [sp, #8]
 3054              	.LVL204:
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  else
 3055              		.loc 20 831 13 view .LVU708
 3056              	.LBE1563:
 3057              	.LBE1564:
 3058              	.LBB1565:
 3059              	.LBI1565:
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{ }
 3060              		.loc 20 823 2 is_stmt 1 view .LVU709
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{ }
 3061              		.loc 20 823 2 is_stmt 0 view .LVU710
 3062              	.LBE1565:
 3063 00ce DDE7     		b	.L152
 3064              	.L150:
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{ }
 3065              		.loc 20 823 2 view .LVU711
 3066              	.LBE1569:
 238:MotorControl/encoder.cpp ****             set_error(ERROR_ILLEGAL_HALL_STATE);
 3067              		.loc 3 238 9 is_stmt 1 view .LVU712
 3068              	.LVL205:
 3069              	.LBB1570:
 3070              	.LBI1570:
1164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return reference(*this, __position); }
1165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _GLIBCXX_CONSTEXPR bool
1167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       operator[](size_t __position) const
1168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _Unchecked_test(__position); }
1169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       ///@}
1170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
1172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @brief Returns a numerical interpretation of the %bitset.
1173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @return  The integral equivalent of the bits.
1174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @throw  std::overflow_error  If there are too many bits to be
1175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *                               represented in an @c unsigned @c long.
1176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
1177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       unsigned long
1178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       to_ulong() const
1179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return this->_M_do_to_ulong(); }
1180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #if __cplusplus >= 201103L
1182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       unsigned long long
1183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       to_ullong() const
1184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return this->_M_do_to_ullong(); }
1185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** #endif
1186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /**
1188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @brief Returns a character interpretation of the %bitset.
1189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  @return  The string equivalent of the bits.
ARM GAS  /tmp/cc5nV8qb.s 			page 205


1190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *
1191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  Note the ordering of the bits:  decreasing character positions
1192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  correspond to increasing bit positions (see the main class notes for
1193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        *  an example).
1194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****        */
1195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT, class _Traits, class _Alloc>
1196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	std::basic_string<_CharT, _Traits, _Alloc>
1197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	to_string() const
1198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
1199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  std::basic_string<_CharT, _Traits, _Alloc> __result;
1200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_copy_to_string(__result, _CharT('0'), _CharT('1'));
1201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  return __result;
1202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
1203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // _GLIBCXX_RESOLVE_LIB_DEFECTS
1205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // 396. what are characters zero and one.
1206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT, class _Traits, class _Alloc>
1207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	std::basic_string<_CharT, _Traits, _Alloc>
1208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	to_string(_CharT __zero, _CharT __one = _CharT('1')) const
1209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
1210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  std::basic_string<_CharT, _Traits, _Alloc> __result;
1211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  _M_copy_to_string(__result, __zero, __one);
1212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  return __result;
1213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
1214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // _GLIBCXX_RESOLVE_LIB_DEFECTS
1216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // 434. bitset::to_string() hard to use.
1217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT, class _Traits>
1218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	std::basic_string<_CharT, _Traits, std::allocator<_CharT> >
1219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	to_string() const
1220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{ return to_string<_CharT, _Traits, std::allocator<_CharT> >(); }
1221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // _GLIBCXX_RESOLVE_LIB_DEFECTS
1223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // 853. to_string needs updating with zero and one.
1224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT, class _Traits>
1225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	std::basic_string<_CharT, _Traits, std::allocator<_CharT> >
1226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	to_string(_CharT __zero, _CharT __one = _CharT('1')) const
1227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{ return to_string<_CharT, _Traits,
1228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	                   std::allocator<_CharT> >(__zero, __one); }
1229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT>
1231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	std::basic_string<_CharT, std::char_traits<_CharT>,
1232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	                  std::allocator<_CharT> >
1233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	to_string() const
1234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
1235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  return to_string<_CharT, std::char_traits<_CharT>,
1236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	                   std::allocator<_CharT> >();
1237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
1238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT>
1240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	std::basic_string<_CharT, std::char_traits<_CharT>,
1241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	                  std::allocator<_CharT> >
1242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	to_string(_CharT __zero, _CharT __one = _CharT('1')) const
1243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{
1244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	  return to_string<_CharT, std::char_traits<_CharT>,
1245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	                   std::allocator<_CharT> >(__zero, __one);
1246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	}
ARM GAS  /tmp/cc5nV8qb.s 			page 206


1247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       std::basic_string<char, std::char_traits<char>, std::allocator<char> >
1249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       to_string() const
1250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
1251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return to_string<char, std::char_traits<char>,
1252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	                 std::allocator<char> >();
1253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
1254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       std::basic_string<char, std::char_traits<char>, std::allocator<char> >
1256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       to_string(char __zero, char __one = '1') const
1257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       {
1258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	return to_string<char, std::char_traits<char>,
1259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	                 std::allocator<char> >(__zero, __one);
1260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       }
1261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // Helper functions for string operations.
1263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT, class _Traits>
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         void
1265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         _M_copy_from_ptr(const _CharT*, size_t, size_t, size_t,
1266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 			 _CharT, _CharT);
1267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT, class _Traits, class _Alloc>
1269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	void
1270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	_M_copy_from_string(const std::basic_string<_CharT,
1271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 			    _Traits, _Alloc>& __s, size_t __pos, size_t __n,
1272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 			    _CharT __zero, _CharT __one)
1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{ _M_copy_from_ptr<_CharT, _Traits>(__s.data(), __s.size(), __pos, __n,
1274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 					    __zero, __one); }
1275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT, class _Traits, class _Alloc>
1277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	void
1278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>&,
1279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 			  _CharT, _CharT) const;
1280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       // NB: Backward compat.
1282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT, class _Traits, class _Alloc>
1283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	void
1284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	_M_copy_from_string(const std::basic_string<_CharT,
1285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 			    _Traits, _Alloc>& __s, size_t __pos, size_t __n)
1286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{ _M_copy_from_string(__s, __pos, __n, _CharT('0'), _CharT('1')); }
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       template<class _CharT, class _Traits, class _Alloc>
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	void
1290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****         _M_copy_to_string(std::basic_string<_CharT, _Traits,_Alloc>& __s) const
1291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 	{ _M_copy_to_string(__s, _CharT('0'), _CharT('1')); }
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /// Returns the number of bits which are set.
1294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       size_t
1295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       count() const _GLIBCXX_NOEXCEPT
1296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return this->_M_do_count(); }
1297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /// Returns the total number of bits.
1299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       _GLIBCXX_CONSTEXPR size_t
1300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       size() const _GLIBCXX_NOEXCEPT
1301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _Nb; }
1302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
1303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       ///@{
ARM GAS  /tmp/cc5nV8qb.s 			page 207


1304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       /// These comparisons for equality/inequality are, well, @e bitwise.
1305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       bool
1306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       operator==(const bitset<_Nb>& __rhs) const _GLIBCXX_NOEXCEPT
 3071              		.loc 20 1306 7 view .LVU713
 3072              	.LBB1571:
 3073              	.LBI1571:
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset ****       { return _M_w == __x._M_w; }
 3074              		.loc 20 464 7 view .LVU714
 3075              	.LBB1572:
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 3076              		.loc 20 465 9 view .LVU715
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 3077              		.loc 20 465 16 is_stmt 0 view .LVU716
 3078 00d0 019B     		ldr	r3, [sp, #4]
 3079              	.LVL206:
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 3080              		.loc 20 465 28 view .LVU717
 3081 00d2 029A     		ldr	r2, [sp, #8]
 3082              	.LVL207:
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 3083              		.loc 20 465 28 view .LVU718
 3084              	.LBE1572:
 3085              	.LBE1571:
 3086              	.LBE1570:
 238:MotorControl/encoder.cpp ****             set_error(ERROR_ILLEGAL_HALL_STATE);
 3087              		.loc 3 238 9 view .LVU719
 3088 00d4 9342     		cmp	r3, r2
 3089 00d6 0CD1     		bne	.L166
 247:MotorControl/encoder.cpp ****         uint8_t hall_polarity = 0;
 3090              		.loc 3 247 9 is_stmt 1 view .LVU720
 3091              	.LVL208:
 247:MotorControl/encoder.cpp ****         uint8_t hall_polarity = 0;
 3092              		.loc 3 247 9 is_stmt 0 view .LVU721
 3093              	.LBE1578:
 3094              	.LBE1587:
 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bitset **** 
 3095              		.loc 20 483 9 is_stmt 1 view .LVU722
 3096              	.LBB1588:
 3097              	.LBB1579:
 248:MotorControl/encoder.cpp ****         auto flip_detect = [](uint8_t states, unsigned int idx)->bool {
 3098              		.loc 3 248 9 view .LVU723
 249:MotorControl/encoder.cpp ****             return (~states & 0xFF) == (1<<(0+idx) | 1<<(7-idx));
 3099              		.loc 3 249 9 view .LVU724
 252:MotorControl/encoder.cpp ****             hall_polarity = 0b000;
 3100              		.loc 3 252 9 view .LVU725
 3101              	.LBB1573:
 3102              	.LBI1573:
 249:MotorControl/encoder.cpp ****             return (~states & 0xFF) == (1<<(0+idx) | 1<<(7-idx));
 3103              		.loc 3 249 28 view .LVU726
 3104              	.LBB1574:
 250:MotorControl/encoder.cpp ****         };
 3105              		.loc 3 250 13 view .LVU727
 250:MotorControl/encoder.cpp ****         };
 3106              		.loc 3 250 22 is_stmt 0 view .LVU728
 3107 00d8 DBB2     		uxtb	r3, r3
 250:MotorControl/encoder.cpp ****         };
 3108              		.loc 3 250 21 view .LVU729
ARM GAS  /tmp/cc5nV8qb.s 			page 208


 3109 00da DB43     		mvns	r3, r3
 3110              	.LVL209:
 250:MotorControl/encoder.cpp ****         };
 3111              		.loc 3 250 29 view .LVU730
 3112 00dc DBB2     		uxtb	r3, r3
 3113              	.LVL210:
 250:MotorControl/encoder.cpp ****         };
 3114              		.loc 3 250 29 view .LVU731
 3115              	.LBE1574:
 3116              	.LBE1573:
 252:MotorControl/encoder.cpp ****             hall_polarity = 0b000;
 3117              		.loc 3 252 9 view .LVU732
 3118 00de 812B     		cmp	r3, #129
 3119 00e0 12D0     		beq	.L158
 254:MotorControl/encoder.cpp ****             hall_polarity = 0b001;
 3120              		.loc 3 254 16 is_stmt 1 view .LVU733
 3121              	.LVL211:
 254:MotorControl/encoder.cpp ****             hall_polarity = 0b001;
 3122              		.loc 3 254 16 is_stmt 0 view .LVU734
 3123              	.LBE1579:
 3124              	.LBE1588:
 250:MotorControl/encoder.cpp ****         };
 3125              		.loc 3 250 13 is_stmt 1 view .LVU735
 3126              	.LBB1589:
 3127              	.LBB1580:
 254:MotorControl/encoder.cpp ****             hall_polarity = 0b001;
 3128              		.loc 3 254 16 is_stmt 0 view .LVU736
 3129 00e2 422B     		cmp	r3, #66
 3130 00e4 19D0     		beq	.L159
 256:MotorControl/encoder.cpp ****             hall_polarity = 0b010;
 3131              		.loc 3 256 16 is_stmt 1 view .LVU737
 3132              	.LVL212:
 256:MotorControl/encoder.cpp ****             hall_polarity = 0b010;
 3133              		.loc 3 256 16 is_stmt 0 view .LVU738
 3134              	.LBE1580:
 3135              	.LBE1589:
 250:MotorControl/encoder.cpp ****         };
 3136              		.loc 3 250 13 is_stmt 1 view .LVU739
 3137              	.LBB1590:
 3138              	.LBB1581:
 256:MotorControl/encoder.cpp ****             hall_polarity = 0b010;
 3139              		.loc 3 256 16 is_stmt 0 view .LVU740
 3140 00e6 242B     		cmp	r3, #36
 3141 00e8 19D0     		beq	.L160
 258:MotorControl/encoder.cpp ****             hall_polarity = 0b100;
 3142              		.loc 3 258 16 is_stmt 1 view .LVU741
 3143              	.LVL213:
 258:MotorControl/encoder.cpp ****             hall_polarity = 0b100;
 3144              		.loc 3 258 16 is_stmt 0 view .LVU742
 3145              	.LBE1581:
 3146              	.LBE1590:
 250:MotorControl/encoder.cpp ****         };
 3147              		.loc 3 250 13 is_stmt 1 view .LVU743
 3148              	.LBB1591:
 3149              	.LBB1582:
 258:MotorControl/encoder.cpp ****             hall_polarity = 0b100;
 3150              		.loc 3 258 16 is_stmt 0 view .LVU744
ARM GAS  /tmp/cc5nV8qb.s 			page 209


 3151 00ea 182B     		cmp	r3, #24
 3152 00ec 07D1     		bne	.L167
 259:MotorControl/encoder.cpp ****         } else {
 3153              		.loc 3 259 27 view .LVU745
 3154 00ee 0423     		movs	r3, #4
 3155 00f0 0BE0     		b	.L156
 3156              	.LVL214:
 3157              	.L166:
 239:MotorControl/encoder.cpp ****             return false;
 3158              		.loc 3 239 13 is_stmt 1 view .LVU746
 239:MotorControl/encoder.cpp ****             return false;
 3159              		.loc 3 239 22 is_stmt 0 view .LVU747
 3160 00f2 1021     		movs	r1, #16
 3161 00f4 2046     		mov	r0, r4
 3162 00f6 FFF7FEFF 		bl	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
 3163              	.LVL215:
 240:MotorControl/encoder.cpp ****         }
 3164              		.loc 3 240 13 is_stmt 1 view .LVU748
 3165              	.L155:
 240:MotorControl/encoder.cpp ****         }
 3166              		.loc 3 240 20 is_stmt 0 discriminator 1 view .LVU749
 3167 00fa 0026     		movs	r6, #0
 3168              	.LVL216:
 240:MotorControl/encoder.cpp ****         }
 3169              		.loc 3 240 20 discriminator 1 view .LVU750
 3170 00fc 0AE0     		b	.L163
 3171              	.LVL217:
 3172              	.L167:
 261:MotorControl/encoder.cpp ****             return false;
 3173              		.loc 3 261 13 is_stmt 1 view .LVU751
 261:MotorControl/encoder.cpp ****             return false;
 3174              		.loc 3 261 22 is_stmt 0 view .LVU752
 3175 00fe 1021     		movs	r1, #16
 3176 0100 2046     		mov	r0, r4
 3177 0102 FFF7FEFF 		bl	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
 3178              	.LVL218:
 262:MotorControl/encoder.cpp ****         }
 3179              		.loc 3 262 13 is_stmt 1 view .LVU753
 262:MotorControl/encoder.cpp ****         }
 3180              		.loc 3 262 20 is_stmt 0 view .LVU754
 3181 0106 F8E7     		b	.L155
 3182              	.LVL219:
 3183              	.L158:
 253:MotorControl/encoder.cpp ****         } else if (flip_detect(states, 1)) {
 3184              		.loc 3 253 27 view .LVU755
 3185 0108 0023     		movs	r3, #0
 3186              	.L156:
 3187              	.LVL220:
 264:MotorControl/encoder.cpp ****         config_.hall_polarity_calibrated = true;
 3188              		.loc 3 264 9 is_stmt 1 view .LVU756
 264:MotorControl/encoder.cpp ****         config_.hall_polarity_calibrated = true;
 3189              		.loc 3 264 31 is_stmt 0 view .LVU757
 3190 010a 84F86430 		strb	r3, [r4, #100]
 265:MotorControl/encoder.cpp ****     }
 3191              		.loc 3 265 9 is_stmt 1 view .LVU758
 265:MotorControl/encoder.cpp ****     }
 3192              		.loc 3 265 42 is_stmt 0 view .LVU759
ARM GAS  /tmp/cc5nV8qb.s 			page 210


 3193 010e 0123     		movs	r3, #1
 3194              	.LVL221:
 265:MotorControl/encoder.cpp ****     }
 3195              		.loc 3 265 42 view .LVU760
 3196 0110 84F86530 		strb	r3, [r4, #101]
 3197              	.LVL222:
 3198              	.L163:
 265:MotorControl/encoder.cpp ****     }
 3199              		.loc 3 265 42 view .LVU761
 3200              	.LBE1582:
 3201              	.LBE1591:
 269:MotorControl/encoder.cpp **** 
 3202              		.loc 3 269 1 view .LVU762
 3203 0114 3046     		mov	r0, r6
 3204 0116 12B0     		add	sp, sp, #72
 3205              	.LCFI27:
 3206              		.cfi_remember_state
 3207              		.cfi_def_cfa_offset 16
 3208              		@ sp needed
 3209 0118 70BD     		pop	{r4, r5, r6, pc}
 3210              	.LVL223:
 3211              	.L159:
 3212              	.LCFI28:
 3213              		.cfi_restore_state
 3214              	.LBB1592:
 3215              	.LBB1583:
 255:MotorControl/encoder.cpp ****         } else if (flip_detect(states, 2)) {
 3216              		.loc 3 255 27 view .LVU763
 3217 011a 0123     		movs	r3, #1
 3218 011c F5E7     		b	.L156
 3219              	.LVL224:
 3220              	.L160:
 257:MotorControl/encoder.cpp ****         } else if (flip_detect(states, 3)) {
 3221              		.loc 3 257 27 view .LVU764
 3222 011e 0223     		movs	r3, #2
 3223 0120 F3E7     		b	.L156
 3224              	.LVL225:
 3225              	.L162:
 257:MotorControl/encoder.cpp ****         } else if (flip_detect(states, 3)) {
 3226              		.loc 3 257 27 view .LVU765
 3227              	.LBE1583:
 3228              	.LBE1592:
 3229              	.LBB1593:
 3230              	.LBI1593:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 3231              		.loc 6 303 11 is_stmt 1 view .LVU766
 3232              	.LBB1594:
 3233 0122 0AA8     		add	r0, sp, #40
 3234              	.LVL226:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 3235              		.loc 6 303 11 is_stmt 0 view .LVU767
 3236 0124 FFF7FEFF 		bl	_ZNSt14_Function_baseD2Ev
 3237              	.LVL227:
 3238              	.LEHB6:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 3239              		.loc 6 303 11 view .LVU768
 3240 0128 FFF7FEFF 		bl	__cxa_end_cleanup
ARM GAS  /tmp/cc5nV8qb.s 			page 211


 3241              	.LVL228:
 3242              	.LEHE6:
 3243              	.LBE1594:
 3244              	.LBE1593:
 3245              		.cfi_endproc
 3246              	.LFE5346:
 3247              		.personality	__gxx_personality_v0
 3248              		.handlerdata
 3249              	.LLSDA5346:
 3250 0008 FF       		.byte	0xff
 3251 0009 FF       		.byte	0xff
 3252 000a 01       		.byte	0x1
 3253 000b 0A       		.uleb128 .LLSDACSE5346-.LLSDACSB5346
 3254              	.LLSDACSB5346:
 3255 000c 6A       		.uleb128 .LEHB5-.LFB5346
 3256 000d 04       		.uleb128 .LEHE5-.LEHB5
 3257 000e A202     		.uleb128 .L162-.LFB5346
 3258 0010 00       		.uleb128 0
 3259 0011 A802     		.uleb128 .LEHB6-.LFB5346
 3260 0013 04       		.uleb128 .LEHE6-.LEHB6
 3261 0014 00       		.uleb128 0
 3262 0015 00       		.uleb128 0
 3263              	.LLSDACSE5346:
 3264              		.section	.text._ZN7Encoder29run_hall_polarity_calibrationEv
 3265              		.fnend
 3267              		.section	.text._ZN7Encoder26run_hall_phase_calibrationEv,"ax",%progbits
 3268              		.align	1
 3269              		.global	_ZN7Encoder26run_hall_phase_calibrationEv
 3270              		.syntax unified
 3271              		.thumb
 3272              		.thumb_func
 3274              	_ZN7Encoder26run_hall_phase_calibrationEv:
 3275              		.fnstart
 3276              	.LVL229:
 3277              	.LFB5354:
 271:MotorControl/encoder.cpp ****     Axis::LockinConfig_t lockin_config = axis_->config_.calibration_lockin;
 3278              		.loc 3 271 44 is_stmt 1 view -0
 3279              		.cfi_startproc
 3280              		@ args = 0, pretend = 0, frame = 48
 3281              		@ frame_needed = 0, uses_anonymous_args = 0
 271:MotorControl/encoder.cpp ****     Axis::LockinConfig_t lockin_config = axis_->config_.calibration_lockin;
 3282              		.loc 3 271 44 is_stmt 0 view .LVU770
 3283 0000 70B5     		push	{r4, r5, r6, lr}
 3284              		.save {r4, r5, r6, lr}
 3285              	.LCFI29:
 3286              		.cfi_def_cfa_offset 16
 3287              		.cfi_offset 4, -16
 3288              		.cfi_offset 5, -12
 3289              		.cfi_offset 6, -8
 3290              		.cfi_offset 14, -4
 3291              		.pad #48
 3292 0002 8CB0     		sub	sp, sp, #48
 3293              	.LCFI30:
 3294              		.cfi_def_cfa_offset 64
 3295 0004 0446     		mov	r4, r0
 272:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 30.0f; // run for 30 seconds
 3296              		.loc 3 272 5 is_stmt 1 view .LVU771
ARM GAS  /tmp/cc5nV8qb.s 			page 212


 272:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 30.0f; // run for 30 seconds
 3297              		.loc 3 272 42 is_stmt 0 view .LVU772
 3298 0006 036B     		ldr	r3, [r0, #48]
 272:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 30.0f; // run for 30 seconds
 3299              		.loc 3 272 26 view .LVU773
 3300 0008 0DF1040E 		add	lr, sp, #4
 3301 000c 03F1240C 		add	ip, r3, #36
 3302 0010 BCE80F00 		ldmia	ip!, {r0, r1, r2, r3}
 3303              	.LVL230:
 272:MotorControl/encoder.cpp ****     lockin_config.finish_distance = lockin_config.vel * 30.0f; // run for 30 seconds
 3304              		.loc 3 272 26 view .LVU774
 3305 0014 AEE80F00 		stmia	lr!, {r0, r1, r2, r3}
 3306 0018 9CE80700 		ldm	ip, {r0, r1, r2}
 3307 001c 8EE80700 		stm	lr, {r0, r1, r2}
 273:MotorControl/encoder.cpp ****     lockin_config.finish_on_distance = true;
 3308              		.loc 3 273 5 is_stmt 1 view .LVU775
 273:MotorControl/encoder.cpp ****     lockin_config.finish_on_distance = true;
 3309              		.loc 3 273 55 is_stmt 0 view .LVU776
 3310 0020 DDED057A 		vldr.32	s15, [sp, #20]
 3311 0024 B3EE0E7A 		vmov.f32	s14, #3.0e+1
 3312 0028 67EE877A 		vmul.f32	s15, s15, s14
 273:MotorControl/encoder.cpp ****     lockin_config.finish_on_distance = true;
 3313              		.loc 3 273 35 view .LVU777
 3314 002c CDED067A 		vstr.32	s15, [sp, #24]
 274:MotorControl/encoder.cpp ****     lockin_config.finish_on_enc_idx = false;
 3315              		.loc 3 274 5 is_stmt 1 view .LVU778
 274:MotorControl/encoder.cpp ****     lockin_config.finish_on_enc_idx = false;
 3316              		.loc 3 274 38 is_stmt 0 view .LVU779
 3317 0030 0123     		movs	r3, #1
 3318 0032 8DF81D30 		strb	r3, [sp, #29]
 275:MotorControl/encoder.cpp ****     lockin_config.finish_on_vel = false;
 3319              		.loc 3 275 5 is_stmt 1 view .LVU780
 275:MotorControl/encoder.cpp ****     lockin_config.finish_on_vel = false;
 3320              		.loc 3 275 37 is_stmt 0 view .LVU781
 3321 0036 0022     		movs	r2, #0
 3322 0038 8DF81E20 		strb	r2, [sp, #30]
 276:MotorControl/encoder.cpp **** 
 3323              		.loc 3 276 5 is_stmt 1 view .LVU782
 276:MotorControl/encoder.cpp **** 
 3324              		.loc 3 276 33 is_stmt 0 view .LVU783
 3325 003c 8DF81C20 		strb	r2, [sp, #28]
 278:MotorControl/encoder.cpp ****         if (const_vel)
 3326              		.loc 3 278 5 is_stmt 1 view .LVU784
 289:MotorControl/encoder.cpp ****     config_.hall_edge_phcnt.fill(0.0f);
 3327              		.loc 3 289 5 view .LVU785
 289:MotorControl/encoder.cpp ****     config_.hall_edge_phcnt.fill(0.0f);
 3328              		.loc 3 289 27 is_stmt 0 view .LVU786
 3329 0040 84F8F530 		strb	r3, [r4, #245]
 290:MotorControl/encoder.cpp ****     hall_phase_calib_seen_count_.fill(0);
 3330              		.loc 3 290 5 is_stmt 1 view .LVU787
 3331              	.LVL231:
 3332              	.LBB1661:
 3333              	.LBI1661:
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { std::fill_n(begin(), size(), __u); }
 3334              		.loc 18 116 7 view .LVU788
 3335              	.LBB1662:
 3336              	.LBI1662:
ARM GAS  /tmp/cc5nV8qb.s 			page 213


 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return iterator(data()); }
 3337              		.loc 18 126 7 view .LVU789
 3338              	.LBB1663:
 3339              	.LBI1663:
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ptr(_M_elems); }
 3340              		.loc 18 234 7 view .LVU790
 3341              	.LBB1664:
 3342              		.loc 18 235 33 is_stmt 0 view .LVU791
 3343 0044 04F16803 		add	r3, r4, #104
 3344              	.LVL232:
 3345              		.loc 18 235 33 view .LVU792
 3346              	.LBE1664:
 3347              	.LBE1663:
 3348              	.LBE1662:
 3349              	.LBB1665:
 3350              	.LBI1665:
 3351              		.loc 19 1089 5 is_stmt 1 view .LVU793
 3352              		.loc 19 1089 5 is_stmt 0 view .LVU794
 3353              	.LBE1665:
 3354              	.LBE1661:
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR long
 3355              		.loc 19 951 37 is_stmt 1 view .LVU795
 3356              	.LBB1673:
 3357              	.LBB1672:
 3358              	.LBB1666:
 3359              	.LBB1667:
 3360              	.LBI1667:
1054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	       std::random_access_iterator_tag)
 3361              		.loc 19 1054 5 view .LVU796
 3362              	.LBB1668:
1065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __first + __n;
 3363              		.loc 19 1065 20 is_stmt 0 view .LVU797
 3364 0048 04F18001 		add	r1, r4, #128
 3365              	.LVL233:
 3366              	.LBB1669:
 3367              	.LBI1669:
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     { std::__fill_a1(__first, __last, __value); }
 3368              		.loc 19 913 5 is_stmt 1 view .LVU798
 3369              	.LBB1670:
 3370              	.LBI1670:
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      const _Tp& __value)
 3371              		.loc 19 868 5 view .LVU799
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      const _Tp& __value)
 3372              		.loc 19 868 5 is_stmt 0 view .LVU800
 3373 004c 02E0     		b	.L170
 3374              	.LVL234:
 3375              	.L195:
 3376              	.LBB1671:
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 3377              		.loc 19 873 11 view .LVU801
 3378 004e 0022     		movs	r2, #0
 3379 0050 43F8042B 		str	r2, [r3], #4	@ float
 3380              	.LVL235:
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	*__first = __tmp;
 3381              		.loc 19 872 7 is_stmt 1 view .LVU802
 3382              	.L170:
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	*__first = __tmp;
ARM GAS  /tmp/cc5nV8qb.s 			page 214


 3383              		.loc 19 872 22 view .LVU803
 3384 0054 9942     		cmp	r1, r3
 3385 0056 FAD1     		bne	.L195
 3386              	.LVL236:
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	*__first = __tmp;
 3387              		.loc 19 872 22 is_stmt 0 view .LVU804
 3388              	.LBE1671:
 3389              	.LBE1670:
 3390              	.LBE1669:
 3391              	.LBE1668:
 3392              	.LBE1667:
 3393              	.LBE1666:
 3394              	.LBE1672:
 3395              	.LBE1673:
 291:MotorControl/encoder.cpp ****     bool success = axis_->run_lockin_spin(lockin_config, false, loop_cb);
 3396              		.loc 3 291 5 is_stmt 1 view .LVU805
 3397              	.LBB1674:
 3398              	.LBI1674:
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { std::fill_n(begin(), size(), __u); }
 3399              		.loc 18 116 7 view .LVU806
 3400              	.LBB1675:
 3401              	.LBI1675:
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return iterator(data()); }
 3402              		.loc 18 126 7 view .LVU807
 3403              	.LBB1676:
 3404              	.LBI1676:
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ptr(_M_elems); }
 3405              		.loc 18 234 7 view .LVU808
 3406              	.LBB1677:
 3407              		.loc 18 235 33 is_stmt 0 view .LVU809
 3408 0058 04F58C73 		add	r3, r4, #280
 3409              	.LVL237:
 3410              		.loc 18 235 33 view .LVU810
 3411              	.LBE1677:
 3412              	.LBE1676:
 3413              	.LBE1675:
 3414              	.LBB1678:
 3415              	.LBI1678:
 3416              		.loc 19 1089 5 is_stmt 1 view .LVU811
 3417              		.loc 19 1089 5 is_stmt 0 view .LVU812
 3418              	.LBE1678:
 3419              	.LBE1674:
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   inline _GLIBCXX_CONSTEXPR long
 3420              		.loc 19 951 37 is_stmt 1 view .LVU813
 3421              	.LBB1686:
 3422              	.LBB1685:
 3423              	.LBB1679:
 3424              	.LBB1680:
 3425              	.LBI1680:
1054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	       std::random_access_iterator_tag)
 3426              		.loc 19 1054 5 view .LVU814
 3427              	.LBB1681:
1065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __first + __n;
 3428              		.loc 19 1065 20 is_stmt 0 view .LVU815
 3429 005c 04F59871 		add	r1, r4, #304
 3430              	.LVL238:
 3431              	.LBB1682:
ARM GAS  /tmp/cc5nV8qb.s 			page 215


 3432              	.LBI1682:
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     { std::__fill_a1(__first, __last, __value); }
 3433              		.loc 19 913 5 is_stmt 1 view .LVU816
 3434              	.LBB1683:
 3435              	.LBI1683:
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      const _Tp& __value)
 3436              		.loc 19 868 5 view .LVU817
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      const _Tp& __value)
 3437              		.loc 19 868 5 is_stmt 0 view .LVU818
 3438 0060 02E0     		b	.L172
 3439              	.LVL239:
 3440              	.L196:
 3441              	.LBB1684:
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 3442              		.loc 19 873 11 view .LVU819
 3443 0062 0022     		movs	r2, #0
 3444 0064 43F8042B 		str	r2, [r3], #4
 3445              	.LVL240:
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	*__first = __tmp;
 3446              		.loc 19 872 7 is_stmt 1 view .LVU820
 3447              	.L172:
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	*__first = __tmp;
 3448              		.loc 19 872 22 view .LVU821
 3449 0068 9942     		cmp	r1, r3
 3450 006a FAD1     		bne	.L196
 3451              	.LVL241:
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	*__first = __tmp;
 3452              		.loc 19 872 22 is_stmt 0 view .LVU822
 3453              	.LBE1684:
 3454              	.LBE1683:
 3455              	.LBE1682:
 3456              	.LBE1681:
 3457              	.LBE1680:
 3458              	.LBE1679:
 3459              	.LBE1685:
 3460              	.LBE1686:
 292:MotorControl/encoder.cpp ****     if (error_ & ERROR_ILLEGAL_HALL_STATE)
 3461              		.loc 3 292 5 is_stmt 1 view .LVU823
 292:MotorControl/encoder.cpp ****     if (error_ & ERROR_ILLEGAL_HALL_STATE)
 3462              		.loc 3 292 20 is_stmt 0 view .LVU824
 3463 006c 256B     		ldr	r5, [r4, #48]
 292:MotorControl/encoder.cpp ****     if (error_ & ERROR_ILLEGAL_HALL_STATE)
 3464              		.loc 3 292 42 view .LVU825
 3465 006e 2146     		mov	r1, r4
 3466 0070 08A8     		add	r0, sp, #32
 3467 0072 FFF7FEFF 		bl	_ZNSt8functionIFbbEEC1IZN7Encoder26run_hall_phase_calibrationEvEUlbE_vvEET_
 3468              	.LVL242:
 3469 0076 08AB     		add	r3, sp, #32
 3470 0078 0022     		movs	r2, #0
 3471 007a 01A9     		add	r1, sp, #4
 3472 007c 2846     		mov	r0, r5
 3473              	.LEHB7:
 3474 007e FFF7FEFF 		bl	_ZN4Axis15run_lockin_spinERKNS_14LockinConfig_tEbSt8functionIFbbEE
 3475              	.LVL243:
 3476              	.LEHE7:
 3477 0082 0646     		mov	r6, r0
 3478              	.LVL244:
ARM GAS  /tmp/cc5nV8qb.s 			page 216


 3479              	.LBB1687:
 3480              	.LBI1687:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 3481              		.loc 6 303 11 is_stmt 1 view .LVU826
 3482              	.LBB1688:
 3483              	.LBB1689:
 3484              	.LBI1689:
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     {
 3485              		.loc 6 242 5 view .LVU827
 3486              	.LBB1690:
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 3487              		.loc 6 244 7 view .LVU828
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 3488              		.loc 6 244 11 is_stmt 0 view .LVU829
 3489 0084 0A9B     		ldr	r3, [sp, #40]
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h **** 	_M_manager(_M_functor, _M_functor, __destroy_functor);
 3490              		.loc 6 244 7 view .LVU830
 3491 0086 1BB1     		cbz	r3, .L173
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 3492              		.loc 6 245 2 is_stmt 1 view .LVU831
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 3493              		.loc 6 245 12 is_stmt 0 view .LVU832
 3494 0088 0322     		movs	r2, #3
 3495 008a 08A9     		add	r1, sp, #32
 3496              	.LVL245:
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 3497              		.loc 6 245 12 view .LVU833
 3498 008c 0846     		mov	r0, r1
 3499 008e 9847     		blx	r3
 3500              	.LVL246:
 3501              	.L173:
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     }
 3502              		.loc 6 245 12 view .LVU834
 3503              	.LBE1690:
 3504              	.LBE1689:
 3505              	.LBE1688:
 3506              	.LBE1687:
 293:MotorControl/encoder.cpp ****         success = false;
 3507              		.loc 3 293 5 is_stmt 1 view .LVU835
 293:MotorControl/encoder.cpp ****         success = false;
 3508              		.loc 3 293 16 is_stmt 0 view .LVU836
 3509 0090 1021     		movs	r1, #16
 3510 0092 B4F88C00 		ldrh	r0, [r4, #140]
 3511 0096 FFF7FEFF 		bl	_ZanN10ODriveIntf11EncoderIntf5ErrorES1_
 3512              	.LVL247:
 293:MotorControl/encoder.cpp ****         success = false;
 3513              		.loc 3 293 5 view .LVU837
 3514 009a 0028     		cmp	r0, #0
 3515 009c 71D1     		bne	.L187
 296:MotorControl/encoder.cpp ****         // Check deltas to dicern rotation direction
 3516              		.loc 3 296 5 is_stmt 1 view .LVU838
 3517              	.LBB1691:
 3518 009e 002E     		cmp	r6, #0
 3519 00a0 70D0     		beq	.L174
 3520              	.LBB1692:
 3521              	.LBB1693:
 299:MotorControl/encoder.cpp ****             int next_i = (i == 5) ? 0 : i+1;
ARM GAS  /tmp/cc5nV8qb.s 			page 217


 3522              		.loc 3 299 18 is_stmt 0 view .LVU839
 3523 00a2 0023     		movs	r3, #0
 3524              	.LBE1693:
 298:MotorControl/encoder.cpp ****         for (int i = 0; i < 6; i++) {
 3525              		.loc 3 298 15 view .LVU840
 3526 00a4 9FED426A 		vldr.32	s12, .L199
 3527 00a8 19E0     		b	.L177
 3528              	.LVL248:
 3529              	.L197:
 3530              	.LBB1707:
 3531              	.LBB1694:
 300:MotorControl/encoder.cpp ****             delta_phase += wrap_pm_pi(config_.hall_edge_phcnt[next_i] - config_.hall_edge_phcnt[i])
 3532              		.loc 3 300 35 discriminator 1 view .LVU841
 3533 00aa 5A1C     		adds	r2, r3, #1
 3534              	.L176:
 3535              	.LVL249:
 301:MotorControl/encoder.cpp ****         }
 3536              		.loc 3 301 13 is_stmt 1 discriminator 4 view .LVU842
 3537              	.LBB1695:
 3538              	.LBI1695:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 3539              		.loc 18 185 7 discriminator 4 view .LVU843
 3540              	.LBB1696:
 3541              	.LBI1696:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3542              		.loc 18 55 7 discriminator 4 view .LVU844
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3543              		.loc 18 55 7 is_stmt 0 discriminator 4 view .LVU845
 3544              	.LBE1696:
 3545              	.LBE1695:
 3546              	.LBB1697:
 3547              	.LBI1697:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 3548              		.loc 18 185 7 is_stmt 1 discriminator 4 view .LVU846
 3549              	.LBB1698:
 3550              	.LBI1698:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3551              		.loc 18 55 7 discriminator 4 view .LVU847
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3552              		.loc 18 55 7 is_stmt 0 discriminator 4 view .LVU848
 3553              	.LBE1698:
 3554              	.LBE1697:
 301:MotorControl/encoder.cpp ****         }
 3555              		.loc 3 301 38 discriminator 4 view .LVU849
 3556 00ac 04EB8202 		add	r2, r4, r2, lsl #2
 3557              	.LVL250:
 301:MotorControl/encoder.cpp ****         }
 3558              		.loc 3 301 38 discriminator 4 view .LVU850
 3559 00b0 04EB8301 		add	r1, r4, r3, lsl #2
 3560 00b4 D2ED1A7A 		vldr.32	s15, [r2, #104]
 3561 00b8 91ED1A7A 		vldr.32	s14, [r1, #104]
 3562 00bc 77EEC77A 		vsub.f32	s15, s15, s14
 3563              	.LVL251:
 3564              	.LBB1699:
 3565              	.LBI1699:
 139:./MotorControl/utils.hpp ****     return wrap_pm(x, 2 * M_PI);
 3566              		.loc 17 139 14 is_stmt 1 discriminator 4 view .LVU851
ARM GAS  /tmp/cc5nV8qb.s 			page 218


 3567              	.LBE1699:
 3568              	.LBE1694:
 3569              	.LBE1707:
 3570              	.LBE1692:
 3571              	.LBE1691:
 140:./MotorControl/utils.hpp **** }
 3572              		.loc 17 140 5 discriminator 4 view .LVU852
 3573              	.LBB1742:
 3574              	.LBB1740:
 3575              	.LBB1708:
 3576              	.LBB1705:
 3577              	.LBB1704:
 3578              	.LBB1700:
 3579              	.LBI1700:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 3580              		.loc 17 123 14 discriminator 4 view .LVU853
 3581              	.LBB1701:
 125:./MotorControl/utils.hpp **** #else
 3582              		.loc 17 125 5 discriminator 4 view .LVU854
 125:./MotorControl/utils.hpp **** #else
 3583              		.loc 17 125 36 is_stmt 0 discriminator 4 view .LVU855
 3584 00c0 DFED3C6A 		vldr.32	s13, .L199+4
 3585 00c4 87EEA67A 		vdiv.f32	s14, s15, s13
 3586              	.LVL252:
 3587              	.LBB1702:
 3588              	.LBI1702:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 3589              		.loc 17 108 12 is_stmt 1 discriminator 4 view .LVU856
 3590              	.LBB1703:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 3591              		.loc 17 110 5 discriminator 4 view .LVU857
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 3592              		.loc 17 111 5 discriminator 4 view .LVU858
 3593              		.syntax unified
 3594              	@ 111 "./MotorControl/utils.hpp" 1
 3595 00c8 BDEE477A 		vcvtr.s32.f32   s14, s14
 3596              	@ 0 "" 2
 3597              	.LVL253:
 114:./MotorControl/utils.hpp **** #else
 3598              		.loc 17 114 5 discriminator 4 view .LVU859
 114:./MotorControl/utils.hpp **** #else
 3599              		.loc 17 114 5 is_stmt 0 discriminator 4 view .LVU860
 3600              		.thumb
 3601              		.syntax unified
 3602              	.LBE1703:
 3603              	.LBE1702:
 125:./MotorControl/utils.hpp **** #else
 3604              		.loc 17 125 42 discriminator 4 view .LVU861
 3605 00cc B8EEC77A 		vcvt.f32.s32	s14, s14
 3606              	.LVL254:
 129:./MotorControl/utils.hpp **** }
 3607              		.loc 17 129 5 is_stmt 1 discriminator 4 view .LVU862
 129:./MotorControl/utils.hpp **** }
 3608              		.loc 17 129 23 is_stmt 0 discriminator 4 view .LVU863
 3609 00d0 27EE267A 		vmul.f32	s14, s14, s13
 3610              	.LVL255:
 129:./MotorControl/utils.hpp **** }
ARM GAS  /tmp/cc5nV8qb.s 			page 219


 3611              		.loc 17 129 25 discriminator 4 view .LVU864
 3612 00d4 77EEC77A 		vsub.f32	s15, s15, s14
 3613              	.LVL256:
 129:./MotorControl/utils.hpp **** }
 3614              		.loc 17 129 25 discriminator 4 view .LVU865
 3615              	.LBE1701:
 3616              	.LBE1700:
 3617              	.LBE1704:
 301:MotorControl/encoder.cpp ****         }
 3618              		.loc 3 301 25 discriminator 4 view .LVU866
 3619 00d8 36EE276A 		vadd.f32	s12, s12, s15
 3620              	.LVL257:
 301:MotorControl/encoder.cpp ****         }
 3621              		.loc 3 301 25 discriminator 4 view .LVU867
 3622              	.LBE1705:
 299:MotorControl/encoder.cpp ****             int next_i = (i == 5) ? 0 : i+1;
 3623              		.loc 3 299 9 is_stmt 1 discriminator 4 view .LVU868
 3624 00dc 0133     		adds	r3, r3, #1
 3625              	.LVL258:
 3626              	.L177:
 299:MotorControl/encoder.cpp ****             int next_i = (i == 5) ? 0 : i+1;
 3627              		.loc 3 299 27 discriminator 2 view .LVU869
 3628 00de 052B     		cmp	r3, #5
 3629 00e0 02DC     		bgt	.L175
 3630              	.LBB1706:
 300:MotorControl/encoder.cpp ****             delta_phase += wrap_pm_pi(config_.hall_edge_phcnt[next_i] - config_.hall_edge_phcnt[i])
 3631              		.loc 3 300 13 view .LVU870
 300:MotorControl/encoder.cpp ****             delta_phase += wrap_pm_pi(config_.hall_edge_phcnt[next_i] - config_.hall_edge_phcnt[i])
 3632              		.loc 3 300 35 is_stmt 0 view .LVU871
 3633 00e2 E2D1     		bne	.L197
 3634 00e4 0022     		movs	r2, #0
 3635 00e6 E1E7     		b	.L176
 3636              	.L175:
 3637              	.LBE1706:
 3638              	.LBE1708:
 304:MotorControl/encoder.cpp ****             config_.direction = -1;
 3639              		.loc 3 304 9 is_stmt 1 view .LVU872
 3640              	.LBB1709:
 3641 00e8 B5EEC06A 		vcmpe.f32	s12, #0
 3642 00ec F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 3643 00f0 05D4     		bmi	.L198
 309:MotorControl/encoder.cpp ****         }
 3644              		.loc 3 309 13 view .LVU873
 309:MotorControl/encoder.cpp ****         }
 3645              		.loc 3 309 31 is_stmt 0 view .LVU874
 3646 00f2 0123     		movs	r3, #1
 3647              	.LVL259:
 309:MotorControl/encoder.cpp ****         }
 3648              		.loc 3 309 31 view .LVU875
 3649 00f4 E365     		str	r3, [r4, #92]
 3650              	.L180:
 309:MotorControl/encoder.cpp ****         }
 3651              		.loc 3 309 31 view .LVU876
 3652              	.LBE1709:
 312:MotorControl/encoder.cpp ****         for (int i = 0; i < 6; i++) {
 3653              		.loc 3 312 9 is_stmt 1 view .LVU877
 312:MotorControl/encoder.cpp ****         for (int i = 0; i < 6; i++) {
ARM GAS  /tmp/cc5nV8qb.s 			page 220


 3654              		.loc 3 312 49 is_stmt 0 view .LVU878
 3655 00f6 94ED1A6A 		vldr.32	s12, [r4, #104]
 3656              	.LVL260:
 313:MotorControl/encoder.cpp ****             float& phcnt = config_.hall_edge_phcnt[i];
 3657              		.loc 3 313 9 is_stmt 1 view .LVU879
 3658              	.LBB1724:
 313:MotorControl/encoder.cpp ****             float& phcnt = config_.hall_edge_phcnt[i];
 3659              		.loc 3 313 18 is_stmt 0 view .LVU880
 3660 00fa 0023     		movs	r3, #0
 3661 00fc 20E0     		b	.L185
 3662              	.LVL261:
 3663              	.L198:
 313:MotorControl/encoder.cpp ****             float& phcnt = config_.hall_edge_phcnt[i];
 3664              		.loc 3 313 18 view .LVU881
 3665              	.LBE1724:
 3666              	.LBB1737:
 3667              	.LBB1710:
 305:MotorControl/encoder.cpp ****             for (int i = 0; i < 6; i++)
 3668              		.loc 3 305 13 is_stmt 1 view .LVU882
 305:MotorControl/encoder.cpp ****             for (int i = 0; i < 6; i++)
 3669              		.loc 3 305 31 is_stmt 0 view .LVU883
 3670 00fe 4FF0FF33 		mov	r3, #-1
 3671              	.LVL262:
 305:MotorControl/encoder.cpp ****             for (int i = 0; i < 6; i++)
 3672              		.loc 3 305 31 view .LVU884
 3673 0102 E365     		str	r3, [r4, #92]
 306:MotorControl/encoder.cpp ****                 config_.hall_edge_phcnt[i] = wrap_pm_pi(-config_.hall_edge_phcnt[i]);
 3674              		.loc 3 306 13 is_stmt 1 view .LVU885
 3675              	.LVL263:
 3676              	.LBB1711:
 306:MotorControl/encoder.cpp ****                 config_.hall_edge_phcnt[i] = wrap_pm_pi(-config_.hall_edge_phcnt[i]);
 3677              		.loc 3 306 22 is_stmt 0 view .LVU886
 3678 0104 0023     		movs	r3, #0
 3679              	.LVL264:
 3680              	.L181:
 306:MotorControl/encoder.cpp ****                 config_.hall_edge_phcnt[i] = wrap_pm_pi(-config_.hall_edge_phcnt[i]);
 3681              		.loc 3 306 31 is_stmt 1 discriminator 3 view .LVU887
 3682 0106 052B     		cmp	r3, #5
 3683 0108 F5DC     		bgt	.L180
 307:MotorControl/encoder.cpp ****         } else {
 3684              		.loc 3 307 17 discriminator 2 view .LVU888
 3685              	.LVL265:
 3686              	.LBB1712:
 3687              	.LBI1712:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 3688              		.loc 18 185 7 discriminator 2 view .LVU889
 3689              	.LBB1713:
 3690              	.LBI1713:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3691              		.loc 18 55 7 discriminator 2 view .LVU890
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3692              		.loc 18 55 7 is_stmt 0 discriminator 2 view .LVU891
 3693              	.LBE1713:
 3694              	.LBE1712:
 307:MotorControl/encoder.cpp ****         } else {
 3695              		.loc 3 307 56 discriminator 2 view .LVU892
 3696 010a 04EB8302 		add	r2, r4, r3, lsl #2
ARM GAS  /tmp/cc5nV8qb.s 			page 221


 3697 010e D2ED1A7A 		vldr.32	s15, [r2, #104]
 3698 0112 F1EE677A 		vneg.f32	s15, s15
 3699              	.LVL266:
 3700              	.LBB1714:
 3701              	.LBI1714:
 139:./MotorControl/utils.hpp ****     return wrap_pm(x, 2 * M_PI);
 3702              		.loc 17 139 14 is_stmt 1 discriminator 2 view .LVU893
 3703              	.LBE1714:
 3704              	.LBE1711:
 3705              	.LBE1710:
 3706              	.LBE1737:
 3707              	.LBE1740:
 3708              	.LBE1742:
 140:./MotorControl/utils.hpp **** }
 3709              		.loc 17 140 5 discriminator 2 view .LVU894
 3710              	.LBB1743:
 3711              	.LBB1741:
 3712              	.LBB1738:
 3713              	.LBB1723:
 3714              	.LBB1722:
 3715              	.LBB1719:
 3716              	.LBB1715:
 3717              	.LBI1715:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 3718              		.loc 17 123 14 discriminator 2 view .LVU895
 3719              	.LBB1716:
 125:./MotorControl/utils.hpp **** #else
 3720              		.loc 17 125 5 discriminator 2 view .LVU896
 125:./MotorControl/utils.hpp **** #else
 3721              		.loc 17 125 36 is_stmt 0 discriminator 2 view .LVU897
 3722 0116 DFED276A 		vldr.32	s13, .L199+4
 3723 011a 87EEA67A 		vdiv.f32	s14, s15, s13
 3724              	.LVL267:
 3725              	.LBB1717:
 3726              	.LBI1717:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 3727              		.loc 17 108 12 is_stmt 1 discriminator 2 view .LVU898
 3728              	.LBB1718:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 3729              		.loc 17 110 5 discriminator 2 view .LVU899
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 3730              		.loc 17 111 5 discriminator 2 view .LVU900
 3731              		.syntax unified
 3732              	@ 111 "./MotorControl/utils.hpp" 1
 3733 011e BDEE477A 		vcvtr.s32.f32   s14, s14
 3734              	@ 0 "" 2
 3735              	.LVL268:
 114:./MotorControl/utils.hpp **** #else
 3736              		.loc 17 114 5 discriminator 2 view .LVU901
 114:./MotorControl/utils.hpp **** #else
 3737              		.loc 17 114 5 is_stmt 0 discriminator 2 view .LVU902
 3738              		.thumb
 3739              		.syntax unified
 3740              	.LBE1718:
 3741              	.LBE1717:
 125:./MotorControl/utils.hpp **** #else
 3742              		.loc 17 125 42 discriminator 2 view .LVU903
ARM GAS  /tmp/cc5nV8qb.s 			page 222


 3743 0122 B8EEC77A 		vcvt.f32.s32	s14, s14
 3744              	.LVL269:
 129:./MotorControl/utils.hpp **** }
 3745              		.loc 17 129 5 is_stmt 1 discriminator 2 view .LVU904
 129:./MotorControl/utils.hpp **** }
 3746              		.loc 17 129 23 is_stmt 0 discriminator 2 view .LVU905
 3747 0126 27EE267A 		vmul.f32	s14, s14, s13
 3748              	.LVL270:
 129:./MotorControl/utils.hpp **** }
 3749              		.loc 17 129 25 discriminator 2 view .LVU906
 3750 012a 77EEC77A 		vsub.f32	s15, s15, s14
 3751              	.LVL271:
 129:./MotorControl/utils.hpp **** }
 3752              		.loc 17 129 25 discriminator 2 view .LVU907
 3753              	.LBE1716:
 3754              	.LBE1715:
 3755              	.LBE1719:
 3756              	.LBB1720:
 3757              	.LBI1720:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 3758              		.loc 18 185 7 is_stmt 1 discriminator 2 view .LVU908
 3759              	.LBB1721:
 3760              	.LBI1721:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3761              		.loc 18 55 7 discriminator 2 view .LVU909
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3762              		.loc 18 55 7 is_stmt 0 discriminator 2 view .LVU910
 3763              	.LBE1721:
 3764              	.LBE1720:
 307:MotorControl/encoder.cpp ****         } else {
 3765              		.loc 3 307 44 discriminator 2 view .LVU911
 3766 012e C2ED1A7A 		vstr.32	s15, [r2, #104]
 306:MotorControl/encoder.cpp ****                 config_.hall_edge_phcnt[i] = wrap_pm_pi(-config_.hall_edge_phcnt[i]);
 3767              		.loc 3 306 13 is_stmt 1 discriminator 2 view .LVU912
 3768 0132 0133     		adds	r3, r3, #1
 3769              	.LVL272:
 306:MotorControl/encoder.cpp ****                 config_.hall_edge_phcnt[i] = wrap_pm_pi(-config_.hall_edge_phcnt[i]);
 3770              		.loc 3 306 13 is_stmt 0 discriminator 2 view .LVU913
 3771 0134 E7E7     		b	.L181
 3772              	.LVL273:
 3773              	.L183:
 306:MotorControl/encoder.cpp ****                 config_.hall_edge_phcnt[i] = wrap_pm_pi(-config_.hall_edge_phcnt[i]);
 3774              		.loc 3 306 13 discriminator 2 view .LVU914
 3775              	.LBE1722:
 3776              	.LBE1723:
 3777              	.LBE1738:
 3778              	.LBB1739:
 3779              	.LBB1725:
 3780              	.LBB1726:
 3781              	.LBB1727:
 136:./MotorControl/utils.hpp **** }
 3782              		.loc 17 136 5 is_stmt 1 view .LVU915
 136:./MotorControl/utils.hpp **** }
 3783              		.loc 17 136 5 is_stmt 0 view .LVU916
 3784              	.LBE1727:
 3785              	.LBE1726:
 315:MotorControl/encoder.cpp ****         }
ARM GAS  /tmp/cc5nV8qb.s 			page 223


 3786              		.loc 3 315 19 view .LVU917
 3787 0136 04EB8202 		add	r2, r4, r2, lsl #2
 3788              	.LVL274:
 315:MotorControl/encoder.cpp ****         }
 3789              		.loc 3 315 19 view .LVU918
 3790 013a C2ED1A7A 		vstr.32	s15, [r2, #104]
 3791              	.LBE1725:
 313:MotorControl/encoder.cpp ****             float& phcnt = config_.hall_edge_phcnt[i];
 3792              		.loc 3 313 9 is_stmt 1 view .LVU919
 3793 013e 0133     		adds	r3, r3, #1
 3794              	.LVL275:
 3795              	.L185:
 313:MotorControl/encoder.cpp ****             float& phcnt = config_.hall_edge_phcnt[i];
 3796              		.loc 3 313 27 discriminator 3 view .LVU920
 3797 0140 052B     		cmp	r3, #5
 3798 0142 29DC     		bgt	.L182
 3799              	.LBB1736:
 314:MotorControl/encoder.cpp ****             phcnt = fmodf_pos((6.0f / (2.0f * M_PI)) * (phcnt - offset), 6.0f);
 3800              		.loc 3 314 13 discriminator 2 view .LVU921
 314:MotorControl/encoder.cpp ****             phcnt = fmodf_pos((6.0f / (2.0f * M_PI)) * (phcnt - offset), 6.0f);
 3801              		.loc 3 314 53 is_stmt 0 discriminator 2 view .LVU922
 3802 0144 1A46     		mov	r2, r3
 3803              	.LVL276:
 3804              	.LBB1733:
 3805              	.LBI1733:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 3806              		.loc 18 185 7 is_stmt 1 discriminator 2 view .LVU923
 3807              	.LBB1734:
 3808              	.LBI1734:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3809              		.loc 18 55 7 discriminator 2 view .LVU924
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3810              		.loc 18 55 7 is_stmt 0 discriminator 2 view .LVU925
 3811              	.LBE1734:
 3812              	.LBE1733:
 315:MotorControl/encoder.cpp ****         }
 3813              		.loc 3 315 13 is_stmt 1 discriminator 2 view .LVU926
 315:MotorControl/encoder.cpp ****         }
 3814              		.loc 3 315 57 is_stmt 0 discriminator 2 view .LVU927
 3815 0146 04EB8301 		add	r1, r4, r3, lsl #2
 3816 014a D1ED1A7A 		vldr.32	s15, [r1, #104]
 315:MotorControl/encoder.cpp ****         }
 3817              		.loc 3 315 63 discriminator 2 view .LVU928
 3818 014e 77EEC67A 		vsub.f32	s15, s15, s12
 315:MotorControl/encoder.cpp ****         }
 3819              		.loc 3 315 30 discriminator 2 view .LVU929
 3820 0152 9FED197A 		vldr.32	s14, .L199+8
 3821 0156 67EE877A 		vmul.f32	s15, s15, s14
 3822              	.LVL277:
 3823              	.LBB1735:
 3824              	.LBI1726:
 133:./MotorControl/utils.hpp ****     float res = wrap_pm(x, y);
 3825              		.loc 17 133 14 is_stmt 1 discriminator 2 view .LVU930
 3826              	.LBB1732:
 134:./MotorControl/utils.hpp ****     if (res < 0) res += y;
 3827              		.loc 17 134 5 discriminator 2 view .LVU931
 3828              	.LBB1728:
ARM GAS  /tmp/cc5nV8qb.s 			page 224


 3829              	.LBI1728:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 3830              		.loc 17 123 14 discriminator 2 view .LVU932
 3831              	.LBB1729:
 125:./MotorControl/utils.hpp **** #else
 3832              		.loc 17 125 5 discriminator 2 view .LVU933
 125:./MotorControl/utils.hpp **** #else
 3833              		.loc 17 125 36 is_stmt 0 discriminator 2 view .LVU934
 3834 015a F1EE086A 		vmov.f32	s13, #6.0e+0
 3835 015e 87EEA67A 		vdiv.f32	s14, s15, s13
 3836              	.LVL278:
 3837              	.LBB1730:
 3838              	.LBI1730:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 3839              		.loc 17 108 12 is_stmt 1 discriminator 2 view .LVU935
 3840              	.LBB1731:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 3841              		.loc 17 110 5 discriminator 2 view .LVU936
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 3842              		.loc 17 111 5 discriminator 2 view .LVU937
 3843              		.syntax unified
 3844              	@ 111 "./MotorControl/utils.hpp" 1
 3845 0162 BDEE477A 		vcvtr.s32.f32   s14, s14
 3846              	@ 0 "" 2
 3847              	.LVL279:
 114:./MotorControl/utils.hpp **** #else
 3848              		.loc 17 114 5 discriminator 2 view .LVU938
 114:./MotorControl/utils.hpp **** #else
 3849              		.loc 17 114 5 is_stmt 0 discriminator 2 view .LVU939
 3850              		.thumb
 3851              		.syntax unified
 3852              	.LBE1731:
 3853              	.LBE1730:
 125:./MotorControl/utils.hpp **** #else
 3854              		.loc 17 125 42 discriminator 2 view .LVU940
 3855 0166 B8EEC77A 		vcvt.f32.s32	s14, s14
 3856              	.LVL280:
 129:./MotorControl/utils.hpp **** }
 3857              		.loc 17 129 5 is_stmt 1 discriminator 2 view .LVU941
 129:./MotorControl/utils.hpp **** }
 3858              		.loc 17 129 23 is_stmt 0 discriminator 2 view .LVU942
 3859 016a 27EE267A 		vmul.f32	s14, s14, s13
 3860              	.LVL281:
 129:./MotorControl/utils.hpp **** }
 3861              		.loc 17 129 25 discriminator 2 view .LVU943
 3862 016e 77EEC77A 		vsub.f32	s15, s15, s14
 3863              	.LVL282:
 129:./MotorControl/utils.hpp **** }
 3864              		.loc 17 129 25 discriminator 2 view .LVU944
 3865              	.LBE1729:
 3866              	.LBE1728:
 135:./MotorControl/utils.hpp ****     return res;
 3867              		.loc 17 135 5 is_stmt 1 discriminator 2 view .LVU945
 3868 0172 F5EEC07A 		vcmpe.f32	s15, #0
 3869 0176 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 3870 017a DCD5     		bpl	.L183
 135:./MotorControl/utils.hpp ****     return res;
ARM GAS  /tmp/cc5nV8qb.s 			page 225


 3871              		.loc 17 135 18 view .LVU946
 135:./MotorControl/utils.hpp ****     return res;
 3872              		.loc 17 135 22 is_stmt 0 view .LVU947
 3873 017c 77EEA67A 		vadd.f32	s15, s15, s13
 3874              	.LVL283:
 135:./MotorControl/utils.hpp ****     return res;
 3875              		.loc 17 135 22 view .LVU948
 3876 0180 D9E7     		b	.L183
 3877              	.LVL284:
 3878              	.L187:
 135:./MotorControl/utils.hpp ****     return res;
 3879              		.loc 17 135 22 view .LVU949
 3880              	.LBE1732:
 3881              	.LBE1735:
 3882              	.LBE1736:
 3883              	.LBE1739:
 3884              	.LBE1741:
 3885              	.LBE1743:
 294:MotorControl/encoder.cpp **** 
 3886              		.loc 3 294 17 view .LVU950
 3887 0182 0026     		movs	r6, #0
 3888              	.LVL285:
 3889              	.L174:
 3890              	.LBB1744:
 318:MotorControl/encoder.cpp ****     }
 3891              		.loc 3 318 9 is_stmt 1 view .LVU951
 318:MotorControl/encoder.cpp ****     }
 3892              		.loc 3 318 33 is_stmt 0 view .LVU952
 3893 0184 04F1680C 		add	ip, r4, #104
 3894 0188 0C4D     		ldr	r5, .L199+12
 3895 018a 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 3896 018c ACE80F00 		stmia	ip!, {r0, r1, r2, r3}
 3897 0190 95E80300 		ldm	r5, {r0, r1}
 3898 0194 8CE80300 		stm	ip, {r0, r1}
 3899              	.L182:
 318:MotorControl/encoder.cpp ****     }
 3900              		.loc 3 318 33 view .LVU953
 3901              	.LBE1744:
 321:MotorControl/encoder.cpp ****     return success;
 3902              		.loc 3 321 5 is_stmt 1 view .LVU954
 321:MotorControl/encoder.cpp ****     return success;
 3903              		.loc 3 321 27 is_stmt 0 view .LVU955
 3904 0198 0023     		movs	r3, #0
 3905 019a 84F8F530 		strb	r3, [r4, #245]
 322:MotorControl/encoder.cpp **** }
 3906              		.loc 3 322 5 is_stmt 1 view .LVU956
 323:MotorControl/encoder.cpp **** 
 3907              		.loc 3 323 1 is_stmt 0 view .LVU957
 3908 019e 3046     		mov	r0, r6
 3909 01a0 0CB0     		add	sp, sp, #48
 3910              	.LCFI31:
 3911              		.cfi_remember_state
 3912              		.cfi_def_cfa_offset 16
 3913              		@ sp needed
 3914 01a2 70BD     		pop	{r4, r5, r6, pc}
 3915              	.LVL286:
 3916              	.L189:
ARM GAS  /tmp/cc5nV8qb.s 			page 226


 3917              	.LCFI32:
 3918              		.cfi_restore_state
 3919              	.LBB1745:
 3920              	.LBI1745:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 3921              		.loc 6 303 11 is_stmt 1 view .LVU958
 3922              	.LBB1746:
 3923 01a4 08A8     		add	r0, sp, #32
 3924              	.LVL287:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 3925              		.loc 6 303 11 is_stmt 0 view .LVU959
 3926 01a6 FFF7FEFF 		bl	_ZNSt14_Function_baseD2Ev
 3927              	.LVL288:
 3928              	.LEHB8:
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h ****     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
 3929              		.loc 6 303 11 view .LVU960
 3930 01aa FFF7FEFF 		bl	__cxa_end_cleanup
 3931              	.LVL289:
 3932              	.LEHE8:
 3933              	.L200:
 3934 01ae 00BF     		.align	2
 3935              	.L199:
 3936 01b0 00000000 		.word	0
 3937 01b4 DB0FC940 		.word	1086918619
 3938 01b8 4576743F 		.word	1064597061
 3939 01bc 00000000 		.word	_ZN7Encoder18hall_edge_defaultsE
 3940              	.LBE1746:
 3941              	.LBE1745:
 3942              		.cfi_endproc
 3943              	.LFE5354:
 3944              		.personality	__gxx_personality_v0
 3945              		.handlerdata
 3946              	.LLSDA5354:
 3947 0008 FF       		.byte	0xff
 3948 0009 FF       		.byte	0xff
 3949 000a 01       		.byte	0x1
 3950 000b 0A       		.uleb128 .LLSDACSE5354-.LLSDACSB5354
 3951              	.LLSDACSB5354:
 3952 000c 7E       		.uleb128 .LEHB7-.LFB5354
 3953 000d 04       		.uleb128 .LEHE7-.LEHB7
 3954 000e A403     		.uleb128 .L189-.LFB5354
 3955 0010 00       		.uleb128 0
 3956 0011 AA03     		.uleb128 .LEHB8-.LFB5354
 3957 0013 04       		.uleb128 .LEHE8-.LEHB8
 3958 0014 00       		.uleb128 0
 3959 0015 00       		.uleb128 0
 3960              	.LLSDACSE5354:
 3961              		.section	.text._ZN7Encoder26run_hall_phase_calibrationEv
 3962              		.fnend
 3964              		.section	.text._ZN7Encoder17read_sampled_gpioE9Stm32Gpio,"ax",%progbits
 3965              		.align	1
 3966              		.global	_ZN7Encoder17read_sampled_gpioE9Stm32Gpio
 3967              		.syntax unified
 3968              		.thumb
 3969              		.thumb_func
 3971              	_ZN7Encoder17read_sampled_gpioE9Stm32Gpio:
 3972              		.fnstart
ARM GAS  /tmp/cc5nV8qb.s 			page 227


 3973              	.LVL290:
 3974              	.LFB5359:
 476:MotorControl/encoder.cpp **** 
 477:MotorControl/encoder.cpp **** //!(1) 读出编码器的值（增量式编码器）
 478:MotorControl/encoder.cpp **** //!(2) 获取某些IO口的电平值，是整个IO口（比如：GPIOA、GPIOB等）全部读出先
 479:MotorControl/encoder.cpp **** void Encoder::sample_now() {
 480:MotorControl/encoder.cpp ****     switch (mode_) {
 481:MotorControl/encoder.cpp ****         case MODE_INCREMENTAL: {//!增量式编码器
 482:MotorControl/encoder.cpp ****             tim_cnt_sample_ = (int16_t)timer_->Instance->CNT;//!读相应定时器的count值
 483:MotorControl/encoder.cpp ****         } break;
 484:MotorControl/encoder.cpp **** 
 485:MotorControl/encoder.cpp ****         case MODE_HALL: {//!霍尔编码器
 486:MotorControl/encoder.cpp ****             // do nothing: samples already captured in general GPIO capture
 487:MotorControl/encoder.cpp ****         } break;
 488:MotorControl/encoder.cpp **** 
 489:MotorControl/encoder.cpp ****         case MODE_SINCOS: {//!sincos编码器核心输出：一个正弦信号（sin），一个余
 490:MotorControl/encoder.cpp ****             sincos_sample_s_ = get_adc_relative_voltage(get_gpio(config_.sincos_gpio_pin_sin)) - 0.
 491:MotorControl/encoder.cpp ****             sincos_sample_c_ = get_adc_relative_voltage(get_gpio(config_.sincos_gpio_pin_cos)) - 0.
 492:MotorControl/encoder.cpp ****         } break;
 493:MotorControl/encoder.cpp **** 
 494:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_AMS:
 495:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_CUI:
 496:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_AEAT:
 497:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_RLS:
 498:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_MA732://!通过spi总线读出对应的位置值 绝对式编码器
 499:MotorControl/encoder.cpp ****         {
 500:MotorControl/encoder.cpp ****             abs_spi_start_transaction();
 501:MotorControl/encoder.cpp ****             // Do nothing
 502:MotorControl/encoder.cpp ****         } break;
 503:MotorControl/encoder.cpp **** 
 504:MotorControl/encoder.cpp ****         default: {
 505:MotorControl/encoder.cpp ****            set_error(ERROR_UNSUPPORTED_ENCODER_MODE);//!设置axis为ERROR_ENCODER_FAILED
 506:MotorControl/encoder.cpp ****         } break;
 507:MotorControl/encoder.cpp ****     }
 508:MotorControl/encoder.cpp **** 
 509:MotorControl/encoder.cpp ****     // Sample all GPIO digital input data registers, used for HALL sensors for example.
 510:MotorControl/encoder.cpp ****     //!static const constexpr GPIO_TypeDef* ports_to_sample[] = { GPIOA, GPIOB, GPIOC };
 511:MotorControl/encoder.cpp ****     for (size_t i = 0; i < sizeof(ports_to_sample) / sizeof(ports_to_sample[0]); ++i) {
 512:MotorControl/encoder.cpp ****         port_samples_[i] = ports_to_sample[i]->IDR; //!读取输入数据寄存器
 513:MotorControl/encoder.cpp ****     }
 514:MotorControl/encoder.cpp **** }
 515:MotorControl/encoder.cpp **** 
 516:MotorControl/encoder.cpp **** bool Encoder::read_sampled_gpio(Stm32Gpio gpio) {
 3975              		.loc 3 516 49 is_stmt 1 view -0
 3976              		.cfi_startproc
 3977              		@ args = 0, pretend = 0, frame = 8
 3978              		@ frame_needed = 0, uses_anonymous_args = 0
 3979              		@ link register save eliminated.
 3980              		.loc 3 516 49 is_stmt 0 view .LVU962
 3981 0000 82B0     		sub	sp, sp, #8
 3982              	.LCFI33:
 3983              		.cfi_def_cfa_offset 8
 3984 0002 02AB     		add	r3, sp, #8
 3985 0004 03E90600 		stmdb	r3, {r1, r2}
 517:MotorControl/encoder.cpp ****     for (size_t i = 0; i < sizeof(ports_to_sample) / sizeof(ports_to_sample[0]); ++i) {
 3986              		.loc 3 517 5 is_stmt 1 view .LVU963
 3987              	.LVL291:
ARM GAS  /tmp/cc5nV8qb.s 			page 228


 3988              	.LBB1747:
 3989              		.loc 3 517 17 is_stmt 0 view .LVU964
 3990 0008 0023     		movs	r3, #0
 3991 000a 00E0     		b	.L204
 3992              	.LVL292:
 3993              	.L203:
 3994              		.loc 3 517 5 is_stmt 1 discriminator 2 view .LVU965
 3995 000c 0133     		adds	r3, r3, #1
 3996              	.LVL293:
 3997              	.L204:
 3998              		.loc 3 517 26 discriminator 1 view .LVU966
 3999 000e 022B     		cmp	r3, #2
 4000 0010 10D8     		bhi	.L205
 518:MotorControl/encoder.cpp ****         if (ports_to_sample[i] == gpio.port_) {
 4001              		.loc 3 518 9 view .LVU967
 4002              		.loc 3 518 30 is_stmt 0 view .LVU968
 4003 0012 0A4A     		ldr	r2, .L207
 4004 0014 52F82310 		ldr	r1, [r2, r3, lsl #2]
 4005              		.loc 3 518 40 view .LVU969
 4006 0018 009A     		ldr	r2, [sp]
 4007              		.loc 3 518 9 view .LVU970
 4008 001a 9142     		cmp	r1, r2
 4009 001c F6D1     		bne	.L203
 519:MotorControl/encoder.cpp ****             return port_samples_[i] & gpio.pin_mask_;
 4010              		.loc 3 519 13 is_stmt 1 view .LVU971
 4011              		.loc 3 519 35 is_stmt 0 view .LVU972
 4012 001e 7433     		adds	r3, r3, #116
 4013              	.LVL294:
 4014              		.loc 3 519 35 view .LVU973
 4015 0020 00EB4300 		add	r0, r0, r3, lsl #1
 4016              	.LVL295:
 4017              		.loc 3 519 35 view .LVU974
 4018 0024 8288     		ldrh	r2, [r0, #4]
 4019              		.loc 3 519 44 view .LVU975
 4020 0026 BDF80430 		ldrh	r3, [sp, #4]
 4021              	.LVL296:
 4022              		.loc 3 519 44 view .LVU976
 4023 002a 1A42     		tst	r2, r3
 4024 002c 14BF     		ite	ne
 4025 002e 0120     		movne	r0, #1
 4026 0030 0020     		moveq	r0, #0
 4027 0032 00E0     		b	.L202
 4028              	.LVL297:
 4029              	.L205:
 4030              		.loc 3 519 44 view .LVU977
 4031              	.LBE1747:
 520:MotorControl/encoder.cpp ****         }
 521:MotorControl/encoder.cpp ****     }
 522:MotorControl/encoder.cpp ****     return false;
 4032              		.loc 3 522 12 view .LVU978
 4033 0034 0020     		movs	r0, #0
 4034              	.LVL298:
 4035              	.L202:
 523:MotorControl/encoder.cpp **** }
 4036              		.loc 3 523 1 view .LVU979
 4037 0036 02B0     		add	sp, sp, #8
 4038              	.LCFI34:
ARM GAS  /tmp/cc5nV8qb.s 			page 229


 4039              		.cfi_def_cfa_offset 0
 4040              		@ sp needed
 4041 0038 7047     		bx	lr
 4042              	.L208:
 4043 003a 00BF     		.align	2
 4044              	.L207:
 4045 003c 00000000 		.word	_ZN7Encoder15ports_to_sampleE
 4046              		.cfi_endproc
 4047              	.LFE5359:
 4048              		.cantunwind
 4049              		.fnend
 4051              		.section	.text._ZN7Encoder19decode_hall_samplesEv,"ax",%progbits
 4052              		.align	1
 4053              		.global	_ZN7Encoder19decode_hall_samplesEv
 4054              		.syntax unified
 4055              		.thumb
 4056              		.thumb_func
 4058              	_ZN7Encoder19decode_hall_samplesEv:
 4059              		.fnstart
 4060              	.LVL299:
 4061              	.LFB5360:
 524:MotorControl/encoder.cpp **** 
 525:MotorControl/encoder.cpp **** void Encoder::decode_hall_samples() {
 4062              		.loc 3 525 37 is_stmt 1 view -0
 4063              		.cfi_startproc
 4064              		@ args = 0, pretend = 0, frame = 0
 4065              		@ frame_needed = 0, uses_anonymous_args = 0
 4066              		.loc 3 525 37 is_stmt 0 view .LVU981
 4067 0000 38B5     		push	{r3, r4, r5, lr}
 4068              	.LCFI35:
 4069              		.cfi_def_cfa_offset 16
 4070              		.cfi_offset 3, -16
 4071              		.cfi_offset 4, -12
 4072              		.cfi_offset 5, -8
 4073              		.cfi_offset 14, -4
 4074 0002 0446     		mov	r4, r0
 526:MotorControl/encoder.cpp ****     hall_state_ = (read_sampled_gpio(hallA_gpio_) ? 1 : 0)
 4075              		.loc 3 526 5 is_stmt 1 view .LVU982
 4076              		.loc 3 526 37 is_stmt 0 view .LVU983
 4077 0004 00F11403 		add	r3, r0, #20
 4078 0008 93E80600 		ldm	r3, {r1, r2}
 4079 000c FFF7FEFF 		bl	_ZN7Encoder17read_sampled_gpioE9Stm32Gpio
 4080              	.LVL300:
 527:MotorControl/encoder.cpp ****                 | (read_sampled_gpio(hallB_gpio_) ? 2 : 0)
 4081              		.loc 3 527 17 view .LVU984
 4082 0010 B8B1     		cbz	r0, .L213
 4083 0012 0125     		movs	r5, #1
 4084              	.L210:
 4085              		.loc 3 527 37 discriminator 4 view .LVU985
 4086 0014 04F11C03 		add	r3, r4, #28
 4087 0018 93E80600 		ldm	r3, {r1, r2}
 4088 001c 2046     		mov	r0, r4
 4089 001e FFF7FEFF 		bl	_ZN7Encoder17read_sampled_gpioE9Stm32Gpio
 4090              	.LVL301:
 4091              		.loc 3 527 17 discriminator 4 view .LVU986
 4092 0022 80B1     		cbz	r0, .L214
 4093              		.loc 3 527 17 view .LVU987
ARM GAS  /tmp/cc5nV8qb.s 			page 230


 4094 0024 0223     		movs	r3, #2
 4095              	.L211:
 4096              		.loc 3 527 17 discriminator 8 view .LVU988
 4097 0026 1D43     		orrs	r5, r5, r3
 528:MotorControl/encoder.cpp ****                 | (read_sampled_gpio(hallC_gpio_) ? 4 : 0);
 4098              		.loc 3 528 37 discriminator 8 view .LVU989
 4099 0028 04F12403 		add	r3, r4, #36
 4100 002c 93E80600 		ldm	r3, {r1, r2}
 4101 0030 2046     		mov	r0, r4
 4102 0032 FFF7FEFF 		bl	_ZN7Encoder17read_sampled_gpioE9Stm32Gpio
 4103              	.LVL302:
 4104              		.loc 3 528 17 discriminator 8 view .LVU990
 4105 0036 40B1     		cbz	r0, .L215
 4106              		.loc 3 528 17 view .LVU991
 4107 0038 0423     		movs	r3, #4
 4108              	.L212:
 4109              		.loc 3 528 17 discriminator 4 view .LVU992
 4110 003a 1D43     		orrs	r5, r5, r3
 526:MotorControl/encoder.cpp ****     hall_state_ = (read_sampled_gpio(hallA_gpio_) ? 1 : 0)
 4111              		.loc 3 526 17 discriminator 4 view .LVU993
 4112 003c 84F8F250 		strb	r5, [r4, #242]
 529:MotorControl/encoder.cpp **** }
 4113              		.loc 3 529 1 discriminator 4 view .LVU994
 4114 0040 38BD     		pop	{r3, r4, r5, pc}
 4115              	.LVL303:
 4116              	.L213:
 527:MotorControl/encoder.cpp ****                 | (read_sampled_gpio(hallB_gpio_) ? 2 : 0)
 4117              		.loc 3 527 17 view .LVU995
 4118 0042 0025     		movs	r5, #0
 4119 0044 E6E7     		b	.L210
 4120              	.L214:
 527:MotorControl/encoder.cpp ****                 | (read_sampled_gpio(hallB_gpio_) ? 2 : 0)
 4121              		.loc 3 527 17 view .LVU996
 4122 0046 0023     		movs	r3, #0
 4123 0048 EDE7     		b	.L211
 4124              	.L215:
 528:MotorControl/encoder.cpp ****                 | (read_sampled_gpio(hallC_gpio_) ? 4 : 0);
 4125              		.loc 3 528 17 view .LVU997
 4126 004a 0023     		movs	r3, #0
 4127 004c F5E7     		b	.L212
 4128              		.cfi_endproc
 4129              	.LFE5360:
 4130              		.cantunwind
 4131              		.fnend
 4133              		.section	.text._ZN7Encoder25abs_spi_start_transactionEv,"ax",%progbits
 4134              		.align	1
 4135              		.global	_ZN7Encoder25abs_spi_start_transactionEv
 4136              		.syntax unified
 4137              		.thumb
 4138              		.thumb_func
 4140              	_ZN7Encoder25abs_spi_start_transactionEv:
 4141              		.fnstart
 4142              	.LVL304:
 4143              	.LFB5361:
 530:MotorControl/encoder.cpp **** 
 531:MotorControl/encoder.cpp **** bool Encoder::abs_spi_start_transaction() {
 4144              		.loc 3 531 43 is_stmt 1 view -0
ARM GAS  /tmp/cc5nV8qb.s 			page 231


 4145              		.cfi_startproc
 4146              		@ args = 0, pretend = 0, frame = 0
 4147              		@ frame_needed = 0, uses_anonymous_args = 0
 4148              		.loc 3 531 43 is_stmt 0 view .LVU999
 4149 0000 70B5     		push	{r4, r5, r6, lr}
 4150              		.save {r4, r5, r6, lr}
 4151              	.LCFI36:
 4152              		.cfi_def_cfa_offset 16
 4153              		.cfi_offset 4, -16
 4154              		.cfi_offset 5, -12
 4155              		.cfi_offset 6, -8
 4156              		.cfi_offset 14, -4
 532:MotorControl/encoder.cpp ****     if (mode_ & MODE_FLAG_ABS){//!啥也不干
 4157              		.loc 3 532 5 is_stmt 1 view .LVU1000
 4158              	.LBB1748:
 4159              		.loc 3 532 9 is_stmt 0 view .LVU1001
 4160 0002 B0F83A31 		ldrh	r3, [r0, #314]
 4161              		.loc 3 532 5 view .LVU1002
 4162 0006 13F4807F 		tst	r3, #256
 4163 000a 02D1     		bne	.L221
 4164              	.LBE1748:
 533:MotorControl/encoder.cpp ****         if (Stm32SpiArbiter::acquire_task(&spi_task_)) {
 534:MotorControl/encoder.cpp ****             spi_task_.ncs_gpio = abs_spi_cs_gpio_;
 535:MotorControl/encoder.cpp ****             spi_task_.tx_buf = (uint8_t*)abs_spi_dma_tx_;
 536:MotorControl/encoder.cpp ****             spi_task_.rx_buf = (uint8_t*)abs_spi_dma_rx_;
 537:MotorControl/encoder.cpp ****             spi_task_.length = 1;
 538:MotorControl/encoder.cpp ****             spi_task_.on_complete = [](void* ctx, bool success) { ((Encoder*)ctx)->abs_spi_cb(succe
 539:MotorControl/encoder.cpp ****             spi_task_.on_complete_ctx = this;
 540:MotorControl/encoder.cpp ****             spi_task_.next = nullptr;
 541:MotorControl/encoder.cpp ****             
 542:MotorControl/encoder.cpp ****             spi_arbiter_->transfer_async(&spi_task_);
 543:MotorControl/encoder.cpp ****         } else {
 544:MotorControl/encoder.cpp ****             return false;
 545:MotorControl/encoder.cpp ****         }
 546:MotorControl/encoder.cpp ****     }
 547:MotorControl/encoder.cpp ****     return true;
 4165              		.loc 3 547 12 view .LVU1003
 4166 000c 0125     		movs	r5, #1
 4167              	.LVL305:
 4168              	.L218:
 548:MotorControl/encoder.cpp **** }
 4169              		.loc 3 548 1 view .LVU1004
 4170 000e 2846     		mov	r0, r5
 4171 0010 70BD     		pop	{r4, r5, r6, pc}
 4172              	.LVL306:
 4173              	.L221:
 4174              		.loc 3 548 1 view .LVU1005
 4175 0012 0446     		mov	r4, r0
 533:MotorControl/encoder.cpp ****         if (Stm32SpiArbiter::acquire_task(&spi_task_)) {
 4176              		.loc 3 533 9 is_stmt 1 view .LVU1006
 4177              	.LBB1751:
 4178              	.LBB1749:
 533:MotorControl/encoder.cpp ****         if (Stm32SpiArbiter::acquire_task(&spi_task_)) {
 4179              		.loc 3 533 42 is_stmt 0 view .LVU1007
 4180 0014 00F5A876 		add	r6, r0, #336
 4181 0018 3046     		mov	r0, r6
 4182              	.LVL307:
ARM GAS  /tmp/cc5nV8qb.s 			page 232


 533:MotorControl/encoder.cpp ****         if (Stm32SpiArbiter::acquire_task(&spi_task_)) {
 4183              		.loc 3 533 42 view .LVU1008
 4184 001a FFF7FEFF 		bl	_ZN15Stm32SpiArbiter12acquire_taskEPNS_7SpiTaskE
 4185              	.LVL308:
 533:MotorControl/encoder.cpp ****         if (Stm32SpiArbiter::acquire_task(&spi_task_)) {
 4186              		.loc 3 533 9 view .LVU1009
 4187 001e 0546     		mov	r5, r0
 4188 0020 0028     		cmp	r0, #0
 4189 0022 F4D0     		beq	.L218
 4190              	.LBB1750:
 534:MotorControl/encoder.cpp ****             spi_task_.tx_buf = (uint8_t*)abs_spi_dma_tx_;
 4191              		.loc 3 534 13 is_stmt 1 view .LVU1010
 534:MotorControl/encoder.cpp ****             spi_task_.tx_buf = (uint8_t*)abs_spi_dma_tx_;
 4192              		.loc 3 534 32 is_stmt 0 view .LVU1011
 4193 0024 D4F83C31 		ldr	r3, [r4, #316]	@ unaligned
 4194 0028 C4F87C31 		str	r3, [r4, #380]	@ unaligned
 4195 002c B4F84031 		ldrh	r3, [r4, #320]	@ unaligned
 4196 0030 A4F88031 		strh	r3, [r4, #384]	@ unaligned
 535:MotorControl/encoder.cpp ****             spi_task_.rx_buf = (uint8_t*)abs_spi_dma_rx_;
 4197              		.loc 3 535 13 is_stmt 1 view .LVU1012
 535:MotorControl/encoder.cpp ****             spi_task_.rx_buf = (uint8_t*)abs_spi_dma_rx_;
 4198              		.loc 3 535 42 is_stmt 0 view .LVU1013
 4199 0034 04F5A673 		add	r3, r4, #332
 535:MotorControl/encoder.cpp ****             spi_task_.rx_buf = (uint8_t*)abs_spi_dma_rx_;
 4200              		.loc 3 535 30 view .LVU1014
 4201 0038 C4F88431 		str	r3, [r4, #388]
 536:MotorControl/encoder.cpp ****             spi_task_.length = 1;
 4202              		.loc 3 536 13 is_stmt 1 view .LVU1015
 536:MotorControl/encoder.cpp ****             spi_task_.length = 1;
 4203              		.loc 3 536 42 is_stmt 0 view .LVU1016
 4204 003c 04F5A773 		add	r3, r4, #334
 536:MotorControl/encoder.cpp ****             spi_task_.length = 1;
 4205              		.loc 3 536 30 view .LVU1017
 4206 0040 C4F88831 		str	r3, [r4, #392]
 537:MotorControl/encoder.cpp ****             spi_task_.on_complete = [](void* ctx, bool success) { ((Encoder*)ctx)->abs_spi_cb(succe
 4207              		.loc 3 537 13 is_stmt 1 view .LVU1018
 537:MotorControl/encoder.cpp ****             spi_task_.on_complete = [](void* ctx, bool success) { ((Encoder*)ctx)->abs_spi_cb(succe
 4208              		.loc 3 537 30 is_stmt 0 view .LVU1019
 4209 0044 0123     		movs	r3, #1
 4210 0046 C4F88C31 		str	r3, [r4, #396]
 538:MotorControl/encoder.cpp ****             spi_task_.on_complete_ctx = this;
 4211              		.loc 3 538 13 is_stmt 1 view .LVU1020
 538:MotorControl/encoder.cpp ****             spi_task_.on_complete_ctx = this;
 4212              		.loc 3 538 35 is_stmt 0 view .LVU1021
 4213 004a 064B     		ldr	r3, .L222
 4214 004c C4F89031 		str	r3, [r4, #400]
 539:MotorControl/encoder.cpp ****             spi_task_.next = nullptr;
 4215              		.loc 3 539 13 is_stmt 1 view .LVU1022
 539:MotorControl/encoder.cpp ****             spi_task_.next = nullptr;
 4216              		.loc 3 539 39 is_stmt 0 view .LVU1023
 4217 0050 C4F89441 		str	r4, [r4, #404]
 540:MotorControl/encoder.cpp ****             
 4218              		.loc 3 540 13 is_stmt 1 view .LVU1024
 540:MotorControl/encoder.cpp ****             
 4219              		.loc 3 540 28 is_stmt 0 view .LVU1025
 4220 0054 0023     		movs	r3, #0
 4221 0056 C4F89C31 		str	r3, [r4, #412]
ARM GAS  /tmp/cc5nV8qb.s 			page 233


 542:MotorControl/encoder.cpp ****         } else {
 4222              		.loc 3 542 13 is_stmt 1 view .LVU1026
 542:MotorControl/encoder.cpp ****         } else {
 4223              		.loc 3 542 41 is_stmt 0 view .LVU1027
 4224 005a 3146     		mov	r1, r6
 4225 005c E06A     		ldr	r0, [r4, #44]
 4226 005e FFF7FEFF 		bl	_ZN15Stm32SpiArbiter14transfer_asyncEPNS_7SpiTaskE
 4227              	.LVL309:
 4228              	.LBE1750:
 4229              	.LBE1749:
 4230 0062 D4E7     		b	.L218
 4231              	.L223:
 4232              		.align	2
 4233              	.L222:
 4234 0064 00000000 		.word	_ZZN7Encoder25abs_spi_start_transactionEvENUlPvbE_4_FUNES0_b
 4235              	.LBE1751:
 4236              		.cfi_endproc
 4237              	.LFE5361:
 4238              		.fnend
 4240              		.section	.text._ZN7Encoder10sample_nowEv,"ax",%progbits
 4241              		.align	1
 4242              		.global	_ZN7Encoder10sample_nowEv
 4243              		.syntax unified
 4244              		.thumb
 4245              		.thumb_func
 4247              	_ZN7Encoder10sample_nowEv:
 4248              		.fnstart
 4249              	.LVL310:
 4250              	.LFB5358:
 479:MotorControl/encoder.cpp ****     switch (mode_) {
 4251              		.loc 3 479 28 is_stmt 1 view -0
 4252              		.cfi_startproc
 4253              		@ args = 0, pretend = 0, frame = 16
 4254              		@ frame_needed = 0, uses_anonymous_args = 0
 479:MotorControl/encoder.cpp ****     switch (mode_) {
 4255              		.loc 3 479 28 is_stmt 0 view .LVU1029
 4256 0000 30B5     		push	{r4, r5, lr}
 4257              		.save {r4, r5, lr}
 4258              	.LCFI37:
 4259              		.cfi_def_cfa_offset 12
 4260              		.cfi_offset 4, -12
 4261              		.cfi_offset 5, -8
 4262              		.cfi_offset 14, -4
 4263 0002 2DED028B 		vpush.64	{d8}
 4264              		.vsave {d8}
 4265              	.LCFI38:
 4266              		.cfi_def_cfa_offset 20
 4267              		.cfi_offset 80, -20
 4268              		.cfi_offset 81, -16
 4269              		.pad #20
 4270 0006 85B0     		sub	sp, sp, #20
 4271              	.LCFI39:
 4272              		.cfi_def_cfa_offset 40
 4273 0008 0446     		mov	r4, r0
 480:MotorControl/encoder.cpp ****         case MODE_INCREMENTAL: {//!增量式编码器
 4274              		.loc 3 480 5 is_stmt 1 view .LVU1030
 480:MotorControl/encoder.cpp ****         case MODE_INCREMENTAL: {//!增量式编码器
ARM GAS  /tmp/cc5nV8qb.s 			page 234


 4275              		.loc 3 480 13 is_stmt 0 view .LVU1031
 4276 000a B0F83A31 		ldrh	r3, [r0, #314]
 480:MotorControl/encoder.cpp ****         case MODE_INCREMENTAL: {//!增量式编码器
 4277              		.loc 3 480 5 view .LVU1032
 4278 000e 022B     		cmp	r3, #2
 4279 0010 13D0     		beq	.L225
 4280 0012 04D8     		bhi	.L226
 4281 0014 5BB1     		cbz	r3, .L227
 4282 0016 012B     		cmp	r3, #1
 4283 0018 2ED1     		bne	.L229
 4284              	.LVL311:
 4285              	.L228:
 479:MotorControl/encoder.cpp ****     switch (mode_) {
 4286              		.loc 3 479 28 discriminator 3 view .LVU1033
 4287 001a 0023     		movs	r3, #0
 4288 001c 3BE0     		b	.L232
 4289              	.LVL312:
 4290              	.L226:
 480:MotorControl/encoder.cpp ****         case MODE_INCREMENTAL: {//!增量式编码器
 4291              		.loc 3 480 5 view .LVU1034
 4292 001e A3F58073 		sub	r3, r3, #256
 4293 0022 9BB2     		uxth	r3, r3
 4294 0024 042B     		cmp	r3, #4
 4295 0026 27D8     		bhi	.L229
 494:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_CUI:
 4296              		.loc 3 494 9 is_stmt 1 view .LVU1035
 495:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_AEAT:
 4297              		.loc 3 495 9 view .LVU1036
 496:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_RLS:
 4298              		.loc 3 496 9 view .LVU1037
 497:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_MA732://!通过spi总线读出对应的位置值 绝对式编码器
 4299              		.loc 3 497 9 view .LVU1038
 498:MotorControl/encoder.cpp ****         {
 4300              		.loc 3 498 9 view .LVU1039
 499:MotorControl/encoder.cpp ****             abs_spi_start_transaction();
 4301              		.loc 3 499 9 view .LVU1040
 500:MotorControl/encoder.cpp ****             // Do nothing
 4302              		.loc 3 500 13 view .LVU1041
 500:MotorControl/encoder.cpp ****             // Do nothing
 4303              		.loc 3 500 38 is_stmt 0 view .LVU1042
 4304 0028 FFF7FEFF 		bl	_ZN7Encoder25abs_spi_start_transactionEv
 4305              	.LVL313:
 502:MotorControl/encoder.cpp **** 
 4306              		.loc 3 502 11 is_stmt 1 view .LVU1043
 4307 002c F5E7     		b	.L228
 4308              	.LVL314:
 4309              	.L227:
 481:MotorControl/encoder.cpp ****             tim_cnt_sample_ = (int16_t)timer_->Instance->CNT;//!读相应定时器的count值
 4310              		.loc 3 481 9 view .LVU1044
 481:MotorControl/encoder.cpp ****             tim_cnt_sample_ = (int16_t)timer_->Instance->CNT;//!读相应定时器的count值
 4311              		.loc 3 481 32 view .LVU1045
 482:MotorControl/encoder.cpp ****         } break;
 4312              		.loc 3 482 13 view .LVU1046
 482:MotorControl/encoder.cpp ****         } break;
 4313              		.loc 3 482 40 is_stmt 0 view .LVU1047
 4314 002e 8368     		ldr	r3, [r0, #8]
 482:MotorControl/encoder.cpp ****         } break;
ARM GAS  /tmp/cc5nV8qb.s 			page 235


 4315              		.loc 3 482 48 view .LVU1048
 4316 0030 1B68     		ldr	r3, [r3]
 482:MotorControl/encoder.cpp ****         } break;
 4317              		.loc 3 482 58 view .LVU1049
 4318 0032 5B6A     		ldr	r3, [r3, #36]
 482:MotorControl/encoder.cpp ****         } break;
 4319              		.loc 3 482 29 view .LVU1050
 4320 0034 A0F8EA30 		strh	r3, [r0, #234]	@ movhi
 483:MotorControl/encoder.cpp **** 
 4321              		.loc 3 483 11 is_stmt 1 view .LVU1051
 4322 0038 EFE7     		b	.L228
 4323              	.L225:
 489:MotorControl/encoder.cpp ****             sincos_sample_s_ = get_adc_relative_voltage(get_gpio(config_.sincos_gpio_pin_sin)) - 0.
 4324              		.loc 3 489 9 view .LVU1052
 489:MotorControl/encoder.cpp ****             sincos_sample_s_ = get_adc_relative_voltage(get_gpio(config_.sincos_gpio_pin_sin)) - 0.
 4325              		.loc 3 489 27 view .LVU1053
 490:MotorControl/encoder.cpp ****             sincos_sample_c_ = get_adc_relative_voltage(get_gpio(config_.sincos_gpio_pin_cos)) - 0.
 4326              		.loc 3 490 13 view .LVU1054
 490:MotorControl/encoder.cpp ****             sincos_sample_c_ = get_adc_relative_voltage(get_gpio(config_.sincos_gpio_pin_cos)) - 0.
 4327              		.loc 3 490 56 is_stmt 0 view .LVU1055
 4328 003a 6D46     		mov	r5, sp
 4329 003c B0F88210 		ldrh	r1, [r0, #130]
 4330 0040 2846     		mov	r0, r5
 4331              	.LVL315:
 490:MotorControl/encoder.cpp ****             sincos_sample_c_ = get_adc_relative_voltage(get_gpio(config_.sincos_gpio_pin_cos)) - 0.
 4332              		.loc 3 490 56 view .LVU1056
 4333 0042 FFF7FEFF 		bl	_ZL8get_gpioj
 4334              	.LVL316:
 4335 0046 95E80300 		ldm	r5, {r0, r1}
 4336 004a FFF7FEFF 		bl	get_adc_relative_voltage
 4337              	.LVL317:
 490:MotorControl/encoder.cpp ****             sincos_sample_c_ = get_adc_relative_voltage(get_gpio(config_.sincos_gpio_pin_cos)) - 0.
 4338              		.loc 3 490 96 view .LVU1057
 4339 004e B6EE008A 		vmov.f32	s16, #5.0e-1
 4340 0052 30EE480A 		vsub.f32	s0, s0, s16
 490:MotorControl/encoder.cpp ****             sincos_sample_c_ = get_adc_relative_voltage(get_gpio(config_.sincos_gpio_pin_cos)) - 0.
 4341              		.loc 3 490 30 view .LVU1058
 4342 0056 84ED4C0A 		vstr.32	s0, [r4, #304]
 491:MotorControl/encoder.cpp ****         } break;
 4343              		.loc 3 491 13 is_stmt 1 view .LVU1059
 491:MotorControl/encoder.cpp ****         } break;
 4344              		.loc 3 491 56 is_stmt 0 view .LVU1060
 4345 005a 02AD     		add	r5, sp, #8
 4346 005c B4F88410 		ldrh	r1, [r4, #132]
 4347 0060 2846     		mov	r0, r5
 4348 0062 FFF7FEFF 		bl	_ZL8get_gpioj
 4349              	.LVL318:
 4350 0066 95E80300 		ldm	r5, {r0, r1}
 4351 006a FFF7FEFF 		bl	get_adc_relative_voltage
 4352              	.LVL319:
 491:MotorControl/encoder.cpp ****         } break;
 4353              		.loc 3 491 96 view .LVU1061
 4354 006e 30EE480A 		vsub.f32	s0, s0, s16
 491:MotorControl/encoder.cpp ****         } break;
 4355              		.loc 3 491 30 view .LVU1062
 4356 0072 84ED4D0A 		vstr.32	s0, [r4, #308]
 492:MotorControl/encoder.cpp **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 236


 4357              		.loc 3 492 11 is_stmt 1 view .LVU1063
 4358 0076 D0E7     		b	.L228
 4359              	.LVL320:
 4360              	.L229:
 504:MotorControl/encoder.cpp ****            set_error(ERROR_UNSUPPORTED_ENCODER_MODE);//!设置axis为ERROR_ENCODER_FAILED
 4361              		.loc 3 504 9 view .LVU1064
 504:MotorControl/encoder.cpp ****            set_error(ERROR_UNSUPPORTED_ENCODER_MODE);//!设置axis为ERROR_ENCODER_FAILED
 4362              		.loc 3 504 18 view .LVU1065
 505:MotorControl/encoder.cpp ****         } break;
 4363              		.loc 3 505 12 view .LVU1066
 505:MotorControl/encoder.cpp ****         } break;
 4364              		.loc 3 505 21 is_stmt 0 view .LVU1067
 4365 0078 0821     		movs	r1, #8
 4366 007a 2046     		mov	r0, r4
 4367              	.LVL321:
 505:MotorControl/encoder.cpp ****         } break;
 4368              		.loc 3 505 21 view .LVU1068
 4369 007c FFF7FEFF 		bl	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
 4370              	.LVL322:
 506:MotorControl/encoder.cpp ****     }
 4371              		.loc 3 506 11 is_stmt 1 view .LVU1069
 4372 0080 CBE7     		b	.L228
 4373              	.LVL323:
 4374              	.L235:
 4375              	.LBB1752:
 512:MotorControl/encoder.cpp ****     }
 4376              		.loc 3 512 9 discriminator 2 view .LVU1070
 512:MotorControl/encoder.cpp ****     }
 4377              		.loc 3 512 45 is_stmt 0 discriminator 2 view .LVU1071
 4378 0082 084A     		ldr	r2, .L236
 4379 0084 52F82320 		ldr	r2, [r2, r3, lsl #2]
 512:MotorControl/encoder.cpp ****     }
 4380              		.loc 3 512 48 discriminator 2 view .LVU1072
 4381 0088 1169     		ldr	r1, [r2, #16]
 512:MotorControl/encoder.cpp ****     }
 4382              		.loc 3 512 26 discriminator 2 view .LVU1073
 4383 008a 03F17402 		add	r2, r3, #116
 4384 008e 04EB4202 		add	r2, r4, r2, lsl #1
 4385 0092 9180     		strh	r1, [r2, #4]	@ movhi
 511:MotorControl/encoder.cpp ****         port_samples_[i] = ports_to_sample[i]->IDR; //!读取输入数据寄存器
 4386              		.loc 3 511 5 is_stmt 1 discriminator 2 view .LVU1074
 4387 0094 0133     		adds	r3, r3, #1
 4388              	.LVL324:
 4389              	.L232:
 511:MotorControl/encoder.cpp ****         port_samples_[i] = ports_to_sample[i]->IDR; //!读取输入数据寄存器
 4390              		.loc 3 511 26 discriminator 3 view .LVU1075
 4391 0096 022B     		cmp	r3, #2
 4392 0098 F3D9     		bls	.L235
 4393              	.LBE1752:
 514:MotorControl/encoder.cpp **** 
 4394              		.loc 3 514 1 is_stmt 0 view .LVU1076
 4395 009a 05B0     		add	sp, sp, #20
 4396              	.LCFI40:
 4397              		.cfi_def_cfa_offset 20
 4398              		@ sp needed
 4399 009c BDEC028B 		vldm	sp!, {d8}
 4400              	.LCFI41:
ARM GAS  /tmp/cc5nV8qb.s 			page 237


 4401              		.cfi_restore 80
 4402              		.cfi_restore 81
 4403              		.cfi_def_cfa_offset 12
 4404 00a0 30BD     		pop	{r4, r5, pc}
 4405              	.LVL325:
 4406              	.L237:
 514:MotorControl/encoder.cpp **** 
 4407              		.loc 3 514 1 view .LVU1077
 4408 00a2 00BF     		.align	2
 4409              	.L236:
 4410 00a4 00000000 		.word	_ZN7Encoder15ports_to_sampleE
 4411              		.cfi_endproc
 4412              	.LFE5358:
 4413              		.fnend
 4415              		.section	.text._Z10ams_parityt,"ax",%progbits
 4416              		.align	1
 4417              		.global	_Z10ams_parityt
 4418              		.syntax unified
 4419              		.thumb
 4420              		.thumb_func
 4422              	_Z10ams_parityt:
 4423              		.fnstart
 4424              	.LVL326:
 4425              	.LFB5365:
 549:MotorControl/encoder.cpp **** 
 550:MotorControl/encoder.cpp **** uint8_t ams_parity(uint16_t v) {
 4426              		.loc 3 550 32 is_stmt 1 view -0
 4427              		.cfi_startproc
 4428              		@ args = 0, pretend = 0, frame = 0
 4429              		@ frame_needed = 0, uses_anonymous_args = 0
 4430              		@ link register save eliminated.
 551:MotorControl/encoder.cpp ****     v ^= v >> 8;
 4431              		.loc 3 551 5 view .LVU1079
 4432              		.loc 3 551 7 is_stmt 0 view .LVU1080
 4433 0000 80EA1020 		eor	r0, r0, r0, lsr #8
 4434              	.LVL327:
 552:MotorControl/encoder.cpp ****     v ^= v >> 4;
 4435              		.loc 3 552 5 is_stmt 1 view .LVU1081
 4436              		.loc 3 552 7 is_stmt 0 view .LVU1082
 4437 0004 80EA1010 		eor	r0, r0, r0, lsr #4
 4438              	.LVL328:
 553:MotorControl/encoder.cpp ****     v ^= v >> 2;
 4439              		.loc 3 553 5 is_stmt 1 view .LVU1083
 4440              		.loc 3 553 7 is_stmt 0 view .LVU1084
 4441 0008 80EA9000 		eor	r0, r0, r0, lsr #2
 4442              	.LVL329:
 554:MotorControl/encoder.cpp ****     v ^= v >> 1;
 4443              		.loc 3 554 5 is_stmt 1 view .LVU1085
 4444              		.loc 3 554 7 is_stmt 0 view .LVU1086
 4445 000c 80EA5000 		eor	r0, r0, r0, lsr #1
 4446              	.LVL330:
 555:MotorControl/encoder.cpp ****     return v & 1;
 4447              		.loc 3 555 5 is_stmt 1 view .LVU1087
 556:MotorControl/encoder.cpp **** }
 4448              		.loc 3 556 1 is_stmt 0 view .LVU1088
 4449 0010 00F00100 		and	r0, r0, #1
 4450              	.LVL331:
ARM GAS  /tmp/cc5nV8qb.s 			page 238


 4451              		.loc 3 556 1 view .LVU1089
 4452 0014 7047     		bx	lr
 4453              		.cfi_endproc
 4454              	.LFE5365:
 4455              		.cantunwind
 4456              		.fnend
 4458              		.section	.text._Z10cui_parityt,"ax",%progbits
 4459              		.align	1
 4460              		.global	_Z10cui_parityt
 4461              		.syntax unified
 4462              		.thumb
 4463              		.thumb_func
 4465              	_Z10cui_parityt:
 4466              		.fnstart
 4467              	.LVL332:
 4468              	.LFB5366:
 557:MotorControl/encoder.cpp **** 
 558:MotorControl/encoder.cpp **** uint8_t cui_parity(uint16_t v) {
 4469              		.loc 3 558 32 is_stmt 1 view -0
 4470              		.cfi_startproc
 4471              		@ args = 0, pretend = 0, frame = 0
 4472              		@ frame_needed = 0, uses_anonymous_args = 0
 4473              		@ link register save eliminated.
 559:MotorControl/encoder.cpp ****     v ^= v >> 8;
 4474              		.loc 3 559 5 view .LVU1091
 4475              		.loc 3 559 7 is_stmt 0 view .LVU1092
 4476 0000 80EA1020 		eor	r0, r0, r0, lsr #8
 4477              	.LVL333:
 560:MotorControl/encoder.cpp ****     v ^= v >> 4;
 4478              		.loc 3 560 5 is_stmt 1 view .LVU1093
 4479              		.loc 3 560 7 is_stmt 0 view .LVU1094
 4480 0004 80EA1010 		eor	r0, r0, r0, lsr #4
 4481              	.LVL334:
 561:MotorControl/encoder.cpp ****     v ^= v >> 2;
 4482              		.loc 3 561 5 is_stmt 1 view .LVU1095
 4483              		.loc 3 561 7 is_stmt 0 view .LVU1096
 4484 0008 80EA9000 		eor	r0, r0, r0, lsr #2
 4485              	.LVL335:
 562:MotorControl/encoder.cpp ****     return ~v & 3;
 4486              		.loc 3 562 5 is_stmt 1 view .LVU1097
 4487              		.loc 3 562 15 is_stmt 0 view .LVU1098
 4488 000c C043     		mvns	r0, r0
 4489              	.LVL336:
 563:MotorControl/encoder.cpp **** }
 4490              		.loc 3 563 1 view .LVU1099
 4491 000e 00F00300 		and	r0, r0, #3
 4492              	.LVL337:
 4493              		.loc 3 563 1 view .LVU1100
 4494 0012 7047     		bx	lr
 4495              		.cfi_endproc
 4496              	.LFE5366:
 4497              		.cantunwind
 4498              		.fnend
 4500              		.section	.text._ZN7Encoder10abs_spi_cbEb,"ax",%progbits
 4501              		.align	1
 4502              		.global	_ZN7Encoder10abs_spi_cbEb
 4503              		.syntax unified
ARM GAS  /tmp/cc5nV8qb.s 			page 239


 4504              		.thumb
 4505              		.thumb_func
 4507              	_ZN7Encoder10abs_spi_cbEb:
 4508              		.fnstart
 4509              	.LVL338:
 4510              	.LFB5367:
 564:MotorControl/encoder.cpp **** 
 565:MotorControl/encoder.cpp **** void Encoder::abs_spi_cb(bool success) {
 4511              		.loc 3 565 40 is_stmt 1 view -0
 4512              		.cfi_startproc
 4513              		@ args = 0, pretend = 0, frame = 0
 4514              		@ frame_needed = 0, uses_anonymous_args = 0
 4515              		.loc 3 565 40 is_stmt 0 view .LVU1102
 4516 0000 38B5     		push	{r3, r4, r5, lr}
 4517              		.save {r3, r4, r5, lr}
 4518              	.LCFI42:
 4519              		.cfi_def_cfa_offset 16
 4520              		.cfi_offset 3, -16
 4521              		.cfi_offset 4, -12
 4522              		.cfi_offset 5, -8
 4523              		.cfi_offset 14, -4
 4524 0002 0446     		mov	r4, r0
 566:MotorControl/encoder.cpp ****     uint16_t pos;
 4525              		.loc 3 566 5 is_stmt 1 view .LVU1103
 567:MotorControl/encoder.cpp **** 
 568:MotorControl/encoder.cpp ****     if (!success) {
 4526              		.loc 3 568 5 view .LVU1104
 4527 0004 69B3     		cbz	r1, .L241
 569:MotorControl/encoder.cpp ****         goto done;
 570:MotorControl/encoder.cpp ****     }
 571:MotorControl/encoder.cpp **** 
 572:MotorControl/encoder.cpp ****     switch (mode_) {
 4528              		.loc 3 572 5 view .LVU1105
 4529              	.LBB1753:
 4530              		.loc 3 572 13 is_stmt 0 view .LVU1106
 4531 0006 B0F83A31 		ldrh	r3, [r0, #314]
 4532              		.loc 3 572 5 view .LVU1107
 4533 000a A3F58073 		sub	r3, r3, #256
 4534 000e 042B     		cmp	r3, #4
 4535 0010 30D8     		bhi	.L242
 4536 0012 DFE803F0 		tbb	[pc, r3]
 4537              	.L244:
 4538 0016 0F       		.byte	(.L247-.L244)/2
 4539 0017 03       		.byte	(.L246-.L244)/2
 4540 0018 2F       		.byte	(.L242-.L244)/2
 4541 0019 18       		.byte	(.L245-.L244)/2
 4542 001a 2B       		.byte	(.L243-.L244)/2
 4543 001b 00       		.p2align 1
 4544              	.L246:
 4545              	.LBB1754:
 573:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_AMS: {
 4546              		.loc 3 573 9 is_stmt 1 view .LVU1108
 4547              		.loc 3 573 32 view .LVU1109
 4548              	.LBB1755:
 574:MotorControl/encoder.cpp ****             uint16_t rawVal = abs_spi_dma_rx_[0];
 4549              		.loc 3 574 13 view .LVU1110
 4550              		.loc 3 574 22 is_stmt 0 view .LVU1111
ARM GAS  /tmp/cc5nV8qb.s 			page 240


 4551 001c B0F84E51 		ldrh	r5, [r0, #334]
 4552              	.LVL339:
 575:MotorControl/encoder.cpp ****             // check if parity is correct (even) and error flag clear
 576:MotorControl/encoder.cpp ****             if (ams_parity(rawVal) || ((rawVal >> 14) & 1)) {
 4553              		.loc 3 576 13 is_stmt 1 view .LVU1112
 4554              		.loc 3 576 27 is_stmt 0 view .LVU1113
 4555 0020 2846     		mov	r0, r5
 4556              	.LVL340:
 4557              		.loc 3 576 27 view .LVU1114
 4558 0022 FFF7FEFF 		bl	_Z10ams_parityt
 4559              	.LVL341:
 4560              		.loc 3 576 36 view .LVU1115
 4561 0026 E0B9     		cbnz	r0, .L241
 4562              		.loc 3 576 36 discriminator 2 view .LVU1116
 4563 0028 15F4804F 		tst	r5, #16384
 4564 002c 19D1     		bne	.L241
 577:MotorControl/encoder.cpp ****                 goto done;
 578:MotorControl/encoder.cpp ****             }
 579:MotorControl/encoder.cpp ****             pos = rawVal & 0x3fff;
 4565              		.loc 3 579 13 is_stmt 1 view .LVU1117
 4566              		.loc 3 579 17 is_stmt 0 view .LVU1118
 4567 002e C5F30D00 		ubfx	r0, r5, #0, #14
 4568              	.LVL342:
 4569              		.loc 3 579 17 view .LVU1119
 4570              	.LBE1755:
 580:MotorControl/encoder.cpp ****         } break;
 4571              		.loc 3 580 11 is_stmt 1 view .LVU1120
 4572 0032 0BE0     		b	.L248
 4573              	.LVL343:
 4574              	.L247:
 581:MotorControl/encoder.cpp **** 
 582:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_CUI: {
 4575              		.loc 3 582 9 view .LVU1121
 4576              		.loc 3 582 32 view .LVU1122
 4577              	.LBB1756:
 583:MotorControl/encoder.cpp ****             uint16_t rawVal = abs_spi_dma_rx_[0];
 4578              		.loc 3 583 13 view .LVU1123
 4579              		.loc 3 583 22 is_stmt 0 view .LVU1124
 4580 0034 B0F84E51 		ldrh	r5, [r0, #334]
 4581              	.LVL344:
 584:MotorControl/encoder.cpp ****             // check if parity is correct
 585:MotorControl/encoder.cpp ****             if (cui_parity(rawVal)) {
 4582              		.loc 3 585 13 is_stmt 1 view .LVU1125
 4583              		.loc 3 585 27 is_stmt 0 view .LVU1126
 4584 0038 2846     		mov	r0, r5
 4585              	.LVL345:
 4586              		.loc 3 585 27 view .LVU1127
 4587 003a FFF7FEFF 		bl	_Z10cui_parityt
 4588              	.LVL346:
 4589              		.loc 3 585 13 view .LVU1128
 4590 003e 80B9     		cbnz	r0, .L241
 586:MotorControl/encoder.cpp ****                 goto done;
 587:MotorControl/encoder.cpp ****             }
 588:MotorControl/encoder.cpp ****             pos = rawVal & 0x3fff;
 4591              		.loc 3 588 13 is_stmt 1 view .LVU1129
 4592              		.loc 3 588 17 is_stmt 0 view .LVU1130
 4593 0040 C5F30D00 		ubfx	r0, r5, #0, #14
ARM GAS  /tmp/cc5nV8qb.s 			page 241


 4594              	.LVL347:
 4595              		.loc 3 588 17 view .LVU1131
 4596              	.LBE1756:
 589:MotorControl/encoder.cpp ****         } break;
 4597              		.loc 3 589 11 is_stmt 1 view .LVU1132
 4598 0044 02E0     		b	.L248
 4599              	.LVL348:
 4600              	.L245:
 590:MotorControl/encoder.cpp **** 
 591:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_RLS: {
 4601              		.loc 3 591 9 view .LVU1133
 4602              		.loc 3 591 32 view .LVU1134
 4603              	.LBB1757:
 592:MotorControl/encoder.cpp ****             uint16_t rawVal = abs_spi_dma_rx_[0];
 4604              		.loc 3 592 13 view .LVU1135
 4605              		.loc 3 592 22 is_stmt 0 view .LVU1136
 4606 0046 B0F84E01 		ldrh	r0, [r0, #334]
 4607              	.LVL349:
 593:MotorControl/encoder.cpp ****             pos = (rawVal >> 2) & 0x3fff;
 4608              		.loc 3 593 13 is_stmt 1 view .LVU1137
 4609              		.loc 3 593 17 is_stmt 0 view .LVU1138
 4610 004a 8008     		lsrs	r0, r0, #2
 4611              	.LVL350:
 4612              		.loc 3 593 17 view .LVU1139
 4613              	.LBE1757:
 594:MotorControl/encoder.cpp ****         } break;
 4614              		.loc 3 594 11 is_stmt 1 view .LVU1140
 4615              	.L248:
 595:MotorControl/encoder.cpp **** 
 596:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_MA732: {
 597:MotorControl/encoder.cpp ****             uint16_t rawVal = abs_spi_dma_rx_[0];
 598:MotorControl/encoder.cpp ****             pos = (rawVal >> 2) & 0x3fff;
 599:MotorControl/encoder.cpp ****         } break;
 600:MotorControl/encoder.cpp **** 
 601:MotorControl/encoder.cpp ****         default: {
 602:MotorControl/encoder.cpp ****            set_error(ERROR_UNSUPPORTED_ENCODER_MODE);
 603:MotorControl/encoder.cpp ****            goto done;
 604:MotorControl/encoder.cpp ****         } break;
 4616              		.loc 3 604 11 view .LVU1141
 4617              	.LBE1754:
 4618              	.LBE1753:
 605:MotorControl/encoder.cpp ****     }
 606:MotorControl/encoder.cpp **** 
 607:MotorControl/encoder.cpp ****     pos_abs_ = pos;
 4619              		.loc 3 607 5 view .LVU1142
 4620              		.loc 3 607 14 is_stmt 0 view .LVU1143
 4621 004c C4F8C800 		str	r0, [r4, #200]
 608:MotorControl/encoder.cpp ****     abs_spi_pos_updated_ = true;
 4622              		.loc 3 608 5 is_stmt 1 view .LVU1144
 4623              		.loc 3 608 26 is_stmt 0 view .LVU1145
 4624 0050 0123     		movs	r3, #1
 4625 0052 84F83831 		strb	r3, [r4, #312]
 609:MotorControl/encoder.cpp ****     if (config_.pre_calibrated) {
 4626              		.loc 3 609 5 is_stmt 1 view .LVU1146
 4627              		.loc 3 609 17 is_stmt 0 view .LVU1147
 4628 0056 94F85930 		ldrb	r3, [r4, #89]	@ zero_extendqisi2
 4629              		.loc 3 609 5 view .LVU1148
ARM GAS  /tmp/cc5nV8qb.s 			page 242


 4630 005a 13B1     		cbz	r3, .L241
 610:MotorControl/encoder.cpp ****         is_ready_ = true;
 4631              		.loc 3 610 9 is_stmt 1 view .LVU1149
 4632              		.loc 3 610 19 is_stmt 0 view .LVU1150
 4633 005c 0123     		movs	r3, #1
 4634 005e 84F88F30 		strb	r3, [r4, #143]
 4635              	.LVL351:
 4636              	.L241:
 611:MotorControl/encoder.cpp ****     }
 612:MotorControl/encoder.cpp **** 
 613:MotorControl/encoder.cpp **** done:
 4637              		.loc 3 613 1 is_stmt 1 view .LVU1151
 614:MotorControl/encoder.cpp ****     Stm32SpiArbiter::release_task(&spi_task_);
 4638              		.loc 3 614 5 view .LVU1152
 4639              		.loc 3 614 34 is_stmt 0 view .LVU1153
 4640 0062 04F5A870 		add	r0, r4, #336
 4641 0066 FFF7FEFF 		bl	_ZN15Stm32SpiArbiter12release_taskEPNS_7SpiTaskE
 4642              	.LVL352:
 615:MotorControl/encoder.cpp **** }
 4643              		.loc 3 615 1 view .LVU1154
 4644 006a 38BD     		pop	{r3, r4, r5, pc}
 4645              	.LVL353:
 4646              	.L243:
 4647              	.LBB1760:
 4648              	.LBB1759:
 596:MotorControl/encoder.cpp ****             uint16_t rawVal = abs_spi_dma_rx_[0];
 4649              		.loc 3 596 9 is_stmt 1 view .LVU1155
 596:MotorControl/encoder.cpp ****             uint16_t rawVal = abs_spi_dma_rx_[0];
 4650              		.loc 3 596 34 view .LVU1156
 4651              	.LBB1758:
 597:MotorControl/encoder.cpp ****             pos = (rawVal >> 2) & 0x3fff;
 4652              		.loc 3 597 13 view .LVU1157
 597:MotorControl/encoder.cpp ****             pos = (rawVal >> 2) & 0x3fff;
 4653              		.loc 3 597 22 is_stmt 0 view .LVU1158
 4654 006c B0F84E01 		ldrh	r0, [r0, #334]
 4655              	.LVL354:
 598:MotorControl/encoder.cpp ****         } break;
 4656              		.loc 3 598 13 is_stmt 1 view .LVU1159
 598:MotorControl/encoder.cpp ****         } break;
 4657              		.loc 3 598 17 is_stmt 0 view .LVU1160
 4658 0070 8008     		lsrs	r0, r0, #2
 4659              	.LVL355:
 598:MotorControl/encoder.cpp ****         } break;
 4660              		.loc 3 598 17 view .LVU1161
 4661              	.LBE1758:
 599:MotorControl/encoder.cpp **** 
 4662              		.loc 3 599 11 is_stmt 1 view .LVU1162
 4663 0072 EBE7     		b	.L248
 4664              	.LVL356:
 4665              	.L242:
 601:MotorControl/encoder.cpp ****            set_error(ERROR_UNSUPPORTED_ENCODER_MODE);
 4666              		.loc 3 601 9 view .LVU1163
 601:MotorControl/encoder.cpp ****            set_error(ERROR_UNSUPPORTED_ENCODER_MODE);
 4667              		.loc 3 601 18 view .LVU1164
 602:MotorControl/encoder.cpp ****            goto done;
 4668              		.loc 3 602 12 view .LVU1165
 602:MotorControl/encoder.cpp ****            goto done;
ARM GAS  /tmp/cc5nV8qb.s 			page 243


 4669              		.loc 3 602 21 is_stmt 0 view .LVU1166
 4670 0074 0821     		movs	r1, #8
 4671              	.LVL357:
 602:MotorControl/encoder.cpp ****            goto done;
 4672              		.loc 3 602 21 view .LVU1167
 4673 0076 FFF7FEFF 		bl	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
 4674              	.LVL358:
 603:MotorControl/encoder.cpp ****         } break;
 4675              		.loc 3 603 12 is_stmt 1 view .LVU1168
 603:MotorControl/encoder.cpp ****         } break;
 4676              		.loc 3 603 17 is_stmt 0 view .LVU1169
 4677 007a F2E7     		b	.L241
 4678              	.LBE1759:
 4679              	.LBE1760:
 4680              		.cfi_endproc
 4681              	.LFE5367:
 4682              		.fnend
 4684              		.section	.text._ZZN7Encoder25abs_spi_start_transactionEvENUlPvbE_4_FUNES0_b,"ax",%progbits
 4685              		.align	1
 4686              		.syntax unified
 4687              		.thumb
 4688              		.thumb_func
 4690              	_ZZN7Encoder25abs_spi_start_transactionEvENUlPvbE_4_FUNES0_b:
 4691              		.fnstart
 4692              	.LFB5363:
 538:MotorControl/encoder.cpp ****             spi_task_.on_complete_ctx = this;
 4693              		.loc 3 538 37 is_stmt 1 view -0
 4694              		.cfi_startproc
 4695              		@ args = 0, pretend = 0, frame = 0
 4696              		@ frame_needed = 0, uses_anonymous_args = 0
 4697 0000 08B5     		push	{r3, lr}
 4698              		.save {r3, lr}
 4699              	.LCFI43:
 4700              		.cfi_def_cfa_offset 8
 4701              		.cfi_offset 3, -8
 4702              		.cfi_offset 14, -4
 4703              	.LVL359:
 4704              	.LBB1761:
 4705              	.LBI1761:
 538:MotorControl/encoder.cpp ****             spi_task_.on_complete_ctx = this;
 4706              		.loc 3 538 37 view .LVU1171
 4707              	.LBB1762:
 538:MotorControl/encoder.cpp ****             spi_task_.on_complete_ctx = this;
 4708              		.loc 3 538 67 view .LVU1172
 538:MotorControl/encoder.cpp ****             spi_task_.on_complete_ctx = this;
 4709              		.loc 3 538 94 is_stmt 0 view .LVU1173
 4710 0002 FFF7FEFF 		bl	_ZN7Encoder10abs_spi_cbEb
 4711              	.LVL360:
 538:MotorControl/encoder.cpp ****             spi_task_.on_complete_ctx = this;
 4712              		.loc 3 538 94 view .LVU1174
 4713              	.LBE1762:
 4714              	.LBE1761:
 538:MotorControl/encoder.cpp ****             spi_task_.on_complete_ctx = this;
 4715              		.loc 3 538 105 view .LVU1175
 4716 0006 08BD     		pop	{r3, pc}
 4717              		.cfi_endproc
 4718              	.LFE5363:
ARM GAS  /tmp/cc5nV8qb.s 			page 244


 4719              		.fnend
 4721              		.section	.text._ZN7Encoder19abs_spi_cs_pin_initEv,"ax",%progbits
 4722              		.align	1
 4723              		.global	_ZN7Encoder19abs_spi_cs_pin_initEv
 4724              		.syntax unified
 4725              		.thumb
 4726              		.thumb_func
 4728              	_ZN7Encoder19abs_spi_cs_pin_initEv:
 4729              		.fnstart
 4730              	.LVL361:
 4731              	.LFB5368:
 616:MotorControl/encoder.cpp **** 
 617:MotorControl/encoder.cpp **** void Encoder::abs_spi_cs_pin_init(){
 4732              		.loc 3 617 36 is_stmt 1 view -0
 4733              		.cfi_startproc
 4734              		@ args = 0, pretend = 0, frame = 8
 4735              		@ frame_needed = 0, uses_anonymous_args = 0
 4736              		.loc 3 617 36 is_stmt 0 view .LVU1177
 4737 0000 30B5     		push	{r4, r5, lr}
 4738              		.save {r4, r5, lr}
 4739              	.LCFI44:
 4740              		.cfi_def_cfa_offset 12
 4741              		.cfi_offset 4, -12
 4742              		.cfi_offset 5, -8
 4743              		.cfi_offset 14, -4
 4744              		.pad #12
 4745 0002 83B0     		sub	sp, sp, #12
 4746              	.LCFI45:
 4747              		.cfi_def_cfa_offset 24
 4748 0004 0446     		mov	r4, r0
 618:MotorControl/encoder.cpp ****     // Decode and init cs pin
 619:MotorControl/encoder.cpp **** #if HW_VERSION_MAJOR == 4
 620:MotorControl/encoder.cpp ****     if (mode_ == MODE_SPI_ABS_MA732)
 621:MotorControl/encoder.cpp ****         abs_spi_cs_gpio_ = {GPIOA, GPIO_PIN_15};
 622:MotorControl/encoder.cpp ****     else
 623:MotorControl/encoder.cpp **** #else
 624:MotorControl/encoder.cpp ****     abs_spi_cs_gpio_ = get_gpio(config_.abs_spi_cs_gpio_pin);
 4749              		.loc 3 624 5 is_stmt 1 view .LVU1178
 4750              		.loc 3 624 60 is_stmt 0 view .LVU1179
 4751 0006 B0F88010 		ldrh	r1, [r0, #128]
 4752 000a 6846     		mov	r0, sp
 4753              	.LVL362:
 4754              		.loc 3 624 60 view .LVU1180
 4755 000c FFF7FEFF 		bl	_ZL8get_gpioj
 4756              	.LVL363:
 4757              		.loc 3 624 22 view .LVU1181
 4758 0010 04F59E75 		add	r5, r4, #316
 4759 0014 0098     		ldr	r0, [sp]
 4760 0016 C4F83C01 		str	r0, [r4, #316]	@ unaligned
 4761 001a BDF80430 		ldrh	r3, [sp, #4]	@ unaligned
 4762 001e A4F84031 		strh	r3, [r4, #320]	@ unaligned
 625:MotorControl/encoder.cpp **** #endif
 626:MotorControl/encoder.cpp ****     abs_spi_cs_gpio_.config(GPIO_MODE_OUTPUT_PP, GPIO_PULLUP);
 4763              		.loc 3 626 5 is_stmt 1 view .LVU1182
 4764              		.loc 3 626 28 is_stmt 0 view .LVU1183
 4765 0022 0023     		movs	r3, #0
 4766 0024 0122     		movs	r2, #1
ARM GAS  /tmp/cc5nV8qb.s 			page 245


 4767 0026 1146     		mov	r1, r2
 4768 0028 2846     		mov	r0, r5
 4769 002a FFF7FEFF 		bl	_ZN9Stm32Gpio6configEmmm
 4770              	.LVL364:
 627:MotorControl/encoder.cpp **** 
 628:MotorControl/encoder.cpp ****     // Write pin high
 629:MotorControl/encoder.cpp ****     abs_spi_cs_gpio_.write(true);
 4771              		.loc 3 629 5 is_stmt 1 view .LVU1184
 4772              	.LBB1765:
 4773              	.LBI1765:
  11:./Drivers/STM32/stm32_gpio.hpp ****     Stm32Gpio(GPIO_TypeDef* port, uint16_t pin) : port_(port), pin_mask_(pin) {}
  12:./Drivers/STM32/stm32_gpio.hpp **** 
  13:./Drivers/STM32/stm32_gpio.hpp ****     operator bool() const { return port_ && pin_mask_; }
  14:./Drivers/STM32/stm32_gpio.hpp **** 
  15:./Drivers/STM32/stm32_gpio.hpp ****     /**
  16:./Drivers/STM32/stm32_gpio.hpp ****      * @brief Configures the GPIO with the specified parameters.
  17:./Drivers/STM32/stm32_gpio.hpp ****      * 
  18:./Drivers/STM32/stm32_gpio.hpp ****      * This can be done regardless of the current state of the GPIO.
  19:./Drivers/STM32/stm32_gpio.hpp ****      * 
  20:./Drivers/STM32/stm32_gpio.hpp ****      * If any subscription is in place, it is not disabled by this function.
  21:./Drivers/STM32/stm32_gpio.hpp ****      */
  22:./Drivers/STM32/stm32_gpio.hpp ****     bool config(uint32_t mode, uint32_t pull, uint32_t speed = GPIO_SPEED_FREQ_LOW);
  23:./Drivers/STM32/stm32_gpio.hpp **** 
  24:./Drivers/STM32/stm32_gpio.hpp ****     void write(bool state) {
 4774              		.loc 15 24 10 view .LVU1185
 4775              	.LBB1766:
  25:./Drivers/STM32/stm32_gpio.hpp ****         if (port_) {
 4776              		.loc 15 25 9 view .LVU1186
 4777              		.loc 15 25 13 is_stmt 0 view .LVU1187
 4778 002e D4F83C01 		ldr	r0, [r4, #316]
 4779              		.loc 15 25 9 view .LVU1188
 4780 0032 20B1     		cbz	r0, .L252
  26:./Drivers/STM32/stm32_gpio.hpp ****             HAL_GPIO_WritePin(port_, pin_mask_, state ? GPIO_PIN_SET : GPIO_PIN_RESET);
 4781              		.loc 15 26 13 is_stmt 1 view .LVU1189
 4782              		.loc 15 26 30 is_stmt 0 view .LVU1190
 4783 0034 0122     		movs	r2, #1
 4784 0036 B4F84011 		ldrh	r1, [r4, #320]
 4785 003a FFF7FEFF 		bl	HAL_GPIO_WritePin
 4786              	.LVL365:
 4787              	.L252:
 4788              		.loc 15 26 30 view .LVU1191
 4789              	.LBE1766:
 4790              	.LBE1765:
 630:MotorControl/encoder.cpp **** }
 4791              		.loc 3 630 1 view .LVU1192
 4792 003e 03B0     		add	sp, sp, #12
 4793              	.LCFI46:
 4794              		.cfi_def_cfa_offset 12
 4795              		@ sp needed
 4796 0040 30BD     		pop	{r4, r5, pc}
 4797              		.loc 3 630 1 view .LVU1193
 4798              		.cfi_endproc
 4799              	.LFE5368:
 4800              		.fnend
 4802              		.section	.text._ZN7Encoder5setupEv,"ax",%progbits
 4803              		.align	1
 4804              		.global	_ZN7Encoder5setupEv
ARM GAS  /tmp/cc5nV8qb.s 			page 246


 4805              		.syntax unified
 4806              		.thumb
 4807              		.thumb_func
 4809              	_ZN7Encoder5setupEv:
 4810              		.fnstart
 4811              	.LVL366:
 4812              	.LFB5332:
  36:MotorControl/encoder.cpp ****     HAL_TIM_Encoder_Start(timer_, TIM_CHANNEL_ALL);
 4813              		.loc 3 36 23 is_stmt 1 view -0
 4814              		.cfi_startproc
 4815              		@ args = 0, pretend = 0, frame = 0
 4816              		@ frame_needed = 0, uses_anonymous_args = 0
  36:MotorControl/encoder.cpp ****     HAL_TIM_Encoder_Start(timer_, TIM_CHANNEL_ALL);
 4817              		.loc 3 36 23 is_stmt 0 view .LVU1195
 4818 0000 10B5     		push	{r4, lr}
 4819              		.save {r4, lr}
 4820              	.LCFI47:
 4821              		.cfi_def_cfa_offset 8
 4822              		.cfi_offset 4, -8
 4823              		.cfi_offset 14, -4
 4824 0002 0446     		mov	r4, r0
  37:MotorControl/encoder.cpp ****     set_idx_subscribe();
 4825              		.loc 3 37 5 is_stmt 1 view .LVU1196
  37:MotorControl/encoder.cpp ****     set_idx_subscribe();
 4826              		.loc 3 37 26 is_stmt 0 view .LVU1197
 4827 0004 1821     		movs	r1, #24
 4828 0006 8068     		ldr	r0, [r0, #8]
 4829              	.LVL367:
  37:MotorControl/encoder.cpp ****     set_idx_subscribe();
 4830              		.loc 3 37 26 view .LVU1198
 4831 0008 FFF7FEFF 		bl	HAL_TIM_Encoder_Start
 4832              	.LVL368:
  38:MotorControl/encoder.cpp **** 
 4833              		.loc 3 38 5 is_stmt 1 view .LVU1199
  38:MotorControl/encoder.cpp **** 
 4834              		.loc 3 38 22 is_stmt 0 view .LVU1200
 4835 000c 0021     		movs	r1, #0
 4836 000e 2046     		mov	r0, r4
 4837 0010 FFF7FEFF 		bl	_ZN7Encoder17set_idx_subscribeEb
 4838              	.LVL369:
  40:MotorControl/encoder.cpp **** 
 4839              		.loc 3 40 5 is_stmt 1 view .LVU1201
  40:MotorControl/encoder.cpp **** 
 4840              		.loc 3 40 21 is_stmt 0 view .LVU1202
 4841 0014 A38E     		ldrh	r3, [r4, #52]
  40:MotorControl/encoder.cpp **** 
 4842              		.loc 3 40 11 view .LVU1203
 4843 0016 A4F83A31 		strh	r3, [r4, #314]	@ movhi
  42:MotorControl/encoder.cpp ****         .Mode = SPI_MODE_MASTER,
 4844              		.loc 3 42 5 is_stmt 1 view .LVU1204
  46:MotorControl/encoder.cpp ****         .CLKPhase = SPI_PHASE_2EDGE,
 4845              		.loc 3 46 84 is_stmt 0 view .LVU1205
 4846 001a B3F5817F 		cmp	r3, #258
 4847 001e 2CD0     		beq	.L259
  46:MotorControl/encoder.cpp ****         .CLKPhase = SPI_PHASE_2EDGE,
 4848              		.loc 3 46 52 discriminator 2 view .LVU1206
 4849 0020 B3F5827F 		cmp	r3, #260
ARM GAS  /tmp/cc5nV8qb.s 			page 247


 4850 0024 27D0     		beq	.L262
  46:MotorControl/encoder.cpp ****         .CLKPhase = SPI_PHASE_2EDGE,
 4851              		.loc 3 46 84 view .LVU1207
 4852 0026 0020     		movs	r0, #0
 4853              	.L256:
  42:MotorControl/encoder.cpp ****         .Mode = SPI_MODE_MASTER,
 4854              		.loc 3 42 22 view .LVU1208
 4855 0028 4FF48272 		mov	r2, #260
 4856 002c C4F85021 		str	r2, [r4, #336]
 4857 0030 0022     		movs	r2, #0
 4858 0032 C4F85421 		str	r2, [r4, #340]
 4859 0036 4FF40061 		mov	r1, #2048
 4860 003a C4F85811 		str	r1, [r4, #344]
 4861 003e C4F85C01 		str	r0, [r4, #348]
 4862 0042 0121     		movs	r1, #1
 4863 0044 C4F86011 		str	r1, [r4, #352]
 4864 0048 4FF40071 		mov	r1, #512
 4865 004c C4F86411 		str	r1, [r4, #356]
 4866 0050 1821     		movs	r1, #24
 4867 0052 C4F86811 		str	r1, [r4, #360]
 4868 0056 C4F86C21 		str	r2, [r4, #364]
 4869 005a C4F87021 		str	r2, [r4, #368]
 4870 005e C4F87421 		str	r2, [r4, #372]
 4871 0062 0A22     		movs	r2, #10
 4872 0064 C4F87821 		str	r2, [r4, #376]
  56:MotorControl/encoder.cpp ****         abs_spi_dma_tx_[0] = 0x0000;
 4873              		.loc 3 56 5 is_stmt 1 view .LVU1209
 4874 0068 B3F5827F 		cmp	r3, #260
 4875 006c 07D0     		beq	.L263
 4876              	.L257:
  60:MotorControl/encoder.cpp ****         abs_spi_cs_pin_init();
 4877              		.loc 3 60 5 view .LVU1210
 4878 006e 13F4807F 		tst	r3, #256
 4879 0072 08D1     		bne	.L264
 4880              	.L255:
  67:MotorControl/encoder.cpp **** 
 4881              		.loc 3 67 1 is_stmt 0 view .LVU1211
 4882 0074 10BD     		pop	{r4, pc}
 4883              	.LVL370:
 4884              	.L262:
  46:MotorControl/encoder.cpp ****         .CLKPhase = SPI_PHASE_2EDGE,
 4885              		.loc 3 46 84 view .LVU1212
 4886 0076 0220     		movs	r0, #2
 4887 0078 D6E7     		b	.L256
 4888              	.L259:
 4889 007a 0220     		movs	r0, #2
 4890 007c D4E7     		b	.L256
 4891              	.L263:
  57:MotorControl/encoder.cpp ****     }
 4892              		.loc 3 57 9 is_stmt 1 view .LVU1213
  57:MotorControl/encoder.cpp ****     }
 4893              		.loc 3 57 28 is_stmt 0 view .LVU1214
 4894 007e 0022     		movs	r2, #0
 4895 0080 A4F84C21 		strh	r2, [r4, #332]	@ movhi
 4896 0084 F3E7     		b	.L257
 4897              	.L264:
  61:MotorControl/encoder.cpp **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 248


 4898              		.loc 3 61 9 is_stmt 1 view .LVU1215
  61:MotorControl/encoder.cpp **** 
 4899              		.loc 3 61 28 is_stmt 0 view .LVU1216
 4900 0086 2046     		mov	r0, r4
 4901 0088 FFF7FEFF 		bl	_ZN7Encoder19abs_spi_cs_pin_initEv
 4902              	.LVL371:
  63:MotorControl/encoder.cpp ****             axis_->controller_.anticogging_valid_ = true;
 4903              		.loc 3 63 9 is_stmt 1 view .LVU1217
  63:MotorControl/encoder.cpp ****             axis_->controller_.anticogging_valid_ = true;
 4904              		.loc 3 63 13 is_stmt 0 view .LVU1218
 4905 008c 236B     		ldr	r3, [r4, #48]
  63:MotorControl/encoder.cpp ****             axis_->controller_.anticogging_valid_ = true;
 4906              		.loc 3 63 20 view .LVU1219
 4907 008e D3F80031 		ldr	r3, [r3, #256]
  63:MotorControl/encoder.cpp ****             axis_->controller_.anticogging_valid_ = true;
 4908              		.loc 3 63 52 view .LVU1220
 4909 0092 03F54052 		add	r2, r3, #12288
 4910 0096 92F89828 		ldrb	r2, [r2, #2200]	@ zero_extendqisi2
  63:MotorControl/encoder.cpp ****             axis_->controller_.anticogging_valid_ = true;
 4911              		.loc 3 63 9 view .LVU1221
 4912 009a 002A     		cmp	r2, #0
 4913 009c EAD0     		beq	.L255
  64:MotorControl/encoder.cpp ****         }
 4914              		.loc 3 64 13 is_stmt 1 view .LVU1222
  64:MotorControl/encoder.cpp ****         }
 4915              		.loc 3 64 51 is_stmt 0 view .LVU1223
 4916 009e 03F54053 		add	r3, r3, #12288
 4917 00a2 0122     		movs	r2, #1
 4918 00a4 83F83E29 		strb	r2, [r3, #2366]
  67:MotorControl/encoder.cpp **** 
 4919              		.loc 3 67 1 view .LVU1224
 4920 00a8 E4E7     		b	.L255
 4921              		.cfi_endproc
 4922              	.LFE5332:
 4923              		.fnend
 4925              		.section	.text._ZN7Encoder10hall_modelEf,"ax",%progbits
 4926              		.align	1
 4927              		.global	_ZN7Encoder10hall_modelEf
 4928              		.syntax unified
 4929              		.thumb
 4930              		.thumb_func
 4932              	_ZN7Encoder10hall_modelEf:
 4933              		.fnstart
 4934              	.LVL372:
 4935              	.LFB5369:
 631:MotorControl/encoder.cpp **** 
 632:MotorControl/encoder.cpp **** // Note that this may return counts +1 or -1 without any wrapping
 633:MotorControl/encoder.cpp **** int32_t Encoder::hall_model(float internal_pos) {
 4936              		.loc 3 633 49 is_stmt 1 view -0
 4937              		.cfi_startproc
 4938              		@ args = 0, pretend = 0, frame = 0
 4939              		@ frame_needed = 0, uses_anonymous_args = 0
 4940              		.loc 3 633 49 is_stmt 0 view .LVU1226
 4941 0000 10B5     		push	{r4, lr}
 4942              	.LCFI48:
 4943              		.cfi_def_cfa_offset 8
 4944              		.cfi_offset 4, -8
ARM GAS  /tmp/cc5nV8qb.s 			page 249


 4945              		.cfi_offset 14, -4
 4946 0002 2DED028B 		vpush.64	{d8}
 4947              	.LCFI49:
 4948              		.cfi_def_cfa_offset 16
 4949              		.cfi_offset 80, -16
 4950              		.cfi_offset 81, -12
 4951 0006 0446     		mov	r4, r0
 4952 0008 B0EE408A 		vmov.f32	s16, s0
 634:MotorControl/encoder.cpp ****     int32_t base_cnt = (int32_t)std::floor(internal_pos);
 4953              		.loc 3 634 5 is_stmt 1 view .LVU1227
 4954              	.LVL373:
 4955              	.LBB1767:
 4956              	.LBI1767:
 4957              		.file 21 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // -*- C++ -*- C forwarding header.
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // Copyright (C) 1997-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** /** @file include/cmath
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****  *  This is a Standard C++ Library file.  You should @c \#include this file
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****  *  in your programs, rather than any of the @a *.h implementation files.
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****  *
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****  *  This is the C++ version of the Standard C Library header @c math.h,
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****  *  and its contents are (mostly) the same as that header, but are all
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****  *  contained in the namespace @c std (except for names which are defined
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****  *  as macros in C).
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****  */
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** //
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // ISO C++ 14882: 26.5  C library
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** //
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #pragma GCC system_header
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #include <bits/c++config.h>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #include <bits/cpp_type_traits.h>
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #include <ext/type_traits.h>
ARM GAS  /tmp/cc5nV8qb.s 			page 250


  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #define _GLIBCXX_INCLUDE_NEXT_C_HEADERS
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #include_next <math.h>
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef _GLIBCXX_INCLUDE_NEXT_C_HEADERS
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #include <bits/std_abs.h>
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #ifndef _GLIBCXX_CMATH
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #define _GLIBCXX_CMATH 1
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** // Get rid of those macros defined in <math.h> in lieu of real functions.
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef div
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef acos
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef asin
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef atan
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef atan2
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef ceil
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef cos
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef cosh
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef exp
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef fabs
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef floor
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef fmod
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef frexp
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef ldexp
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef log
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef log10
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef modf
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef pow
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef sin
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef sinh
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef sqrt
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef tan
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #undef tanh
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** extern "C++"
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** {
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** namespace std _GLIBCXX_VISIBILITY(default)
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** {
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   using ::acos;
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR float
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   acos(float __x)
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_acosf(__x); }
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR long double
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   acos(long double __x)
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_acosl(__x); }
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #endif
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   template<typename _Tp>
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     inline _GLIBCXX_CONSTEXPR
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****                                     double>::__type
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     acos(_Tp __x)
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     { return __builtin_acos(__x); }
ARM GAS  /tmp/cc5nV8qb.s 			page 251


 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   using ::asin;
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR float
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   asin(float __x)
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_asinf(__x); }
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR long double
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   asin(long double __x)
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_asinl(__x); }
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #endif
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   template<typename _Tp>
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     inline _GLIBCXX_CONSTEXPR
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****                                     double>::__type
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     asin(_Tp __x)
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     { return __builtin_asin(__x); }
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   using ::atan;
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR float
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   atan(float __x)
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_atanf(__x); }
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR long double
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   atan(long double __x)
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_atanl(__x); }
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #endif
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   template<typename _Tp>
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     inline _GLIBCXX_CONSTEXPR
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****                                     double>::__type
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     atan(_Tp __x)
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     { return __builtin_atan(__x); }
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   using ::atan2;
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR float
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   atan2(float __y, float __x)
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_atan2f(__y, __x); }
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR long double
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   atan2(long double __y, long double __x)
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_atan2l(__y, __x); }
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #endif
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   template<typename _Tp, typename _Up>
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     inline _GLIBCXX_CONSTEXPR
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     atan2(_Tp __y, _Up __x)
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     {
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****       typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
ARM GAS  /tmp/cc5nV8qb.s 			page 252


 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****       return atan2(__type(__y), __type(__x));
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     }
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   using ::ceil;
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR float
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   ceil(float __x)
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_ceilf(__x); }
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR long double
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   ceil(long double __x)
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_ceill(__x); }
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #endif
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   template<typename _Tp>
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     inline _GLIBCXX_CONSTEXPR
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****                                     double>::__type
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     ceil(_Tp __x)
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     { return __builtin_ceil(__x); }
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   using ::cos;
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR float
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   cos(float __x)
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_cosf(__x); }
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR long double
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   cos(long double __x)
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_cosl(__x); }
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #endif
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   template<typename _Tp>
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     inline _GLIBCXX_CONSTEXPR
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****                                     double>::__type
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     cos(_Tp __x)
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     { return __builtin_cos(__x); }
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   using ::cosh;
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR float
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   cosh(float __x)
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_coshf(__x); }
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR long double
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   cosh(long double __x)
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_coshl(__x); }
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #endif
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   template<typename _Tp>
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     inline _GLIBCXX_CONSTEXPR
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****                                     double>::__type
ARM GAS  /tmp/cc5nV8qb.s 			page 253


 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     cosh(_Tp __x)
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     { return __builtin_cosh(__x); }
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   using ::exp;
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR float
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   exp(float __x)
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_expf(__x); }
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR long double
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   exp(long double __x)
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_expl(__x); }
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #endif
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   template<typename _Tp>
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     inline _GLIBCXX_CONSTEXPR
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****                                     double>::__type
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     exp(_Tp __x)
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     { return __builtin_exp(__x); }
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   using ::fabs;
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR float
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   fabs(float __x)
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_fabsf(__x); }
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR long double
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   fabs(long double __x)
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_fabsl(__x); }
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #endif
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   template<typename _Tp>
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     inline _GLIBCXX_CONSTEXPR
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****                                     double>::__type
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     fabs(_Tp __x)
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****     { return __builtin_fabs(__x); }
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   using ::floor;
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** 
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath **** #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   inline _GLIBCXX_CONSTEXPR float
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   floor(float __x)
 4958              		.loc 21 260 3 view .LVU1228
 4959              	.LBB1768:
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_floorf(__x); }
 4960              		.loc 21 261 5 view .LVU1229
 4961              		.loc 21 261 28 is_stmt 0 view .LVU1230
 4962 000c FFF7FEFF 		bl	floorf
 4963              	.LVL374:
 4964              		.loc 21 261 28 view .LVU1231
 4965              	.LBE1768:
 4966              	.LBE1767:
 4967              		.loc 3 634 56 view .LVU1232
ARM GAS  /tmp/cc5nV8qb.s 			page 254


 4968 0010 FDEEC07A 		vcvt.s32.f32	s15, s0
 4969 0014 17EE900A 		vmov	r0, s15	@ int
 4970              	.LVL375:
 635:MotorControl/encoder.cpp **** 
 636:MotorControl/encoder.cpp ****     float pos_in_range = fmodf_pos(internal_pos, 6.0f);
 4971              		.loc 3 636 5 is_stmt 1 view .LVU1233
 4972              	.LBB1769:
 4973              	.LBI1769:
 133:./MotorControl/utils.hpp ****     float res = wrap_pm(x, y);
 4974              		.loc 17 133 14 view .LVU1234
 4975              	.LBB1770:
 134:./MotorControl/utils.hpp ****     if (res < 0) res += y;
 4976              		.loc 17 134 5 view .LVU1235
 4977              	.LBB1771:
 4978              	.LBI1771:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 4979              		.loc 17 123 14 view .LVU1236
 4980              	.LBB1772:
 125:./MotorControl/utils.hpp **** #else
 4981              		.loc 17 125 5 view .LVU1237
 125:./MotorControl/utils.hpp **** #else
 4982              		.loc 17 125 36 is_stmt 0 view .LVU1238
 4983 0018 F1EE087A 		vmov.f32	s15, #6.0e+0
 4984 001c 88EE277A 		vdiv.f32	s14, s16, s15
 4985              	.LVL376:
 4986              	.LBB1773:
 4987              	.LBI1773:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 4988              		.loc 17 108 12 is_stmt 1 view .LVU1239
 4989              	.LBB1774:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 4990              		.loc 17 110 5 view .LVU1240
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 4991              		.loc 17 111 5 view .LVU1241
 4992              		.syntax unified
 4993              	@ 111 "./MotorControl/utils.hpp" 1
 4994 0020 BDEE470A 		vcvtr.s32.f32   s0, s14
 4995              	@ 0 "" 2
 4996              	.LVL377:
 114:./MotorControl/utils.hpp **** #else
 4997              		.loc 17 114 5 view .LVU1242
 114:./MotorControl/utils.hpp **** #else
 4998              		.loc 17 114 5 is_stmt 0 view .LVU1243
 4999              		.thumb
 5000              		.syntax unified
 5001              	.LBE1774:
 5002              	.LBE1773:
 125:./MotorControl/utils.hpp **** #else
 5003              		.loc 17 125 42 view .LVU1244
 5004 0024 B8EEC00A 		vcvt.f32.s32	s0, s0
 5005              	.LVL378:
 129:./MotorControl/utils.hpp **** }
 5006              		.loc 17 129 5 is_stmt 1 view .LVU1245
 129:./MotorControl/utils.hpp **** }
 5007              		.loc 17 129 23 is_stmt 0 view .LVU1246
 5008 0028 20EE270A 		vmul.f32	s0, s0, s15
 5009              	.LVL379:
ARM GAS  /tmp/cc5nV8qb.s 			page 255


 129:./MotorControl/utils.hpp **** }
 5010              		.loc 17 129 25 view .LVU1247
 5011 002c 38EE400A 		vsub.f32	s0, s16, s0
 5012              	.LVL380:
 129:./MotorControl/utils.hpp **** }
 5013              		.loc 17 129 25 view .LVU1248
 5014              	.LBE1772:
 5015              	.LBE1771:
 135:./MotorControl/utils.hpp ****     return res;
 5016              		.loc 17 135 5 is_stmt 1 view .LVU1249
 5017 0030 B5EEC00A 		vcmpe.f32	s0, #0
 5018 0034 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5019 0038 39D4     		bmi	.L280
 5020              	.L266:
 136:./MotorControl/utils.hpp **** }
 5021              		.loc 17 136 5 view .LVU1250
 5022              	.LVL381:
 136:./MotorControl/utils.hpp **** }
 5023              		.loc 17 136 5 is_stmt 0 view .LVU1251
 5024              	.LBE1770:
 5025              	.LBE1769:
 637:MotorControl/encoder.cpp ****     int pos_idx = (int)pos_in_range;
 5026              		.loc 3 637 5 is_stmt 1 view .LVU1252
 5027              		.loc 3 637 9 is_stmt 0 view .LVU1253
 5028 003a FDEEC07A 		vcvt.s32.f32	s15, s0
 5029 003e 17EE903A 		vmov	r3, s15	@ int
 5030              	.LVL382:
 638:MotorControl/encoder.cpp ****     if (pos_idx == 6) pos_idx = 5; // in case of rounding error
 5031              		.loc 3 638 5 is_stmt 1 view .LVU1254
 5032 0042 062B     		cmp	r3, #6
 5033 0044 36D0     		beq	.L273
 639:MotorControl/encoder.cpp ****     int next_i = (pos_idx == 5) ? 0 : pos_idx+1;
 5034              		.loc 3 639 5 view .LVU1255
 5035              		.loc 3 639 33 is_stmt 0 view .LVU1256
 5036 0046 052B     		cmp	r3, #5
 5037 0048 37D0     		beq	.L274
 5038              		.loc 3 639 33 discriminator 1 view .LVU1257
 5039 004a 5A1C     		adds	r2, r3, #1
 5040              	.LVL383:
 5041              	.L268:
 640:MotorControl/encoder.cpp **** 
 641:MotorControl/encoder.cpp ****     float below_edge = config_.hall_edge_phcnt[pos_idx];
 5042              		.loc 3 641 5 is_stmt 1 discriminator 4 view .LVU1258
 5043              	.LBB1776:
 5044              	.LBI1776:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 5045              		.loc 18 185 7 discriminator 4 view .LVU1259
 5046              	.LBB1777:
 5047              	.LBI1777:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 5048              		.loc 18 55 7 discriminator 4 view .LVU1260
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 5049              		.loc 18 55 7 is_stmt 0 discriminator 4 view .LVU1261
 5050              	.LBE1777:
 5051              	.LBE1776:
 5052              		.loc 3 641 55 discriminator 4 view .LVU1262
 5053 004c 04EB8303 		add	r3, r4, r3, lsl #2
ARM GAS  /tmp/cc5nV8qb.s 			page 256


 5054 0050 D3ED1A7A 		vldr.32	s15, [r3, #104]
 5055              	.LVL384:
 642:MotorControl/encoder.cpp ****     float above_edge = config_.hall_edge_phcnt[next_i];
 5056              		.loc 3 642 5 is_stmt 1 discriminator 4 view .LVU1263
 5057              	.LBB1778:
 5058              	.LBI1778:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 5059              		.loc 18 185 7 discriminator 4 view .LVU1264
 5060              	.LBB1779:
 5061              	.LBI1779:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 5062              		.loc 18 55 7 discriminator 4 view .LVU1265
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 5063              		.loc 18 55 7 is_stmt 0 discriminator 4 view .LVU1266
 5064              	.LBE1779:
 5065              	.LBE1778:
 5066              		.loc 3 642 54 discriminator 4 view .LVU1267
 5067 0054 04EB8204 		add	r4, r4, r2, lsl #2
 5068              	.LVL385:
 5069              		.loc 3 642 54 discriminator 4 view .LVU1268
 5070 0058 94ED1A6A 		vldr.32	s12, [r4, #104]
 5071              	.LVL386:
 643:MotorControl/encoder.cpp **** 
 644:MotorControl/encoder.cpp ****     // if we are blow the "below" edge, we are the count under
 645:MotorControl/encoder.cpp ****     if (wrap_pm(pos_in_range - below_edge, 6.0f) < 0.0f)
 5072              		.loc 3 645 5 is_stmt 1 discriminator 4 view .LVU1269
 5073              		.loc 3 645 16 is_stmt 0 discriminator 4 view .LVU1270
 5074 005c 70EE677A 		vsub.f32	s15, s0, s15
 5075              	.LVL387:
 5076              	.LBB1780:
 5077              	.LBI1780:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 5078              		.loc 17 123 14 is_stmt 1 discriminator 4 view .LVU1271
 5079              	.LBB1781:
 125:./MotorControl/utils.hpp **** #else
 5080              		.loc 17 125 5 discriminator 4 view .LVU1272
 125:./MotorControl/utils.hpp **** #else
 5081              		.loc 17 125 36 is_stmt 0 discriminator 4 view .LVU1273
 5082 0060 F1EE086A 		vmov.f32	s13, #6.0e+0
 5083 0064 87EEA67A 		vdiv.f32	s14, s15, s13
 5084              	.LVL388:
 5085              	.LBB1782:
 5086              	.LBI1782:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 5087              		.loc 17 108 12 is_stmt 1 discriminator 4 view .LVU1274
 5088              	.LBB1783:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 5089              		.loc 17 110 5 discriminator 4 view .LVU1275
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 5090              		.loc 17 111 5 discriminator 4 view .LVU1276
 5091              		.syntax unified
 5092              	@ 111 "./MotorControl/utils.hpp" 1
 5093 0068 BDEE477A 		vcvtr.s32.f32   s14, s14
 5094              	@ 0 "" 2
 5095              	.LVL389:
 114:./MotorControl/utils.hpp **** #else
 5096              		.loc 17 114 5 discriminator 4 view .LVU1277
ARM GAS  /tmp/cc5nV8qb.s 			page 257


 114:./MotorControl/utils.hpp **** #else
 5097              		.loc 17 114 5 is_stmt 0 discriminator 4 view .LVU1278
 5098              		.thumb
 5099              		.syntax unified
 5100              	.LBE1783:
 5101              	.LBE1782:
 125:./MotorControl/utils.hpp **** #else
 5102              		.loc 17 125 42 discriminator 4 view .LVU1279
 5103 006c B8EEC77A 		vcvt.f32.s32	s14, s14
 5104              	.LVL390:
 129:./MotorControl/utils.hpp **** }
 5105              		.loc 17 129 5 is_stmt 1 discriminator 4 view .LVU1280
 129:./MotorControl/utils.hpp **** }
 5106              		.loc 17 129 23 is_stmt 0 discriminator 4 view .LVU1281
 5107 0070 27EE267A 		vmul.f32	s14, s14, s13
 5108              	.LVL391:
 129:./MotorControl/utils.hpp **** }
 5109              		.loc 17 129 25 discriminator 4 view .LVU1282
 5110 0074 77EEC77A 		vsub.f32	s15, s15, s14
 5111              	.LVL392:
 129:./MotorControl/utils.hpp **** }
 5112              		.loc 17 129 25 discriminator 4 view .LVU1283
 5113              	.LBE1781:
 5114              	.LBE1780:
 5115              		.loc 3 645 5 discriminator 4 view .LVU1284
 5116 0078 F5EEC07A 		vcmpe.f32	s15, #0
 5117 007c F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5118 0080 1DD4     		bmi	.L281
 646:MotorControl/encoder.cpp ****         return base_cnt - 1;
 647:MotorControl/encoder.cpp ****     // if we are above the "above" edge, we are the count over
 648:MotorControl/encoder.cpp ****     else if (wrap_pm(pos_in_range - above_edge, 6.0f) > 0.0f)
 5119              		.loc 3 648 10 is_stmt 1 view .LVU1285
 5120              		.loc 3 648 21 is_stmt 0 view .LVU1286
 5121 0082 30EE460A 		vsub.f32	s0, s0, s12
 5122              	.LVL393:
 5123              	.LBB1784:
 5124              	.LBI1784:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 5125              		.loc 17 123 14 is_stmt 1 view .LVU1287
 5126              	.LBB1785:
 125:./MotorControl/utils.hpp **** #else
 5127              		.loc 17 125 5 view .LVU1288
 125:./MotorControl/utils.hpp **** #else
 5128              		.loc 17 125 36 is_stmt 0 view .LVU1289
 5129 0086 B1EE087A 		vmov.f32	s14, #6.0e+0
 5130 008a C0EE077A 		vdiv.f32	s15, s0, s14
 5131              	.LVL394:
 5132              	.LBB1786:
 5133              	.LBI1786:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 5134              		.loc 17 108 12 is_stmt 1 view .LVU1290
 5135              	.LBB1787:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 5136              		.loc 17 110 5 view .LVU1291
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 5137              		.loc 17 111 5 view .LVU1292
 5138              		.syntax unified
ARM GAS  /tmp/cc5nV8qb.s 			page 258


 5139              	@ 111 "./MotorControl/utils.hpp" 1
 5140 008e FDEE677A 		vcvtr.s32.f32   s15, s15
 5141              	@ 0 "" 2
 5142              	.LVL395:
 114:./MotorControl/utils.hpp **** #else
 5143              		.loc 17 114 5 view .LVU1293
 114:./MotorControl/utils.hpp **** #else
 5144              		.loc 17 114 5 is_stmt 0 view .LVU1294
 5145              		.thumb
 5146              		.syntax unified
 5147              	.LBE1787:
 5148              	.LBE1786:
 125:./MotorControl/utils.hpp **** #else
 5149              		.loc 17 125 42 view .LVU1295
 5150 0092 F8EEE77A 		vcvt.f32.s32	s15, s15
 5151              	.LVL396:
 129:./MotorControl/utils.hpp **** }
 5152              		.loc 17 129 5 is_stmt 1 view .LVU1296
 129:./MotorControl/utils.hpp **** }
 5153              		.loc 17 129 23 is_stmt 0 view .LVU1297
 5154 0096 67EE877A 		vmul.f32	s15, s15, s14
 5155              	.LVL397:
 129:./MotorControl/utils.hpp **** }
 5156              		.loc 17 129 25 view .LVU1298
 5157 009a 30EE670A 		vsub.f32	s0, s0, s15
 5158              	.LVL398:
 129:./MotorControl/utils.hpp **** }
 5159              		.loc 17 129 25 view .LVU1299
 5160              	.LBE1785:
 5161              	.LBE1784:
 5162              		.loc 3 648 10 view .LVU1300
 5163 009e B5EEC00A 		vcmpe.f32	s0, #0
 5164 00a2 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5165 00a6 0CDC     		bgt	.L282
 5166              	.LVL399:
 5167              	.L265:
 649:MotorControl/encoder.cpp ****         return base_cnt + 1;
 650:MotorControl/encoder.cpp ****     // otherwise we are in the nominal count (or completely lost)
 651:MotorControl/encoder.cpp ****     return base_cnt;
 652:MotorControl/encoder.cpp **** }
 5168              		.loc 3 652 1 view .LVU1301
 5169 00a8 BDEC028B 		vldm	sp!, {d8}
 5170              	.LCFI50:
 5171              		.cfi_remember_state
 5172              		.cfi_restore 80
 5173              		.cfi_restore 81
 5174              		.cfi_def_cfa_offset 8
 5175              	.LVL400:
 5176              		.loc 3 652 1 view .LVU1302
 5177 00ac 10BD     		pop	{r4, pc}
 5178              	.LVL401:
 5179              	.L280:
 5180              	.LCFI51:
 5181              		.cfi_restore_state
 5182              	.LBB1788:
 5183              	.LBB1775:
 135:./MotorControl/utils.hpp ****     return res;
ARM GAS  /tmp/cc5nV8qb.s 			page 259


 5184              		.loc 17 135 18 is_stmt 1 view .LVU1303
 135:./MotorControl/utils.hpp ****     return res;
 5185              		.loc 17 135 22 is_stmt 0 view .LVU1304
 5186 00ae 30EE270A 		vadd.f32	s0, s0, s15
 5187              	.LVL402:
 135:./MotorControl/utils.hpp ****     return res;
 5188              		.loc 17 135 22 view .LVU1305
 5189 00b2 C2E7     		b	.L266
 5190              	.LVL403:
 5191              	.L273:
 135:./MotorControl/utils.hpp ****     return res;
 5192              		.loc 17 135 22 view .LVU1306
 5193              	.LBE1775:
 5194              	.LBE1788:
 638:MotorControl/encoder.cpp ****     int next_i = (pos_idx == 5) ? 0 : pos_idx+1;
 5195              		.loc 3 638 31 view .LVU1307
 5196 00b4 0523     		movs	r3, #5
 5197              	.LVL404:
 639:MotorControl/encoder.cpp **** 
 5198              		.loc 3 639 33 view .LVU1308
 5199 00b6 0022     		movs	r2, #0
 5200 00b8 C8E7     		b	.L268
 5201              	.LVL405:
 5202              	.L274:
 639:MotorControl/encoder.cpp **** 
 5203              		.loc 3 639 33 view .LVU1309
 5204 00ba 0022     		movs	r2, #0
 5205 00bc C6E7     		b	.L268
 5206              	.LVL406:
 5207              	.L281:
 646:MotorControl/encoder.cpp ****     // if we are above the "above" edge, we are the count over
 5208              		.loc 3 646 9 is_stmt 1 view .LVU1310
 646:MotorControl/encoder.cpp ****     // if we are above the "above" edge, we are the count over
 5209              		.loc 3 646 27 is_stmt 0 view .LVU1311
 5210 00be 0138     		subs	r0, r0, #1
 5211              	.LVL407:
 646:MotorControl/encoder.cpp ****     // if we are above the "above" edge, we are the count over
 5212              		.loc 3 646 27 view .LVU1312
 5213 00c0 F2E7     		b	.L265
 5214              	.LVL408:
 5215              	.L282:
 649:MotorControl/encoder.cpp ****     // otherwise we are in the nominal count (or completely lost)
 5216              		.loc 3 649 9 is_stmt 1 view .LVU1313
 649:MotorControl/encoder.cpp ****     // otherwise we are in the nominal count (or completely lost)
 5217              		.loc 3 649 27 is_stmt 0 view .LVU1314
 5218 00c2 0130     		adds	r0, r0, #1
 5219              	.LVL409:
 649:MotorControl/encoder.cpp ****     // otherwise we are in the nominal count (or completely lost)
 5220              		.loc 3 649 27 view .LVU1315
 5221 00c4 F0E7     		b	.L265
 5222              		.cfi_endproc
 5223              	.LFE5369:
 5224              		.cantunwind
 5225              		.fnend
 5227              		.section	.text._ZN7Encoder6updateEv,"ax",%progbits
 5228              		.align	1
 5229              		.global	_ZN7Encoder6updateEv
ARM GAS  /tmp/cc5nV8qb.s 			page 260


 5230              		.syntax unified
 5231              		.thumb
 5232              		.thumb_func
 5234              	_ZN7Encoder6updateEv:
 5235              		.fnstart
 5236              	.LVL410:
 5237              	.LFB5370:
 653:MotorControl/encoder.cpp **** 
 654:MotorControl/encoder.cpp **** bool Encoder::update() {
 5238              		.loc 3 654 24 is_stmt 1 view -0
 5239              		.cfi_startproc
 5240              		@ args = 0, pretend = 0, frame = 32
 5241              		@ frame_needed = 0, uses_anonymous_args = 0
 5242              		.loc 3 654 24 is_stmt 0 view .LVU1317
 5243 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 5244              		.save {r4, r5, r6, r7, r8, lr}
 5245              	.LCFI52:
 5246              		.cfi_def_cfa_offset 24
 5247              		.cfi_offset 4, -24
 5248              		.cfi_offset 5, -20
 5249              		.cfi_offset 6, -16
 5250              		.cfi_offset 7, -12
 5251              		.cfi_offset 8, -8
 5252              		.cfi_offset 14, -4
 5253 0004 2DED068B 		vpush.64	{d8, d9, d10}
 5254              		.vsave {d8, d9, d10}
 5255              	.LCFI53:
 5256              		.cfi_def_cfa_offset 48
 5257              		.cfi_offset 80, -48
 5258              		.cfi_offset 81, -44
 5259              		.cfi_offset 82, -40
 5260              		.cfi_offset 83, -36
 5261              		.cfi_offset 84, -32
 5262              		.cfi_offset 85, -28
 5263              		.pad #32
 5264 0008 88B0     		sub	sp, sp, #32
 5265              	.LCFI54:
 5266              		.cfi_def_cfa_offset 80
 5267 000a 0446     		mov	r4, r0
 655:MotorControl/encoder.cpp ****     // update internal encoder state.
 656:MotorControl/encoder.cpp ****     int32_t delta_enc = 0;
 5268              		.loc 3 656 5 is_stmt 1 view .LVU1318
 5269              	.LVL411:
 657:MotorControl/encoder.cpp ****     int32_t pos_abs_latched = pos_abs_; //LATCH
 5270              		.loc 3 657 5 view .LVU1319
 5271              		.loc 3 657 13 is_stmt 0 view .LVU1320
 5272 000c D0F8C850 		ldr	r5, [r0, #200]
 5273              	.LVL412:
 658:MotorControl/encoder.cpp **** 
 659:MotorControl/encoder.cpp ****     switch (mode_) {
 5274              		.loc 3 659 5 is_stmt 1 view .LVU1321
 5275              	.LBB1957:
 5276              		.loc 3 659 13 is_stmt 0 view .LVU1322
 5277 0010 B0F83A31 		ldrh	r3, [r0, #314]
 5278              		.loc 3 659 5 view .LVU1323
 5279 0014 022B     		cmp	r3, #2
 5280 0016 00F01482 		beq	.L284
ARM GAS  /tmp/cc5nV8qb.s 			page 261


 5281 001a 18D8     		bhi	.L285
 5282 001c E3B3     		cbz	r3, .L286
 5283 001e 012B     		cmp	r3, #1
 5284 0020 40F05E82 		bne	.L288
 5285              	.LBB1958:
 660:MotorControl/encoder.cpp ****         case MODE_INCREMENTAL: {
 661:MotorControl/encoder.cpp ****             //TODO: use count_in_cpr_ instead as shadow_count_ can overflow
 662:MotorControl/encoder.cpp ****             //or use 64 bit
 663:MotorControl/encoder.cpp ****             int16_t delta_enc_16 = (int16_t)tim_cnt_sample_ - (int16_t)shadow_count_;
 664:MotorControl/encoder.cpp ****             delta_enc = (int32_t)delta_enc_16; //sign extend
 665:MotorControl/encoder.cpp ****         } break;
 666:MotorControl/encoder.cpp **** 
 667:MotorControl/encoder.cpp ****         case MODE_HALL: {
 5286              		.loc 3 667 9 is_stmt 1 view .LVU1324
 5287              		.loc 3 667 25 view .LVU1325
 5288              	.LBB1959:
 668:MotorControl/encoder.cpp ****             decode_hall_samples();
 5289              		.loc 3 668 13 view .LVU1326
 5290              		.loc 3 668 32 is_stmt 0 view .LVU1327
 5291 0024 FFF7FEFF 		bl	_ZN7Encoder19decode_hall_samplesEv
 5292              	.LVL413:
 669:MotorControl/encoder.cpp ****             if (sample_hall_states_) {
 5293              		.loc 3 669 13 is_stmt 1 view .LVU1328
 5294              		.loc 3 669 17 is_stmt 0 view .LVU1329
 5295 0028 94F8F630 		ldrb	r3, [r4, #246]	@ zero_extendqisi2
 5296              		.loc 3 669 13 view .LVU1330
 5297 002c 43B1     		cbz	r3, .L291
 670:MotorControl/encoder.cpp ****                 states_seen_count_[hall_state_]++;
 5298              		.loc 3 670 17 is_stmt 1 view .LVU1331
 5299              		.loc 3 670 36 is_stmt 0 view .LVU1332
 5300 002e 94F8F230 		ldrb	r3, [r4, #242]	@ zero_extendqisi2
 5301              	.LVL414:
 5302              	.LBB1960:
 5303              	.LBI1960:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 5304              		.loc 18 185 7 is_stmt 1 view .LVU1333
 5305              	.LBB1961:
 5306              	.LBI1961:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 5307              		.loc 18 55 7 view .LVU1334
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 5308              		.loc 18 55 7 is_stmt 0 view .LVU1335
 5309              	.LBE1961:
 5310              	.LBE1960:
 5311              		.loc 3 670 48 view .LVU1336
 5312 0032 04EB8303 		add	r3, r4, r3, lsl #2
 5313 0036 D3F8F820 		ldr	r2, [r3, #248]
 5314 003a 0132     		adds	r2, r2, #1
 5315 003c C3F8F820 		str	r2, [r3, #248]
 5316              	.L291:
 671:MotorControl/encoder.cpp ****             }
 672:MotorControl/encoder.cpp ****             if (config_.hall_polarity_calibrated) {
 5317              		.loc 3 672 13 is_stmt 1 view .LVU1337
 5318              	.LBB1962:
 5319              		.loc 3 672 25 is_stmt 0 view .LVU1338
 5320 0040 94F86530 		ldrb	r3, [r4, #101]	@ zero_extendqisi2
 5321              		.loc 3 672 13 view .LVU1339
ARM GAS  /tmp/cc5nV8qb.s 			page 262


 5322 0044 002B     		cmp	r3, #0
 5323 0046 40F05A81 		bne	.L350
 5324              	.LBE1962:
 5325              	.LBE1959:
 5326              	.LBE1958:
 5327              	.LBE1957:
 656:MotorControl/encoder.cpp ****     int32_t pos_abs_latched = pos_abs_; //LATCH
 5328              		.loc 3 656 13 view .LVU1340
 5329 004a 0026     		movs	r6, #0
 5330 004c 2BE0     		b	.L290
 5331              	.LVL415:
 5332              	.L285:
 5333              	.LBB2070:
 659:MotorControl/encoder.cpp ****         case MODE_INCREMENTAL: {
 5334              		.loc 3 659 5 view .LVU1341
 5335 004e A3F58073 		sub	r3, r3, #256
 5336 0052 9BB2     		uxth	r3, r3
 5337 0054 042B     		cmp	r3, #4
 5338 0056 00F24382 		bhi	.L288
 5339              	.LBB2065:
 673:MotorControl/encoder.cpp ****                 int32_t hall_cnt;
 674:MotorControl/encoder.cpp ****                 if (decode_hall((hall_state_ ^ config_.hall_polarity), &hall_cnt)) {
 675:MotorControl/encoder.cpp ****                     if (calibrate_hall_phase_) {
 676:MotorControl/encoder.cpp ****                         if (sample_hall_phase_ && last_hall_cnt_.has_value()) {
 677:MotorControl/encoder.cpp ****                             int mod_hall_cnt = mod(hall_cnt - last_hall_cnt_.value(), 6);
 678:MotorControl/encoder.cpp ****                             size_t edge_idx;
 679:MotorControl/encoder.cpp ****                             if (mod_hall_cnt == 0) { goto skip; } // no count - do nothing
 680:MotorControl/encoder.cpp ****                             else if (mod_hall_cnt == 1) { // counted up
 681:MotorControl/encoder.cpp ****                                 edge_idx = hall_cnt;
 682:MotorControl/encoder.cpp ****                             } else if (mod_hall_cnt == 5) { // counted down
 683:MotorControl/encoder.cpp ****                                 edge_idx = last_hall_cnt_.value();
 684:MotorControl/encoder.cpp ****                             } else {
 685:MotorControl/encoder.cpp ****                                 set_error(ERROR_ILLEGAL_HALL_STATE);
 686:MotorControl/encoder.cpp ****                                 return false;
 687:MotorControl/encoder.cpp ****                             }
 688:MotorControl/encoder.cpp **** 
 689:MotorControl/encoder.cpp ****                             auto maybe_phase = axis_->open_loop_controller_.phase_.any();
 690:MotorControl/encoder.cpp ****                             if (maybe_phase) {
 691:MotorControl/encoder.cpp ****                                 float phase = maybe_phase.value();
 692:MotorControl/encoder.cpp ****                                 // Early increment to get the right divisor in recursive average
 693:MotorControl/encoder.cpp ****                                 hall_phase_calib_seen_count_[edge_idx]++;
 694:MotorControl/encoder.cpp ****                                 float& edge_phase = config_.hall_edge_phcnt[edge_idx];
 695:MotorControl/encoder.cpp ****                                 if (hall_phase_calib_seen_count_[edge_idx] == 1)
 696:MotorControl/encoder.cpp ****                                     edge_phase = phase;
 697:MotorControl/encoder.cpp ****                                 else {
 698:MotorControl/encoder.cpp ****                                     // circularly wrapped recursive average
 699:MotorControl/encoder.cpp ****                                     edge_phase += (phase - edge_phase) / hall_phase_calib_seen_coun
 700:MotorControl/encoder.cpp ****                                     edge_phase = wrap_pm_pi(edge_phase);
 701:MotorControl/encoder.cpp ****                                 }
 702:MotorControl/encoder.cpp ****                             }
 703:MotorControl/encoder.cpp ****                         }
 704:MotorControl/encoder.cpp ****                     skip:
 705:MotorControl/encoder.cpp ****                         last_hall_cnt_ = hall_cnt;
 706:MotorControl/encoder.cpp **** 
 707:MotorControl/encoder.cpp ****                         return true; // Skip all velocity and phase estimation
 708:MotorControl/encoder.cpp ****                     }
 709:MotorControl/encoder.cpp **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 263


 710:MotorControl/encoder.cpp ****                     delta_enc = hall_cnt - count_in_cpr_;
 711:MotorControl/encoder.cpp ****                     delta_enc = mod(delta_enc, 6);
 712:MotorControl/encoder.cpp ****                     if (delta_enc > 3)
 713:MotorControl/encoder.cpp ****                         delta_enc -= 6;
 714:MotorControl/encoder.cpp ****                 } else {
 715:MotorControl/encoder.cpp ****                     if (!config_.ignore_illegal_hall_state) {
 716:MotorControl/encoder.cpp ****                         set_error(ERROR_ILLEGAL_HALL_STATE);
 717:MotorControl/encoder.cpp ****                         return false;
 718:MotorControl/encoder.cpp ****                     }
 719:MotorControl/encoder.cpp ****                 }
 720:MotorControl/encoder.cpp ****             }
 721:MotorControl/encoder.cpp ****         } break;
 722:MotorControl/encoder.cpp **** 
 723:MotorControl/encoder.cpp ****         case MODE_SINCOS: {
 724:MotorControl/encoder.cpp ****             float phase = fast_atan2(sincos_sample_s_, sincos_sample_c_);
 725:MotorControl/encoder.cpp ****             int fake_count = (int)(1000.0f * phase);
 726:MotorControl/encoder.cpp ****             //CPR = 6283 = 2pi * 1k
 727:MotorControl/encoder.cpp **** 
 728:MotorControl/encoder.cpp ****             delta_enc = fake_count - count_in_cpr_;
 729:MotorControl/encoder.cpp ****             delta_enc = mod(delta_enc, 6283);
 730:MotorControl/encoder.cpp ****             if (delta_enc > 6283/2)
 731:MotorControl/encoder.cpp ****                 delta_enc -= 6283;
 732:MotorControl/encoder.cpp ****         } break;
 733:MotorControl/encoder.cpp ****         
 734:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_RLS:
 5340              		.loc 3 734 9 is_stmt 1 view .LVU1342
 735:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_AMS:
 5341              		.loc 3 735 9 view .LVU1343
 736:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_CUI: 
 5342              		.loc 3 736 9 view .LVU1344
 737:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_AEAT:
 5343              		.loc 3 737 9 view .LVU1345
 738:MotorControl/encoder.cpp ****         case MODE_SPI_ABS_MA732: {
 5344              		.loc 3 738 9 view .LVU1346
 5345              		.loc 3 738 34 view .LVU1347
 739:MotorControl/encoder.cpp ****             if (abs_spi_pos_updated_ == false) {
 5346              		.loc 3 739 13 view .LVU1348
 5347              		.loc 3 739 17 is_stmt 0 view .LVU1349
 5348 005a 90F83861 		ldrb	r6, [r0, #312]	@ zero_extendqisi2
 5349              		.loc 3 739 13 view .LVU1350
 5350 005e 002E     		cmp	r6, #0
 5351 0060 40F01982 		bne	.L309
 740:MotorControl/encoder.cpp ****                 // Low pass filter the error
 741:MotorControl/encoder.cpp ****                 spi_error_rate_ += current_meas_period * (1.0f - spi_error_rate_);
 5352              		.loc 3 741 17 is_stmt 1 view .LVU1351
 5353              		.loc 3 741 33 is_stmt 0 view .LVU1352
 5354 0064 D0ED337A 		vldr.32	s15, [r0, #204]
 5355              		.loc 3 741 64 view .LVU1353
 5356 0068 B7EE007A 		vmov.f32	s14, #1.0e+0
 5357 006c 37EE677A 		vsub.f32	s14, s14, s15
 5358              		.loc 3 741 56 view .LVU1354
 5359 0070 DFEDDD6A 		vldr.32	s13, .L367
 5360 0074 27EE267A 		vmul.f32	s14, s14, s13
 5361              		.loc 3 741 33 view .LVU1355
 5362 0078 77EE877A 		vadd.f32	s15, s15, s14
 5363 007c C0ED337A 		vstr.32	s15, [r0, #204]
 742:MotorControl/encoder.cpp ****                 if (spi_error_rate_ > 0.05f) {
ARM GAS  /tmp/cc5nV8qb.s 			page 264


 5364              		.loc 3 742 17 is_stmt 1 view .LVU1356
 5365 0080 9FEDDA7A 		vldr.32	s14, .L367+4
 5366 0084 F4EEC77A 		vcmpe.f32	s15, s14
 5367 0088 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5368 008c 40F31182 		ble	.L310
 743:MotorControl/encoder.cpp ****                     set_error(ERROR_ABS_SPI_COM_FAIL);
 5369              		.loc 3 743 21 view .LVU1357
 5370              		.loc 3 743 30 is_stmt 0 view .LVU1358
 5371 0090 8021     		movs	r1, #128
 5372 0092 FFF7FEFF 		bl	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
 5373              	.LVL416:
 744:MotorControl/encoder.cpp ****                     return false;
 5374              		.loc 3 744 21 is_stmt 1 view .LVU1359
 5375              		.loc 3 744 28 is_stmt 0 view .LVU1360
 5376 0096 2CE1     		b	.L307
 5377              	.LVL417:
 5378              	.L286:
 660:MotorControl/encoder.cpp ****             //TODO: use count_in_cpr_ instead as shadow_count_ can overflow
 5379              		.loc 3 660 9 is_stmt 1 view .LVU1361
 660:MotorControl/encoder.cpp ****             //TODO: use count_in_cpr_ instead as shadow_count_ can overflow
 5380              		.loc 3 660 32 view .LVU1362
 5381              	.LBB2051:
 663:MotorControl/encoder.cpp ****             delta_enc = (int32_t)delta_enc_16; //sign extend
 5382              		.loc 3 663 13 view .LVU1363
 663:MotorControl/encoder.cpp ****             delta_enc = (int32_t)delta_enc_16; //sign extend
 5383              		.loc 3 663 45 is_stmt 0 view .LVU1364
 5384 0098 B0F9EA60 		ldrsh	r6, [r0, #234]
 663:MotorControl/encoder.cpp ****             delta_enc = (int32_t)delta_enc_16; //sign extend
 5385              		.loc 3 663 36 view .LVU1365
 5386 009c B6B2     		uxth	r6, r6
 663:MotorControl/encoder.cpp ****             delta_enc = (int32_t)delta_enc_16; //sign extend
 5387              		.loc 3 663 72 view .LVU1366
 5388 009e D0F89030 		ldr	r3, [r0, #144]
 663:MotorControl/encoder.cpp ****             delta_enc = (int32_t)delta_enc_16; //sign extend
 5389              		.loc 3 663 61 view .LVU1367
 5390 00a2 F61A     		subs	r6, r6, r3
 663:MotorControl/encoder.cpp ****             delta_enc = (int32_t)delta_enc_16; //sign extend
 5391              		.loc 3 663 21 view .LVU1368
 5392 00a4 36B2     		sxth	r6, r6
 5393              	.LVL418:
 664:MotorControl/encoder.cpp ****         } break;
 5394              		.loc 3 664 13 is_stmt 1 view .LVU1369
 664:MotorControl/encoder.cpp ****         } break;
 5395              		.loc 3 664 13 is_stmt 0 view .LVU1370
 5396              	.LBE2051:
 665:MotorControl/encoder.cpp **** 
 5397              		.loc 3 665 11 is_stmt 1 view .LVU1371
 5398              	.L290:
 745:MotorControl/encoder.cpp ****                 }
 746:MotorControl/encoder.cpp ****             } else {
 747:MotorControl/encoder.cpp ****                 // Low pass filter the error
 748:MotorControl/encoder.cpp ****                 spi_error_rate_ += current_meas_period * (0.0f - spi_error_rate_);
 749:MotorControl/encoder.cpp ****             }
 750:MotorControl/encoder.cpp **** 
 751:MotorControl/encoder.cpp ****             abs_spi_pos_updated_ = false;
 752:MotorControl/encoder.cpp ****             delta_enc = pos_abs_latched - count_in_cpr_; //LATCH
 753:MotorControl/encoder.cpp ****             delta_enc = mod(delta_enc, config_.cpr);
ARM GAS  /tmp/cc5nV8qb.s 			page 265


 754:MotorControl/encoder.cpp ****             if (delta_enc > config_.cpr/2) {
 755:MotorControl/encoder.cpp ****                 delta_enc -= config_.cpr;
 756:MotorControl/encoder.cpp ****             }
 757:MotorControl/encoder.cpp **** 
 758:MotorControl/encoder.cpp ****         }break;
 759:MotorControl/encoder.cpp ****         default: {
 760:MotorControl/encoder.cpp ****             set_error(ERROR_UNSUPPORTED_ENCODER_MODE);
 761:MotorControl/encoder.cpp ****             return false;
 762:MotorControl/encoder.cpp ****         } break;
 5399              		.loc 3 762 11 view .LVU1372
 5400              	.LBE2065:
 5401              	.LBE2070:
 763:MotorControl/encoder.cpp ****     }
 764:MotorControl/encoder.cpp **** 
 765:MotorControl/encoder.cpp ****     shadow_count_ += delta_enc;
 5402              		.loc 3 765 5 view .LVU1373
 5403              		.loc 3 765 19 is_stmt 0 view .LVU1374
 5404 00a6 D4F89030 		ldr	r3, [r4, #144]
 5405 00aa 06EB0308 		add	r8, r6, r3
 5406 00ae C4F89080 		str	r8, [r4, #144]
 766:MotorControl/encoder.cpp ****     count_in_cpr_ += delta_enc;
 5407              		.loc 3 766 5 is_stmt 1 view .LVU1375
 5408              		.loc 3 766 19 is_stmt 0 view .LVU1376
 5409 00b2 D4F89430 		ldr	r3, [r4, #148]
 5410 00b6 3344     		add	r3, r3, r6
 5411 00b8 C4F89430 		str	r3, [r4, #148]
 767:MotorControl/encoder.cpp ****     count_in_cpr_ = mod(count_in_cpr_, config_.cpr);
 5412              		.loc 3 767 5 is_stmt 1 view .LVU1377
 5413              		.loc 3 767 48 is_stmt 0 view .LVU1378
 5414 00bc 276D     		ldr	r7, [r4, #80]
 5415              	.LVL419:
 5416              	.LBB2071:
 5417              	.LBI2071:
 154:./MotorControl/utils.hpp ****     int r = dividend % divisor;
 5418              		.loc 17 154 12 is_stmt 1 view .LVU1379
 5419              	.LBB2072:
 155:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 5420              		.loc 17 155 5 view .LVU1380
 155:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 5421              		.loc 17 155 9 is_stmt 0 view .LVU1381
 5422 00be 93FBF7F2 		sdiv	r2, r3, r7
 5423 00c2 07FB1233 		mls	r3, r7, r2, r3
 5424              	.LVL420:
 156:./MotorControl/utils.hpp ****     return r;
 5425              		.loc 17 156 5 is_stmt 1 view .LVU1382
 5426 00c6 002B     		cmp	r3, #0
 5427 00c8 C0F21082 		blt	.L351
 5428              	.L313:
 5429              		.loc 17 157 5 view .LVU1383
 5430              	.LVL421:
 5431              		.loc 17 157 5 is_stmt 0 view .LVU1384
 5432              	.LBE2072:
 5433              	.LBE2071:
 5434              		.loc 3 767 19 view .LVU1385
 5435 00cc C4F89430 		str	r3, [r4, #148]
 768:MotorControl/encoder.cpp **** 
 769:MotorControl/encoder.cpp ****     if(mode_ & MODE_FLAG_ABS)
ARM GAS  /tmp/cc5nV8qb.s 			page 266


 5436              		.loc 3 769 5 is_stmt 1 view .LVU1386
 5437              		.loc 3 769 8 is_stmt 0 view .LVU1387
 5438 00d0 B4F83A31 		ldrh	r3, [r4, #314]
 5439              		.loc 3 769 5 view .LVU1388
 5440 00d4 13F4807F 		tst	r3, #256
 5441 00d8 01D0     		beq	.L314
 770:MotorControl/encoder.cpp ****         count_in_cpr_ = pos_abs_latched;
 5442              		.loc 3 770 9 is_stmt 1 view .LVU1389
 5443              		.loc 3 770 23 is_stmt 0 view .LVU1390
 5444 00da C4F89450 		str	r5, [r4, #148]
 5445              	.L314:
 771:MotorControl/encoder.cpp **** 
 772:MotorControl/encoder.cpp ****     // Memory for pos_circular
 773:MotorControl/encoder.cpp ****     float pos_cpr_counts_last = pos_cpr_counts_;
 5446              		.loc 3 773 5 is_stmt 1 view .LVU1391
 5447              		.loc 3 773 11 is_stmt 0 view .LVU1392
 5448 00de D4ED2C9A 		vldr.32	s19, [r4, #176]
 5449              	.LVL422:
 774:MotorControl/encoder.cpp **** 
 775:MotorControl/encoder.cpp ****     //// run pll (for now pll is in units of encoder counts)
 776:MotorControl/encoder.cpp ****     // Predict current pos
 777:MotorControl/encoder.cpp ****     pos_estimate_counts_ += current_meas_period * vel_estimate_counts_;
 5450              		.loc 3 777 5 is_stmt 1 view .LVU1393
 5451              		.loc 3 777 51 is_stmt 0 view .LVU1394
 5452 00e2 94ED2EAA 		vldr.32	s20, [r4, #184]
 5453              		.loc 3 777 49 view .LVU1395
 5454 00e6 9FEDC08A 		vldr.32	s16, .L367
 5455 00ea 2AEE088A 		vmul.f32	s16, s20, s16
 5456              		.loc 3 777 26 view .LVU1396
 5457 00ee 94ED2B0A 		vldr.32	s0, [r4, #172]
 5458 00f2 38EE009A 		vadd.f32	s18, s16, s0
 5459 00f6 84ED2B9A 		vstr.32	s18, [r4, #172]
 778:MotorControl/encoder.cpp ****     pos_cpr_counts_      += current_meas_period * vel_estimate_counts_;
 5460              		.loc 3 778 5 is_stmt 1 view .LVU1397
 5461              		.loc 3 778 26 is_stmt 0 view .LVU1398
 5462 00fa 38EE298A 		vadd.f32	s16, s16, s19
 5463 00fe 84ED2C8A 		vstr.32	s16, [r4, #176]
 779:MotorControl/encoder.cpp ****     // Encoder model
 780:MotorControl/encoder.cpp ****     auto encoder_model = [this](float internal_pos)->int32_t {
 5464              		.loc 3 780 5 is_stmt 1 view .LVU1399
 781:MotorControl/encoder.cpp ****         if (config_.mode == MODE_HALL)
 782:MotorControl/encoder.cpp ****             return hall_model(internal_pos);
 783:MotorControl/encoder.cpp ****         else
 784:MotorControl/encoder.cpp ****             return (int32_t)std::floor(internal_pos);
 785:MotorControl/encoder.cpp ****     };
 786:MotorControl/encoder.cpp ****     // discrete phase detector
 787:MotorControl/encoder.cpp ****     float delta_pos_counts = (float)(shadow_count_ - encoder_model(pos_estimate_counts_));
 5465              		.loc 3 787 5 view .LVU1400
 5466              	.LVL423:
 5467              	.LBB2074:
 5468              	.LBI2074:
 780:MotorControl/encoder.cpp ****         if (config_.mode == MODE_HALL)
 5469              		.loc 3 780 26 view .LVU1401
 5470              	.LBB2075:
 781:MotorControl/encoder.cpp ****         if (config_.mode == MODE_HALL)
 5471              		.loc 3 781 9 view .LVU1402
 781:MotorControl/encoder.cpp ****         if (config_.mode == MODE_HALL)
ARM GAS  /tmp/cc5nV8qb.s 			page 267


 5472              		.loc 3 781 21 is_stmt 0 view .LVU1403
 5473 0102 A38E     		ldrh	r3, [r4, #52]
 781:MotorControl/encoder.cpp ****         if (config_.mode == MODE_HALL)
 5474              		.loc 3 781 9 view .LVU1404
 5475 0104 012B     		cmp	r3, #1
 5476 0106 00F0F381 		beq	.L352
 784:MotorControl/encoder.cpp ****     };
 5477              		.loc 3 784 13 is_stmt 1 view .LVU1405
 5478              	.LVL424:
 5479              	.LBB2076:
 5480              	.LBI2076:
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_floorf(__x); }
 5481              		.loc 21 260 3 view .LVU1406
 5482              	.LBB2077:
 5483              		.loc 21 261 5 view .LVU1407
 5484              		.loc 21 261 28 is_stmt 0 view .LVU1408
 5485 010a B0EE490A 		vmov.f32	s0, s18
 5486 010e FFF7FEFF 		bl	floorf
 5487              	.LVL425:
 5488              		.loc 21 261 28 view .LVU1409
 5489              	.LBE2077:
 5490              	.LBE2076:
 784:MotorControl/encoder.cpp ****     };
 5491              		.loc 3 784 52 view .LVU1410
 5492 0112 FDEEC07A 		vcvt.s32.f32	s15, s0
 5493 0116 17EE900A 		vmov	r0, s15	@ int
 5494              	.L316:
 5495              	.LVL426:
 784:MotorControl/encoder.cpp ****     };
 5496              		.loc 3 784 52 view .LVU1411
 5497              	.LBE2075:
 5498              	.LBE2074:
 5499              		.loc 3 787 52 view .LVU1412
 5500 011a A8EB0008 		sub	r8, r8, r0
 5501              		.loc 3 787 89 view .LVU1413
 5502 011e 07EE908A 		vmov	s15, r8	@ int
 5503 0122 F8EEE78A 		vcvt.f32.s32	s17, s15
 5504              	.LVL427:
 788:MotorControl/encoder.cpp ****     float delta_pos_cpr_counts = (float)(count_in_cpr_ - encoder_model(pos_cpr_counts_));
 5505              		.loc 3 788 5 is_stmt 1 view .LVU1414
 5506              		.loc 3 788 42 is_stmt 0 view .LVU1415
 5507 0126 D4F89450 		ldr	r5, [r4, #148]
 5508              	.LVL428:
 5509              	.LBB2079:
 5510              	.LBI2079:
 780:MotorControl/encoder.cpp ****         if (config_.mode == MODE_HALL)
 5511              		.loc 3 780 26 is_stmt 1 view .LVU1416
 5512              	.LBB2080:
 781:MotorControl/encoder.cpp ****             return hall_model(internal_pos);
 5513              		.loc 3 781 9 view .LVU1417
 781:MotorControl/encoder.cpp ****             return hall_model(internal_pos);
 5514              		.loc 3 781 21 is_stmt 0 view .LVU1418
 5515 012a A38E     		ldrh	r3, [r4, #52]
 781:MotorControl/encoder.cpp ****             return hall_model(internal_pos);
 5516              		.loc 3 781 9 view .LVU1419
 5517 012c 012B     		cmp	r3, #1
 5518 012e 00F0E581 		beq	.L353
ARM GAS  /tmp/cc5nV8qb.s 			page 268


 784:MotorControl/encoder.cpp ****     };
 5519              		.loc 3 784 13 is_stmt 1 view .LVU1420
 5520              	.LVL429:
 5521              	.LBB2081:
 5522              	.LBI2081:
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath ****   { return __builtin_floorf(__x); }
 5523              		.loc 21 260 3 view .LVU1421
 5524              	.LBB2082:
 5525              		.loc 21 261 5 view .LVU1422
 5526              		.loc 21 261 28 is_stmt 0 view .LVU1423
 5527 0132 B0EE480A 		vmov.f32	s0, s16
 5528 0136 FFF7FEFF 		bl	floorf
 5529              	.LVL430:
 5530              		.loc 21 261 28 view .LVU1424
 5531              	.LBE2082:
 5532              	.LBE2081:
 784:MotorControl/encoder.cpp ****     };
 5533              		.loc 3 784 52 view .LVU1425
 5534 013a FDEEC07A 		vcvt.s32.f32	s15, s0
 5535 013e 17EE900A 		vmov	r0, s15	@ int
 5536              	.L318:
 5537              	.LVL431:
 784:MotorControl/encoder.cpp ****     };
 5538              		.loc 3 784 52 view .LVU1426
 5539              	.LBE2080:
 5540              	.LBE2079:
 5541              		.loc 3 788 56 view .LVU1427
 5542 0142 2B1A     		subs	r3, r5, r0
 5543 0144 07EE903A 		vmov	s15, r3	@ int
 5544              		.loc 3 788 88 view .LVU1428
 5545 0148 F8EEE77A 		vcvt.f32.s32	s15, s15
 5546              	.LVL432:
 789:MotorControl/encoder.cpp ****     delta_pos_cpr_counts = wrap_pm(delta_pos_cpr_counts, (float)(config_.cpr));
 5547              		.loc 3 789 5 is_stmt 1 view .LVU1429
 5548              		.loc 3 789 35 is_stmt 0 view .LVU1430
 5549 014c 07EE107A 		vmov	s14, r7	@ int
 5550 0150 B8EEC77A 		vcvt.f32.s32	s14, s14
 5551              	.LVL433:
 5552              	.LBB2084:
 5553              	.LBI2084:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 5554              		.loc 17 123 14 is_stmt 1 view .LVU1431
 5555              	.LBB2085:
 125:./MotorControl/utils.hpp **** #else
 5556              		.loc 17 125 5 view .LVU1432
 125:./MotorControl/utils.hpp **** #else
 5557              		.loc 17 125 36 is_stmt 0 view .LVU1433
 5558 0154 C7EE876A 		vdiv.f32	s13, s15, s14
 5559              	.LVL434:
 5560              	.LBB2086:
 5561              	.LBI2086:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 5562              		.loc 17 108 12 is_stmt 1 view .LVU1434
 5563              	.LBB2087:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 5564              		.loc 17 110 5 view .LVU1435
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
ARM GAS  /tmp/cc5nV8qb.s 			page 269


 5565              		.loc 17 111 5 view .LVU1436
 5566              		.syntax unified
 5567              	@ 111 "./MotorControl/utils.hpp" 1
 5568 0158 FDEE666A 		vcvtr.s32.f32   s13, s13
 5569              	@ 0 "" 2
 5570              	.LVL435:
 114:./MotorControl/utils.hpp **** #else
 5571              		.loc 17 114 5 view .LVU1437
 114:./MotorControl/utils.hpp **** #else
 5572              		.loc 17 114 5 is_stmt 0 view .LVU1438
 5573              		.thumb
 5574              		.syntax unified
 5575              	.LBE2087:
 5576              	.LBE2086:
 125:./MotorControl/utils.hpp **** #else
 5577              		.loc 17 125 42 view .LVU1439
 5578 015c F8EEE66A 		vcvt.f32.s32	s13, s13
 5579              	.LVL436:
 129:./MotorControl/utils.hpp **** }
 5580              		.loc 17 129 5 is_stmt 1 view .LVU1440
 129:./MotorControl/utils.hpp **** }
 5581              		.loc 17 129 23 is_stmt 0 view .LVU1441
 5582 0160 67EE266A 		vmul.f32	s13, s14, s13
 5583              	.LVL437:
 129:./MotorControl/utils.hpp **** }
 5584              		.loc 17 129 25 view .LVU1442
 5585 0164 77EEE67A 		vsub.f32	s15, s15, s13
 5586              	.LVL438:
 129:./MotorControl/utils.hpp **** }
 5587              		.loc 17 129 25 view .LVU1443
 5588              	.LBE2085:
 5589              	.LBE2084:
 790:MotorControl/encoder.cpp ****     delta_pos_cpr_counts_ += 0.1f * (delta_pos_cpr_counts - delta_pos_cpr_counts_); // for debug
 5590              		.loc 3 790 5 is_stmt 1 view .LVU1444
 5591              		.loc 3 790 27 is_stmt 0 view .LVU1445
 5592 0168 D4ED2D6A 		vldr.32	s13, [r4, #180]
 5593              		.loc 3 790 59 view .LVU1446
 5594 016c 37EEE66A 		vsub.f32	s12, s15, s13
 5595              		.loc 3 790 35 view .LVU1447
 5596 0170 DFED9F5A 		vldr.32	s11, .L367+8
 5597 0174 26EE256A 		vmul.f32	s12, s12, s11
 5598              		.loc 3 790 27 view .LVU1448
 5599 0178 76EE866A 		vadd.f32	s13, s13, s12
 5600 017c C4ED2D6A 		vstr.32	s13, [r4, #180]
 791:MotorControl/encoder.cpp ****     // pll feedback
 792:MotorControl/encoder.cpp ****     pos_estimate_counts_ += current_meas_period * pll_kp_ * delta_pos_counts;
 5601              		.loc 3 792 5 is_stmt 1 view .LVU1449
 5602              		.loc 3 792 51 is_stmt 0 view .LVU1450
 5603 0180 D4ED2F6A 		vldr.32	s13, [r4, #188]
 5604              		.loc 3 792 49 view .LVU1451
 5605 0184 9FED986A 		vldr.32	s12, .L367
 5606 0188 66EE866A 		vmul.f32	s13, s13, s12
 5607              		.loc 3 792 59 view .LVU1452
 5608 018c 26EEA80A 		vmul.f32	s0, s13, s17
 5609              		.loc 3 792 26 view .LVU1453
 5610 0190 39EE000A 		vadd.f32	s0, s18, s0
 5611 0194 84ED2B0A 		vstr.32	s0, [r4, #172]
ARM GAS  /tmp/cc5nV8qb.s 			page 270


 793:MotorControl/encoder.cpp ****     pos_cpr_counts_ += current_meas_period * pll_kp_ * delta_pos_cpr_counts;
 5612              		.loc 3 793 5 is_stmt 1 view .LVU1454
 5613              		.loc 3 793 54 is_stmt 0 view .LVU1455
 5614 0198 66EEA76A 		vmul.f32	s13, s13, s15
 5615              		.loc 3 793 21 view .LVU1456
 5616 019c 38EE268A 		vadd.f32	s16, s16, s13
 5617 01a0 84ED2C8A 		vstr.32	s16, [r4, #176]
 794:MotorControl/encoder.cpp ****     pos_cpr_counts_ = fmodf_pos(pos_cpr_counts_, (float)(config_.cpr));
 5618              		.loc 3 794 5 is_stmt 1 view .LVU1457
 5619              	.LVL439:
 5620              	.LBB2088:
 5621              	.LBI2088:
 133:./MotorControl/utils.hpp ****     float res = wrap_pm(x, y);
 5622              		.loc 17 133 14 view .LVU1458
 5623              	.LBB2089:
 134:./MotorControl/utils.hpp ****     if (res < 0) res += y;
 5624              		.loc 17 134 5 view .LVU1459
 5625              	.LBB2090:
 5626              	.LBI2090:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 5627              		.loc 17 123 14 view .LVU1460
 5628              	.LBB2091:
 125:./MotorControl/utils.hpp **** #else
 5629              		.loc 17 125 5 view .LVU1461
 125:./MotorControl/utils.hpp **** #else
 5630              		.loc 17 125 36 is_stmt 0 view .LVU1462
 5631 01a4 C8EE076A 		vdiv.f32	s13, s16, s14
 5632              	.LVL440:
 5633              	.LBB2092:
 5634              	.LBI2092:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 5635              		.loc 17 108 12 is_stmt 1 view .LVU1463
 5636              	.LBB2093:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 5637              		.loc 17 110 5 view .LVU1464
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 5638              		.loc 17 111 5 view .LVU1465
 5639              		.syntax unified
 5640              	@ 111 "./MotorControl/utils.hpp" 1
 5641 01a8 FDEE666A 		vcvtr.s32.f32   s13, s13
 5642              	@ 0 "" 2
 5643              	.LVL441:
 114:./MotorControl/utils.hpp **** #else
 5644              		.loc 17 114 5 view .LVU1466
 114:./MotorControl/utils.hpp **** #else
 5645              		.loc 17 114 5 is_stmt 0 view .LVU1467
 5646              		.thumb
 5647              		.syntax unified
 5648              	.LBE2093:
 5649              	.LBE2092:
 125:./MotorControl/utils.hpp **** #else
 5650              		.loc 17 125 42 view .LVU1468
 5651 01ac F8EEE66A 		vcvt.f32.s32	s13, s13
 5652              	.LVL442:
 129:./MotorControl/utils.hpp **** }
 5653              		.loc 17 129 5 is_stmt 1 view .LVU1469
 129:./MotorControl/utils.hpp **** }
ARM GAS  /tmp/cc5nV8qb.s 			page 271


 5654              		.loc 17 129 23 is_stmt 0 view .LVU1470
 5655 01b0 67EE266A 		vmul.f32	s13, s14, s13
 5656              	.LVL443:
 129:./MotorControl/utils.hpp **** }
 5657              		.loc 17 129 25 view .LVU1471
 5658 01b4 38EE668A 		vsub.f32	s16, s16, s13
 5659              	.LVL444:
 129:./MotorControl/utils.hpp **** }
 5660              		.loc 17 129 25 view .LVU1472
 5661              	.LBE2091:
 5662              	.LBE2090:
 135:./MotorControl/utils.hpp ****     return res;
 5663              		.loc 17 135 5 is_stmt 1 view .LVU1473
 5664 01b8 B5EEC08A 		vcmpe.f32	s16, #0
 5665 01bc F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5666 01c0 00F1A281 		bmi	.L354
 5667              	.L319:
 136:./MotorControl/utils.hpp **** }
 5668              		.loc 17 136 5 view .LVU1474
 5669              	.LVL445:
 136:./MotorControl/utils.hpp **** }
 5670              		.loc 17 136 5 is_stmt 0 view .LVU1475
 5671              	.LBE2089:
 5672              	.LBE2088:
 5673              		.loc 3 794 21 view .LVU1476
 5674 01c4 84ED2C8A 		vstr.32	s16, [r4, #176]
 795:MotorControl/encoder.cpp ****     vel_estimate_counts_ += current_meas_period * pll_ki_ * delta_pos_cpr_counts;
 5675              		.loc 3 795 5 is_stmt 1 view .LVU1477
 5676              		.loc 3 795 51 is_stmt 0 view .LVU1478
 5677 01c8 94ED306A 		vldr.32	s12, [r4, #192]
 5678              		.loc 3 795 49 view .LVU1479
 5679 01cc DFED866A 		vldr.32	s13, .L367
 5680 01d0 66EE266A 		vmul.f32	s13, s12, s13
 5681              		.loc 3 795 59 view .LVU1480
 5682 01d4 66EEA77A 		vmul.f32	s15, s13, s15
 5683              	.LVL446:
 5684              		.loc 3 795 26 view .LVU1481
 5685 01d8 7AEE277A 		vadd.f32	s15, s20, s15
 5686 01dc C4ED2E7A 		vstr.32	s15, [r4, #184]
 796:MotorControl/encoder.cpp ****     bool snap_to_zero_vel = false;
 5687              		.loc 3 796 5 is_stmt 1 view .LVU1482
 5688              	.LVL447:
 797:MotorControl/encoder.cpp ****     if (std::abs(vel_estimate_counts_) < 0.5f * current_meas_period * pll_ki_) {
 5689              		.loc 3 797 5 view .LVU1483
 5690              	.LBB2095:
 5691              	.LBI2095:
 5692              		.file 22 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // -*- C++ -*- C library enhancements header.
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // Copyright (C) 2016-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 272


  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** /** @file include/bits/std_abs.h
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****  *  This is an internal header file, included by other library headers.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****  *  Do not attempt to use it directly. @headername{cmath, cstdlib}
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****  */
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #ifndef _GLIBCXX_BITS_STD_ABS_H
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #define _GLIBCXX_BITS_STD_ABS_H
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #pragma GCC system_header
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #include <bits/c++config.h>
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #define _GLIBCXX_INCLUDE_NEXT_C_HEADERS
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #include_next <stdlib.h>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #ifdef __CORRECT_ISO_CPP_MATH_H_PROTO
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** # include_next <math.h>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #endif
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #undef _GLIBCXX_INCLUDE_NEXT_C_HEADERS
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #undef abs
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** extern "C++"
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** {
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** namespace std _GLIBCXX_VISIBILITY(default)
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** {
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   using ::abs;
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #ifndef __CORRECT_ISO_CPP_STDLIB_H_PROTO
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   inline long
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   abs(long __i) { return __builtin_labs(__i); }
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #endif
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #ifdef _GLIBCXX_USE_LONG_LONG
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   inline long long
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   abs(long long __x) { return __builtin_llabs (__x); }
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #endif
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // _GLIBCXX_RESOLVE_LIB_DEFECTS
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // 2192. Validity and return type of std::abs(0u) is unclear
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // 2294. <cstdlib> should declare abs(double)
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // 2735. std::abs(short), std::abs(signed char) and others should return int
ARM GAS  /tmp/cc5nV8qb.s 			page 273


  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   inline _GLIBCXX_CONSTEXPR double
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   abs(double __x)
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   { return __builtin_fabs(__x); }
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   inline _GLIBCXX_CONSTEXPR float
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   abs(float __x)
 5693              		.loc 22 75 3 view .LVU1484
 5694              	.LBB2096:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   { return __builtin_fabsf(__x); }
 5695              		.loc 22 76 5 view .LVU1485
 5696              		.loc 22 76 31 is_stmt 0 view .LVU1486
 5697 01e0 F0EEE77A 		vabs.f32	s15, s15
 5698              	.LVL448:
 5699              		.loc 22 76 31 view .LVU1487
 5700              	.LBE2096:
 5701              	.LBE2095:
 5702              		.loc 3 797 69 view .LVU1488
 5703 01e4 DFED836A 		vldr.32	s13, .L367+12
 5704 01e8 26EE266A 		vmul.f32	s12, s12, s13
 5705              		.loc 3 797 5 view .LVU1489
 5706 01ec B4EEE76A 		vcmpe.f32	s12, s15
 5707 01f0 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5708 01f4 40F38B81 		ble	.L348
 798:MotorControl/encoder.cpp ****         vel_estimate_counts_ = 0.0f;  //align delta-sigma on zero to prevent jitter
 5709              		.loc 3 798 9 is_stmt 1 view .LVU1490
 5710              		.loc 3 798 30 is_stmt 0 view .LVU1491
 5711 01f8 0023     		movs	r3, #0
 5712              		.loc 3 798 30 view .LVU1492
 5713 01fa C4F8B830 		str	r3, [r4, #184]	@ float
 799:MotorControl/encoder.cpp ****         snap_to_zero_vel = true;
 5714              		.loc 3 799 9 is_stmt 1 view .LVU1493
 5715              	.LVL449:
 5716              		.loc 3 799 26 is_stmt 0 view .LVU1494
 5717 01fe 0121     		movs	r1, #1
 5718              	.LVL450:
 5719              	.L321:
 800:MotorControl/encoder.cpp ****     }
 801:MotorControl/encoder.cpp **** 
 802:MotorControl/encoder.cpp ****     // Outputs from Encoder for Controller
 803:MotorControl/encoder.cpp ****     pos_estimate_ = pos_estimate_counts_ / (float)config_.cpr;
 5720              		.loc 3 803 5 is_stmt 1 view .LVU1495
 5721              		.loc 3 803 19 is_stmt 0 view .LVU1496
 5722 0200 C0EE077A 		vdiv.f32	s15, s0, s14
 5723              	.LVL451:
 5724              	.LBB2097:
 5725              	.LBI2097:
  48:./MotorControl/component.hpp ****     
  49:./MotorControl/component.hpp ****     /**
  50:./MotorControl/component.hpp ****      * @brief Updates the underlying value of this output port.
  51:./MotorControl/component.hpp ****      */
  52:./MotorControl/component.hpp ****     void operator=(T value) {
 5726              		.loc 13 52 10 is_stmt 1 view .LVU1497
 5727              	.LBB2098:
  53:./MotorControl/component.hpp ****         content_ = value;
 5728              		.loc 13 53 18 is_stmt 0 view .LVU1498
ARM GAS  /tmp/cc5nV8qb.s 			page 274


 5729 0204 C4ED357A 		vstr.32	s15, [r4, #212]
  54:./MotorControl/component.hpp ****         age_ = 0;
 5730              		.loc 13 54 14 view .LVU1499
 5731 0208 0023     		movs	r3, #0
 5732 020a C4F8D030 		str	r3, [r4, #208]
 5733              	.LVL452:
 5734              		.loc 13 54 14 view .LVU1500
 5735              	.LBE2098:
 5736              	.LBE2097:
 804:MotorControl/encoder.cpp ****     vel_estimate_ = vel_estimate_counts_ / (float)config_.cpr;
 5737              		.loc 3 804 5 is_stmt 1 view .LVU1501
 5738              		.loc 3 804 21 is_stmt 0 view .LVU1502
 5739 020e D4ED2E6A 		vldr.32	s13, [r4, #184]
 5740              		.loc 3 804 19 view .LVU1503
 5741 0212 C6EE877A 		vdiv.f32	s15, s13, s14
 5742 0216 04F1D805 		add	r5, r4, #216
 5743              	.LVL453:
 5744              	.LBB2099:
 5745              	.LBI2099:
  52:./MotorControl/component.hpp ****         content_ = value;
 5746              		.loc 13 52 10 is_stmt 1 view .LVU1504
 5747              	.LBB2100:
  53:./MotorControl/component.hpp ****         age_ = 0;
 5748              		.loc 13 53 18 is_stmt 0 view .LVU1505
 5749 021a C4ED377A 		vstr.32	s15, [r4, #220]
 5750              		.loc 13 54 14 view .LVU1506
 5751 021e C4F8D830 		str	r3, [r4, #216]
 5752              	.LVL454:
 5753              		.loc 13 54 14 view .LVU1507
 5754              	.LBE2100:
 5755              	.LBE2099:
 805:MotorControl/encoder.cpp ****     
 806:MotorControl/encoder.cpp ****     // TODO: we should strictly require that this value is from the previous iteration
 807:MotorControl/encoder.cpp ****     // to avoid spinout scenarios. However that requires a proper way to reset
 808:MotorControl/encoder.cpp ****     // the encoder from error states.
 809:MotorControl/encoder.cpp ****     float pos_circular = pos_circular_.any().value_or(0.0f);
 5756              		.loc 3 809 5 is_stmt 1 view .LVU1508
 5757              	.LBB2101:
 5758              	.LBI2101:
  55:./MotorControl/component.hpp ****     }
  56:./MotorControl/component.hpp **** 
  57:./MotorControl/component.hpp ****     /**
  58:./MotorControl/component.hpp ****      * @brief Marks the contained value as outdated. The value is not actually
  59:./MotorControl/component.hpp ****      * deleted and can still be accessed through some of the member functions
  60:./MotorControl/component.hpp ****      * of this class.
  61:./MotorControl/component.hpp ****      */
  62:./MotorControl/component.hpp ****     void reset() {
  63:./MotorControl/component.hpp ****         // This will eventually overflow to 0 so present() could
  64:./MotorControl/component.hpp ****         // theoretically return a very old value however it is very likely that
  65:./MotorControl/component.hpp ****         // the motor will be long disarmed by then.
  66:./MotorControl/component.hpp ****         age_++;
  67:./MotorControl/component.hpp ****     }
  68:./MotorControl/component.hpp **** 
  69:./MotorControl/component.hpp ****     /**
  70:./MotorControl/component.hpp ****      * @brief Returns the value from this control loop iteration or std::nullopt
  71:./MotorControl/component.hpp ****      * if the value was not yet set during this control loop iteration.
  72:./MotorControl/component.hpp ****      */
ARM GAS  /tmp/cc5nV8qb.s 			page 275


  73:./MotorControl/component.hpp ****     std::optional<T> present() {
  74:./MotorControl/component.hpp ****         if (age_ == 0) {
  75:./MotorControl/component.hpp ****             return content_;
  76:./MotorControl/component.hpp ****         } else {
  77:./MotorControl/component.hpp ****             return std::nullopt;
  78:./MotorControl/component.hpp ****         }
  79:./MotorControl/component.hpp ****     }
  80:./MotorControl/component.hpp **** 
  81:./MotorControl/component.hpp ****     /**
  82:./MotorControl/component.hpp ****      * @brief Returns the value from exactly the previous control loop iteration.
  83:./MotorControl/component.hpp ****      * 
  84:./MotorControl/component.hpp ****      * If during the last iteration no value was set or the value was already
  85:./MotorControl/component.hpp ****      * overwritten during this control loop iteration then this function returns
  86:./MotorControl/component.hpp ****      * std::nullopt.
  87:./MotorControl/component.hpp ****      */
  88:./MotorControl/component.hpp ****     std::optional<T> previous() {
  89:./MotorControl/component.hpp ****         if (age_ == 1) {
  90:./MotorControl/component.hpp ****             return content_;
  91:./MotorControl/component.hpp ****         } else {
  92:./MotorControl/component.hpp ****             return std::nullopt;
  93:./MotorControl/component.hpp ****         }
  94:./MotorControl/component.hpp ****     }
  95:./MotorControl/component.hpp **** 
  96:./MotorControl/component.hpp ****     /**
  97:./MotorControl/component.hpp ****      * @brief Returns the value contained in this output port with disregard of
  98:./MotorControl/component.hpp ****      * when the value was set.
  99:./MotorControl/component.hpp ****      * 
 100:./MotorControl/component.hpp ****      * This function is thread-safe if load/store operations of T are atomic.
 101:./MotorControl/component.hpp ****      */
 102:./MotorControl/component.hpp ****     std::optional<T> any() {
 5759              		.loc 13 102 22 view .LVU1509
 5760              	.LBB2102:
 5761              	.LBB2103:
 5762              	.LBI2103:
 693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Converting constructors for engaged optionals.
 695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp,
 696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_self<_Up>, __not_tag<_Up>,
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, _Up&&>,
 698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_convertible<_Up&&, _Tp>> = true>
 699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(_Up&& __t)
 5763              		.loc 14 700 2 view .LVU1510
 5764              	.LBB2104:
 5765              	.LBB2105:
 5766              	.LBB2106:
 5767              	.LBI2106:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 5768              		.loc 7 76 5 view .LVU1511
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 5769              		.loc 7 76 5 is_stmt 0 view .LVU1512
 5770              	.LBE2106:
 5771              	.LBB2107:
 5772              	.LBI2107:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 5773              		.loc 14 607 28 is_stmt 1 view .LVU1513
 5774              	.LBB2108:
ARM GAS  /tmp/cc5nV8qb.s 			page 276


 5775              	.LBB2109:
 5776              	.LBB2110:
 5777              	.LBI2110:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 5778              		.loc 7 76 5 view .LVU1514
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 5779              		.loc 7 76 5 is_stmt 0 view .LVU1515
 5780              	.LBE2110:
 5781              	.LBB2111:
 5782              	.LBI2111:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 5783              		.loc 14 300 42 is_stmt 1 view .LVU1516
 5784              	.LBB2112:
 5785              	.LBB2113:
 5786              	.LBB2114:
 5787              	.LBI2114:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 5788              		.loc 14 115 2 view .LVU1517
 5789              	.LBB2115:
 5790              	.LBB2116:
 5791              	.LBB2117:
 5792              	.LBI2117:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 5793              		.loc 7 76 5 view .LVU1518
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 5794              		.loc 7 76 5 is_stmt 0 view .LVU1519
 5795              	.LBE2117:
 5796              	.LBB2118:
 5797              	.LBI2118:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 5798              		.loc 14 203 6 is_stmt 1 view .LVU1520
 5799              	.LBB2119:
 5800              	.LBB2120:
 5801              	.LBB2121:
 5802              	.LBI2121:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 5803              		.loc 7 76 5 view .LVU1521
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 5804              		.loc 7 76 5 is_stmt 0 view .LVU1522
 5805              	.LBE2121:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 5806              		.loc 14 204 47 view .LVU1523
 5807 0222 D4F8E430 		ldr	r3, [r4, #228]	@ float
 5808 0226 0493     		str	r3, [sp, #16]	@ float
 5809              	.LVL455:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 5810              		.loc 14 204 47 view .LVU1524
 5811              	.LBE2120:
 5812              	.LBE2119:
 5813              	.LBE2118:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 5814              		.loc 14 117 19 view .LVU1525
 5815 0228 0123     		movs	r3, #1
 5816 022a 8DF81430 		strb	r3, [sp, #20]
 5817              	.LVL456:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 5818              		.loc 14 117 19 view .LVU1526
ARM GAS  /tmp/cc5nV8qb.s 			page 277


 5819              	.LBE2116:
 5820              	.LBE2115:
 5821              	.LBE2114:
 5822              	.LBE2113:
 5823              	.LBE2112:
 5824              	.LBE2111:
 5825              	.LBE2109:
 5826              	.LBE2108:
 5827              	.LBE2107:
 5828              	.LBE2105:
 5829              	.LBE2104:
 5830              	.LBE2103:
 5831              	.LBE2102:
 5832              	.LBE2101:
 5833              	.LBB2122:
 5834              	.LBI2122:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp,
 704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_self<_Up>, __not_tag<_Up>,
 705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, _Up&&>,
 706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<is_convertible<_Up&&, _Tp>>> = false>
 707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(_Up&& __t)
 709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _Base(std::in_place, std::forward<_Up>(__t)) { }
 710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up,
 712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_<is_same<_Tp, _Up>>,
 713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, const _Up&>,
 714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_convertible<const _Up&, _Tp>,
 715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<__converts_from_optional<_Tp, _Up>>> = true>
 716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(const optional<_Up>& __t)
 718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(*__t);
 721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up,
 724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_<is_same<_Tp, _Up>>,
 725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, const _Up&>,
 726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<is_convertible<const _Up&, _Tp>>,
 727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<__converts_from_optional<_Tp, _Up>>> = false>
 728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(const optional<_Up>& __t)
 730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(*__t);
 733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template <typename _Up,
 736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		_Requires<__not_<is_same<_Tp, _Up>>,
 737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_constructible<_Tp, _Up&&>,
 738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_convertible<_Up&&, _Tp>,
 739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<__converts_from_optional<_Tp, _Up>>> = true>
 740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(optional<_Up>&& __t)
ARM GAS  /tmp/cc5nV8qb.s 			page 278


 742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(std::move(*__t));
 745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template <typename _Up,
 748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		_Requires<__not_<is_same<_Tp, _Up>>,
 749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_constructible<_Tp, _Up&&>,
 750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<is_convertible<_Up&&, _Tp>>,
 751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<__converts_from_optional<_Tp, _Up>>> = false>
 752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(optional<_Up>&& __t)
 754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(std::move(*__t));
 757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<is_constructible<_Tp, _Args&&...>> = false>
 761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(in_place_t, _Args&&... __args)
 763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Args>(__args)...) { }
 764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<is_constructible<_Tp,
 767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  initializer_list<_Up>&,
 768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  _Args&&...>> = false>
 769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(in_place_t, initializer_list<_Up> __il, _Args&&... __args)
 771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, __il, std::forward<_Args>(__args)...) { }
 772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       optional&
 775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(nullopt_t) noexcept
 776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_reset();
 778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp>
 782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<__and_v<__not_self<_Up>,
 783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__and_<is_scalar<_Tp>,
 784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  is_same<_Tp, decay_t<_Up>>>>,
 785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, _Up>,
 786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, _Up>>,
 787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(_Up&& __u)
 789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (this->_M_is_engaged())
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_get() = std::forward<_Up>(__u);
 792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_construct(std::forward<_Up>(__u));
 794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
 796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
ARM GAS  /tmp/cc5nV8qb.s 			page 279


 799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
 800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, const _Up&>,
 801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, const _Up&>,
 802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__converts_from_optional<_Tp, _Up>>,
 803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__assigns_from_optional<_Tp, _Up>>>,
 804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(const optional<_Up>& __u)
 806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__u)
 808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      if (this->_M_is_engaged())
 810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_get() = *__u;
 811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      else
 812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_construct(*__u);
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
 819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, _Up>,
 824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, _Up>,
 825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__converts_from_optional<_Tp, _Up>>,
 826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__assigns_from_optional<_Tp, _Up>>>,
 827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(optional<_Up>&& __u)
 829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__u)
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      if (this->_M_is_engaged())
 833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_get() = std::move(*__u);
 834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      else
 835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_construct(std::move(*__u));
 836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
 843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<is_constructible_v<_Tp, _Args&&...>, _Tp&>
 847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	emplace(_Args&&... __args)
 848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_reset();
 850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(std::forward<_Args>(__args)...);
 851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_get();
 852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args>
 855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&,
ARM GAS  /tmp/cc5nV8qb.s 			page 280


 856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 				       _Args&&...>, _Tp&>
 857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	emplace(initializer_list<_Up> __il, _Args&&... __args)
 858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_reset();
 860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(__il, std::forward<_Args>(__args)...);
 861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_get();
 862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Destructor is implicit, implemented in _Optional_base.
 865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Swap.
 867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       void
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       swap(optional& __other)
 869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>
 870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       && is_nothrow_swappable_v<_Tp>)
 871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using std::swap;
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_is_engaged() && __other._M_is_engaged())
 875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  swap(this->_M_get(), __other._M_get());
 876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else if (this->_M_is_engaged())
 877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    __other._M_construct(std::move(this->_M_get()));
 879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_destruct();
 880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else if (__other._M_is_engaged())
 882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_construct(std::move(__other._M_get()));
 884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    __other._M_destruct();
 885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Observers.
 889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp*
 890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator->() const
 891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::__addressof(this->_M_get()); }
 892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp*
 894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator->()
 895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::__addressof(this->_M_get()); }
 896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*() const&
 899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_get(); }
 900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*()&
 903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_get(); }
 904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&&
 906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*()&&
 907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::move(this->_M_get()); }
 908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&&
 910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*() const&&
 911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::move(this->_M_get()); }
 912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 281


 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr explicit operator bool() const noexcept
 914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr bool has_value() const noexcept
 917:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 918:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 919:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 920:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value() const&
 921:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 922:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 923:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? this->_M_get()
 924:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), this->_M_get());
 925:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 926:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 927:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 928:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value()&
 929:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 930:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 931:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? this->_M_get()
 932:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), this->_M_get());
 933:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 934:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 935:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&&
 936:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value()&&
 937:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 938:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 939:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? std::move(this->_M_get())
 940:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), std::move(this->_M_get()));
 941:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 942:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 943:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&&
 944:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value() const&&
 945:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 946:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 947:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? std::move(this->_M_get())
 948:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), std::move(this->_M_get()));
 949:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 950:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 952:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr _Tp
 953:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	value_or(_Up&& __u) const&
 954:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 955:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_copy_constructible_v<_Tp>);
 956:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_convertible_v<_Up&&, _Tp>);
 957:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 958:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_is_engaged()
 959:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    ? this->_M_get() : static_cast<_Tp>(std::forward<_Up>(__u));
 960:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 961:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 962:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 963:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr _Tp
 964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	value_or(_Up&& __u) &&
 5835              		.loc 14 964 2 is_stmt 1 view .LVU1527
 5836              	.LBB2123:
 5837              	.LBB2124:
 5838              	.LBI2124:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
ARM GAS  /tmp/cc5nV8qb.s 			page 282


 5839              		.loc 14 433 22 view .LVU1528
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 5840              		.loc 14 433 22 is_stmt 0 view .LVU1529
 5841              	.LBE2124:
 5842              	.LBE2123:
 5843              	.LBE2122:
 810:MotorControl/encoder.cpp ****     pos_circular +=  wrap_pm((pos_cpr_counts_ - pos_cpr_counts_last) / (float)config_.cpr, 1.0f);
 5844              		.loc 3 810 5 is_stmt 1 view .LVU1530
 5845              		.loc 3 810 31 is_stmt 0 view .LVU1531
 5846 022e D4ED2C7A 		vldr.32	s15, [r4, #176]
 5847              		.loc 3 810 47 view .LVU1532
 5848 0232 77EEE99A 		vsub.f32	s19, s15, s19
 5849              	.LVL457:
 5850              		.loc 3 810 72 view .LVU1533
 5851 0236 D4ED147A 		vldr.32	s15, [r4, #80]	@ int
 5852 023a F8EEE76A 		vcvt.f32.s32	s13, s15
 5853              		.loc 3 810 29 view .LVU1534
 5854 023e C9EEA67A 		vdiv.f32	s15, s19, s13
 5855              	.LVL458:
 5856              	.LBB2125:
 5857              	.LBI2125:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 5858              		.loc 17 123 14 is_stmt 1 view .LVU1535
 5859              	.LBB2126:
 125:./MotorControl/utils.hpp **** #else
 5860              		.loc 17 125 5 view .LVU1536
 5861              	.LBB2127:
 5862              	.LBI2127:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 5863              		.loc 17 108 12 view .LVU1537
 5864              	.LBB2128:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 5865              		.loc 17 110 5 view .LVU1538
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 5866              		.loc 17 111 5 view .LVU1539
 5867              		.syntax unified
 5868              	@ 111 "./MotorControl/utils.hpp" 1
 5869 0242 BDEE677A 		vcvtr.s32.f32   s14, s15
 5870              	@ 0 "" 2
 5871              	.LVL459:
 114:./MotorControl/utils.hpp **** #else
 5872              		.loc 17 114 5 view .LVU1540
 114:./MotorControl/utils.hpp **** #else
 5873              		.loc 17 114 5 is_stmt 0 view .LVU1541
 5874              		.thumb
 5875              		.syntax unified
 5876              	.LBE2128:
 5877              	.LBE2127:
 125:./MotorControl/utils.hpp **** #else
 5878              		.loc 17 125 42 view .LVU1542
 5879 0246 B8EEC77A 		vcvt.f32.s32	s14, s14
 5880              	.LVL460:
 129:./MotorControl/utils.hpp **** }
 5881              		.loc 17 129 5 is_stmt 1 view .LVU1543
 129:./MotorControl/utils.hpp **** }
 5882              		.loc 17 129 25 is_stmt 0 view .LVU1544
 5883 024a 77EEC77A 		vsub.f32	s15, s15, s14
ARM GAS  /tmp/cc5nV8qb.s 			page 283


 5884              	.LVL461:
 129:./MotorControl/utils.hpp **** }
 5885              		.loc 17 129 25 view .LVU1545
 5886              	.LBE2126:
 5887              	.LBE2125:
 5888              		.loc 3 810 18 view .LVU1546
 5889 024e 9DED047A 		vldr.32	s14, [sp, #16]
 5890 0252 77EE877A 		vadd.f32	s15, s15, s14
 5891              	.LVL462:
 811:MotorControl/encoder.cpp ****     pos_circular = fmodf_pos(pos_circular, axis_->controller_.config_.circular_setpoint_range);
 5892              		.loc 3 811 5 is_stmt 1 view .LVU1547
 5893              		.loc 3 811 44 is_stmt 0 view .LVU1548
 5894 0256 226B     		ldr	r2, [r4, #48]
 5895              		.loc 3 811 51 view .LVU1549
 5896 0258 D2F80031 		ldr	r3, [r2, #256]
 5897              		.loc 3 811 29 view .LVU1550
 5898 025c 93ED106A 		vldr.32	s12, [r3, #64]
 5899              	.LVL463:
 5900              	.LBB2129:
 5901              	.LBI2129:
 133:./MotorControl/utils.hpp ****     float res = wrap_pm(x, y);
 5902              		.loc 17 133 14 is_stmt 1 view .LVU1551
 5903              	.LBB2130:
 134:./MotorControl/utils.hpp ****     if (res < 0) res += y;
 5904              		.loc 17 134 5 view .LVU1552
 5905              	.LBB2131:
 5906              	.LBI2131:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 5907              		.loc 17 123 14 view .LVU1553
 5908              	.LBB2132:
 125:./MotorControl/utils.hpp **** #else
 5909              		.loc 17 125 5 view .LVU1554
 125:./MotorControl/utils.hpp **** #else
 5910              		.loc 17 125 36 is_stmt 0 view .LVU1555
 5911 0260 87EE867A 		vdiv.f32	s14, s15, s12
 5912              	.LVL464:
 5913              	.LBB2133:
 5914              	.LBI2133:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 5915              		.loc 17 108 12 is_stmt 1 view .LVU1556
 5916              	.LBB2134:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 5917              		.loc 17 110 5 view .LVU1557
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 5918              		.loc 17 111 5 view .LVU1558
 5919              		.syntax unified
 5920              	@ 111 "./MotorControl/utils.hpp" 1
 5921 0264 BDEE477A 		vcvtr.s32.f32   s14, s14
 5922              	@ 0 "" 2
 5923              	.LVL465:
 114:./MotorControl/utils.hpp **** #else
 5924              		.loc 17 114 5 view .LVU1559
 114:./MotorControl/utils.hpp **** #else
 5925              		.loc 17 114 5 is_stmt 0 view .LVU1560
 5926              		.thumb
 5927              		.syntax unified
 5928              	.LBE2134:
ARM GAS  /tmp/cc5nV8qb.s 			page 284


 5929              	.LBE2133:
 125:./MotorControl/utils.hpp **** #else
 5930              		.loc 17 125 42 view .LVU1561
 5931 0268 B8EEC77A 		vcvt.f32.s32	s14, s14
 5932              	.LVL466:
 129:./MotorControl/utils.hpp **** }
 5933              		.loc 17 129 5 is_stmt 1 view .LVU1562
 129:./MotorControl/utils.hpp **** }
 5934              		.loc 17 129 23 is_stmt 0 view .LVU1563
 5935 026c 26EE077A 		vmul.f32	s14, s12, s14
 5936              	.LVL467:
 129:./MotorControl/utils.hpp **** }
 5937              		.loc 17 129 25 view .LVU1564
 5938 0270 77EEC77A 		vsub.f32	s15, s15, s14
 5939              	.LVL468:
 129:./MotorControl/utils.hpp **** }
 5940              		.loc 17 129 25 view .LVU1565
 5941              	.LBE2132:
 5942              	.LBE2131:
 135:./MotorControl/utils.hpp ****     return res;
 5943              		.loc 17 135 5 is_stmt 1 view .LVU1566
 5944 0274 F5EEC07A 		vcmpe.f32	s15, #0
 5945 0278 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5946 027c 00F14981 		bmi	.L355
 5947              	.L324:
 136:./MotorControl/utils.hpp **** }
 5948              		.loc 17 136 5 view .LVU1567
 5949              	.LVL469:
 136:./MotorControl/utils.hpp **** }
 5950              		.loc 17 136 5 is_stmt 0 view .LVU1568
 5951              	.LBE2130:
 5952              	.LBE2129:
 812:MotorControl/encoder.cpp ****     pos_circular_ = pos_circular;
 5953              		.loc 3 812 5 is_stmt 1 view .LVU1569
 5954              	.LBB2136:
 5955              	.LBI2136:
  52:./MotorControl/component.hpp ****         content_ = value;
 5956              		.loc 13 52 10 view .LVU1570
 5957              	.LBB2137:
  53:./MotorControl/component.hpp ****         age_ = 0;
 5958              		.loc 13 53 18 is_stmt 0 view .LVU1571
 5959 0280 C4ED397A 		vstr.32	s15, [r4, #228]
  54:./MotorControl/component.hpp ****     }
 5960              		.loc 13 54 14 view .LVU1572
 5961 0284 0023     		movs	r3, #0
 5962 0286 C4F8E030 		str	r3, [r4, #224]
 5963              	.LVL470:
  54:./MotorControl/component.hpp ****     }
 5964              		.loc 13 54 14 view .LVU1573
 5965              	.LBE2137:
 5966              	.LBE2136:
 813:MotorControl/encoder.cpp **** 
 814:MotorControl/encoder.cpp ****     //// run encoder count interpolation
 815:MotorControl/encoder.cpp ****     int32_t corrected_enc = count_in_cpr_ - config_.phase_offset;
 5967              		.loc 3 815 5 is_stmt 1 view .LVU1574
 5968              		.loc 3 815 29 is_stmt 0 view .LVU1575
 5969 028a D4F89430 		ldr	r3, [r4, #148]
ARM GAS  /tmp/cc5nV8qb.s 			page 285


 5970              		.loc 3 815 53 view .LVU1576
 5971 028e A06C     		ldr	r0, [r4, #72]
 5972              		.loc 3 815 13 view .LVU1577
 5973 0290 1B1A     		subs	r3, r3, r0
 5974 0292 07EE903A 		vmov	s15, r3	@ int
 5975              	.LVL471:
 816:MotorControl/encoder.cpp ****     // if we are stopped, make sure we don't randomly drift
 817:MotorControl/encoder.cpp ****     if (snap_to_zero_vel || !config_.enable_phase_interpolation) {
 5976              		.loc 3 817 5 is_stmt 1 view .LVU1578
 5977 0296 21B9     		cbnz	r1, .L326
 5978              		.loc 3 817 38 is_stmt 0 discriminator 1 view .LVU1579
 5979 0298 94F86130 		ldrb	r3, [r4, #97]	@ zero_extendqisi2
 5980              	.LVL472:
 5981              		.loc 3 817 26 discriminator 1 view .LVU1580
 5982 029c 002B     		cmp	r3, #0
 5983 029e 40F03B81 		bne	.L327
 5984              	.L326:
 818:MotorControl/encoder.cpp ****         interpolation_ = 0.5f;
 5985              		.loc 3 818 9 is_stmt 1 view .LVU1581
 5986              		.loc 3 818 24 is_stmt 0 view .LVU1582
 5987 02a2 4FF07C53 		mov	r3, #1056964608
 5988 02a6 C4F89830 		str	r3, [r4, #152]	@ float
 5989              	.L328:
 819:MotorControl/encoder.cpp ****     // reset interpolation if encoder edge comes
 820:MotorControl/encoder.cpp ****     // TODO: This isn't correct. At high velocities the first phase in this count may very well not
 821:MotorControl/encoder.cpp ****     } else if (delta_enc > 0) {
 822:MotorControl/encoder.cpp ****         interpolation_ = 0.0f;
 823:MotorControl/encoder.cpp ****     } else if (delta_enc < 0) {
 824:MotorControl/encoder.cpp ****         interpolation_ = 1.0f;
 825:MotorControl/encoder.cpp ****     } else {
 826:MotorControl/encoder.cpp ****         // Interpolate (predict) between encoder counts using vel_estimate,
 827:MotorControl/encoder.cpp ****         interpolation_ += current_meas_period * vel_estimate_counts_;
 828:MotorControl/encoder.cpp ****         // don't allow interpolation indicated position outside of [enc, enc+1)
 829:MotorControl/encoder.cpp ****         if (interpolation_ > 1.0f) interpolation_ = 1.0f;
 830:MotorControl/encoder.cpp ****         if (interpolation_ < 0.0f) interpolation_ = 0.0f;
 831:MotorControl/encoder.cpp ****     }
 832:MotorControl/encoder.cpp ****     float interpolated_enc = corrected_enc + interpolation_;
 5990              		.loc 3 832 5 is_stmt 1 view .LVU1583
 5991              		.loc 3 832 44 is_stmt 0 view .LVU1584
 5992 02aa F8EEE77A 		vcvt.f32.s32	s15, s15
 5993              	.LVL473:
 5994              		.loc 3 832 46 view .LVU1585
 5995 02ae 94ED267A 		vldr.32	s14, [r4, #152]
 5996              		.loc 3 832 11 view .LVU1586
 5997 02b2 77EE877A 		vadd.f32	s15, s15, s14
 5998              	.LVL474:
 833:MotorControl/encoder.cpp **** 
 834:MotorControl/encoder.cpp ****     //// compute electrical phase
 835:MotorControl/encoder.cpp ****     //TODO avoid recomputing elec_rad_per_enc every time
 836:MotorControl/encoder.cpp ****     float elec_rad_per_enc = axis_->motor_.config_.pole_pairs * 2 * M_PI * (1.0f / (float)(config_.
 5999              		.loc 3 836 5 is_stmt 1 view .LVU1587
 6000              		.loc 3 836 37 is_stmt 0 view .LVU1588
 6001 02b6 D2F85831 		ldr	r3, [r2, #344]
 6002              		.loc 3 836 52 view .LVU1589
 6003 02ba 1B6A     		ldr	r3, [r3, #32]
 6004              		.loc 3 836 63 view .LVU1590
 6005 02bc 5B00     		lsls	r3, r3, #1
ARM GAS  /tmp/cc5nV8qb.s 			page 286


 6006 02be 07EE103A 		vmov	s14, r3	@ int
 6007              		.loc 3 836 67 view .LVU1591
 6008 02c2 B8EEC77A 		vcvt.f32.s32	s14, s14
 6009 02c6 9FED4C6A 		vldr.32	s12, .L367+16
 6010 02ca 27EE067A 		vmul.f32	s14, s14, s12
 6011              		.loc 3 836 82 view .LVU1592
 6012 02ce F7EE005A 		vmov.f32	s11, #1.0e+0
 6013 02d2 85EEA66A 		vdiv.f32	s12, s11, s13
 6014              		.loc 3 836 11 view .LVU1593
 6015 02d6 27EE067A 		vmul.f32	s14, s14, s12
 6016              	.LVL475:
 837:MotorControl/encoder.cpp ****     float ph = elec_rad_per_enc * (interpolated_enc - config_.phase_offset_float);
 6017              		.loc 3 837 5 is_stmt 1 view .LVU1594
 6018              		.loc 3 837 63 is_stmt 0 view .LVU1595
 6019 02da D4ED136A 		vldr.32	s13, [r4, #76]
 6020              		.loc 3 837 53 view .LVU1596
 6021 02de 77EEE67A 		vsub.f32	s15, s15, s13
 6022              	.LVL476:
 6023              		.loc 3 837 11 view .LVU1597
 6024 02e2 67EE877A 		vmul.f32	s15, s15, s14
 6025              	.LVL477:
 838:MotorControl/encoder.cpp ****     
 839:MotorControl/encoder.cpp ****     if (is_ready_) {
 6026              		.loc 3 839 5 is_stmt 1 view .LVU1598
 6027              		.loc 3 839 9 is_stmt 0 view .LVU1599
 6028 02e6 94F88F60 		ldrb	r6, [r4, #143]	@ zero_extendqisi2
 6029              	.LVL478:
 6030              		.loc 3 839 5 view .LVU1600
 6031 02ea 002E     		cmp	r6, #0
 6032 02ec 40F04281 		bne	.L356
 840:MotorControl/encoder.cpp ****         phase_ = wrap_pm_pi(ph) * config_.direction;
 841:MotorControl/encoder.cpp ****         phase_vel_ = (2*M_PI) * *vel_estimate_.present() * axis_->motor_.config_.pole_pairs * confi
 842:MotorControl/encoder.cpp ****     }
 843:MotorControl/encoder.cpp **** 
 844:MotorControl/encoder.cpp ****     return true;
 6033              		.loc 3 844 12 view .LVU1601
 6034 02f0 0126     		movs	r6, #1
 6035              	.LVL479:
 6036              	.L307:
 845:MotorControl/encoder.cpp **** }
 6037              		.loc 3 845 1 discriminator 5 view .LVU1602
 6038 02f2 3046     		mov	r0, r6
 6039 02f4 08B0     		add	sp, sp, #32
 6040              	.LCFI55:
 6041              		.cfi_remember_state
 6042              		.cfi_def_cfa_offset 48
 6043              		@ sp needed
 6044 02f6 BDEC068B 		vldm	sp!, {d8-d10}
 6045              	.LCFI56:
 6046              		.cfi_restore 84
 6047              		.cfi_restore 85
 6048              		.cfi_restore 82
 6049              		.cfi_restore 83
 6050              		.cfi_restore 80
 6051              		.cfi_restore 81
 6052              		.cfi_def_cfa_offset 24
 6053 02fa BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
ARM GAS  /tmp/cc5nV8qb.s 			page 287


 6054              	.LVL480:
 6055              	.L350:
 6056              	.LCFI57:
 6057              		.cfi_restore_state
 6058              	.LBB2138:
 6059              	.LBB2066:
 6060              	.LBB2052:
 6061              	.LBB2047:
 6062              	.LBB1963:
 673:MotorControl/encoder.cpp ****                 if (decode_hall((hall_state_ ^ config_.hall_polarity), &hall_cnt)) {
 6063              		.loc 3 673 17 is_stmt 1 view .LVU1603
 674:MotorControl/encoder.cpp ****                     if (calibrate_hall_phase_) {
 6064              		.loc 3 674 17 view .LVU1604
 6065              	.LBB1964:
 674:MotorControl/encoder.cpp ****                     if (calibrate_hall_phase_) {
 6066              		.loc 3 674 34 is_stmt 0 view .LVU1605
 6067 02fe 94F8F200 		ldrb	r0, [r4, #242]	@ zero_extendqisi2
 674:MotorControl/encoder.cpp ****                     if (calibrate_hall_phase_) {
 6068              		.loc 3 674 56 view .LVU1606
 6069 0302 94F86430 		ldrb	r3, [r4, #100]	@ zero_extendqisi2
 674:MotorControl/encoder.cpp ****                     if (calibrate_hall_phase_) {
 6070              		.loc 3 674 32 view .LVU1607
 6071 0306 01A9     		add	r1, sp, #4
 6072 0308 5840     		eors	r0, r0, r3
 6073 030a FFF7FEFF 		bl	_ZL11decode_hallhPl
 6074              	.LVL481:
 674:MotorControl/encoder.cpp ****                     if (calibrate_hall_phase_) {
 6075              		.loc 3 674 17 view .LVU1608
 6076 030e 0028     		cmp	r0, #0
 6077 0310 00F08D80 		beq	.L292
 6078              	.LBB1965:
 675:MotorControl/encoder.cpp ****                         if (sample_hall_phase_ && last_hall_cnt_.has_value()) {
 6079              		.loc 3 675 21 is_stmt 1 view .LVU1609
 6080              	.LBB1966:
 675:MotorControl/encoder.cpp ****                         if (sample_hall_phase_ && last_hall_cnt_.has_value()) {
 6081              		.loc 3 675 25 is_stmt 0 view .LVU1610
 6082 0314 94F8F560 		ldrb	r6, [r4, #245]	@ zero_extendqisi2
 675:MotorControl/encoder.cpp ****                         if (sample_hall_phase_ && last_hall_cnt_.has_value()) {
 6083              		.loc 3 675 21 view .LVU1611
 6084 0318 002E     		cmp	r6, #0
 6085 031a 73D0     		beq	.L293
 6086              	.LBB1967:
 676:MotorControl/encoder.cpp ****                             int mod_hall_cnt = mod(hall_cnt - last_hall_cnt_.value(), 6);
 6087              		.loc 3 676 25 is_stmt 1 view .LVU1612
 6088              	.LBB1968:
 676:MotorControl/encoder.cpp ****                             int mod_hall_cnt = mod(hall_cnt - last_hall_cnt_.value(), 6);
 6089              		.loc 3 676 29 is_stmt 0 view .LVU1613
 6090 031c 94F8F730 		ldrb	r3, [r4, #247]	@ zero_extendqisi2
 676:MotorControl/encoder.cpp ****                             int mod_hall_cnt = mod(hall_cnt - last_hall_cnt_.value(), 6);
 6091              		.loc 3 676 48 view .LVU1614
 6092 0320 002B     		cmp	r3, #0
 6093 0322 46D0     		beq	.L294
 6094              	.LVL482:
 6095              	.LBB1969:
 6096              	.LBI1969:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 6097              		.loc 14 916 22 is_stmt 1 discriminator 1 view .LVU1615
ARM GAS  /tmp/cc5nV8qb.s 			page 288


 6098              	.LBB1970:
 6099              	.LBI1970:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 6100              		.loc 14 433 22 discriminator 1 view .LVU1616
 6101              	.LBB1971:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 6102              		.loc 14 434 58 is_stmt 0 discriminator 1 view .LVU1617
 6103 0324 94F8F430 		ldrb	r3, [r4, #244]	@ zero_extendqisi2
 6104              	.LVL483:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 6105              		.loc 14 434 58 discriminator 1 view .LVU1618
 6106              	.LBE1971:
 6107              	.LBE1970:
 6108              	.LBE1969:
 676:MotorControl/encoder.cpp ****                             int mod_hall_cnt = mod(hall_cnt - last_hall_cnt_.value(), 6);
 6109              		.loc 3 676 48 discriminator 1 view .LVU1619
 6110 0328 002B     		cmp	r3, #0
 6111 032a 42D0     		beq	.L294
 6112              	.LBB1972:
 677:MotorControl/encoder.cpp ****                             size_t edge_idx;
 6113              		.loc 3 677 29 is_stmt 1 view .LVU1620
 677:MotorControl/encoder.cpp ****                             size_t edge_idx;
 6114              		.loc 3 677 51 is_stmt 0 view .LVU1621
 6115 032c 0198     		ldr	r0, [sp, #4]
 677:MotorControl/encoder.cpp ****                             size_t edge_idx;
 6116              		.loc 3 677 83 view .LVU1622
 6117 032e 94F8F310 		ldrb	r1, [r4, #243]	@ zero_extendqisi2
 677:MotorControl/encoder.cpp ****                             size_t edge_idx;
 6118              		.loc 3 677 61 view .LVU1623
 6119 0332 421A     		subs	r2, r0, r1
 6120              	.LVL484:
 6121              	.LBB1973:
 6122              	.LBI1973:
 154:./MotorControl/utils.hpp ****     int r = dividend % divisor;
 6123              		.loc 17 154 12 is_stmt 1 view .LVU1624
 6124              	.LBB1974:
 155:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 6125              		.loc 17 155 5 view .LVU1625
 155:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 6126              		.loc 17 155 9 is_stmt 0 view .LVU1626
 6127 0334 314B     		ldr	r3, .L367+20
 6128 0336 83FB0253 		smull	r5, r3, r3, r2
 6129              	.LVL485:
 155:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 6130              		.loc 17 155 9 view .LVU1627
 6131 033a A3EBE273 		sub	r3, r3, r2, asr #31
 6132 033e 03EB4303 		add	r3, r3, r3, lsl #1
 6133              	.LVL486:
 156:./MotorControl/utils.hpp ****     return r;
 6134              		.loc 17 156 5 is_stmt 1 view .LVU1628
 6135 0342 B2EB4303 		subs	r3, r2, r3, lsl #1
 6136              	.LVL487:
 156:./MotorControl/utils.hpp ****     return r;
 6137              		.loc 17 156 5 is_stmt 0 view .LVU1629
 6138 0346 3BD4     		bmi	.L357
 6139              	.LVL488:
 6140              	.L295:
ARM GAS  /tmp/cc5nV8qb.s 			page 289


 6141              		.loc 17 157 5 is_stmt 1 view .LVU1630
 6142              		.loc 17 157 5 is_stmt 0 view .LVU1631
 6143              	.LBE1974:
 6144              	.LBE1973:
 678:MotorControl/encoder.cpp ****                             if (mod_hall_cnt == 0) { goto skip; } // no count - do nothing
 6145              		.loc 3 678 29 is_stmt 1 view .LVU1632
 679:MotorControl/encoder.cpp ****                             else if (mod_hall_cnt == 1) { // counted up
 6146              		.loc 3 679 29 view .LVU1633
 6147 0348 9BB3     		cbz	r3, .L294
 680:MotorControl/encoder.cpp ****                                 edge_idx = hall_cnt;
 6148              		.loc 3 680 34 view .LVU1634
 6149 034a 012B     		cmp	r3, #1
 6150 034c 3AD0     		beq	.L358
 682:MotorControl/encoder.cpp ****                                 edge_idx = last_hall_cnt_.value();
 6151              		.loc 3 682 36 view .LVU1635
 6152 034e 052B     		cmp	r3, #5
 6153 0350 3AD1     		bne	.L359
 6154              	.L298:
 6155              	.LVL489:
 689:MotorControl/encoder.cpp ****                             if (maybe_phase) {
 6156              		.loc 3 689 29 view .LVU1636
 689:MotorControl/encoder.cpp ****                             if (maybe_phase) {
 6157              		.loc 3 689 48 is_stmt 0 view .LVU1637
 6158 0352 236B     		ldr	r3, [r4, #48]
 6159              	.LVL490:
 6160              	.LBB1976:
 6161              	.LBI1976:
 6162              		.loc 13 102 22 is_stmt 1 view .LVU1638
 6163              	.LBB1977:
 6164              	.LBB1978:
 6165              	.LBI1978:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 6166              		.loc 14 700 2 view .LVU1639
 6167              	.LBB1979:
 6168              	.LBB1980:
 6169              	.LBB1981:
 6170              	.LBI1981:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 6171              		.loc 7 76 5 view .LVU1640
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 6172              		.loc 7 76 5 is_stmt 0 view .LVU1641
 6173              	.LBE1981:
 6174              	.LBB1982:
 6175              	.LBI1982:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 6176              		.loc 14 607 28 is_stmt 1 view .LVU1642
 6177              	.LBB1983:
 6178              	.LBB1984:
 6179              	.LBB1985:
 6180              	.LBI1985:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 6181              		.loc 7 76 5 view .LVU1643
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 6182              		.loc 7 76 5 is_stmt 0 view .LVU1644
 6183              	.LBE1985:
 6184              	.LBB1986:
 6185              	.LBI1986:
ARM GAS  /tmp/cc5nV8qb.s 			page 290


 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 6186              		.loc 14 300 42 is_stmt 1 view .LVU1645
 6187              	.LBB1987:
 6188              	.LBB1988:
 6189              	.LBB1989:
 6190              	.LBI1989:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 6191              		.loc 14 115 2 view .LVU1646
 6192              	.LBB1990:
 6193              	.LBB1991:
 6194              	.LBB1992:
 6195              	.LBI1992:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 6196              		.loc 7 76 5 view .LVU1647
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 6197              		.loc 7 76 5 is_stmt 0 view .LVU1648
 6198              	.LBE1992:
 6199              	.LBB1993:
 6200              	.LBI1993:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 6201              		.loc 14 203 6 is_stmt 1 view .LVU1649
 6202              	.LBB1994:
 6203              	.LBB1995:
 6204              	.LBB1996:
 6205              	.LBI1996:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 6206              		.loc 7 76 5 view .LVU1650
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 6207              		.loc 7 76 5 is_stmt 0 view .LVU1651
 6208              	.LBE1996:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 6209              		.loc 14 204 47 view .LVU1652
 6210 0354 D3F84431 		ldr	r3, [r3, #324]	@ float
 6211              	.LVL491:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 6212              		.loc 14 204 47 view .LVU1653
 6213 0358 0293     		str	r3, [sp, #8]	@ float
 6214              	.LVL492:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 6215              		.loc 14 204 47 view .LVU1654
 6216              	.LBE1995:
 6217              	.LBE1994:
 6218              	.LBE1993:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 6219              		.loc 14 117 19 view .LVU1655
 6220 035a 0123     		movs	r3, #1
 6221 035c 8DF80C30 		strb	r3, [sp, #12]
 6222              	.LVL493:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 6223              		.loc 14 117 19 view .LVU1656
 6224              	.LBE1991:
 6225              	.LBE1990:
 6226              	.LBE1989:
 6227              	.LBE1988:
 6228              	.LBE1987:
 6229              	.LBE1986:
 6230              	.LBE1984:
ARM GAS  /tmp/cc5nV8qb.s 			page 291


 6231              	.LBE1983:
 6232              	.LBE1982:
 6233              	.LBE1980:
 6234              	.LBE1979:
 6235              	.LBE1978:
 6236              	.LBE1977:
 6237              	.LBE1976:
 690:MotorControl/encoder.cpp ****                                 float phase = maybe_phase.value();
 6238              		.loc 3 690 29 is_stmt 1 view .LVU1657
 6239              	.LBB1997:
 6240              	.LBB1998:
 6241              	.LBI1998:
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 6242              		.loc 14 913 26 view .LVU1658
 6243              	.LBB1999:
 6244              	.LBI1999:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 6245              		.loc 14 433 22 view .LVU1659
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 6246              		.loc 14 433 22 is_stmt 0 view .LVU1660
 6247              	.LBE1999:
 6248              	.LBE1998:
 6249              	.LBB2000:
 691:MotorControl/encoder.cpp ****                                 // Early increment to get the right divisor in recursive average
 6250              		.loc 3 691 33 is_stmt 1 view .LVU1661
 691:MotorControl/encoder.cpp ****                                 // Early increment to get the right divisor in recursive average
 6251              		.loc 3 691 65 is_stmt 0 view .LVU1662
 6252 0360 DDED027A 		vldr.32	s15, [sp, #8]
 6253              	.LVL494:
 693:MotorControl/encoder.cpp ****                                 float& edge_phase = config_.hall_edge_phcnt[edge_idx];
 6254              		.loc 3 693 33 is_stmt 1 view .LVU1663
 6255              	.LBB2001:
 6256              	.LBI2001:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 6257              		.loc 18 185 7 view .LVU1664
 6258              	.LBB2002:
 6259              	.LBI2002:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 6260              		.loc 18 55 7 view .LVU1665
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 6261              		.loc 18 55 7 is_stmt 0 view .LVU1666
 6262              	.LBE2002:
 6263              	.LBE2001:
 693:MotorControl/encoder.cpp ****                                 float& edge_phase = config_.hall_edge_phcnt[edge_idx];
 6264              		.loc 3 693 71 view .LVU1667
 6265 0364 04EB8102 		add	r2, r4, r1, lsl #2
 6266 0368 D2F81831 		ldr	r3, [r2, #280]
 6267 036c 0133     		adds	r3, r3, #1
 6268 036e C2F81831 		str	r3, [r2, #280]
 694:MotorControl/encoder.cpp ****                                 if (hall_phase_calib_seen_count_[edge_idx] == 1)
 6269              		.loc 3 694 33 is_stmt 1 view .LVU1668
 6270              	.LVL495:
 6271              	.LBB2003:
 6272              	.LBI2003:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 6273              		.loc 18 185 7 view .LVU1669
 6274              	.LBB2004:
ARM GAS  /tmp/cc5nV8qb.s 			page 292


 6275              	.LBI2004:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 6276              		.loc 18 55 7 view .LVU1670
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 6277              		.loc 18 55 7 is_stmt 0 view .LVU1671
 6278              	.LBE2004:
 6279              	.LBE2003:
 695:MotorControl/encoder.cpp ****                                     edge_phase = phase;
 6280              		.loc 3 695 33 is_stmt 1 view .LVU1672
 6281 0372 012B     		cmp	r3, #1
 6282 0374 2ED0     		beq	.L360
 699:MotorControl/encoder.cpp ****                                     edge_phase = wrap_pm_pi(edge_phase);
 6283              		.loc 3 699 37 view .LVU1673
 699:MotorControl/encoder.cpp ****                                     edge_phase = wrap_pm_pi(edge_phase);
 6284              		.loc 3 699 60 is_stmt 0 view .LVU1674
 6285 0376 04EB8101 		add	r1, r4, r1, lsl #2
 6286              	.LVL496:
 699:MotorControl/encoder.cpp ****                                     edge_phase = wrap_pm_pi(edge_phase);
 6287              		.loc 3 699 60 view .LVU1675
 6288 037a 91ED1A7A 		vldr.32	s14, [r1, #104]
 699:MotorControl/encoder.cpp ****                                     edge_phase = wrap_pm_pi(edge_phase);
 6289              		.loc 3 699 58 view .LVU1676
 6290 037e 77EEC76A 		vsub.f32	s13, s15, s14
 699:MotorControl/encoder.cpp ****                                     edge_phase = wrap_pm_pi(edge_phase);
 6291              		.loc 3 699 72 view .LVU1677
 6292 0382 07EE903A 		vmov	s15, r3	@ int
 6293              	.LVL497:
 699:MotorControl/encoder.cpp ****                                     edge_phase = wrap_pm_pi(edge_phase);
 6294              		.loc 3 699 72 view .LVU1678
 6295 0386 F8EEE77A 		vcvt.f32.s32	s15, s15
 6296 038a 86EEA76A 		vdiv.f32	s12, s13, s15
 699:MotorControl/encoder.cpp ****                                     edge_phase = wrap_pm_pi(edge_phase);
 6297              		.loc 3 699 48 view .LVU1679
 6298 038e 77EE067A 		vadd.f32	s15, s14, s12
 6299 0392 C1ED1A7A 		vstr.32	s15, [r1, #104]
 700:MotorControl/encoder.cpp ****                                 }
 6300              		.loc 3 700 37 is_stmt 1 view .LVU1680
 6301              	.LVL498:
 6302              	.LBB2005:
 6303              	.LBI2005:
 139:./MotorControl/utils.hpp ****     return wrap_pm(x, 2 * M_PI);
 6304              		.loc 17 139 14 view .LVU1681
 6305              	.LBE2005:
 6306              	.LBE2000:
 6307              	.LBE1997:
 6308              	.LBE1972:
 6309              	.LBE1968:
 6310              	.LBE1967:
 6311              	.LBE1966:
 6312              	.LBE1965:
 6313              	.LBE1964:
 6314              	.LBE1963:
 6315              	.LBE2047:
 6316              	.LBE2052:
 6317              	.LBE2066:
 6318              	.LBE2138:
 140:./MotorControl/utils.hpp **** }
ARM GAS  /tmp/cc5nV8qb.s 			page 293


 6319              		.loc 17 140 5 view .LVU1682
 6320              	.LBB2139:
 6321              	.LBB2067:
 6322              	.LBB2053:
 6323              	.LBB2048:
 6324              	.LBB2044:
 6325              	.LBB2041:
 6326              	.LBB2039:
 6327              	.LBB2033:
 6328              	.LBB2031:
 6329              	.LBB2018:
 6330              	.LBB2016:
 6331              	.LBB2013:
 6332              	.LBB2011:
 6333              	.LBB2010:
 6334              	.LBB2006:
 6335              	.LBI2006:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 6336              		.loc 17 123 14 view .LVU1683
 6337              	.LBB2007:
 125:./MotorControl/utils.hpp **** #else
 6338              		.loc 17 125 5 view .LVU1684
 125:./MotorControl/utils.hpp **** #else
 6339              		.loc 17 125 36 is_stmt 0 view .LVU1685
 6340 0396 DFED1A6A 		vldr.32	s13, .L367+24
 6341 039a 87EEA67A 		vdiv.f32	s14, s15, s13
 6342              	.LVL499:
 6343              	.LBB2008:
 6344              	.LBI2008:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 6345              		.loc 17 108 12 is_stmt 1 view .LVU1686
 6346              	.LBB2009:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 6347              		.loc 17 110 5 view .LVU1687
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 6348              		.loc 17 111 5 view .LVU1688
 6349              		.syntax unified
 6350              	@ 111 "./MotorControl/utils.hpp" 1
 6351 039e BDEE477A 		vcvtr.s32.f32   s14, s14
 6352              	@ 0 "" 2
 6353              	.LVL500:
 114:./MotorControl/utils.hpp **** #else
 6354              		.loc 17 114 5 view .LVU1689
 114:./MotorControl/utils.hpp **** #else
 6355              		.loc 17 114 5 is_stmt 0 view .LVU1690
 6356              		.thumb
 6357              		.syntax unified
 6358              	.LBE2009:
 6359              	.LBE2008:
 125:./MotorControl/utils.hpp **** #else
 6360              		.loc 17 125 42 view .LVU1691
 6361 03a2 B8EEC77A 		vcvt.f32.s32	s14, s14
 6362              	.LVL501:
 129:./MotorControl/utils.hpp **** }
 6363              		.loc 17 129 5 is_stmt 1 view .LVU1692
 129:./MotorControl/utils.hpp **** }
 6364              		.loc 17 129 23 is_stmt 0 view .LVU1693
ARM GAS  /tmp/cc5nV8qb.s 			page 294


 6365 03a6 27EE267A 		vmul.f32	s14, s14, s13
 6366              	.LVL502:
 129:./MotorControl/utils.hpp **** }
 6367              		.loc 17 129 25 view .LVU1694
 6368 03aa 77EEC77A 		vsub.f32	s15, s15, s14
 6369              	.LVL503:
 129:./MotorControl/utils.hpp **** }
 6370              		.loc 17 129 25 view .LVU1695
 6371              	.LBE2007:
 6372              	.LBE2006:
 6373              	.LBE2010:
 700:MotorControl/encoder.cpp ****                                 }
 6374              		.loc 3 700 48 view .LVU1696
 6375 03ae C1ED1A7A 		vstr.32	s15, [r1, #104]
 6376              	.LVL504:
 6377              	.L294:
 700:MotorControl/encoder.cpp ****                                 }
 6378              		.loc 3 700 48 view .LVU1697
 6379              	.LBE2011:
 6380              	.LBE2013:
 6381              	.LBE2016:
 6382              	.LBE2018:
 704:MotorControl/encoder.cpp ****                         last_hall_cnt_ = hall_cnt;
 6383              		.loc 3 704 21 is_stmt 1 view .LVU1698
 705:MotorControl/encoder.cpp **** 
 6384              		.loc 3 705 25 view .LVU1699
 6385              	.LBB2019:
 6386              	.LBI2019:
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 6387              		.loc 14 788 2 view .LVU1700
 6388              	.LBB2020:
 6389              	.LBB2021:
 6390              	.LBI2021:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 6391              		.loc 14 433 22 view .LVU1701
 6392              	.LBB2022:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 6393              		.loc 14 434 58 is_stmt 0 view .LVU1702
 6394 03b2 94F8F430 		ldrb	r3, [r4, #244]	@ zero_extendqisi2
 6395              	.LVL505:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 6396              		.loc 14 434 58 view .LVU1703
 6397              	.LBE2022:
 6398              	.LBE2021:
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_get() = std::forward<_Up>(__u);
 6399              		.loc 14 790 4 view .LVU1704
 6400 03b6 83B1     		cbz	r3, .L303
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 6401              		.loc 14 791 21 view .LVU1705
 6402 03b8 019B     		ldr	r3, [sp, #4]
 6403 03ba 84F8F330 		strb	r3, [r4, #243]
 6404 03be 98E7     		b	.L307
 6405              	.LVL506:
 6406              	.L357:
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 6407              		.loc 14 791 21 view .LVU1706
 6408              	.LBE2020:
ARM GAS  /tmp/cc5nV8qb.s 			page 295


 6409              	.LBE2019:
 6410              	.LBB2028:
 6411              	.LBB2017:
 6412              	.LBB2014:
 6413              	.LBB1975:
 156:./MotorControl/utils.hpp ****     return r;
 6414              		.loc 17 156 16 is_stmt 1 view .LVU1707
 156:./MotorControl/utils.hpp ****     return r;
 6415              		.loc 17 156 18 is_stmt 0 view .LVU1708
 6416 03c0 0633     		adds	r3, r3, #6
 6417              	.LVL507:
 156:./MotorControl/utils.hpp ****     return r;
 6418              		.loc 17 156 18 view .LVU1709
 6419 03c2 C1E7     		b	.L295
 6420              	.LVL508:
 6421              	.L358:
 156:./MotorControl/utils.hpp ****     return r;
 6422              		.loc 17 156 18 view .LVU1710
 6423              	.LBE1975:
 6424              	.LBE2014:
 681:MotorControl/encoder.cpp ****                             } else if (mod_hall_cnt == 5) { // counted down
 6425              		.loc 3 681 33 is_stmt 1 view .LVU1711
 681:MotorControl/encoder.cpp ****                             } else if (mod_hall_cnt == 5) { // counted down
 6426              		.loc 3 681 42 is_stmt 0 view .LVU1712
 6427 03c4 0146     		mov	r1, r0
 6428              	.LVL509:
 681:MotorControl/encoder.cpp ****                             } else if (mod_hall_cnt == 5) { // counted down
 6429              		.loc 3 681 42 view .LVU1713
 6430 03c6 C4E7     		b	.L298
 6431              	.LVL510:
 6432              	.L359:
 685:MotorControl/encoder.cpp ****                                 return false;
 6433              		.loc 3 685 33 is_stmt 1 view .LVU1714
 685:MotorControl/encoder.cpp ****                                 return false;
 6434              		.loc 3 685 42 is_stmt 0 view .LVU1715
 6435 03c8 1021     		movs	r1, #16
 6436 03ca 2046     		mov	r0, r4
 6437 03cc FFF7FEFF 		bl	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
 6438              	.LVL511:
 686:MotorControl/encoder.cpp ****                             }
 6439              		.loc 3 686 33 is_stmt 1 view .LVU1716
 686:MotorControl/encoder.cpp ****                             }
 6440              		.loc 3 686 40 is_stmt 0 view .LVU1717
 6441 03d0 0026     		movs	r6, #0
 6442 03d2 8EE7     		b	.L307
 6443              	.LVL512:
 6444              	.L360:
 6445              	.LBB2015:
 6446              	.LBB2012:
 696:MotorControl/encoder.cpp ****                                 else {
 6447              		.loc 3 696 37 is_stmt 1 view .LVU1718
 696:MotorControl/encoder.cpp ****                                 else {
 6448              		.loc 3 696 48 is_stmt 0 view .LVU1719
 6449 03d4 C2ED1A7A 		vstr.32	s15, [r2, #104]
 6450 03d8 EBE7     		b	.L294
 6451              	.LVL513:
 6452              	.L303:
ARM GAS  /tmp/cc5nV8qb.s 			page 296


 696:MotorControl/encoder.cpp ****                                 else {
 6453              		.loc 3 696 48 view .LVU1720
 6454              	.LBE2012:
 6455              	.LBE2015:
 6456              	.LBE2017:
 6457              	.LBE2028:
 6458              	.LBB2029:
 6459              	.LBB2026:
 6460              	.LBB2023:
 6461              	.LBI2023:
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 6462              		.loc 14 415 2 is_stmt 1 view .LVU1721
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 6463              		.loc 14 415 2 is_stmt 0 view .LVU1722
 6464              	.LBE2023:
 6465              	.LBE2026:
 6466              	.LBE2029:
 6467              	.LBE2031:
 6468              	.LBE2033:
 6469              	.LBE2039:
 6470              	.LBE2041:
 6471              	.LBE2044:
 6472              	.LBE2048:
 6473              	.LBE2053:
 6474              	.LBE2067:
 6475              	.LBE2139:
 6476              		.loc 8 175 3 is_stmt 1 view .LVU1723
 6477              	.LBB2140:
 6478              	.LBB2068:
 6479              	.LBB2054:
 6480              	.LBB2049:
 6481              	.LBB2045:
 6482              	.LBB2042:
 6483              	.LBB2040:
 6484              	.LBB2034:
 6485              	.LBB2032:
 6486              	.LBB2030:
 6487              	.LBB2027:
 6488              	.LBB2025:
 6489              	.LBB2024:
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    (std::__addressof(static_cast<_Dp*>(this)->_M_payload._M_payload))
 6490              		.loc 14 418 4 is_stmt 0 view .LVU1724
 6491 03da 019B     		ldr	r3, [sp, #4]
 6492 03dc 84F8F330 		strb	r3, [r4, #243]
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 6493              		.loc 14 421 51 view .LVU1725
 6494 03e0 0123     		movs	r3, #1
 6495 03e2 84F8F430 		strb	r3, [r4, #244]
 6496              	.LVL514:
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 6497              		.loc 14 421 51 view .LVU1726
 6498              	.LBE2024:
 6499              	.LBE2025:
 6500              	.LBE2027:
 6501              	.LBE2030:
 707:MotorControl/encoder.cpp ****                     }
 6502              		.loc 3 707 25 is_stmt 1 view .LVU1727
ARM GAS  /tmp/cc5nV8qb.s 			page 297


 707:MotorControl/encoder.cpp ****                     }
 6503              		.loc 3 707 32 is_stmt 0 view .LVU1728
 6504 03e6 84E7     		b	.L307
 6505              	.L368:
 6506              		.align	2
 6507              	.L367:
 6508 03e8 6F120339 		.word	956502639
 6509 03ec CDCC4C3D 		.word	1028443341
 6510 03f0 CDCCCC3D 		.word	1036831949
 6511 03f4 6F128338 		.word	948114031
 6512 03f8 DB0F4940 		.word	1078530011
 6513 03fc ABAAAA2A 		.word	715827883
 6514 0400 DB0FC940 		.word	1086918619
 6515              	.LVL515:
 6516              	.L293:
 707:MotorControl/encoder.cpp ****                     }
 6517              		.loc 3 707 32 view .LVU1729
 6518              	.LBE2032:
 6519              	.LBE2034:
 710:MotorControl/encoder.cpp ****                     delta_enc = mod(delta_enc, 6);
 6520              		.loc 3 710 21 is_stmt 1 view .LVU1730
 710:MotorControl/encoder.cpp ****                     delta_enc = mod(delta_enc, 6);
 6521              		.loc 3 710 44 is_stmt 0 view .LVU1731
 6522 0404 D4F89420 		ldr	r2, [r4, #148]
 710:MotorControl/encoder.cpp ****                     delta_enc = mod(delta_enc, 6);
 6523              		.loc 3 710 31 view .LVU1732
 6524 0408 019B     		ldr	r3, [sp, #4]
 6525 040a 9B1A     		subs	r3, r3, r2
 6526              	.LVL516:
 711:MotorControl/encoder.cpp ****                     if (delta_enc > 3)
 6527              		.loc 3 711 21 is_stmt 1 view .LVU1733
 6528              	.LBB2035:
 6529              	.LBI2035:
 154:./MotorControl/utils.hpp ****     int r = dividend % divisor;
 6530              		.loc 17 154 12 view .LVU1734
 6531              	.LBB2036:
 155:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 6532              		.loc 17 155 5 view .LVU1735
 155:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 6533              		.loc 17 155 9 is_stmt 0 view .LVU1736
 6534 040c 784E     		ldr	r6, .L369
 6535 040e 86FB0326 		smull	r2, r6, r6, r3
 6536 0412 A6EBE376 		sub	r6, r6, r3, asr #31
 6537 0416 06EB4606 		add	r6, r6, r6, lsl #1
 6538              	.LVL517:
 156:./MotorControl/utils.hpp ****     return r;
 6539              		.loc 17 156 5 is_stmt 1 view .LVU1737
 6540 041a B3EB4606 		subs	r6, r3, r6, lsl #1
 6541              	.LVL518:
 156:./MotorControl/utils.hpp ****     return r;
 6542              		.loc 17 156 5 is_stmt 0 view .LVU1738
 6543 041e 04D4     		bmi	.L361
 6544              	.LVL519:
 6545              	.L305:
 6546              		.loc 17 157 5 is_stmt 1 view .LVU1739
 6547              		.loc 17 157 5 is_stmt 0 view .LVU1740
 6548              	.LBE2036:
ARM GAS  /tmp/cc5nV8qb.s 			page 298


 6549              	.LBE2035:
 712:MotorControl/encoder.cpp ****                         delta_enc -= 6;
 6550              		.loc 3 712 21 is_stmt 1 view .LVU1741
 6551 0420 032E     		cmp	r6, #3
 6552 0422 7FF740AE 		ble	.L290
 713:MotorControl/encoder.cpp ****                 } else {
 6553              		.loc 3 713 25 view .LVU1742
 713:MotorControl/encoder.cpp ****                 } else {
 6554              		.loc 3 713 35 is_stmt 0 view .LVU1743
 6555 0426 063E     		subs	r6, r6, #6
 6556              	.LVL520:
 713:MotorControl/encoder.cpp ****                 } else {
 6557              		.loc 3 713 35 view .LVU1744
 6558 0428 3DE6     		b	.L290
 6559              	.LVL521:
 6560              	.L361:
 6561              	.LBB2038:
 6562              	.LBB2037:
 156:./MotorControl/utils.hpp ****     return r;
 6563              		.loc 17 156 16 is_stmt 1 view .LVU1745
 156:./MotorControl/utils.hpp ****     return r;
 6564              		.loc 17 156 18 is_stmt 0 view .LVU1746
 6565 042a 0636     		adds	r6, r6, #6
 6566              	.LVL522:
 156:./MotorControl/utils.hpp ****     return r;
 6567              		.loc 17 156 18 view .LVU1747
 6568 042c F8E7     		b	.L305
 6569              	.LVL523:
 6570              	.L292:
 156:./MotorControl/utils.hpp ****     return r;
 6571              		.loc 17 156 18 view .LVU1748
 6572              	.LBE2037:
 6573              	.LBE2038:
 6574              	.LBE2040:
 715:MotorControl/encoder.cpp ****                         set_error(ERROR_ILLEGAL_HALL_STATE);
 6575              		.loc 3 715 21 is_stmt 1 view .LVU1749
 715:MotorControl/encoder.cpp ****                         set_error(ERROR_ILLEGAL_HALL_STATE);
 6576              		.loc 3 715 34 is_stmt 0 view .LVU1750
 6577 042e 94F86360 		ldrb	r6, [r4, #99]	@ zero_extendqisi2
 715:MotorControl/encoder.cpp ****                         set_error(ERROR_ILLEGAL_HALL_STATE);
 6578              		.loc 3 715 21 view .LVU1751
 6579 0432 0EB1     		cbz	r6, .L362
 6580              	.LBE2042:
 6581              	.LBE2045:
 6582              	.LBE2049:
 6583              	.LBE2054:
 6584              	.LBE2068:
 6585              	.LBE2140:
 656:MotorControl/encoder.cpp ****     int32_t pos_abs_latched = pos_abs_; //LATCH
 6586              		.loc 3 656 13 view .LVU1752
 6587 0434 0026     		movs	r6, #0
 656:MotorControl/encoder.cpp ****     int32_t pos_abs_latched = pos_abs_; //LATCH
 6588              		.loc 3 656 13 view .LVU1753
 6589 0436 36E6     		b	.L290
 6590              	.L362:
 6591              	.LBB2141:
 6592              	.LBB2069:
ARM GAS  /tmp/cc5nV8qb.s 			page 299


 6593              	.LBB2055:
 6594              	.LBB2050:
 6595              	.LBB2046:
 6596              	.LBB2043:
 716:MotorControl/encoder.cpp ****                         return false;
 6597              		.loc 3 716 25 is_stmt 1 view .LVU1754
 716:MotorControl/encoder.cpp ****                         return false;
 6598              		.loc 3 716 34 is_stmt 0 view .LVU1755
 6599 0438 1021     		movs	r1, #16
 6600 043a 2046     		mov	r0, r4
 6601 043c FFF7FEFF 		bl	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
 6602              	.LVL524:
 717:MotorControl/encoder.cpp ****                     }
 6603              		.loc 3 717 25 is_stmt 1 view .LVU1756
 717:MotorControl/encoder.cpp ****                     }
 6604              		.loc 3 717 32 is_stmt 0 view .LVU1757
 6605 0440 57E7     		b	.L307
 6606              	.LVL525:
 6607              	.L284:
 717:MotorControl/encoder.cpp ****                     }
 6608              		.loc 3 717 32 view .LVU1758
 6609              	.LBE2043:
 6610              	.LBE2046:
 6611              	.LBE2050:
 6612              	.LBE2055:
 723:MotorControl/encoder.cpp ****             float phase = fast_atan2(sincos_sample_s_, sincos_sample_c_);
 6613              		.loc 3 723 9 is_stmt 1 view .LVU1759
 723:MotorControl/encoder.cpp ****             float phase = fast_atan2(sincos_sample_s_, sincos_sample_c_);
 6614              		.loc 3 723 27 view .LVU1760
 6615              	.LBB2056:
 724:MotorControl/encoder.cpp ****             int fake_count = (int)(1000.0f * phase);
 6616              		.loc 3 724 13 view .LVU1761
 724:MotorControl/encoder.cpp ****             int fake_count = (int)(1000.0f * phase);
 6617              		.loc 3 724 37 is_stmt 0 view .LVU1762
 6618 0442 D0ED4D0A 		vldr.32	s1, [r0, #308]
 6619 0446 90ED4C0A 		vldr.32	s0, [r0, #304]
 6620 044a FFF7FEFF 		bl	_Z10fast_atan2ff
 6621              	.LVL526:
 725:MotorControl/encoder.cpp ****             //CPR = 6283 = 2pi * 1k
 6622              		.loc 3 725 13 is_stmt 1 view .LVU1763
 725:MotorControl/encoder.cpp ****             //CPR = 6283 = 2pi * 1k
 6623              		.loc 3 725 44 is_stmt 0 view .LVU1764
 6624 044e DFED697A 		vldr.32	s15, .L369+4
 6625 0452 20EE270A 		vmul.f32	s0, s0, s15
 6626              	.LVL527:
 725:MotorControl/encoder.cpp ****             //CPR = 6283 = 2pi * 1k
 6627              		.loc 3 725 17 view .LVU1765
 6628 0456 BDEEC00A 		vcvt.s32.f32	s0, s0
 6629              	.LVL528:
 728:MotorControl/encoder.cpp ****             delta_enc = mod(delta_enc, 6283);
 6630              		.loc 3 728 13 is_stmt 1 view .LVU1766
 728:MotorControl/encoder.cpp ****             delta_enc = mod(delta_enc, 6283);
 6631              		.loc 3 728 38 is_stmt 0 view .LVU1767
 6632 045a D4F89430 		ldr	r3, [r4, #148]
 728:MotorControl/encoder.cpp ****             delta_enc = mod(delta_enc, 6283);
 6633              		.loc 3 728 23 view .LVU1768
 6634 045e 10EE102A 		vmov	r2, s0	@ int
ARM GAS  /tmp/cc5nV8qb.s 			page 300


 6635 0462 D31A     		subs	r3, r2, r3
 6636              	.LVL529:
 729:MotorControl/encoder.cpp ****             if (delta_enc > 6283/2)
 6637              		.loc 3 729 13 is_stmt 1 view .LVU1769
 6638              	.LBB2057:
 6639              	.LBI2057:
 154:./MotorControl/utils.hpp ****     int r = dividend % divisor;
 6640              		.loc 17 154 12 view .LVU1770
 6641              	.LBB2058:
 155:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 6642              		.loc 17 155 5 view .LVU1771
 155:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 6643              		.loc 17 155 9 is_stmt 0 view .LVU1772
 6644 0464 644A     		ldr	r2, .L369+8
 6645 0466 82FB0312 		smull	r1, r2, r2, r3
 6646 046a DE17     		asrs	r6, r3, #31
 6647 046c C6EBA226 		rsb	r6, r6, r2, asr #10
 6648 0470 41F68B02 		movw	r2, #6283
 6649 0474 02FB1636 		mls	r6, r2, r6, r3
 6650              	.LVL530:
 156:./MotorControl/utils.hpp ****     return r;
 6651              		.loc 17 156 5 is_stmt 1 view .LVU1773
 6652 0478 002E     		cmp	r6, #0
 6653 047a 08DB     		blt	.L363
 6654              	.L308:
 6655              		.loc 17 157 5 view .LVU1774
 6656              	.LVL531:
 6657              		.loc 17 157 5 is_stmt 0 view .LVU1775
 6658              	.LBE2058:
 6659              	.LBE2057:
 730:MotorControl/encoder.cpp ****                 delta_enc -= 6283;
 6660              		.loc 3 730 13 is_stmt 1 view .LVU1776
 6661 047c 40F64543 		movw	r3, #3141
 6662 0480 9E42     		cmp	r6, r3
 6663 0482 7FF710AE 		ble	.L290
 731:MotorControl/encoder.cpp ****         } break;
 6664              		.loc 3 731 17 view .LVU1777
 731:MotorControl/encoder.cpp ****         } break;
 6665              		.loc 3 731 27 is_stmt 0 view .LVU1778
 6666 0486 A6F5C456 		sub	r6, r6, #6272
 6667              	.LVL532:
 731:MotorControl/encoder.cpp ****         } break;
 6668              		.loc 3 731 27 view .LVU1779
 6669 048a 0B3E     		subs	r6, r6, #11
 6670              	.LVL533:
 731:MotorControl/encoder.cpp ****         } break;
 6671              		.loc 3 731 27 view .LVU1780
 6672 048c 0BE6     		b	.L290
 6673              	.LVL534:
 6674              	.L363:
 6675              	.LBB2060:
 6676              	.LBB2059:
 156:./MotorControl/utils.hpp ****     return r;
 6677              		.loc 17 156 16 is_stmt 1 view .LVU1781
 156:./MotorControl/utils.hpp ****     return r;
 6678              		.loc 17 156 18 is_stmt 0 view .LVU1782
 6679 048e 06F5C456 		add	r6, r6, #6272
ARM GAS  /tmp/cc5nV8qb.s 			page 301


 6680              	.LVL535:
 156:./MotorControl/utils.hpp ****     return r;
 6681              		.loc 17 156 18 view .LVU1783
 6682 0492 0B36     		adds	r6, r6, #11
 6683              	.LVL536:
 156:./MotorControl/utils.hpp ****     return r;
 6684              		.loc 17 156 18 view .LVU1784
 6685 0494 F2E7     		b	.L308
 6686              	.LVL537:
 6687              	.L309:
 156:./MotorControl/utils.hpp ****     return r;
 6688              		.loc 17 156 18 view .LVU1785
 6689              	.LBE2059:
 6690              	.LBE2060:
 6691              	.LBE2056:
 748:MotorControl/encoder.cpp ****             }
 6692              		.loc 3 748 17 is_stmt 1 view .LVU1786
 748:MotorControl/encoder.cpp ****             }
 6693              		.loc 3 748 33 is_stmt 0 view .LVU1787
 6694 0496 90ED337A 		vldr.32	s14, [r0, #204]
 748:MotorControl/encoder.cpp ****             }
 6695              		.loc 3 748 64 view .LVU1788
 6696 049a DFED587A 		vldr.32	s15, .L369+12
 6697 049e 77EEC77A 		vsub.f32	s15, s15, s14
 748:MotorControl/encoder.cpp ****             }
 6698              		.loc 3 748 56 view .LVU1789
 6699 04a2 DFED576A 		vldr.32	s13, .L369+16
 6700 04a6 67EEA67A 		vmul.f32	s15, s15, s13
 748:MotorControl/encoder.cpp ****             }
 6701              		.loc 3 748 33 view .LVU1790
 6702 04aa 77EE277A 		vadd.f32	s15, s14, s15
 6703 04ae C0ED337A 		vstr.32	s15, [r0, #204]
 6704              	.L310:
 751:MotorControl/encoder.cpp ****             delta_enc = pos_abs_latched - count_in_cpr_; //LATCH
 6705              		.loc 3 751 13 is_stmt 1 view .LVU1791
 751:MotorControl/encoder.cpp ****             delta_enc = pos_abs_latched - count_in_cpr_; //LATCH
 6706              		.loc 3 751 34 is_stmt 0 view .LVU1792
 6707 04b2 0023     		movs	r3, #0
 6708 04b4 84F83831 		strb	r3, [r4, #312]
 752:MotorControl/encoder.cpp ****             delta_enc = mod(delta_enc, config_.cpr);
 6709              		.loc 3 752 13 is_stmt 1 view .LVU1793
 752:MotorControl/encoder.cpp ****             delta_enc = mod(delta_enc, config_.cpr);
 6710              		.loc 3 752 43 is_stmt 0 view .LVU1794
 6711 04b8 D4F89460 		ldr	r6, [r4, #148]
 752:MotorControl/encoder.cpp ****             delta_enc = mod(delta_enc, config_.cpr);
 6712              		.loc 3 752 23 view .LVU1795
 6713 04bc AE1B     		subs	r6, r5, r6
 6714              	.LVL538:
 753:MotorControl/encoder.cpp ****             if (delta_enc > config_.cpr/2) {
 6715              		.loc 3 753 13 is_stmt 1 view .LVU1796
 753:MotorControl/encoder.cpp ****             if (delta_enc > config_.cpr/2) {
 6716              		.loc 3 753 48 is_stmt 0 view .LVU1797
 6717 04be 236D     		ldr	r3, [r4, #80]
 6718              	.LVL539:
 6719              	.LBB2061:
 6720              	.LBI2061:
 154:./MotorControl/utils.hpp ****     int r = dividend % divisor;
ARM GAS  /tmp/cc5nV8qb.s 			page 302


 6721              		.loc 17 154 12 is_stmt 1 view .LVU1798
 6722              	.LBB2062:
 155:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 6723              		.loc 17 155 5 view .LVU1799
 155:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 6724              		.loc 17 155 9 is_stmt 0 view .LVU1800
 6725 04c0 96FBF3F2 		sdiv	r2, r6, r3
 6726 04c4 03FB1266 		mls	r6, r3, r2, r6
 6727              	.LVL540:
 156:./MotorControl/utils.hpp ****     return r;
 6728              		.loc 17 156 5 is_stmt 1 view .LVU1801
 6729 04c8 002E     		cmp	r6, #0
 6730 04ca 07DB     		blt	.L364
 6731              	.L312:
 6732              		.loc 17 157 5 view .LVU1802
 6733              	.LVL541:
 6734              		.loc 17 157 5 is_stmt 0 view .LVU1803
 6735              	.LBE2062:
 6736              	.LBE2061:
 754:MotorControl/encoder.cpp ****                 delta_enc -= config_.cpr;
 6737              		.loc 3 754 13 is_stmt 1 view .LVU1804
 754:MotorControl/encoder.cpp ****                 delta_enc -= config_.cpr;
 6738              		.loc 3 754 40 is_stmt 0 view .LVU1805
 6739 04cc 03EBD372 		add	r2, r3, r3, lsr #31
 754:MotorControl/encoder.cpp ****                 delta_enc -= config_.cpr;
 6740              		.loc 3 754 13 view .LVU1806
 6741 04d0 B6EB620F 		cmp	r6, r2, asr #1
 6742 04d4 7FF7E7AD 		ble	.L290
 755:MotorControl/encoder.cpp ****             }
 6743              		.loc 3 755 17 is_stmt 1 view .LVU1807
 755:MotorControl/encoder.cpp ****             }
 6744              		.loc 3 755 27 is_stmt 0 view .LVU1808
 6745 04d8 F61A     		subs	r6, r6, r3
 6746              	.LVL542:
 755:MotorControl/encoder.cpp ****             }
 6747              		.loc 3 755 27 view .LVU1809
 6748 04da E4E5     		b	.L290
 6749              	.LVL543:
 6750              	.L364:
 6751              	.LBB2064:
 6752              	.LBB2063:
 156:./MotorControl/utils.hpp ****     return r;
 6753              		.loc 17 156 16 is_stmt 1 view .LVU1810
 156:./MotorControl/utils.hpp ****     return r;
 6754              		.loc 17 156 18 is_stmt 0 view .LVU1811
 6755 04dc 1E44     		add	r6, r6, r3
 6756              	.LVL544:
 156:./MotorControl/utils.hpp ****     return r;
 6757              		.loc 17 156 18 view .LVU1812
 6758 04de F5E7     		b	.L312
 6759              	.LVL545:
 6760              	.L288:
 156:./MotorControl/utils.hpp ****     return r;
 6761              		.loc 17 156 18 view .LVU1813
 6762              	.LBE2063:
 6763              	.LBE2064:
 759:MotorControl/encoder.cpp ****             set_error(ERROR_UNSUPPORTED_ENCODER_MODE);
ARM GAS  /tmp/cc5nV8qb.s 			page 303


 6764              		.loc 3 759 9 is_stmt 1 view .LVU1814
 759:MotorControl/encoder.cpp ****             set_error(ERROR_UNSUPPORTED_ENCODER_MODE);
 6765              		.loc 3 759 18 view .LVU1815
 760:MotorControl/encoder.cpp ****             return false;
 6766              		.loc 3 760 13 view .LVU1816
 760:MotorControl/encoder.cpp ****             return false;
 6767              		.loc 3 760 22 is_stmt 0 view .LVU1817
 6768 04e0 0821     		movs	r1, #8
 6769 04e2 2046     		mov	r0, r4
 6770              	.LVL546:
 760:MotorControl/encoder.cpp ****             return false;
 6771              		.loc 3 760 22 view .LVU1818
 6772 04e4 FFF7FEFF 		bl	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
 6773              	.LVL547:
 761:MotorControl/encoder.cpp ****         } break;
 6774              		.loc 3 761 13 is_stmt 1 view .LVU1819
 761:MotorControl/encoder.cpp ****         } break;
 6775              		.loc 3 761 20 is_stmt 0 view .LVU1820
 6776 04e8 0026     		movs	r6, #0
 6777 04ea 02E7     		b	.L307
 6778              	.LVL548:
 6779              	.L351:
 761:MotorControl/encoder.cpp ****         } break;
 6780              		.loc 3 761 20 view .LVU1821
 6781              	.LBE2069:
 6782              	.LBE2141:
 6783              	.LBB2142:
 6784              	.LBB2073:
 156:./MotorControl/utils.hpp ****     return r;
 6785              		.loc 17 156 16 is_stmt 1 view .LVU1822
 156:./MotorControl/utils.hpp ****     return r;
 6786              		.loc 17 156 18 is_stmt 0 view .LVU1823
 6787 04ec 3B44     		add	r3, r3, r7
 6788              	.LVL549:
 156:./MotorControl/utils.hpp ****     return r;
 6789              		.loc 17 156 18 view .LVU1824
 6790 04ee EDE5     		b	.L313
 6791              	.LVL550:
 6792              	.L352:
 156:./MotorControl/utils.hpp ****     return r;
 6793              		.loc 17 156 18 view .LVU1825
 6794              	.LBE2073:
 6795              	.LBE2142:
 6796              	.LBB2143:
 6797              	.LBB2078:
 782:MotorControl/encoder.cpp ****         else
 6798              		.loc 3 782 13 is_stmt 1 view .LVU1826
 782:MotorControl/encoder.cpp ****         else
 6799              		.loc 3 782 30 is_stmt 0 view .LVU1827
 6800 04f0 B0EE490A 		vmov.f32	s0, s18
 6801 04f4 2046     		mov	r0, r4
 6802 04f6 FFF7FEFF 		bl	_ZN7Encoder10hall_modelEf
 6803              	.LVL551:
 782:MotorControl/encoder.cpp ****         else
 6804              		.loc 3 782 43 view .LVU1828
 6805 04fa 0EE6     		b	.L316
 6806              	.LVL552:
ARM GAS  /tmp/cc5nV8qb.s 			page 304


 6807              	.L353:
 782:MotorControl/encoder.cpp ****         else
 6808              		.loc 3 782 43 view .LVU1829
 6809              	.LBE2078:
 6810              	.LBE2143:
 6811              	.LBB2144:
 6812              	.LBB2083:
 782:MotorControl/encoder.cpp ****         else
 6813              		.loc 3 782 13 is_stmt 1 view .LVU1830
 782:MotorControl/encoder.cpp ****         else
 6814              		.loc 3 782 30 is_stmt 0 view .LVU1831
 6815 04fc B0EE480A 		vmov.f32	s0, s16
 6816 0500 2046     		mov	r0, r4
 6817 0502 FFF7FEFF 		bl	_ZN7Encoder10hall_modelEf
 6818              	.LVL553:
 782:MotorControl/encoder.cpp ****         else
 6819              		.loc 3 782 43 view .LVU1832
 6820 0506 1CE6     		b	.L318
 6821              	.LVL554:
 6822              	.L354:
 782:MotorControl/encoder.cpp ****         else
 6823              		.loc 3 782 43 view .LVU1833
 6824              	.LBE2083:
 6825              	.LBE2144:
 6826              	.LBB2145:
 6827              	.LBB2094:
 135:./MotorControl/utils.hpp ****     return res;
 6828              		.loc 17 135 18 is_stmt 1 view .LVU1834
 135:./MotorControl/utils.hpp ****     return res;
 6829              		.loc 17 135 22 is_stmt 0 view .LVU1835
 6830 0508 38EE078A 		vadd.f32	s16, s16, s14
 6831              	.LVL555:
 135:./MotorControl/utils.hpp ****     return res;
 6832              		.loc 17 135 22 view .LVU1836
 6833 050c 5AE6     		b	.L319
 6834              	.LVL556:
 6835              	.L348:
 135:./MotorControl/utils.hpp ****     return res;
 6836              		.loc 17 135 22 view .LVU1837
 6837              	.LBE2094:
 6838              	.LBE2145:
 796:MotorControl/encoder.cpp ****     if (std::abs(vel_estimate_counts_) < 0.5f * current_meas_period * pll_ki_) {
 6839              		.loc 3 796 10 view .LVU1838
 6840 050e 0021     		movs	r1, #0
 6841 0510 76E6     		b	.L321
 6842              	.LVL557:
 6843              	.L355:
 6844              	.LBB2146:
 6845              	.LBB2135:
 135:./MotorControl/utils.hpp ****     return res;
 6846              		.loc 17 135 18 is_stmt 1 view .LVU1839
 135:./MotorControl/utils.hpp ****     return res;
 6847              		.loc 17 135 22 is_stmt 0 view .LVU1840
 6848 0512 77EE867A 		vadd.f32	s15, s15, s12
 6849              	.LVL558:
 135:./MotorControl/utils.hpp ****     return res;
 6850              		.loc 17 135 22 view .LVU1841
ARM GAS  /tmp/cc5nV8qb.s 			page 305


 6851 0516 B3E6     		b	.L324
 6852              	.LVL559:
 6853              	.L327:
 135:./MotorControl/utils.hpp ****     return res;
 6854              		.loc 17 135 22 view .LVU1842
 6855              	.LBE2135:
 6856              	.LBE2146:
 821:MotorControl/encoder.cpp ****         interpolation_ = 0.0f;
 6857              		.loc 3 821 12 is_stmt 1 view .LVU1843
 6858 0518 002E     		cmp	r6, #0
 6859 051a 03DD     		ble	.L329
 822:MotorControl/encoder.cpp ****     } else if (delta_enc < 0) {
 6860              		.loc 3 822 9 view .LVU1844
 822:MotorControl/encoder.cpp ****     } else if (delta_enc < 0) {
 6861              		.loc 3 822 24 is_stmt 0 view .LVU1845
 6862 051c 0023     		movs	r3, #0
 6863 051e C4F89830 		str	r3, [r4, #152]	@ float
 6864 0522 C2E6     		b	.L328
 6865              	.L329:
 823:MotorControl/encoder.cpp ****         interpolation_ = 1.0f;
 6866              		.loc 3 823 12 is_stmt 1 view .LVU1846
 6867 0524 002E     		cmp	r6, #0
 6868 0526 20DB     		blt	.L365
 827:MotorControl/encoder.cpp ****         // don't allow interpolation indicated position outside of [enc, enc+1)
 6869              		.loc 3 827 9 view .LVU1847
 827:MotorControl/encoder.cpp ****         // don't allow interpolation indicated position outside of [enc, enc+1)
 6870              		.loc 3 827 49 is_stmt 0 view .LVU1848
 6871 0528 94ED2E7A 		vldr.32	s14, [r4, #184]
 827:MotorControl/encoder.cpp ****         // don't allow interpolation indicated position outside of [enc, enc+1)
 6872              		.loc 3 827 47 view .LVU1849
 6873 052c 9FED346A 		vldr.32	s12, .L369+16
 6874 0530 27EE067A 		vmul.f32	s14, s14, s12
 827:MotorControl/encoder.cpp ****         // don't allow interpolation indicated position outside of [enc, enc+1)
 6875              		.loc 3 827 24 view .LVU1850
 6876 0534 94ED266A 		vldr.32	s12, [r4, #152]
 6877 0538 37EE067A 		vadd.f32	s14, s14, s12
 6878 053c 84ED267A 		vstr.32	s14, [r4, #152]
 829:MotorControl/encoder.cpp ****         if (interpolation_ < 0.0f) interpolation_ = 0.0f;
 6879              		.loc 3 829 9 is_stmt 1 view .LVU1851
 6880 0540 B7EE006A 		vmov.f32	s12, #1.0e+0
 6881 0544 B4EEC67A 		vcmpe.f32	s14, s12
 6882 0548 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 6883 054c 01DD     		ble	.L331
 829:MotorControl/encoder.cpp ****         if (interpolation_ < 0.0f) interpolation_ = 0.0f;
 6884              		.loc 3 829 36 discriminator 1 view .LVU1852
 829:MotorControl/encoder.cpp ****         if (interpolation_ < 0.0f) interpolation_ = 0.0f;
 6885              		.loc 3 829 51 is_stmt 0 discriminator 1 view .LVU1853
 6886 054e 84ED266A 		vstr.32	s12, [r4, #152]
 6887              	.L331:
 830:MotorControl/encoder.cpp ****     }
 6888              		.loc 3 830 9 is_stmt 1 view .LVU1854
 830:MotorControl/encoder.cpp ****     }
 6889              		.loc 3 830 13 is_stmt 0 view .LVU1855
 6890 0552 94ED267A 		vldr.32	s14, [r4, #152]
 830:MotorControl/encoder.cpp ****     }
 6891              		.loc 3 830 9 view .LVU1856
 6892 0556 B5EEC07A 		vcmpe.f32	s14, #0
ARM GAS  /tmp/cc5nV8qb.s 			page 306


 6893 055a F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 6894 055e 7FF5A4AE 		bpl	.L328
 830:MotorControl/encoder.cpp ****     }
 6895              		.loc 3 830 36 is_stmt 1 discriminator 1 view .LVU1857
 830:MotorControl/encoder.cpp ****     }
 6896              		.loc 3 830 51 is_stmt 0 discriminator 1 view .LVU1858
 6897 0562 0023     		movs	r3, #0
 6898 0564 C4F89830 		str	r3, [r4, #152]	@ float
 6899 0568 9FE6     		b	.L328
 6900              	.L365:
 824:MotorControl/encoder.cpp ****     } else {
 6901              		.loc 3 824 9 is_stmt 1 view .LVU1859
 824:MotorControl/encoder.cpp ****     } else {
 6902              		.loc 3 824 24 is_stmt 0 view .LVU1860
 6903 056a 4FF07E53 		mov	r3, #1065353216
 6904 056e C4F89830 		str	r3, [r4, #152]	@ float
 6905 0572 9AE6     		b	.L328
 6906              	.LVL560:
 6907              	.L356:
 840:MotorControl/encoder.cpp ****         phase_vel_ = (2*M_PI) * *vel_estimate_.present() * axis_->motor_.config_.pole_pairs * confi
 6908              		.loc 3 840 9 is_stmt 1 view .LVU1861
 6909              	.LBB2147:
 6910              	.LBI2147:
 139:./MotorControl/utils.hpp ****     return wrap_pm(x, 2 * M_PI);
 6911              		.loc 17 139 14 view .LVU1862
 6912              	.LBE2147:
 140:./MotorControl/utils.hpp **** }
 6913              		.loc 17 140 5 view .LVU1863
 6914              	.LBB2152:
 6915              	.LBB2148:
 6916              	.LBI2148:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 6917              		.loc 17 123 14 view .LVU1864
 6918              	.LBB2149:
 125:./MotorControl/utils.hpp **** #else
 6919              		.loc 17 125 5 view .LVU1865
 125:./MotorControl/utils.hpp **** #else
 6920              		.loc 17 125 36 is_stmt 0 view .LVU1866
 6921 0574 DFED236A 		vldr.32	s13, .L369+20
 6922 0578 87EEA67A 		vdiv.f32	s14, s15, s13
 6923              	.LVL561:
 6924              	.LBB2150:
 6925              	.LBI2150:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 6926              		.loc 17 108 12 is_stmt 1 view .LVU1867
 6927              	.LBB2151:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 6928              		.loc 17 110 5 view .LVU1868
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 6929              		.loc 17 111 5 view .LVU1869
 6930              		.syntax unified
 6931              	@ 111 "./MotorControl/utils.hpp" 1
 6932 057c BDEE477A 		vcvtr.s32.f32   s14, s14
 6933              	@ 0 "" 2
 6934              	.LVL562:
 114:./MotorControl/utils.hpp **** #else
 6935              		.loc 17 114 5 view .LVU1870
ARM GAS  /tmp/cc5nV8qb.s 			page 307


 114:./MotorControl/utils.hpp **** #else
 6936              		.loc 17 114 5 is_stmt 0 view .LVU1871
 6937              		.thumb
 6938              		.syntax unified
 6939              	.LBE2151:
 6940              	.LBE2150:
 125:./MotorControl/utils.hpp **** #else
 6941              		.loc 17 125 42 view .LVU1872
 6942 0580 B8EEC77A 		vcvt.f32.s32	s14, s14
 6943              	.LVL563:
 129:./MotorControl/utils.hpp **** }
 6944              		.loc 17 129 5 is_stmt 1 view .LVU1873
 129:./MotorControl/utils.hpp **** }
 6945              		.loc 17 129 23 is_stmt 0 view .LVU1874
 6946 0584 27EE267A 		vmul.f32	s14, s14, s13
 6947              	.LVL564:
 129:./MotorControl/utils.hpp **** }
 6948              		.loc 17 129 25 view .LVU1875
 6949 0588 77EEC77A 		vsub.f32	s15, s15, s14
 6950              	.LVL565:
 129:./MotorControl/utils.hpp **** }
 6951              		.loc 17 129 25 view .LVU1876
 6952              	.LBE2149:
 6953              	.LBE2148:
 6954              	.LBE2152:
 840:MotorControl/encoder.cpp ****         phase_vel_ = (2*M_PI) * *vel_estimate_.present() * axis_->motor_.config_.pole_pairs * confi
 6955              		.loc 3 840 16 view .LVU1877
 6956 058c 94ED177A 		vldr.32	s14, [r4, #92]	@ int
 6957 0590 B8EEC77A 		vcvt.f32.s32	s14, s14
 6958 0594 67EE277A 		vmul.f32	s15, s14, s15
 6959              	.LVL566:
 6960              	.LBB2153:
 6961              	.LBI2153:
  52:./MotorControl/component.hpp ****         content_ = value;
 6962              		.loc 13 52 10 is_stmt 1 view .LVU1878
 6963              	.LBB2154:
  53:./MotorControl/component.hpp ****         age_ = 0;
 6964              		.loc 13 53 18 is_stmt 0 view .LVU1879
 6965 0598 C4ED287A 		vstr.32	s15, [r4, #160]
  54:./MotorControl/component.hpp ****     }
 6966              		.loc 13 54 14 view .LVU1880
 6967 059c 0023     		movs	r3, #0
 6968              	.LVL567:
  54:./MotorControl/component.hpp ****     }
 6969              		.loc 13 54 14 view .LVU1881
 6970 059e C4F89C30 		str	r3, [r4, #156]
 6971              	.LVL568:
  54:./MotorControl/component.hpp ****     }
 6972              		.loc 13 54 14 view .LVU1882
 6973              	.LBE2154:
 6974              	.LBE2153:
 841:MotorControl/encoder.cpp ****     }
 6975              		.loc 3 841 9 is_stmt 1 view .LVU1883
 6976              	.LBB2155:
 6977              	.LBI2155:
  73:./MotorControl/component.hpp ****         if (age_ == 0) {
 6978              		.loc 13 73 22 view .LVU1884
ARM GAS  /tmp/cc5nV8qb.s 			page 308


 6979              	.LBB2156:
  74:./MotorControl/component.hpp ****             return content_;
 6980              		.loc 13 74 13 is_stmt 0 view .LVU1885
 6981 05a2 D4F8D830 		ldr	r3, [r4, #216]
  74:./MotorControl/component.hpp ****             return content_;
 6982              		.loc 13 74 9 view .LVU1886
 6983 05a6 EBB1     		cbz	r3, .L366
 6984              	.LVL569:
 6985              	.LBB2157:
 6986              	.LBI2157:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 6987              		.loc 14 692 17 is_stmt 1 view .LVU1887
 6988              	.LBB2158:
 6989              	.LBB2159:
 6990              	.LBI2159:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 6991              		.loc 14 602 17 view .LVU1888
 6992              	.LBB2160:
 6993              	.LBI2160:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 6994              		.loc 14 302 7 view .LVU1889
 6995              	.LBB2161:
 6996              	.LBI2161:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 6997              		.loc 14 110 7 view .LVU1890
 6998              	.LBB2162:
 6999              	.LBB2163:
 7000              	.LBI2163:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 7001              		.loc 14 199 14 view .LVU1891
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 7002              		.loc 14 199 14 is_stmt 0 view .LVU1892
 7003              	.LBE2163:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 7004              		.loc 14 110 7 view .LVU1893
 7005 05a8 0023     		movs	r3, #0
 7006 05aa 8DF81C30 		strb	r3, [sp, #28]
 7007              	.LVL570:
 7008              	.L335:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 7009              		.loc 14 110 7 view .LVU1894
 7010              	.LBE2162:
 7011              	.LBE2161:
 7012              	.LBE2160:
 7013              	.LBE2159:
 7014              	.LBE2158:
 7015              	.LBE2157:
 7016              	.LBE2156:
 7017              	.LBE2155:
 841:MotorControl/encoder.cpp ****     }
 7018              		.loc 3 841 31 view .LVU1895
 7019 05ae 9DED067A 		vldr.32	s14, [sp, #24]
 7020 05b2 DFED147A 		vldr.32	s15, .L369+20
 7021 05b6 27EE277A 		vmul.f32	s14, s14, s15
 841:MotorControl/encoder.cpp ****     }
 7022              		.loc 3 841 60 view .LVU1896
 7023 05ba 236B     		ldr	r3, [r4, #48]
ARM GAS  /tmp/cc5nV8qb.s 			page 309


 841:MotorControl/encoder.cpp ****     }
 7024              		.loc 3 841 67 view .LVU1897
 7025 05bc D3F85831 		ldr	r3, [r3, #344]
 841:MotorControl/encoder.cpp ****     }
 7026              		.loc 3 841 82 view .LVU1898
 7027 05c0 D3ED087A 		vldr.32	s15, [r3, #32]	@ int
 841:MotorControl/encoder.cpp ****     }
 7028              		.loc 3 841 58 view .LVU1899
 7029 05c4 F8EEE77A 		vcvt.f32.s32	s15, s15
 7030 05c8 27EE877A 		vmul.f32	s14, s15, s14
 841:MotorControl/encoder.cpp ****     }
 7031              		.loc 3 841 20 view .LVU1900
 7032 05cc D4ED177A 		vldr.32	s15, [r4, #92]	@ int
 7033 05d0 F8EEE77A 		vcvt.f32.s32	s15, s15
 7034 05d4 67EE877A 		vmul.f32	s15, s15, s14
 7035              	.LVL571:
 7036              	.LBB2184:
 7037              	.LBI2184:
  52:./MotorControl/component.hpp ****         content_ = value;
 7038              		.loc 13 52 10 is_stmt 1 view .LVU1901
 7039              	.LBB2185:
  53:./MotorControl/component.hpp ****         age_ = 0;
 7040              		.loc 13 53 18 is_stmt 0 view .LVU1902
 7041 05d8 C4ED2A7A 		vstr.32	s15, [r4, #168]
  54:./MotorControl/component.hpp ****     }
 7042              		.loc 13 54 14 view .LVU1903
 7043 05dc 0023     		movs	r3, #0
 7044 05de C4F8A430 		str	r3, [r4, #164]
 7045              	.LVL572:
  54:./MotorControl/component.hpp ****     }
 7046              		.loc 13 54 14 view .LVU1904
 7047              	.LBE2185:
 7048              	.LBE2184:
 7049 05e2 86E6     		b	.L307
 7050              	.LVL573:
 7051              	.L366:
 7052              	.LBB2186:
 7053              	.LBB2183:
 7054              	.LBB2164:
 7055              	.LBI2164:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 7056              		.loc 14 700 2 is_stmt 1 view .LVU1905
 7057              	.LBB2165:
 7058              	.LBB2166:
 7059              	.LBB2167:
 7060              	.LBI2167:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7061              		.loc 7 76 5 view .LVU1906
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7062              		.loc 7 76 5 is_stmt 0 view .LVU1907
 7063              	.LBE2167:
 7064              	.LBB2168:
 7065              	.LBI2168:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 7066              		.loc 14 607 28 is_stmt 1 view .LVU1908
 7067              	.LBB2169:
 7068              	.LBB2170:
ARM GAS  /tmp/cc5nV8qb.s 			page 310


 7069              	.LBB2171:
 7070              	.LBI2171:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7071              		.loc 7 76 5 view .LVU1909
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7072              		.loc 7 76 5 is_stmt 0 view .LVU1910
 7073              	.LBE2171:
 7074              	.LBB2172:
 7075              	.LBI2172:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 7076              		.loc 14 300 42 is_stmt 1 view .LVU1911
 7077              	.LBB2173:
 7078              	.LBB2174:
 7079              	.LBB2175:
 7080              	.LBI2175:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 7081              		.loc 14 115 2 view .LVU1912
 7082              	.LBB2176:
 7083              	.LBB2177:
 7084              	.LBB2178:
 7085              	.LBI2178:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7086              		.loc 7 76 5 view .LVU1913
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7087              		.loc 7 76 5 is_stmt 0 view .LVU1914
 7088              	.LBE2178:
 7089              	.LBB2179:
 7090              	.LBI2179:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 7091              		.loc 14 203 6 is_stmt 1 view .LVU1915
 7092              	.LBB2180:
 7093              	.LBB2181:
 7094              	.LBB2182:
 7095              	.LBI2182:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7096              		.loc 7 76 5 view .LVU1916
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7097              		.loc 7 76 5 is_stmt 0 view .LVU1917
 7098              	.LBE2182:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 7099              		.loc 14 204 47 view .LVU1918
 7100 05e4 6B68     		ldr	r3, [r5, #4]	@ float
 7101 05e6 0693     		str	r3, [sp, #24]	@ float
 7102              	.LVL574:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 7103              		.loc 14 204 47 view .LVU1919
 7104              	.LBE2181:
 7105              	.LBE2180:
 7106              	.LBE2179:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 7107              		.loc 14 117 19 view .LVU1920
 7108 05e8 0123     		movs	r3, #1
 7109 05ea 8DF81C30 		strb	r3, [sp, #28]
 7110              	.LVL575:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 7111              		.loc 14 117 19 view .LVU1921
 7112              	.LBE2177:
ARM GAS  /tmp/cc5nV8qb.s 			page 311


 7113              	.LBE2176:
 7114              	.LBE2175:
 7115              	.LBE2174:
 7116              	.LBE2173:
 7117              	.LBE2172:
 7118              	.LBE2170:
 7119              	.LBE2169:
 7120              	.LBE2168:
 7121              	.LBE2166:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 7122              		.loc 14 701 51 view .LVU1922
 7123 05ee DEE7     		b	.L335
 7124              	.L370:
 7125              		.align	2
 7126              	.L369:
 7127 05f0 ABAAAA2A 		.word	715827883
 7128 05f4 00007A44 		.word	1148846080
 7129 05f8 BF05B929 		.word	699991487
 7130 05fc 00000000 		.word	0
 7131 0600 6F120339 		.word	956502639
 7132 0604 DB0FC940 		.word	1086918619
 7133              	.LBE2165:
 7134              	.LBE2164:
 7135              	.LBE2183:
 7136              	.LBE2186:
 7137              		.cfi_endproc
 7138              	.LFE5370:
 7139              		.fnend
 7141              		.section	.text._ZSt28__variant_construct_by_indexILj2ESt7variantIJSt4pairIffEPS2_P10OutputPortIS2_
 7142              		.align	1
 7143              		.weak	_ZSt28__variant_construct_by_indexILj2ESt7variantIJSt4pairIffEPS2_P10OutputPortIS2_EEEJRS6_E
 7144              		.syntax unified
 7145              		.thumb
 7146              		.thumb_func
 7148              	_ZSt28__variant_construct_by_indexILj2ESt7variantIJSt4pairIffEPS2_P10OutputPortIS2_EEEJRS6_EEvRT0_D
 7149              		.fnstart
 7150              	.LVL576:
 7151              	.LFB6434:
1068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 7152              		.loc 1 1068 10 is_stmt 1 view -0
 7153              		.cfi_startproc
 7154              		@ args = 0, pretend = 0, frame = 0
 7155              		@ frame_needed = 0, uses_anonymous_args = 0
 7156              		@ link register save eliminated.
1070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       auto&& __storage = __detail::__variant::__get<_Np>(__v);
 7157              		.loc 1 1070 20 is_stmt 0 view .LVU1924
 7158 0000 0223     		movs	r3, #2
 7159 0002 0372     		strb	r3, [r0, #8]
 7160              	.LVL577:
 7161              	.LBB2187:
 7162              	.LBI2187:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 7163              		.loc 1 276 5 is_stmt 1 view .LVU1925
 7164              	.LBB2188:
 7165              	.LBB2189:
 7166              	.LBI2189:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
ARM GAS  /tmp/cc5nV8qb.s 			page 312


 7167              		.loc 1 267 5 view .LVU1926
 7168              	.LBB2190:
 7169              	.LBB2191:
 7170              	.LBI2191:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 7171              		.loc 1 267 5 view .LVU1927
 7172              	.LBB2192:
 7173              	.LBB2193:
 7174              	.LBI2193:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 7175              		.loc 1 262 5 view .LVU1928
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 7176              		.loc 1 262 5 is_stmt 0 view .LVU1929
 7177              	.LBE2193:
 7178              	.LBE2192:
 7179              	.LBE2191:
 7180              	.LBE2190:
 7181              	.LBE2189:
 7182              	.LBE2188:
 7183              	.LBE2187:
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         remove_reference_t<decltype(__storage)>
 7184              		.loc 1 1072 7 view .LVU1930
 7185 0004 0B68     		ldr	r3, [r1]
 7186              	.LVL578:
 7187              		.loc 8 175 3 is_stmt 1 view .LVU1931
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         remove_reference_t<decltype(__storage)>
 7188              		.loc 1 1072 7 is_stmt 0 view .LVU1932
 7189 0006 0360     		str	r3, [r0]
1075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 7190              		.loc 1 1075 5 view .LVU1933
 7191 0008 7047     		bx	lr
 7192              		.cfi_endproc
 7193              	.LFE6434:
 7194              		.cantunwind
 7195              		.fnend
 7197              		.section	.text._ZSt28__variant_construct_by_indexILj2ESt7variantIJfPfP10OutputPortIfEEEJRS4_EEvRT0
 7198              		.align	1
 7199              		.weak	_ZSt28__variant_construct_by_indexILj2ESt7variantIJfPfP10OutputPortIfEEEJRS4_EEvRT0_DpOT1_
 7200              		.syntax unified
 7201              		.thumb
 7202              		.thumb_func
 7204              	_ZSt28__variant_construct_by_indexILj2ESt7variantIJfPfP10OutputPortIfEEEJRS4_EEvRT0_DpOT1_:
 7205              		.fnstart
 7206              	.LVL579:
 7207              	.LFB6438:
1068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 7208              		.loc 1 1068 10 is_stmt 1 view -0
 7209              		.cfi_startproc
 7210              		@ args = 0, pretend = 0, frame = 0
 7211              		@ frame_needed = 0, uses_anonymous_args = 0
 7212              		@ link register save eliminated.
1070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       auto&& __storage = __detail::__variant::__get<_Np>(__v);
 7213              		.loc 1 1070 20 is_stmt 0 view .LVU1935
 7214 0000 0223     		movs	r3, #2
 7215 0002 0371     		strb	r3, [r0, #4]
 7216              	.LVL580:
 7217              	.LBB2194:
ARM GAS  /tmp/cc5nV8qb.s 			page 313


 7218              	.LBI2194:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 7219              		.loc 1 276 5 is_stmt 1 view .LVU1936
 7220              	.LBB2195:
 7221              	.LBB2196:
 7222              	.LBI2196:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 7223              		.loc 1 267 5 view .LVU1937
 7224              	.LBB2197:
 7225              	.LBB2198:
 7226              	.LBI2198:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 7227              		.loc 1 267 5 view .LVU1938
 7228              	.LBB2199:
 7229              	.LBB2200:
 7230              	.LBI2200:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 7231              		.loc 1 262 5 view .LVU1939
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 7232              		.loc 1 262 5 is_stmt 0 view .LVU1940
 7233              	.LBE2200:
 7234              	.LBE2199:
 7235              	.LBE2198:
 7236              	.LBE2197:
 7237              	.LBE2196:
 7238              	.LBE2195:
 7239              	.LBE2194:
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         remove_reference_t<decltype(__storage)>
 7240              		.loc 1 1072 7 view .LVU1941
 7241 0004 0B68     		ldr	r3, [r1]
 7242              	.LVL581:
 7243              		.loc 8 175 3 is_stmt 1 view .LVU1942
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         remove_reference_t<decltype(__storage)>
 7244              		.loc 1 1072 7 is_stmt 0 view .LVU1943
 7245 0006 0360     		str	r3, [r0]
1075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 7246              		.loc 1 1075 5 view .LVU1944
 7247 0008 7047     		bx	lr
 7248              		.cfi_endproc
 7249              	.LFE6438:
 7250              		.cantunwind
 7251              		.fnend
 7253              		.global	__aeabi_ldivmod
 7254              		.section	.text._ZN7Encoder22run_offset_calibrationEv,"ax",%progbits
 7255              		.align	1
 7256              		.global	_ZN7Encoder22run_offset_calibrationEv
 7257              		.syntax unified
 7258              		.thumb
 7259              		.thumb_func
 7261              	_ZN7Encoder22run_offset_calibrationEv:
 7262              		.fnstart
 7263              	.LVL582:
 7264              	.LFB5356:
 328:MotorControl/encoder.cpp ****     const float start_lock_duration = 1.0f;
 7265              		.loc 3 328 40 is_stmt 1 view -0
 7266              		.cfi_startproc
 7267              		@ args = 0, pretend = 0, frame = 48
ARM GAS  /tmp/cc5nV8qb.s 			page 314


 7268              		@ frame_needed = 0, uses_anonymous_args = 0
 328:MotorControl/encoder.cpp ****     const float start_lock_duration = 1.0f;
 7269              		.loc 3 328 40 is_stmt 0 view .LVU1946
 7270 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 7271              		.save {r4, r5, r6, r7, r8, lr}
 7272              	.LCFI58:
 7273              		.cfi_def_cfa_offset 24
 7274              		.cfi_offset 4, -24
 7275              		.cfi_offset 5, -20
 7276              		.cfi_offset 6, -16
 7277              		.cfi_offset 7, -12
 7278              		.cfi_offset 8, -8
 7279              		.cfi_offset 14, -4
 7280              		.pad #48
 7281 0004 8CB0     		sub	sp, sp, #48
 7282              	.LCFI59:
 7283              		.cfi_def_cfa_offset 72
 7284 0006 0446     		mov	r4, r0
 329:MotorControl/encoder.cpp **** 
 7285              		.loc 3 329 5 is_stmt 1 view .LVU1947
 7286              	.LVL583:
 332:MotorControl/encoder.cpp ****         set_error(ERROR_INDEX_NOT_FOUND_YET);
 7287              		.loc 3 332 5 view .LVU1948
 332:MotorControl/encoder.cpp ****         set_error(ERROR_INDEX_NOT_FOUND_YET);
 7288              		.loc 3 332 17 is_stmt 0 view .LVU1949
 7289 0008 90F85830 		ldrb	r3, [r0, #88]	@ zero_extendqisi2
 332:MotorControl/encoder.cpp ****         set_error(ERROR_INDEX_NOT_FOUND_YET);
 7290              		.loc 3 332 5 view .LVU1950
 7291 000c 23B1     		cbz	r3, .L374
 332:MotorControl/encoder.cpp ****         set_error(ERROR_INDEX_NOT_FOUND_YET);
 7292              		.loc 3 332 31 discriminator 1 view .LVU1951
 7293 000e 90F88E60 		ldrb	r6, [r0, #142]	@ zero_extendqisi2
 332:MotorControl/encoder.cpp ****         set_error(ERROR_INDEX_NOT_FOUND_YET);
 7294              		.loc 3 332 27 discriminator 1 view .LVU1952
 7295 0012 002E     		cmp	r6, #0
 7296 0014 00F04C81 		beq	.L428
 7297              	.L374:
 337:MotorControl/encoder.cpp ****         set_error(ERROR_HALL_NOT_CALIBRATED_YET);
 7298              		.loc 3 337 5 is_stmt 1 view .LVU1953
 337:MotorControl/encoder.cpp ****         set_error(ERROR_HALL_NOT_CALIBRATED_YET);
 7299              		.loc 3 337 17 is_stmt 0 view .LVU1954
 7300 0018 A38E     		ldrh	r3, [r4, #52]
 337:MotorControl/encoder.cpp ****         set_error(ERROR_HALL_NOT_CALIBRATED_YET);
 7301              		.loc 3 337 5 view .LVU1955
 7302 001a 012B     		cmp	r3, #1
 7303 001c 00F04C81 		beq	.L429
 7304              	.L376:
 344:MotorControl/encoder.cpp **** 
 7305              		.loc 3 344 5 is_stmt 1 view .LVU1956
 344:MotorControl/encoder.cpp **** 
 7306              		.loc 3 344 21 is_stmt 0 view .LVU1957
 7307 0020 D4F89430 		ldr	r3, [r4, #148]
 344:MotorControl/encoder.cpp **** 
 7308              		.loc 3 344 19 view .LVU1958
 7309 0024 C4F89030 		str	r3, [r4, #144]
 346:MotorControl/encoder.cpp ****         // Reset state variables
 7310              		.loc 3 346 5 is_stmt 1 view .LVU1959
ARM GAS  /tmp/cc5nV8qb.s 			page 315


 7311              	.LVL584:
 7312              	.LBB2631:
 7313              	.LBB2632:
 7314              	.LBI2632:
  39:./Drivers/STM32/stm32_system.h **** }
  40:./Drivers/STM32/stm32_system.h **** 
  41:./Drivers/STM32/stm32_system.h **** #ifdef __cplusplus
  42:./Drivers/STM32/stm32_system.h **** }
  43:./Drivers/STM32/stm32_system.h **** #endif
  44:./Drivers/STM32/stm32_system.h **** 
  45:./Drivers/STM32/stm32_system.h **** 
  46:./Drivers/STM32/stm32_system.h **** // C++ only definitions
  47:./Drivers/STM32/stm32_system.h **** 
  48:./Drivers/STM32/stm32_system.h **** #ifdef __cplusplus
  49:./Drivers/STM32/stm32_system.h **** 
  50:./Drivers/STM32/stm32_system.h **** struct CriticalSectionContext {
  51:./Drivers/STM32/stm32_system.h ****     CriticalSectionContext(const CriticalSectionContext&) = delete;
  52:./Drivers/STM32/stm32_system.h ****     CriticalSectionContext(const CriticalSectionContext&&) = delete;
  53:./Drivers/STM32/stm32_system.h ****     void operator=(const CriticalSectionContext&) = delete;
  54:./Drivers/STM32/stm32_system.h ****     void operator=(const CriticalSectionContext&&) = delete;
  55:./Drivers/STM32/stm32_system.h ****     operator bool() { return true; };
  56:./Drivers/STM32/stm32_system.h ****     CriticalSectionContext() : mask_(cpu_enter_critical()) {}
 7315              		.loc 4 56 5 view .LVU1960
 7316              	.LBB2633:
 7317              	.LBB2634:
 7318              	.LBB2635:
 7319              	.LBI2635:
  31:./Drivers/STM32/stm32_system.h ****     uint32_t primask = __get_PRIMASK();
 7320              		.loc 4 31 24 view .LVU1961
 7321              	.LBB2636:
  32:./Drivers/STM32/stm32_system.h ****     __disable_irq();
 7322              		.loc 4 32 5 view .LVU1962
 7323              	.LBB2637:
 7324              	.LBI2637:
 382:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 7325              		.loc 5 382 31 view .LVU1963
 7326              	.LBB2638:
 384:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 7327              		.loc 5 384 3 view .LVU1964
 386:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 7328              		.loc 5 386 3 view .LVU1965
 7329              		.syntax unified
 7330              	@ 386 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 7331 0028 EFF31085 		MRS r5, primask
 7332              	@ 0 "" 2
 7333              	.LVL585:
 387:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 7334              		.loc 5 387 3 view .LVU1966
 387:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 7335              		.loc 5 387 3 is_stmt 0 view .LVU1967
 7336              		.thumb
 7337              		.syntax unified
 7338              	.LBE2638:
 7339              	.LBE2637:
  33:./Drivers/STM32/stm32_system.h ****     return primask;
 7340              		.loc 4 33 5 is_stmt 1 view .LVU1968
 7341              	.LBB2639:
ARM GAS  /tmp/cc5nV8qb.s 			page 316


 7342              	.LBI2639:
 140:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 7343              		.loc 5 140 27 view .LVU1969
 7344              	.LBB2640:
 142:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 7345              		.loc 5 142 3 view .LVU1970
 7346              		.syntax unified
 7347              	@ 142 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 7348 002c 72B6     		cpsid i
 7349              	@ 0 "" 2
 7350              		.thumb
 7351              		.syntax unified
 7352              	.LBE2640:
 7353              	.LBE2639:
  34:./Drivers/STM32/stm32_system.h **** }
 7354              		.loc 4 34 5 view .LVU1971
 7355              	.LBE2636:
 7356              	.LBE2635:
 7357              		.loc 4 56 58 is_stmt 0 view .LVU1972
 7358 002e 0095     		str	r5, [sp]
 7359 0030 0022     		movs	r2, #0
 7360 0032 8DF80420 		strb	r2, [sp, #4]
 7361              	.LVL586:
 7362              		.loc 4 56 58 view .LVU1973
 7363              	.LBE2634:
 7364              	.LBE2633:
 7365              	.LBE2632:
 7366              	.LBE2631:
  55:./Drivers/STM32/stm32_system.h ****     CriticalSectionContext() : mask_(cpu_enter_critical()) {}
 7367              		.loc 4 55 23 is_stmt 1 view .LVU1974
 7368              	.LBB2988:
 7369              	.LBB2641:
 348:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.Vdq_setpoint_ = {0.0f, 0.0f};
 7370              		.loc 3 348 9 view .LVU1975
 7371              	.LBB2642:
 7372              	.LBI2642:
 7373              		.file 23 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // Pair implementation -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // Copyright (C) 2001-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // You should have received a copy of the GNU General Public License and
ARM GAS  /tmp/cc5nV8qb.s 			page 317


  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** /*
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  *
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * Copyright (c) 1994
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * Hewlett-Packard Company
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  *
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * Permission to use, copy, modify, distribute and sell this software
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * and its documentation for any purpose is hereby granted without fee,
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * provided that the above copyright notice appear in all copies and
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * that both that copyright notice and this permission notice appear
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * in supporting documentation.  Hewlett-Packard Company makes no
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * representations about the suitability of this software for any
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  *
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  *
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * Copyright (c) 1996,1997
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * Silicon Graphics Computer Systems, Inc.
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  *
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * Permission to use, copy, modify, distribute and sell this software
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * and its documentation for any purpose is hereby granted without fee,
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * provided that the above copyright notice appear in all copies and
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * that both that copyright notice and this permission notice appear
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * in supporting documentation.  Silicon Graphics makes no
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * representations about the suitability of this software for any
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  */
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** /** @file bits/stl_pair.h
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  *  This is an internal header file, included by other library headers.
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  *  Do not attempt to use it directly. @headername{utility}
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  */
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #ifndef _STL_PAIR_H
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #define _STL_PAIR_H 1
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #include <bits/move.h> // for std::move / std::forward, and std::swap
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus >= 201103L
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** # include <type_traits> // for std::__decay_and_strip, std::is_reference_v
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus > 201703L
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** # include <compare>
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** # define __cpp_lib_constexpr_utility 201811L
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** namespace std _GLIBCXX_VISIBILITY(default)
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** {
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   /**
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *  @addtogroup utilities
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *  @{
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    */
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 318


  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus >= 201103L
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   /// Tag type for piecewise construction of std::pair objects.
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   struct piecewise_construct_t { explicit piecewise_construct_t() = default; };
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   /// Tag for piecewise construction of std::pair objects.
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   _GLIBCXX17_INLINE constexpr piecewise_construct_t piecewise_construct =
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     piecewise_construct_t();
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   /// @cond undocumented
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   // Forward declarations.
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   template<typename...>
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     class tuple;
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   template<std::size_t...>
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     struct _Index_tuple;
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   // Concept utility functions, reused in conditionally-explicit
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   // constructors.
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   // See PR 70437, don't look at is_constructible or
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   // is_convertible if the types are the same to
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   // avoid querying those properties for incomplete types.
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   template <bool, typename _T1, typename _T2>
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     struct _PCC
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     {
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _ConstructiblePair()
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return __and_<is_constructible<_T1, const _U1&>,
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      is_constructible<_T2, const _U2&>>::value;
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _ImplicitlyConvertiblePair()
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return __and_<is_convertible<const _U1&, _T1>,
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      is_convertible<const _U2&, _T2>>::value;
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _MoveConstructiblePair()
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return __and_<is_constructible<_T1, _U1&&>,
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      is_constructible<_T2, _U2&&>>::value;
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _ImplicitlyMoveConvertiblePair()
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return __and_<is_convertible<_U1&&, _T1>,
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      is_convertible<_U2&&, _T2>>::value;
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <bool __implicit, typename _U1, typename _U2>
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _CopyMovePair()
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	using __do_converts = __and_<is_convertible<const _U1&, _T1>,
ARM GAS  /tmp/cc5nV8qb.s 			page 319


 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 				  is_convertible<_U2&&, _T2>>;
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	using __converts = typename conditional<__implicit,
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 				       __do_converts,
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 				       __not_<__do_converts>>::type;
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return __and_<is_constructible<_T1, const _U1&>,
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      is_constructible<_T2, _U2&&>,
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      __converts
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      >::value;
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <bool __implicit, typename _U1, typename _U2>
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _MoveCopyPair()
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	using __do_converts = __and_<is_convertible<_U1&&, _T1>,
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 				  is_convertible<const _U2&, _T2>>;
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	using __converts = typename conditional<__implicit,
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 				       __do_converts,
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 				       __not_<__do_converts>>::type;
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return __and_<is_constructible<_T1, _U1&&>,
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      is_constructible<_T2, const _U2&&>,
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      __converts
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		      >::value;
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   };
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   template <typename _T1, typename _T2>
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     struct _PCC<false, _T1, _T2>
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     {
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _ConstructiblePair()
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return false;
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _ImplicitlyConvertiblePair()
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return false;
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _MoveConstructiblePair()
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return false;
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       static constexpr bool _ImplicitlyMoveConvertiblePair()
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	return false;
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       }
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   };
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif // C++11
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   template<typename _U1, typename _U2> class __pair_base
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   {
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus >= 201103L
ARM GAS  /tmp/cc5nV8qb.s 			page 320


 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     template<typename _T1, typename _T2> friend struct pair;
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     __pair_base() = default;
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     ~__pair_base() = default;
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     __pair_base(const __pair_base&) = default;
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     __pair_base& operator=(const __pair_base&) = delete;
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif // C++11
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   };
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   /// @endcond
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****  /**
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *  @brief Struct holding two objects of arbitrary type.
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *  @tparam _T1  Type of first object.
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *  @tparam _T2  Type of second object.
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    *  <https://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****    */
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****   template<typename _T1, typename _T2>
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     struct pair
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     : private __pair_base<_T1, _T2>
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****     {
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       typedef _T1 first_type;    ///< The type of the `first` member
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       typedef _T2 second_type;   ///< The type of the `second` member
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       _T1 first;                 ///< The first member
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       _T2 second;                ///< The second member
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       // _GLIBCXX_RESOLVE_LIB_DEFECTS
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       // 265.  std::pair::pair() effects overly restrictive
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /** The default constructor creates @c first and @c second using their
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        *  respective default constructors.  */
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus >= 201103L
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1 = _T1,
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                 typename _U2 = _T2,
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                 typename enable_if<__and_<
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                                      __is_implicitly_default_constructible<_U1>,
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                                      __is_implicitly_default_constructible<_U2>>
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                                    ::value, bool>::type = true>
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       _GLIBCXX_CONSTEXPR pair()
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       : first(), second() { }
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus >= 201103L
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1 = _T1,
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                 typename _U2 = _T2,
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                 typename enable_if<__and_<
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                        is_default_constructible<_U1>,
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                        is_default_constructible<_U2>,
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                        __not_<
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          __and_<__is_implicitly_default_constructible<_U1>,
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                                 __is_implicitly_default_constructible<_U2>>>>
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                                    ::value, bool>::type = false>
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       explicit constexpr pair()
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       : first(), second() { }
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 321


 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus < 201103L
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// Two objects may be passed to a @c pair constructor to be copied.
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       pair(const _T1& __a, const _T2& __b)
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       : first(__a), second(__b) { }
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #else
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       // Shortcut for constraining the templates that don't take pairs.
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// @cond undocumented
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       using _PCCP = _PCC<true, _T1, _T2>;
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// @endcond
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// Construct from two const lvalues, allowing implicit conversions.
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1 = _T1, typename _U2=_T2, typename
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCP::template
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ConstructiblePair<_U1, _U2>()
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	                 && _PCCP::template
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ImplicitlyConvertiblePair<_U1, _U2>(),
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=true>
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       constexpr pair(const _T1& __a, const _T2& __b)
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       : first(__a), second(__b) { }
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// Construct from two const lvalues, disallowing implicit conversions.
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        template<typename _U1 = _T1, typename _U2=_T2, typename
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		enable_if<_PCCP::template
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			    _ConstructiblePair<_U1, _U2>()
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	                  && !_PCCP::template
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			    _ImplicitlyConvertiblePair<_U1, _U2>(),
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=false>
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       explicit constexpr pair(const _T1& __a, const _T2& __b)
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       : first(__a), second(__b) { }
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus < 201103L
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// There is also a templated constructor to convert from other pairs.
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename _U2>
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	pair(const pair<_U1, _U2>& __p)
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	: first(__p.first), second(__p.second) { }
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #else
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       // Shortcut for constraining the templates that take pairs.
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// @cond undocumented
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template <typename _U1, typename _U2>
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****         using _PCCFP = _PCC<!is_same<_T1, _U1>::value
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			    || !is_same<_T2, _U2>::value,
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			    _T1, _T2>;
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       /// @endcond
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename _U2, typename
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCFP<_U1, _U2>::template
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ConstructiblePair<_U1, _U2>()
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	                 && _PCCFP<_U1, _U2>::template
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ImplicitlyConvertiblePair<_U1, _U2>(),
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			  bool>::type=true>
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****         constexpr pair(const pair<_U1, _U2>& __p)
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****         : first(__p.first), second(__p.second) { }
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename _U2, typename
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCFP<_U1, _U2>::template
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ConstructiblePair<_U1, _U2>()
ARM GAS  /tmp/cc5nV8qb.s 			page 322


 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			 && !_PCCFP<_U1, _U2>::template
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ImplicitlyConvertiblePair<_U1, _U2>(),
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=false>
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	explicit constexpr pair(const pair<_U1, _U2>& __p)
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	: first(__p.first), second(__p.second) { }
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #endif
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** #if __cplusplus >= 201103L
 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       constexpr pair(const pair&) = default;	///< Copy constructor
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       constexpr pair(pair&&) = default;		///< Move constructor
 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       // DR 811.
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCP::template
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _MoveCopyPair<true, _U1, _T2>(),
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=true>
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        constexpr pair(_U1&& __x, const _T2& __y)
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        : first(std::forward<_U1>(__x)), second(__y) { }
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCP::template
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _MoveCopyPair<false, _U1, _T2>(),
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=false>
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        explicit constexpr pair(_U1&& __x, const _T2& __y)
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        : first(std::forward<_U1>(__x)), second(__y) { }
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U2, typename
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCP::template
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _CopyMovePair<true, _T1, _U2>(),
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=true>
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        constexpr pair(const _T1& __x, _U2&& __y)
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        : first(__x), second(std::forward<_U2>(__y)) { }
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U2, typename
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCP::template
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _CopyMovePair<false, _T1, _U2>(),
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=false>
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        explicit pair(const _T1& __x, _U2&& __y)
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****        : first(__x), second(std::forward<_U2>(__y)) { }
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename _U2, typename
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCP::template
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _MoveConstructiblePair<_U1, _U2>()
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			  && _PCCP::template
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=true>
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	constexpr pair(_U1&& __x, _U2&& __y)
 7374              		.loc 23 352 12 view .LVU1976
 7375              	.LBB2643:
 7376              	.LBB2644:
 7377              	.LBB2645:
 7378              	.LBI2645:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7379              		.loc 7 76 5 view .LVU1977
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7380              		.loc 7 76 5 is_stmt 0 view .LVU1978
 7381              	.LBE2645:
ARM GAS  /tmp/cc5nV8qb.s 			page 323


 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
 7382              		.loc 23 353 64 view .LVU1979
 7383 0036 0023     		movs	r3, #0
 7384 0038 0493     		str	r3, [sp, #16]	@ float
 7385              	.LVL587:
 7386              	.LBB2646:
 7387              	.LBI2646:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7388              		.loc 7 76 5 is_stmt 1 view .LVU1980
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7389              		.loc 7 76 5 is_stmt 0 view .LVU1981
 7390              	.LBE2646:
 7391              		.loc 23 353 64 view .LVU1982
 7392 003a 0593     		str	r3, [sp, #20]	@ float
 7393              	.LVL588:
 7394              		.loc 23 353 64 view .LVU1983
 7395              	.LBE2644:
 7396              	.LBE2643:
 7397              	.LBE2642:
 348:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.Vdq_setpoint_ = {0.0f, 0.0f};
 7398              		.loc 3 348 9 view .LVU1984
 7399 003c 276B     		ldr	r7, [r4, #48]
 7400              	.LVL589:
 348:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.Vdq_setpoint_ = {0.0f, 0.0f};
 7401              		.loc 3 348 9 view .LVU1985
 7402 003e 02AE     		add	r6, sp, #8
 7403 0040 04A9     		add	r1, sp, #16
 7404 0042 03C9     		ldm	r1, {r0, r1}
 7405              	.LVL590:
 348:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.Vdq_setpoint_ = {0.0f, 0.0f};
 7406              		.loc 3 348 9 view .LVU1986
 7407 0044 86E80300 		stm	r6, {r0, r1}
 7408              	.LBB2647:
 7409              	.LBI2647:
  52:./MotorControl/component.hpp ****         content_ = value;
 7410              		.loc 13 52 10 is_stmt 1 view .LVU1987
 7411              	.LVL591:
 7412              	.LBB2648:
 7413              	.LBB2649:
 7414              	.LBI2649:
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename _U2, typename
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCP::template
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _MoveConstructiblePair<_U1, _U2>()
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			  && !_PCCP::template
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=false>
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	explicit constexpr pair(_U1&& __x, _U2&& __y)
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename _U2, typename
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCFP<_U1, _U2>::template
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _MoveConstructiblePair<_U1, _U2>()
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			  && _PCCFP<_U1, _U2>::template
 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=true>
ARM GAS  /tmp/cc5nV8qb.s 			page 324


 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	constexpr pair(pair<_U1, _U2>&& __p)
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	: first(std::forward<_U1>(__p.first)),
 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	  second(std::forward<_U2>(__p.second)) { }
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename _U1, typename _U2, typename
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	       enable_if<_PCCFP<_U1, _U2>::template
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _MoveConstructiblePair<_U1, _U2>()
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			  && !_PCCFP<_U1, _U2>::template
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****                          bool>::type=false>
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	explicit constexpr pair(pair<_U1, _U2>&& __p)
 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	: first(std::forward<_U1>(__p.first)),
 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	  second(std::forward<_U2>(__p.second)) { }
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       template<typename... _Args1, typename... _Args2>
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	_GLIBCXX20_CONSTEXPR
 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****         pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       _GLIBCXX20_CONSTEXPR pair&
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       operator=(typename conditional<
 7415              		.loc 23 390 7 view .LVU1988
 7416              	.LBB2650:
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		__and_<is_copy_assignable<_T1>,
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		       is_copy_assignable<_T2>>::value,
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		const pair&, const __nonesuch&>::type __p)
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h ****       {
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	first = __p.first;
 7417              		.loc 23 395 8 is_stmt 0 view .LVU1989
 7418 0048 C7F82C31 		str	r3, [r7, #300]	@ float
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	second = __p.second;
 7419              		.loc 23 396 9 view .LVU1990
 7420 004c C7F83031 		str	r3, [r7, #304]	@ float
 7421              	.LVL592:
 7422              		.loc 23 396 9 view .LVU1991
 7423              	.LBE2650:
 7424              	.LBE2649:
  54:./MotorControl/component.hpp ****     }
 7425              		.loc 13 54 14 view .LVU1992
 7426 0050 C7F82821 		str	r2, [r7, #296]
 7427              	.LVL593:
  54:./MotorControl/component.hpp ****     }
 7428              		.loc 13 54 14 view .LVU1993
 7429              	.LBE2648:
 7430              	.LBE2647:
 349:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.phase_ = 0.0f;
 7431              		.loc 3 349 9 is_stmt 1 view .LVU1994
 7432              	.LBB2651:
 7433              	.LBI2651:
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
 7434              		.loc 23 352 12 view .LVU1995
 7435              	.LBB2652:
 7436              	.LBB2653:
 7437              	.LBB2654:
 7438              	.LBI2654:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7439              		.loc 7 76 5 view .LVU1996
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
ARM GAS  /tmp/cc5nV8qb.s 			page 325


 7440              		.loc 7 76 5 is_stmt 0 view .LVU1997
 7441              	.LBE2654:
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 7442              		.loc 23 353 64 view .LVU1998
 7443 0054 0693     		str	r3, [sp, #24]	@ float
 7444              	.LVL594:
 7445              	.LBB2655:
 7446              	.LBI2655:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7447              		.loc 7 76 5 is_stmt 1 view .LVU1999
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 7448              		.loc 7 76 5 is_stmt 0 view .LVU2000
 7449              	.LBE2655:
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 7450              		.loc 23 353 64 view .LVU2001
 7451 0056 0793     		str	r3, [sp, #28]	@ float
 7452              	.LVL595:
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 
 7453              		.loc 23 353 64 view .LVU2002
 7454              	.LBE2653:
 7455              	.LBE2652:
 7456              	.LBE2651:
 349:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.phase_ = 0.0f;
 7457              		.loc 3 349 9 view .LVU2003
 7458 0058 276B     		ldr	r7, [r4, #48]
 7459              	.LVL596:
 349:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.phase_ = 0.0f;
 7460              		.loc 3 349 9 view .LVU2004
 7461 005a 06A9     		add	r1, sp, #24
 7462 005c 03C9     		ldm	r1, {r0, r1}
 7463 005e 86E80300 		stm	r6, {r0, r1}
 7464              	.LBB2656:
 7465              	.LBI2656:
  52:./MotorControl/component.hpp ****         content_ = value;
 7466              		.loc 13 52 10 is_stmt 1 view .LVU2005
 7467              	.LVL597:
 7468              	.LBB2657:
 7469              	.LBB2658:
 7470              	.LBI2658:
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 		__and_<is_copy_assignable<_T1>,
 7471              		.loc 23 390 7 view .LVU2006
 7472              	.LBB2659:
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h **** 	second = __p.second;
 7473              		.loc 23 395 8 is_stmt 0 view .LVU2007
 7474 0062 C7F83831 		str	r3, [r7, #312]	@ float
 7475              		.loc 23 396 9 view .LVU2008
 7476 0066 C7F83C31 		str	r3, [r7, #316]	@ float
 7477              	.LVL598:
 7478              		.loc 23 396 9 view .LVU2009
 7479              	.LBE2659:
 7480              	.LBE2658:
  54:./MotorControl/component.hpp ****     }
 7481              		.loc 13 54 14 view .LVU2010
 7482 006a C7F83421 		str	r2, [r7, #308]
 7483              	.LVL599:
  54:./MotorControl/component.hpp ****     }
 7484              		.loc 13 54 14 view .LVU2011
ARM GAS  /tmp/cc5nV8qb.s 			page 326


 7485              	.LBE2657:
 7486              	.LBE2656:
 350:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.phase_vel_ = 0.0f;
 7487              		.loc 3 350 9 is_stmt 1 view .LVU2012
 7488 006e 216B     		ldr	r1, [r4, #48]
 7489              	.LVL600:
 7490              	.LBB2660:
 7491              	.LBI2660:
  52:./MotorControl/component.hpp ****         content_ = value;
 7492              		.loc 13 52 10 view .LVU2013
 7493              	.LBB2661:
  53:./MotorControl/component.hpp ****         age_ = 0;
 7494              		.loc 13 53 18 is_stmt 0 view .LVU2014
 7495 0070 C1F84431 		str	r3, [r1, #324]	@ float
  54:./MotorControl/component.hpp ****     }
 7496              		.loc 13 54 14 view .LVU2015
 7497 0074 C1F84021 		str	r2, [r1, #320]
 7498              	.LVL601:
  54:./MotorControl/component.hpp ****     }
 7499              		.loc 13 54 14 view .LVU2016
 7500              	.LBE2661:
 7501              	.LBE2660:
 351:MotorControl/encoder.cpp **** 
 7502              		.loc 3 351 9 is_stmt 1 view .LVU2017
 7503 0078 216B     		ldr	r1, [r4, #48]
 7504              	.LVL602:
 7505              	.LBB2662:
 7506              	.LBI2662:
  52:./MotorControl/component.hpp ****         content_ = value;
 7507              		.loc 13 52 10 view .LVU2018
 7508              	.LBB2663:
  53:./MotorControl/component.hpp ****         age_ = 0;
 7509              		.loc 13 53 18 is_stmt 0 view .LVU2019
 7510 007a C1F84C31 		str	r3, [r1, #332]	@ float
  54:./MotorControl/component.hpp ****     }
 7511              		.loc 13 54 14 view .LVU2020
 7512 007e C1F84821 		str	r2, [r1, #328]
 7513              	.LVL603:
  54:./MotorControl/component.hpp ****     }
 7514              		.loc 13 54 14 view .LVU2021
 7515              	.LBE2663:
 7516              	.LBE2662:
 353:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.max_current_ramp_ = max_current_ramp;
 7517              		.loc 3 353 9 is_stmt 1 view .LVU2022
 353:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.max_current_ramp_ = max_current_ramp;
 7518              		.loc 3 353 34 is_stmt 0 view .LVU2023
 7519 0082 236B     		ldr	r3, [r4, #48]
 353:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.max_current_ramp_ = max_current_ramp;
 7520              		.loc 3 353 41 view .LVU2024
 7521 0084 D3F85821 		ldr	r2, [r3, #344]
 353:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.max_current_ramp_ = max_current_ramp;
 7522              		.loc 3 353 56 view .LVU2025
 7523 0088 D2ED097A 		vldr.32	s15, [r2, #36]
 353:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.max_current_ramp_ = max_current_ramp;
 7524              		.loc 3 353 15 view .LVU2026
 7525 008c 77EEA77A 		vadd.f32	s15, s15, s15
 7526              	.LVL604:
ARM GAS  /tmp/cc5nV8qb.s 			page 327


 354:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.max_voltage_ramp_ = max_current_ramp;
 7527              		.loc 3 354 9 is_stmt 1 view .LVU2027
 354:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.max_voltage_ramp_ = max_current_ramp;
 7528              		.loc 3 354 56 is_stmt 0 view .LVU2028
 7529 0090 C3ED427A 		vstr.32	s15, [r3, #264]
 355:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.max_phase_vel_ramp_ = INFINITY;
 7530              		.loc 3 355 9 is_stmt 1 view .LVU2029
 7531 0094 236B     		ldr	r3, [r4, #48]
 355:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.max_phase_vel_ramp_ = INFINITY;
 7532              		.loc 3 355 56 is_stmt 0 view .LVU2030
 7533 0096 C3ED437A 		vstr.32	s15, [r3, #268]
 356:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_current_ = axis_->motor_.config_.motor_type != Motor::M
 7534              		.loc 3 356 9 is_stmt 1 view .LVU2031
 7535 009a 236B     		ldr	r3, [r4, #48]
 356:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_current_ = axis_->motor_.config_.motor_type != Motor::M
 7536              		.loc 3 356 58 is_stmt 0 view .LVU2032
 7537 009c 4FF0FF42 		mov	r2, #2139095040
 7538 00a0 C3F81021 		str	r2, [r3, #272]	@ float
 357:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_voltage_ = axis_->motor_.config_.motor_type != Motor::M
 7539              		.loc 3 357 9 is_stmt 1 view .LVU2033
 357:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_voltage_ = axis_->motor_.config_.motor_type != Motor::M
 7540              		.loc 3 357 56 is_stmt 0 view .LVU2034
 7541 00a4 236B     		ldr	r3, [r4, #48]
 357:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_voltage_ = axis_->motor_.config_.motor_type != Motor::M
 7542              		.loc 3 357 63 view .LVU2035
 7543 00a6 D3F85821 		ldr	r2, [r3, #344]
 357:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_voltage_ = axis_->motor_.config_.motor_type != Motor::M
 7544              		.loc 3 357 78 view .LVU2036
 7545 00aa 92F83810 		ldrb	r1, [r2, #56]	@ zero_extendqisi2
 357:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_voltage_ = axis_->motor_.config_.motor_type != Motor::M
 7546              		.loc 3 357 117 view .LVU2037
 7547 00ae 0229     		cmp	r1, #2
 7548 00b0 00F00D81 		beq	.L421
 357:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_voltage_ = axis_->motor_.config_.motor_type != Motor::M
 7549              		.loc 3 357 117 discriminator 1 view .LVU2038
 7550 00b4 526A     		ldr	r2, [r2, #36]	@ float
 7551              	.L377:
 357:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_voltage_ = axis_->motor_.config_.motor_type != Motor::M
 7552              		.loc 3 357 54 discriminator 4 view .LVU2039
 7553 00b6 C3F81821 		str	r2, [r3, #280]	@ float
 358:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_vel_ = 0.0f;
 7554              		.loc 3 358 9 is_stmt 1 discriminator 4 view .LVU2040
 358:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_vel_ = 0.0f;
 7555              		.loc 3 358 56 is_stmt 0 discriminator 4 view .LVU2041
 7556 00ba 236B     		ldr	r3, [r4, #48]
 358:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_vel_ = 0.0f;
 7557              		.loc 3 358 63 discriminator 4 view .LVU2042
 7558 00bc D3F85821 		ldr	r2, [r3, #344]
 358:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_vel_ = 0.0f;
 7559              		.loc 3 358 78 discriminator 4 view .LVU2043
 7560 00c0 92F83810 		ldrb	r1, [r2, #56]	@ zero_extendqisi2
 358:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_vel_ = 0.0f;
 7561              		.loc 3 358 117 discriminator 4 view .LVU2044
 7562 00c4 0229     		cmp	r1, #2
 7563 00c6 00F00481 		beq	.L430
 358:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_vel_ = 0.0f;
 7564              		.loc 3 358 117 view .LVU2045
ARM GAS  /tmp/cc5nV8qb.s 			page 328


 7565 00ca 0022     		movs	r2, #0
 7566              	.L378:
 358:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_vel_ = 0.0f;
 7567              		.loc 3 358 54 discriminator 4 view .LVU2046
 7568 00cc C3F81C21 		str	r2, [r3, #284]	@ float
 359:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.total_distance_ = 0.0f;
 7569              		.loc 3 359 9 is_stmt 1 discriminator 4 view .LVU2047
 7570 00d0 236B     		ldr	r3, [r4, #48]
 359:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.total_distance_ = 0.0f;
 7571              		.loc 3 359 50 is_stmt 0 discriminator 4 view .LVU2048
 7572 00d2 DFEDB87A 		vldr.32	s15, .L454
 7573              	.LVL605:
 359:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.total_distance_ = 0.0f;
 7574              		.loc 3 359 50 discriminator 4 view .LVU2049
 7575 00d6 C3ED457A 		vstr.32	s15, [r3, #276]
 360:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.phase_ = axis_->open_loop_controller_.initial_phase_ = wrap_pm
 7576              		.loc 3 360 9 is_stmt 1 discriminator 4 view .LVU2050
 7577 00da 236B     		ldr	r3, [r4, #48]
 7578              	.LVL606:
 7579              	.LBB2664:
 7580              	.LBI2664:
  52:./MotorControl/component.hpp ****         content_ = value;
 7581              		.loc 13 52 10 discriminator 4 view .LVU2051
 7582              	.LBB2665:
  53:./MotorControl/component.hpp ****         age_ = 0;
 7583              		.loc 13 53 18 is_stmt 0 discriminator 4 view .LVU2052
 7584 00dc C3ED557A 		vstr.32	s15, [r3, #340]
  54:./MotorControl/component.hpp ****     }
 7585              		.loc 13 54 14 discriminator 4 view .LVU2053
 7586 00e0 0022     		movs	r2, #0
 7587 00e2 C3F85021 		str	r2, [r3, #336]
 7588              	.LVL607:
  54:./MotorControl/component.hpp ****     }
 7589              		.loc 13 54 14 discriminator 4 view .LVU2054
 7590              	.LBE2665:
 7591              	.LBE2664:
 361:MotorControl/encoder.cpp **** 
 7592              		.loc 3 361 9 is_stmt 1 discriminator 4 view .LVU2055
 361:MotorControl/encoder.cpp **** 
 7593              		.loc 3 361 116 is_stmt 0 discriminator 4 view .LVU2056
 7594 00e6 94ED0F7A 		vldr.32	s14, [r4, #60]
 361:MotorControl/encoder.cpp **** 
 7595              		.loc 3 361 136 discriminator 4 view .LVU2057
 7596 00ea F6EE006A 		vmov.f32	s13, #5.0e-1
 7597 00ee 27EE267A 		vmul.f32	s14, s14, s13
 361:MotorControl/encoder.cpp **** 
 7598              		.loc 3 361 103 discriminator 4 view .LVU2058
 7599 00f2 77EEC77A 		vsub.f32	s15, s15, s14
 361:MotorControl/encoder.cpp **** 
 7600              		.loc 3 361 47 discriminator 4 view .LVU2059
 7601 00f6 236B     		ldr	r3, [r4, #48]
 7602              	.LVL608:
 7603              	.LBB2666:
 7604              	.LBI2666:
 139:./MotorControl/utils.hpp ****     return wrap_pm(x, 2 * M_PI);
 7605              		.loc 17 139 14 is_stmt 1 discriminator 4 view .LVU2060
 7606              	.LBE2666:
ARM GAS  /tmp/cc5nV8qb.s 			page 329


 7607              	.LBE2641:
 7608              	.LBE2988:
 140:./MotorControl/utils.hpp **** }
 7609              		.loc 17 140 5 discriminator 4 view .LVU2061
 7610              	.LBB2989:
 7611              	.LBB2978:
 7612              	.LBB2671:
 7613              	.LBB2667:
 7614              	.LBI2667:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 7615              		.loc 17 123 14 discriminator 4 view .LVU2062
 7616              	.LBB2668:
 125:./MotorControl/utils.hpp **** #else
 7617              		.loc 17 125 5 discriminator 4 view .LVU2063
 125:./MotorControl/utils.hpp **** #else
 7618              		.loc 17 125 36 is_stmt 0 discriminator 4 view .LVU2064
 7619 00f8 DFEDAF6A 		vldr.32	s13, .L454+4
 7620 00fc 87EEA67A 		vdiv.f32	s14, s15, s13
 7621              	.LVL609:
 7622              	.LBB2669:
 7623              	.LBI2669:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 7624              		.loc 17 108 12 is_stmt 1 discriminator 4 view .LVU2065
 7625              	.LBB2670:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 7626              		.loc 17 110 5 discriminator 4 view .LVU2066
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 7627              		.loc 17 111 5 discriminator 4 view .LVU2067
 7628              		.syntax unified
 7629              	@ 111 "./MotorControl/utils.hpp" 1
 7630 0100 BDEE477A 		vcvtr.s32.f32   s14, s14
 7631              	@ 0 "" 2
 7632              	.LVL610:
 114:./MotorControl/utils.hpp **** #else
 7633              		.loc 17 114 5 discriminator 4 view .LVU2068
 114:./MotorControl/utils.hpp **** #else
 7634              		.loc 17 114 5 is_stmt 0 discriminator 4 view .LVU2069
 7635              		.thumb
 7636              		.syntax unified
 7637              	.LBE2670:
 7638              	.LBE2669:
 125:./MotorControl/utils.hpp **** #else
 7639              		.loc 17 125 42 discriminator 4 view .LVU2070
 7640 0104 B8EEC77A 		vcvt.f32.s32	s14, s14
 7641              	.LVL611:
 129:./MotorControl/utils.hpp **** }
 7642              		.loc 17 129 5 is_stmt 1 discriminator 4 view .LVU2071
 129:./MotorControl/utils.hpp **** }
 7643              		.loc 17 129 23 is_stmt 0 discriminator 4 view .LVU2072
 7644 0108 27EE267A 		vmul.f32	s14, s14, s13
 7645              	.LVL612:
 129:./MotorControl/utils.hpp **** }
 7646              		.loc 17 129 25 discriminator 4 view .LVU2073
 7647 010c 77EEC77A 		vsub.f32	s15, s15, s14
 7648              	.LVL613:
 129:./MotorControl/utils.hpp **** }
 7649              		.loc 17 129 25 discriminator 4 view .LVU2074
ARM GAS  /tmp/cc5nV8qb.s 			page 330


 7650              	.LBE2668:
 7651              	.LBE2667:
 7652              	.LBE2671:
 361:MotorControl/encoder.cpp **** 
 7653              		.loc 3 361 45 discriminator 4 view .LVU2075
 7654 0110 C3ED487A 		vstr.32	s15, [r3, #288]
 361:MotorControl/encoder.cpp **** 
 7655              		.loc 3 361 9 discriminator 4 view .LVU2076
 7656 0114 236B     		ldr	r3, [r4, #48]
 7657              	.LVL614:
 7658              	.LBB2672:
 7659              	.LBI2672:
  52:./MotorControl/component.hpp ****         content_ = value;
 7660              		.loc 13 52 10 is_stmt 1 discriminator 4 view .LVU2077
 7661              	.LBB2673:
  53:./MotorControl/component.hpp ****         age_ = 0;
 7662              		.loc 13 53 18 is_stmt 0 discriminator 4 view .LVU2078
 7663 0116 C3ED517A 		vstr.32	s15, [r3, #324]
  54:./MotorControl/component.hpp ****     }
 7664              		.loc 13 54 14 discriminator 4 view .LVU2079
 7665 011a C3F84021 		str	r2, [r3, #320]
 7666              	.LVL615:
  54:./MotorControl/component.hpp ****     }
 7667              		.loc 13 54 14 discriminator 4 view .LVU2080
 7668              	.LBE2673:
 7669              	.LBE2672:
 363:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.Idq_setpoint_src_.connect_to(&axis_->open_loop_controller_.I
 7670              		.loc 3 363 9 is_stmt 1 discriminator 4 view .LVU2081
 363:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.Idq_setpoint_src_.connect_to(&axis_->open_loop_controller_.I
 7671              		.loc 3 363 71 is_stmt 0 discriminator 4 view .LVU2082
 7672 011e 236B     		ldr	r3, [r4, #48]
 363:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.Idq_setpoint_src_.connect_to(&axis_->open_loop_controller_.I
 7673              		.loc 3 363 78 discriminator 4 view .LVU2083
 7674 0120 D3F85821 		ldr	r2, [r3, #344]
 363:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.Idq_setpoint_src_.connect_to(&axis_->open_loop_controller_.I
 7675              		.loc 3 363 93 discriminator 4 view .LVU2084
 7676 0124 92F83830 		ldrb	r3, [r2, #56]	@ zero_extendqisi2
 363:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.Idq_setpoint_src_.connect_to(&axis_->open_loop_controller_.I
 7677              		.loc 3 363 104 discriminator 4 view .LVU2085
 7678 0128 023B     		subs	r3, r3, #2
 7679 012a 18BF     		it	ne
 7680 012c 0123     		movne	r3, #1
 363:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.Idq_setpoint_src_.connect_to(&axis_->open_loop_controller_.I
 7681              		.loc 3 363 68 discriminator 4 view .LVU2086
 7682 012e 82F8E030 		strb	r3, [r2, #224]
 364:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.Vdq_setpoint_src_.connect_to(&axis_->open_loop_controller_.V
 7683              		.loc 3 364 9 is_stmt 1 discriminator 4 view .LVU2087
 7684 0132 236B     		ldr	r3, [r4, #48]
 364:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.Vdq_setpoint_src_.connect_to(&axis_->open_loop_controller_.V
 7685              		.loc 3 364 16 is_stmt 0 discriminator 4 view .LVU2088
 7686 0134 D3F85821 		ldr	r2, [r3, #344]
 364:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.Vdq_setpoint_src_.connect_to(&axis_->open_loop_controller_.V
 7687              		.loc 3 364 68 discriminator 4 view .LVU2089
 7688 0138 03F59473 		add	r3, r3, #296
 7689              	.LVL616:
 364:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.Vdq_setpoint_src_.connect_to(&axis_->open_loop_controller_.V
 7690              		.loc 3 364 68 discriminator 4 view .LVU2090
ARM GAS  /tmp/cc5nV8qb.s 			page 331


 7691 013c 0293     		str	r3, [sp, #8]
 7692              	.LVL617:
 7693              	.LBB2674:
 7694              	.LBI2674:
 103:./MotorControl/component.hpp ****         return content_;
 104:./MotorControl/component.hpp ****     }
 105:./MotorControl/component.hpp ****     
 106:./MotorControl/component.hpp **** private:
 107:./MotorControl/component.hpp ****     uint32_t age_ = 2; // Age in number of control loop iterations
 108:./MotorControl/component.hpp ****     T content_;
 109:./MotorControl/component.hpp **** };
 110:./MotorControl/component.hpp **** 
 111:./MotorControl/component.hpp **** /**
 112:./MotorControl/component.hpp ****  * @brief An input port provides a value from the source to which it's configured.
 113:./MotorControl/component.hpp ****  * 
 114:./MotorControl/component.hpp ****  * The source can be one of:
 115:./MotorControl/component.hpp ****  *  - an internally stored value
 116:./MotorControl/component.hpp ****  *  - an externally stored value (referenced by a pointer)
 117:./MotorControl/component.hpp ****  *  - an external OutputPort (referenced by a pointer)
 118:./MotorControl/component.hpp ****  *  - none (all queries will return std::nullopt)
 119:./MotorControl/component.hpp ****  * 
 120:./MotorControl/component.hpp ****  * Member functions of this class are not thread-safe unless otherwise noted.
 121:./MotorControl/component.hpp ****  */
 122:./MotorControl/component.hpp **** template<typename T>
 123:./MotorControl/component.hpp **** class InputPort {
 124:./MotorControl/component.hpp **** public:
 125:./MotorControl/component.hpp ****     void connect_to(OutputPort<T>* input_port) {
 7695              		.loc 13 125 10 is_stmt 1 discriminator 4 view .LVU2091
 7696              	.LBB2675:
 126:./MotorControl/component.hpp ****         content_ = input_port;
 7697              		.loc 13 126 18 is_stmt 0 discriminator 4 view .LVU2092
 7698 013e 02F1E406 		add	r6, r2, #228
 7699              	.LVL618:
 7700              	.LBB2676:
 7701              	.LBI2676:
1293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
1294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     class variant
1297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : private __detail::__variant::_Variant_base<_Types...>,
1298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       private _Enable_default_constructor<
1299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_default_ctor,
1300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  variant<_Types...>>,
1301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       private _Enable_copy_move<
1302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_copy_ctor,
1303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_copy_assign,
1304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_move_ctor,
1305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_move_assign,
1306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant<_Types...>>
1307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     private:
1309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _UTypes, typename _Tp>
1310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend decltype(auto) __variant_cast(_Tp&&);
1311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename _Variant, typename... _Args>
1312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend void __variant_construct_by_index(_Variant& __v,
1313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						 _Args&&... __args);
1314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/cc5nV8qb.s 			page 332


1315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(sizeof...(_Types) > 0,
1316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "variant must have at least one alternative");
1317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!(std::is_reference_v<_Types> || ...),
1318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "variant must have no reference alternative");
1319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!(std::is_void_v<_Types> || ...),
1320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "variant must have no void alternative");
1321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = __detail::__variant::_Variant_base<_Types...>;
1323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Default_ctor_enabler =
1324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Enable_default_constructor<
1325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __detail::__variant::_Traits<_Types...>::_S_default_ctor,
1326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    variant<_Types...>>;
1327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr bool __not_self
1330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  = !is_same_v<__remove_cvref_t<_Tp>, variant>;
1331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr bool
1334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__exactly_once = __detail::__variant::__exactly_once<_Tp, _Types...>;
1335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr size_t __accepted_index
1338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  = __detail::__variant::__accepted_index<_Tp, variant>::value;
1339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename = enable_if_t<(_Np < sizeof...(_Types))>>
1341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	using __to_type = variant_alternative_t<_Np, variant>;
1342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename = enable_if_t<__not_self<_Tp>>>
1344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	using __accepted_type = __to_type<__accepted_index<_Tp>>;
1345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr size_t __index_of =
1348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __detail::__variant::__index_of_v<_Tp, _Types...>;
1349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Traits = __detail::__variant::_Traits<_Types...>;
1351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __is_in_place_tag : false_type { };
1354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __is_in_place_tag<in_place_type_t<_Tp>> : true_type { };
1356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np>
1357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __is_in_place_tag<in_place_index_t<_Np>> : true_type { };
1358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr bool __not_in_place_tag
1361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  = !__is_in_place_tag<__remove_cvref_t<_Tp>>::value;
1362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     public:
1364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant() = default;
1365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant(const variant& __rhs) = default;
1366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant(variant&&) = default;
1367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant& operator=(const variant&) = default;
1368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant& operator=(variant&&) = default;
1369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       ~variant() = default;
1370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp,
ARM GAS  /tmp/cc5nV8qb.s 			page 333


1372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<sizeof...(_Types) != 0>,
1373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<__not_in_place_tag<_Tp>>,
1374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename _Tj = __accepted_type<_Tp&&>,
1375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<__exactly_once<_Tj>
1376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				      && is_constructible_v<_Tj, _Tp>>>
1377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
1378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(_Tp&& __t)
1379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	noexcept(is_nothrow_constructible_v<_Tj, _Tp>)
1380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: variant(in_place_index<__accepted_index<_Tp>>,
1381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Tp>(__t))
1382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
1383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename... _Args,
1385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<__exactly_once<_Tp>
1386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				      && is_constructible_v<_Tp, _Args...>>>
1387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
1388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(in_place_type_t<_Tp>, _Args&&... __args)
1389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: variant(in_place_index<__index_of<_Tp>>,
1390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...)
1391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
1392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename _Up, typename... _Args,
1394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<__exactly_once<_Tp>
1395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				      && is_constructible_v<_Tp,
1396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					   initializer_list<_Up>&, _Args...>>>
1397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
1398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(in_place_type_t<_Tp>, initializer_list<_Up> __il,
1399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		_Args&&... __args)
1400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: variant(in_place_index<__index_of<_Tp>>, __il,
1401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...)
1402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
1403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args,
1405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename _Tp = __to_type<_Np>,
1406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<is_constructible_v<_Tp, _Args...>>>
1407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
1408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(in_place_index_t<_Np>, _Args&&... __args)
1409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _Base(in_place_index<_Np>, std::forward<_Args>(__args)...),
1410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Default_ctor_enabler(_Enable_default_constructor_tag{})
1411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
1412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename _Up, typename... _Args,
1414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename _Tp = __to_type<_Np>,
1415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<is_constructible_v<_Tp,
1416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 							 initializer_list<_Up>&,
1417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 							 _Args...>>>
1418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
1419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(in_place_index_t<_Np>, initializer_list<_Up> __il,
1420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		_Args&&... __args)
1421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _Base(in_place_index<_Np>, __il, std::forward<_Args>(__args)...),
1422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Default_ctor_enabler(_Enable_default_constructor_tag{})
1423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
1424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<__exactly_once<__accepted_type<_Tp&&>>
1427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    && is_constructible_v<__accepted_type<_Tp&&>, _Tp>
1428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    && is_assignable_v<__accepted_type<_Tp&&>&, _Tp>,
ARM GAS  /tmp/cc5nV8qb.s 			page 334


1429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    variant&>
1430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	operator=(_Tp&& __rhs)
 7702              		.loc 1 1430 2 is_stmt 1 discriminator 4 view .LVU2093
 7703              	.LBB2677:
 7704              	.LBB2678:
 7705              	.LBB2679:
 7706              	.LBI2679:
1431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
1432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		 && is_nothrow_constructible_v<__accepted_type<_Tp&&>, _Tp>)
1433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  constexpr auto __index = __accepted_index<_Tp>;
1435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if (index() == __index)
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
1437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
1438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      using _Tj = __accepted_type<_Tp&&>;
1440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      if constexpr (is_nothrow_constructible_v<_Tj, _Tp>
1441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			    || !is_nothrow_move_constructible_v<_Tj>)
1442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		this->emplace<__index>(std::forward<_Tp>(__rhs));
1443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      else
1444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		operator=(variant(std::forward<_Tp>(__rhs)));
1445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return *this;
1447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename... _Args>
1450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<is_constructible_v<_Tp, _Args...> && __exactly_once<_Tp>,
1451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    _Tp&>
1452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	emplace(_Args&&... __args)
1453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  constexpr size_t __index = __index_of<_Tp>;
1455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return this->emplace<__index>(std::forward<_Args>(__args)...);
1456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename _Up, typename... _Args>
1459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>
1460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    && __exactly_once<_Tp>,
1461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    _Tp&>
1462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	emplace(initializer_list<_Up> __il, _Args&&... __args)
1463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  constexpr size_t __index = __index_of<_Tp>;
1465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return this->emplace<__index>(__il, std::forward<_Args>(__args)...);
1466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
1469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<is_constructible_v<variant_alternative_t<_Np, variant>,
1470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				       _Args...>,
1471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    variant_alternative_t<_Np, variant>&>
1472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	emplace(_Args&&... __args)
1473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  static_assert(_Np < sizeof...(_Types),
1475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			"The index must be in [0, number of alternatives)");
1476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  using type = variant_alternative_t<_Np, variant>;
1477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // Provide the strong exception-safety guarantee when possible,
1478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // to avoid becoming valueless.
1479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (is_nothrow_constructible_v<type, _Args...>)
1480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
ARM GAS  /tmp/cc5nV8qb.s 			page 335


1481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __variant_construct_by_index<_Np>(*this,
1483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
1484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else if constexpr (is_scalar_v<type>)
1486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This might invoke a potentially-throwing conversion operator:
1488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      const type __tmp(std::forward<_Args>(__args)...);
1489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // But these steps won't throw:
1490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
1491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __variant_construct_by_index<_Np>(*this, __tmp);
1492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()
1494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      && _Traits::_S_move_assign)
1495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This construction might throw:
1497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      variant __tmp(in_place_index<_Np>,
1498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			    std::forward<_Args>(__args)...);
1499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // But _Never_valueless_alt<type> means this won't:
1500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      *this = std::move(__tmp);
1501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
1503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This case only provides the basic exception-safety guarantee,
1505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // i.e. the variant can become valueless.
1506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
1507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __try
1508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant_construct_by_index<_Np>(*this,
1510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    std::forward<_Args>(__args)...);
1511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __catch (...)
1513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  this->_M_index = variant_npos;
1515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __throw_exception_again;
1516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return std::get<_Np>(*this);
1519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename _Up, typename... _Args>
1522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<is_constructible_v<variant_alternative_t<_Np, variant>,
1523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				       initializer_list<_Up>&, _Args...>,
1524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    variant_alternative_t<_Np, variant>&>
1525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	emplace(initializer_list<_Up> __il, _Args&&... __args)
1526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  static_assert(_Np < sizeof...(_Types),
1528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			"The index must be in [0, number of alternatives)");
1529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  using type = variant_alternative_t<_Np, variant>;
1530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // Provide the strong exception-safety guarantee when possible,
1531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // to avoid becoming valueless.
1532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (is_nothrow_constructible_v<type,
1533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						   initializer_list<_Up>&,
1534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						   _Args...>)
1535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
1537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __variant_construct_by_index<_Np>(*this, __il,
ARM GAS  /tmp/cc5nV8qb.s 			page 336


1538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
1539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()
1541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      && _Traits::_S_move_assign)
1542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This construction might throw:
1544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      variant __tmp(in_place_index<_Np>, __il,
1545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			    std::forward<_Args>(__args)...);
1546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // But _Never_valueless_alt<type> means this won't:
1547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      *this = std::move(__tmp);
1548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
1550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This case only provides the basic exception-safety guarantee,
1552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // i.e. the variant can become valueless.
1553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
1554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __try
1555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant_construct_by_index<_Np>(*this, __il,
1557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    std::forward<_Args>(__args)...);
1558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __catch (...)
1560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  this->_M_index = variant_npos;
1562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __throw_exception_again;
1563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return std::get<_Np>(*this);
1566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr bool valueless_by_exception() const noexcept
1569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return !this->_M_valid(); }
1570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr size_t index() const noexcept
 7707              		.loc 1 1571 24 discriminator 4 view .LVU2094
 7708              	.LBB2680:
1572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
1573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	using __index_type = typename _Base::__index_type;
1574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (__detail::__variant::__never_valueless<_Types...>())
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return this->_M_index;
1576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
1577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return make_signed_t<__index_type>(this->_M_index);
 7709              		.loc 1 1577 45 is_stmt 0 discriminator 4 view .LVU2095
 7710 0142 92F8EC30 		ldrb	r3, [r2, #236]	@ zero_extendqisi2
 7711              	.LVL619:
 7712              		.loc 1 1577 45 discriminator 4 view .LVU2096
 7713              	.LBE2680:
 7714              	.LBE2679:
1435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
 7715              		.loc 1 1435 4 discriminator 4 view .LVU2097
 7716 0146 022B     		cmp	r3, #2
 7717 0148 00F0C580 		beq	.L431
 7718              	.LVL620:
 7719              	.LBB2681:
 7720              	.LBB2682:
 7721              	.LBI2682:
1472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
ARM GAS  /tmp/cc5nV8qb.s 			page 337


 7722              		.loc 1 1472 2 is_stmt 1 view .LVU2098
 7723              	.LBB2683:
 7724              	.LBB2684:
 7725              	.LBI2684:
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_index = static_cast<__index_type>(variant_npos); }
 7726              		.loc 1 451 12 view .LVU2099
 7727              	.LBB2685:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 7728              		.loc 1 452 18 is_stmt 0 view .LVU2100
 7729 014c FF23     		movs	r3, #255
 7730 014e 3372     		strb	r3, [r6, #8]
 7731              	.LVL621:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 7732              		.loc 1 452 18 view .LVU2101
 7733              	.LBE2685:
 7734              	.LBE2684:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 7735              		.loc 1 1482 41 view .LVU2102
 7736 0150 02A9     		add	r1, sp, #8
 7737              	.LVL622:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 7738              		.loc 1 1482 41 view .LVU2103
 7739 0152 3046     		mov	r0, r6
 7740 0154 FFF7FEFF 		bl	_ZSt28__variant_construct_by_indexILj2ESt7variantIJSt4pairIffEPS2_P10OutputPortIS2_EEEJRS6_EEvR
 7741              	.LVL623:
 7742              	.LBB2686:
 7743              	.LBI2686:
1578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else
1579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return size_t(__index_type(this->_M_index + 1)) - 1;
1580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
1581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void
1583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       swap(variant& __rhs)
1584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       noexcept((__is_nothrow_swappable<_Types>::value && ...)
1585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       && is_nothrow_move_constructible_v<variant>)
1586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
1587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::__raw_idx_visit(
1588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  [this, &__rhs](auto&& __rhs_mem, auto __rhs_index) mutable
1589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
1590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    if constexpr (__rhs_index != variant_npos)
1591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      {
1592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		if (this->index() == __rhs_index)
1593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  {
1594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    auto& __this_mem =
1595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      std::get<__rhs_index>(*this);
1596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    using std::swap;
1597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    swap(__this_mem, __rhs_mem);
1598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  }
1599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		else
1600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  {
1601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    if (!this->valueless_by_exception()) [[__likely__]]
1602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      {
1603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			auto __tmp(std::move(__rhs_mem));
1604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			__rhs = std::move(*this);
1605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			this->_M_destructive_move(__rhs_index,
1606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						  std::move(__tmp));
1607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      }
ARM GAS  /tmp/cc5nV8qb.s 			page 338


1608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    else
1609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      {
1610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			this->_M_destructive_move(__rhs_index,
1611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						  std::move(__rhs_mem));
1612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			__rhs._M_reset();
1613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      }
1614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  }
1615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      }
1616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    else
1617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      {
1618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		if (!this->valueless_by_exception()) [[__likely__]]
1619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  {
1620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    __rhs = std::move(*this);
1621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    this->_M_reset();
1622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  }
1623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      }
1624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __rhs);
1625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
1626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     private:
1628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #if defined(__clang__) && __clang_major__ <= 7
1630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     public:
1631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_M_u; // See https://bugs.llvm.org/show_bug.cgi?id=31852
1632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     private:
1633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #endif
1634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename _Vp>
1636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend constexpr decltype(auto)
1637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::__get(_Vp&& __v) noexcept;
1638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Vp>
1640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend void*
1641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::__get_storage(_Vp&& __v) noexcept;
1642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP) \
1644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Tp> \
1645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend constexpr bool \
1646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	operator __OP(const variant<_Tp...>& __lhs, \
1647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      const variant<_Tp...>& __rhs);
1648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(<)
1650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(<=)
1651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(==)
1652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(!=)
1653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(>=)
1654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(>)
1655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #undef _VARIANT_RELATION_FUNCTION_TEMPLATE
1657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
1658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
1660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>>&
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(variant<_Types...>& __v)
 7744              		.loc 1 1661 5 is_stmt 1 view .LVU2104
 7745              	.LBB2687:
 7746              	.LBB2688:
ARM GAS  /tmp/cc5nV8qb.s 			page 339


 7747              	.LBI2688:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 7748              		.loc 1 1571 24 view .LVU2105
 7749              	.LBB2689:
1577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else
 7750              		.loc 1 1577 45 is_stmt 0 view .LVU2106
 7751 0158 307A     		ldrb	r0, [r6, #8]	@ zero_extendqisi2
 7752              	.LVL624:
1577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else
 7753              		.loc 1 1577 45 view .LVU2107
 7754              	.LBE2689:
 7755              	.LBE2688:
1662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(_Np < sizeof...(_Types),
1664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "The index must be in [0, number of alternatives)");
1665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if (__v.index() != _Np)
 7756              		.loc 1 1665 7 view .LVU2108
 7757 015a 0228     		cmp	r0, #2
 7758 015c 40F0C880 		bne	.L432
 7759              	.LVL625:
 7760              	.L381:
 7761              		.loc 1 1665 7 view .LVU2109
 7762              	.LBE2687:
 7763              	.LBE2686:
 7764              	.LBE2683:
 7765              	.LBE2682:
 7766              	.LBE2681:
 7767              	.LBE2678:
 7768              	.LBE2677:
 7769              	.LBE2676:
 7770              	.LBE2675:
 7771              	.LBE2674:
 365:MotorControl/encoder.cpp ****         
 7772              		.loc 3 365 9 is_stmt 1 view .LVU2110
 7773 0160 236B     		ldr	r3, [r4, #48]
 365:MotorControl/encoder.cpp ****         
 7774              		.loc 3 365 16 is_stmt 0 view .LVU2111
 7775 0162 D3F85821 		ldr	r2, [r3, #344]
 365:MotorControl/encoder.cpp ****         
 7776              		.loc 3 365 68 view .LVU2112
 7777 0166 03F59A73 		add	r3, r3, #308
 7778              	.LVL626:
 365:MotorControl/encoder.cpp ****         
 7779              		.loc 3 365 68 view .LVU2113
 7780 016a 0293     		str	r3, [sp, #8]
 7781              	.LVL627:
 7782              	.LBB2715:
 7783              	.LBI2715:
 125:./MotorControl/component.hpp ****         content_ = input_port;
 7784              		.loc 13 125 10 is_stmt 1 view .LVU2114
 7785              	.LBB2716:
 7786              		.loc 13 126 18 is_stmt 0 view .LVU2115
 7787 016c 02F1F006 		add	r6, r2, #240
 7788              	.LVL628:
 7789              	.LBB2717:
 7790              	.LBI2717:
1430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
ARM GAS  /tmp/cc5nV8qb.s 			page 340


 7791              		.loc 1 1430 2 is_stmt 1 view .LVU2116
 7792              	.LBB2718:
 7793              	.LBB2719:
 7794              	.LBB2720:
 7795              	.LBI2720:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 7796              		.loc 1 1571 24 view .LVU2117
 7797              	.LBB2721:
1577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else
 7798              		.loc 1 1577 45 is_stmt 0 view .LVU2118
 7799 0170 92F8F830 		ldrb	r3, [r2, #248]	@ zero_extendqisi2
 7800              	.LVL629:
1577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else
 7801              		.loc 1 1577 45 view .LVU2119
 7802              	.LBE2721:
 7803              	.LBE2720:
1435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
 7804              		.loc 1 1435 4 view .LVU2120
 7805 0174 022B     		cmp	r3, #2
 7806 0176 00F0C180 		beq	.L433
 7807              	.LVL630:
 7808              	.LBB2722:
 7809              	.LBB2723:
 7810              	.LBI2723:
1472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 7811              		.loc 1 1472 2 is_stmt 1 view .LVU2121
 7812              	.LBB2724:
 7813              	.LBB2725:
 7814              	.LBI2725:
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_index = static_cast<__index_type>(variant_npos); }
 7815              		.loc 1 451 12 view .LVU2122
 7816              	.LBB2726:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 7817              		.loc 1 452 18 is_stmt 0 view .LVU2123
 7818 017a FF23     		movs	r3, #255
 7819 017c 3372     		strb	r3, [r6, #8]
 7820              	.LVL631:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 7821              		.loc 1 452 18 view .LVU2124
 7822              	.LBE2726:
 7823              	.LBE2725:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 7824              		.loc 1 1482 41 view .LVU2125
 7825 017e 02A9     		add	r1, sp, #8
 7826              	.LVL632:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 7827              		.loc 1 1482 41 view .LVU2126
 7828 0180 3046     		mov	r0, r6
 7829 0182 FFF7FEFF 		bl	_ZSt28__variant_construct_by_indexILj2ESt7variantIJSt4pairIffEPS2_P10OutputPortIS2_EEEJRS6_EEvR
 7830              	.LVL633:
 7831              	.LBB2727:
 7832              	.LBI2727:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 7833              		.loc 1 1661 5 is_stmt 1 view .LVU2127
 7834              	.LBB2728:
 7835              	.LBB2729:
 7836              	.LBI2729:
ARM GAS  /tmp/cc5nV8qb.s 			page 341


1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 7837              		.loc 1 1571 24 view .LVU2128
 7838              	.LBB2730:
1577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else
 7839              		.loc 1 1577 45 is_stmt 0 view .LVU2129
 7840 0186 307A     		ldrb	r0, [r6, #8]	@ zero_extendqisi2
 7841              	.LVL634:
1577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else
 7842              		.loc 1 1577 45 view .LVU2130
 7843              	.LBE2730:
 7844              	.LBE2729:
 7845              		.loc 1 1665 7 view .LVU2131
 7846 0188 0228     		cmp	r0, #2
 7847 018a 40F0C480 		bne	.L434
 7848              	.LVL635:
 7849              	.L385:
 7850              		.loc 1 1665 7 view .LVU2132
 7851              	.LBE2728:
 7852              	.LBE2727:
 7853              	.LBE2724:
 7854              	.LBE2723:
 7855              	.LBE2722:
 7856              	.LBE2719:
 7857              	.LBE2718:
 7858              	.LBE2717:
 7859              	.LBE2716:
 7860              	.LBE2715:
 367:MotorControl/encoder.cpp ****         axis_->acim_estimator_.rotor_phase_src_.connect_to(&axis_->open_loop_controller_.phase_);
 7861              		.loc 3 367 9 is_stmt 1 view .LVU2133
 7862 018e 236B     		ldr	r3, [r4, #48]
 367:MotorControl/encoder.cpp ****         axis_->acim_estimator_.rotor_phase_src_.connect_to(&axis_->open_loop_controller_.phase_);
 7863              		.loc 3 367 16 is_stmt 0 view .LVU2134
 7864 0190 D3F85821 		ldr	r2, [r3, #344]
 367:MotorControl/encoder.cpp ****         axis_->acim_estimator_.rotor_phase_src_.connect_to(&axis_->open_loop_controller_.phase_);
 7865              		.loc 3 367 61 view .LVU2135
 7866 0194 03F5A073 		add	r3, r3, #320
 7867              	.LVL636:
 367:MotorControl/encoder.cpp ****         axis_->acim_estimator_.rotor_phase_src_.connect_to(&axis_->open_loop_controller_.phase_);
 7868              		.loc 3 367 61 view .LVU2136
 7869 0198 0293     		str	r3, [sp, #8]
 7870              	.LVL637:
 7871              	.LBB2756:
 7872              	.LBI2756:
 125:./MotorControl/component.hpp ****         content_ = input_port;
 7873              		.loc 13 125 10 is_stmt 1 view .LVU2137
 7874              	.LBB2757:
 7875              		.loc 13 126 18 is_stmt 0 view .LVU2138
 7876 019a 02F1FC06 		add	r6, r2, #252
 7877              	.LVL638:
 7878              	.LBB2758:
 7879              	.LBI2758:
1430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
 7880              		.loc 1 1430 2 is_stmt 1 view .LVU2139
 7881              	.LBB2759:
 7882              	.LBB2760:
 7883              	.LBB2761:
 7884              	.LBI2761:
ARM GAS  /tmp/cc5nV8qb.s 			page 342


1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 7885              		.loc 1 1571 24 view .LVU2140
 7886              	.LBB2762:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 7887              		.loc 1 1575 17 is_stmt 0 view .LVU2141
 7888 019e 92F80031 		ldrb	r3, [r2, #256]	@ zero_extendqisi2
 7889              	.LVL639:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 7890              		.loc 1 1575 17 view .LVU2142
 7891              	.LBE2762:
 7892              	.LBE2761:
1435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
 7893              		.loc 1 1435 4 view .LVU2143
 7894 01a2 022B     		cmp	r3, #2
 7895 01a4 00F0BD80 		beq	.L435
 7896              	.LVL640:
 7897              	.LBB2763:
 7898              	.LBB2764:
 7899              	.LBI2764:
1472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 7900              		.loc 1 1472 2 is_stmt 1 view .LVU2144
 7901              	.LBB2765:
 7902              	.LBB2766:
 7903              	.LBI2766:
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_index = static_cast<__index_type>(variant_npos); }
 7904              		.loc 1 451 12 view .LVU2145
 7905              	.LBB2767:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 7906              		.loc 1 452 18 is_stmt 0 view .LVU2146
 7907 01a8 FF23     		movs	r3, #255
 7908 01aa 3371     		strb	r3, [r6, #4]
 7909              	.LVL641:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 7910              		.loc 1 452 18 view .LVU2147
 7911              	.LBE2767:
 7912              	.LBE2766:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 7913              		.loc 1 1482 41 view .LVU2148
 7914 01ac 02A9     		add	r1, sp, #8
 7915              	.LVL642:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 7916              		.loc 1 1482 41 view .LVU2149
 7917 01ae 3046     		mov	r0, r6
 7918 01b0 FFF7FEFF 		bl	_ZSt28__variant_construct_by_indexILj2ESt7variantIJfPfP10OutputPortIfEEEJRS4_EEvRT0_DpOT1_
 7919              	.LVL643:
 7920              	.LBB2768:
 7921              	.LBI2768:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 7922              		.loc 1 1661 5 is_stmt 1 view .LVU2150
 7923              	.LBB2769:
 7924              	.LBB2770:
 7925              	.LBI2770:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 7926              		.loc 1 1571 24 view .LVU2151
 7927              	.LBB2771:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 7928              		.loc 1 1575 17 is_stmt 0 view .LVU2152
ARM GAS  /tmp/cc5nV8qb.s 			page 343


 7929 01b4 3379     		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 7930              	.LVL644:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 7931              		.loc 1 1575 17 view .LVU2153
 7932              	.LBE2771:
 7933              	.LBE2770:
 7934              		.loc 1 1665 7 view .LVU2154
 7935 01b6 022B     		cmp	r3, #2
 7936 01b8 40F0BD80 		bne	.L436
 7937              	.LVL645:
 7938              	.L389:
 7939              		.loc 1 1665 7 view .LVU2155
 7940              	.LBE2769:
 7941              	.LBE2768:
 7942              	.LBE2765:
 7943              	.LBE2764:
 7944              	.LBE2763:
 7945              	.LBE2760:
 7946              	.LBE2759:
 7947              	.LBE2758:
 7948              	.LBE2757:
 7949              	.LBE2756:
 368:MotorControl/encoder.cpp **** 
 7950              		.loc 3 368 9 is_stmt 1 view .LVU2156
 7951 01bc 236B     		ldr	r3, [r4, #48]
 368:MotorControl/encoder.cpp **** 
 7952              		.loc 3 368 59 is_stmt 0 view .LVU2157
 7953 01be 03F5A072 		add	r2, r3, #320
 7954              	.LVL646:
 368:MotorControl/encoder.cpp **** 
 7955              		.loc 3 368 59 view .LVU2158
 7956 01c2 0292     		str	r2, [sp, #8]
 7957              	.LVL647:
 7958              	.LBB2799:
 7959              	.LBI2799:
 125:./MotorControl/component.hpp ****         content_ = input_port;
 7960              		.loc 13 125 10 is_stmt 1 view .LVU2159
 7961              	.LBB2800:
 7962              		.loc 13 126 18 is_stmt 0 view .LVU2160
 7963 01c4 03F1B806 		add	r6, r3, #184
 7964              	.LVL648:
 7965              	.LBB2801:
 7966              	.LBI2801:
1430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
 7967              		.loc 1 1430 2 is_stmt 1 view .LVU2161
 7968              	.LBB2802:
 7969              	.LBB2803:
 7970              	.LBB2804:
 7971              	.LBI2804:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 7972              		.loc 1 1571 24 view .LVU2162
 7973              	.LBB2805:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 7974              		.loc 1 1575 17 is_stmt 0 view .LVU2163
 7975 01c8 93F8BC20 		ldrb	r2, [r3, #188]	@ zero_extendqisi2
 7976              	.LVL649:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
ARM GAS  /tmp/cc5nV8qb.s 			page 344


 7977              		.loc 1 1575 17 view .LVU2164
 7978              	.LBE2805:
 7979              	.LBE2804:
1435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
 7980              		.loc 1 1435 4 view .LVU2165
 7981 01cc 022A     		cmp	r2, #2
 7982 01ce 00F0B580 		beq	.L437
 7983              	.LVL650:
 7984              	.LBB2806:
 7985              	.LBB2807:
 7986              	.LBI2807:
1472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 7987              		.loc 1 1472 2 is_stmt 1 view .LVU2166
 7988              	.LBB2808:
 7989              	.LBB2809:
 7990              	.LBI2809:
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_index = static_cast<__index_type>(variant_npos); }
 7991              		.loc 1 451 12 view .LVU2167
 7992              	.LBB2810:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 7993              		.loc 1 452 18 is_stmt 0 view .LVU2168
 7994 01d2 FF23     		movs	r3, #255
 7995 01d4 3371     		strb	r3, [r6, #4]
 7996              	.LVL651:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 7997              		.loc 1 452 18 view .LVU2169
 7998              	.LBE2810:
 7999              	.LBE2809:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 8000              		.loc 1 1482 41 view .LVU2170
 8001 01d6 02A9     		add	r1, sp, #8
 8002              	.LVL652:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 8003              		.loc 1 1482 41 view .LVU2171
 8004 01d8 3046     		mov	r0, r6
 8005 01da FFF7FEFF 		bl	_ZSt28__variant_construct_by_indexILj2ESt7variantIJfPfP10OutputPortIfEEEJRS4_EEvRT0_DpOT1_
 8006              	.LVL653:
 8007              	.LBB2811:
 8008              	.LBI2811:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8009              		.loc 1 1661 5 is_stmt 1 view .LVU2172
 8010              	.LBB2812:
 8011              	.LBB2813:
 8012              	.LBI2813:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 8013              		.loc 1 1571 24 view .LVU2173
 8014              	.LBB2814:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8015              		.loc 1 1575 17 is_stmt 0 view .LVU2174
 8016 01de 3379     		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 8017              	.LVL654:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8018              		.loc 1 1575 17 view .LVU2175
 8019              	.LBE2814:
 8020              	.LBE2813:
 8021              		.loc 1 1665 7 view .LVU2176
 8022 01e0 022B     		cmp	r3, #2
ARM GAS  /tmp/cc5nV8qb.s 			page 345


 8023 01e2 40F0B580 		bne	.L438
 8024              	.LVL655:
 8025              	.L393:
 8026              		.loc 1 1665 7 view .LVU2177
 8027              	.LBE2812:
 8028              	.LBE2811:
 8029              	.LBE2808:
 8030              	.LBE2807:
 8031              	.LBE2806:
 8032              	.LBE2803:
 8033              	.LBE2802:
 8034              	.LBE2801:
 8035              	.LBE2800:
 8036              	.LBE2799:
 370:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.phase_vel_src_.connect_to(&axis_->open_loop_controller_.phas
 8037              		.loc 3 370 9 is_stmt 1 view .LVU2178
 8038 01e6 236B     		ldr	r3, [r4, #48]
 370:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.phase_vel_src_.connect_to(&axis_->open_loop_controller_.phas
 8039              		.loc 3 370 16 is_stmt 0 view .LVU2179
 8040 01e8 D3F85821 		ldr	r2, [r3, #344]
 370:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.phase_vel_src_.connect_to(&axis_->open_loop_controller_.phas
 8041              		.loc 3 370 48 view .LVU2180
 8042 01ec 03F5A473 		add	r3, r3, #328
 8043              	.LVL656:
 370:MotorControl/encoder.cpp ****         axis_->motor_.current_control_.phase_vel_src_.connect_to(&axis_->open_loop_controller_.phas
 8044              		.loc 3 370 48 view .LVU2181
 8045 01f0 0293     		str	r3, [sp, #8]
 8046              	.LVL657:
 8047              	.LBB2842:
 8048              	.LBI2842:
 125:./MotorControl/component.hpp ****         content_ = input_port;
 8049              		.loc 13 125 10 is_stmt 1 view .LVU2182
 8050              	.LBB2843:
 8051              		.loc 13 126 18 is_stmt 0 view .LVU2183
 8052 01f2 02F5C276 		add	r6, r2, #388
 8053              	.LVL658:
 8054              	.LBB2844:
 8055              	.LBI2844:
1430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
 8056              		.loc 1 1430 2 is_stmt 1 view .LVU2184
 8057              	.LBB2845:
 8058              	.LBB2846:
 8059              	.LBB2847:
 8060              	.LBI2847:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 8061              		.loc 1 1571 24 view .LVU2185
 8062              	.LBB2848:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8063              		.loc 1 1575 17 is_stmt 0 view .LVU2186
 8064 01f6 92F88831 		ldrb	r3, [r2, #392]	@ zero_extendqisi2
 8065              	.LVL659:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8066              		.loc 1 1575 17 view .LVU2187
 8067              	.LBE2848:
 8068              	.LBE2847:
1435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
 8069              		.loc 1 1435 4 view .LVU2188
ARM GAS  /tmp/cc5nV8qb.s 			page 346


 8070 01fa 022B     		cmp	r3, #2
 8071 01fc 00F0AB80 		beq	.L439
 8072              	.LVL660:
 8073              	.LBB2849:
 8074              	.LBB2850:
 8075              	.LBI2850:
1472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 8076              		.loc 1 1472 2 is_stmt 1 view .LVU2189
 8077              	.LBB2851:
 8078              	.LBB2852:
 8079              	.LBI2852:
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_index = static_cast<__index_type>(variant_npos); }
 8080              		.loc 1 451 12 view .LVU2190
 8081              	.LBB2853:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 8082              		.loc 1 452 18 is_stmt 0 view .LVU2191
 8083 0200 FF23     		movs	r3, #255
 8084 0202 3371     		strb	r3, [r6, #4]
 8085              	.LVL661:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 8086              		.loc 1 452 18 view .LVU2192
 8087              	.LBE2853:
 8088              	.LBE2852:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 8089              		.loc 1 1482 41 view .LVU2193
 8090 0204 02A9     		add	r1, sp, #8
 8091              	.LVL662:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 8092              		.loc 1 1482 41 view .LVU2194
 8093 0206 3046     		mov	r0, r6
 8094 0208 FFF7FEFF 		bl	_ZSt28__variant_construct_by_indexILj2ESt7variantIJfPfP10OutputPortIfEEEJRS4_EEvRT0_DpOT1_
 8095              	.LVL663:
 8096              	.LBB2854:
 8097              	.LBI2854:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8098              		.loc 1 1661 5 is_stmt 1 view .LVU2195
 8099              	.LBB2855:
 8100              	.LBB2856:
 8101              	.LBI2856:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 8102              		.loc 1 1571 24 view .LVU2196
 8103              	.LBB2857:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8104              		.loc 1 1575 17 is_stmt 0 view .LVU2197
 8105 020c 3379     		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 8106              	.LVL664:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8107              		.loc 1 1575 17 view .LVU2198
 8108              	.LBE2857:
 8109              	.LBE2856:
 8110              		.loc 1 1665 7 view .LVU2199
 8111 020e 022B     		cmp	r3, #2
 8112 0210 40F0AB80 		bne	.L440
 8113              	.LVL665:
 8114              	.L397:
 8115              		.loc 1 1665 7 view .LVU2200
 8116              	.LBE2855:
ARM GAS  /tmp/cc5nV8qb.s 			page 347


 8117              	.LBE2854:
 8118              	.LBE2851:
 8119              	.LBE2850:
 8120              	.LBE2849:
 8121              	.LBE2846:
 8122              	.LBE2845:
 8123              	.LBE2844:
 8124              	.LBE2843:
 8125              	.LBE2842:
 371:MotorControl/encoder.cpp ****         axis_->acim_estimator_.rotor_phase_vel_src_.connect_to(&axis_->open_loop_controller_.phase_
 8126              		.loc 3 371 9 is_stmt 1 view .LVU2201
 8127 0214 236B     		ldr	r3, [r4, #48]
 371:MotorControl/encoder.cpp ****         axis_->acim_estimator_.rotor_phase_vel_src_.connect_to(&axis_->open_loop_controller_.phase_
 8128              		.loc 3 371 16 is_stmt 0 view .LVU2202
 8129 0216 D3F85821 		ldr	r2, [r3, #344]
 371:MotorControl/encoder.cpp ****         axis_->acim_estimator_.rotor_phase_vel_src_.connect_to(&axis_->open_loop_controller_.phase_
 8130              		.loc 3 371 65 view .LVU2203
 8131 021a 03F5A473 		add	r3, r3, #328
 8132              	.LVL666:
 371:MotorControl/encoder.cpp ****         axis_->acim_estimator_.rotor_phase_vel_src_.connect_to(&axis_->open_loop_controller_.phase_
 8133              		.loc 3 371 65 view .LVU2204
 8134 021e 0293     		str	r3, [sp, #8]
 8135              	.LVL667:
 8136              	.LBB2885:
 8137              	.LBI2885:
 125:./MotorControl/component.hpp ****         content_ = input_port;
 8138              		.loc 13 125 10 is_stmt 1 view .LVU2205
 8139              	.LBB2886:
 8140              		.loc 13 126 18 is_stmt 0 view .LVU2206
 8141 0220 02F58276 		add	r6, r2, #260
 8142              	.LVL668:
 8143              	.LBB2887:
 8144              	.LBI2887:
1430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
 8145              		.loc 1 1430 2 is_stmt 1 view .LVU2207
 8146              	.LBB2888:
 8147              	.LBB2889:
 8148              	.LBB2890:
 8149              	.LBI2890:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 8150              		.loc 1 1571 24 view .LVU2208
 8151              	.LBB2891:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8152              		.loc 1 1575 17 is_stmt 0 view .LVU2209
 8153 0224 92F80831 		ldrb	r3, [r2, #264]	@ zero_extendqisi2
 8154              	.LVL669:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8155              		.loc 1 1575 17 view .LVU2210
 8156              	.LBE2891:
 8157              	.LBE2890:
1435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
 8158              		.loc 1 1435 4 view .LVU2211
 8159 0228 022B     		cmp	r3, #2
 8160 022a 00F0A180 		beq	.L441
 8161              	.LVL670:
 8162              	.LBB2892:
 8163              	.LBB2893:
ARM GAS  /tmp/cc5nV8qb.s 			page 348


 8164              	.LBI2893:
1472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 8165              		.loc 1 1472 2 is_stmt 1 view .LVU2212
 8166              	.LBB2894:
 8167              	.LBB2895:
 8168              	.LBI2895:
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_index = static_cast<__index_type>(variant_npos); }
 8169              		.loc 1 451 12 view .LVU2213
 8170              	.LBB2896:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 8171              		.loc 1 452 18 is_stmt 0 view .LVU2214
 8172 022e FF23     		movs	r3, #255
 8173 0230 3371     		strb	r3, [r6, #4]
 8174              	.LVL671:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 8175              		.loc 1 452 18 view .LVU2215
 8176              	.LBE2896:
 8177              	.LBE2895:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 8178              		.loc 1 1482 41 view .LVU2216
 8179 0232 02A9     		add	r1, sp, #8
 8180              	.LVL672:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 8181              		.loc 1 1482 41 view .LVU2217
 8182 0234 3046     		mov	r0, r6
 8183 0236 FFF7FEFF 		bl	_ZSt28__variant_construct_by_indexILj2ESt7variantIJfPfP10OutputPortIfEEEJRS4_EEvRT0_DpOT1_
 8184              	.LVL673:
 8185              	.LBB2897:
 8186              	.LBI2897:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8187              		.loc 1 1661 5 is_stmt 1 view .LVU2218
 8188              	.LBB2898:
 8189              	.LBB2899:
 8190              	.LBI2899:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 8191              		.loc 1 1571 24 view .LVU2219
 8192              	.LBB2900:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8193              		.loc 1 1575 17 is_stmt 0 view .LVU2220
 8194 023a 3379     		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 8195              	.LVL674:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8196              		.loc 1 1575 17 view .LVU2221
 8197              	.LBE2900:
 8198              	.LBE2899:
 8199              		.loc 1 1665 7 view .LVU2222
 8200 023c 022B     		cmp	r3, #2
 8201 023e 40F0A180 		bne	.L442
 8202              	.LVL675:
 8203              	.L401:
 8204              		.loc 1 1665 7 view .LVU2223
 8205              	.LBE2898:
 8206              	.LBE2897:
 8207              	.LBE2894:
 8208              	.LBE2893:
 8209              	.LBE2892:
 8210              	.LBE2889:
ARM GAS  /tmp/cc5nV8qb.s 			page 349


 8211              	.LBE2888:
 8212              	.LBE2887:
 8213              	.LBE2886:
 8214              	.LBE2885:
 372:MotorControl/encoder.cpp ****     }
 8215              		.loc 3 372 9 is_stmt 1 view .LVU2224
 8216 0242 236B     		ldr	r3, [r4, #48]
 372:MotorControl/encoder.cpp ****     }
 8217              		.loc 3 372 63 is_stmt 0 view .LVU2225
 8218 0244 03F5A472 		add	r2, r3, #328
 8219              	.LVL676:
 372:MotorControl/encoder.cpp ****     }
 8220              		.loc 3 372 63 view .LVU2226
 8221 0248 0292     		str	r2, [sp, #8]
 8222              	.LVL677:
 8223              	.LBB2928:
 8224              	.LBI2928:
 125:./MotorControl/component.hpp ****         content_ = input_port;
 8225              		.loc 13 125 10 is_stmt 1 view .LVU2227
 8226              	.LBB2929:
 8227              		.loc 13 126 18 is_stmt 0 view .LVU2228
 8228 024a 03F1C006 		add	r6, r3, #192
 8229              	.LVL678:
 8230              	.LBB2930:
 8231              	.LBI2930:
1430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
 8232              		.loc 1 1430 2 is_stmt 1 view .LVU2229
 8233              	.LBB2931:
 8234              	.LBB2932:
 8235              	.LBB2933:
 8236              	.LBI2933:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 8237              		.loc 1 1571 24 view .LVU2230
 8238              	.LBB2934:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8239              		.loc 1 1575 17 is_stmt 0 view .LVU2231
 8240 024e 93F8C420 		ldrb	r2, [r3, #196]	@ zero_extendqisi2
 8241              	.LVL679:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8242              		.loc 1 1575 17 view .LVU2232
 8243              	.LBE2934:
 8244              	.LBE2933:
1435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
 8245              		.loc 1 1435 4 view .LVU2233
 8246 0252 022A     		cmp	r2, #2
 8247 0254 00F09980 		beq	.L443
 8248              	.LVL680:
 8249              	.LBB2935:
 8250              	.LBB2936:
 8251              	.LBI2936:
1472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 8252              		.loc 1 1472 2 is_stmt 1 view .LVU2234
 8253              	.LBB2937:
 8254              	.LBB2938:
 8255              	.LBI2938:
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_index = static_cast<__index_type>(variant_npos); }
 8256              		.loc 1 451 12 view .LVU2235
ARM GAS  /tmp/cc5nV8qb.s 			page 350


 8257              	.LBB2939:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 8258              		.loc 1 452 18 is_stmt 0 view .LVU2236
 8259 0258 FF23     		movs	r3, #255
 8260 025a 3371     		strb	r3, [r6, #4]
 8261              	.LVL681:
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 8262              		.loc 1 452 18 view .LVU2237
 8263              	.LBE2939:
 8264              	.LBE2938:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 8265              		.loc 1 1482 41 view .LVU2238
 8266 025c 02A9     		add	r1, sp, #8
 8267              	.LVL682:
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
 8268              		.loc 1 1482 41 view .LVU2239
 8269 025e 3046     		mov	r0, r6
 8270 0260 FFF7FEFF 		bl	_ZSt28__variant_construct_by_indexILj2ESt7variantIJfPfP10OutputPortIfEEEJRS4_EEvRT0_DpOT1_
 8271              	.LVL683:
 8272              	.LBB2940:
 8273              	.LBI2940:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8274              		.loc 1 1661 5 is_stmt 1 view .LVU2240
 8275              	.LBB2941:
 8276              	.LBB2942:
 8277              	.LBI2942:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 8278              		.loc 1 1571 24 view .LVU2241
 8279              	.LBB2943:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8280              		.loc 1 1575 17 is_stmt 0 view .LVU2242
 8281 0264 3379     		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 8282              	.LVL684:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8283              		.loc 1 1575 17 view .LVU2243
 8284              	.LBE2943:
 8285              	.LBE2942:
 8286              		.loc 1 1665 7 view .LVU2244
 8287 0266 022B     		cmp	r3, #2
 8288 0268 40F09980 		bne	.L444
 8289              	.LVL685:
 8290              	.L405:
 8291              		.loc 1 1665 7 view .LVU2245
 8292              	.LBE2941:
 8293              	.LBE2940:
 8294              	.LBE2937:
 8295              	.LBE2936:
 8296              	.LBE2935:
 8297              	.LBE2932:
 8298              	.LBE2931:
 8299              	.LBE2930:
 8300              	.LBE2929:
 8301              	.LBE2928:
 8302              	.LBE2978:
 8303              	.LBB2979:
 8304              	.LBI2979:
  57:./Drivers/STM32/stm32_system.h ****     ~CriticalSectionContext() { cpu_exit_critical(mask_); }
ARM GAS  /tmp/cc5nV8qb.s 			page 351


 8305              		.loc 4 57 5 is_stmt 1 view .LVU2246
 8306              	.LBB2980:
 8307              		.loc 4 57 33 view .LVU2247
 8308              	.LBB2981:
 8309              	.LBI2981:
  37:./Drivers/STM32/stm32_system.h ****     __set_PRIMASK(priority_mask);
 8310              		.loc 4 37 20 view .LVU2248
 8311              	.LBE2981:
 8312              	.LBE2980:
 8313              	.LBE2979:
 8314              	.LBE2989:
  38:./Drivers/STM32/stm32_system.h **** }
 8315              		.loc 4 38 5 view .LVU2249
 8316              	.LBB2990:
 8317              	.LBB2986:
 8318              	.LBB2985:
 8319              	.LBB2984:
 8320              	.LBB2982:
 8321              	.LBI2982:
 412:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 8322              		.loc 5 412 27 view .LVU2250
 8323              	.LBB2983:
 8324              		.loc 5 414 3 view .LVU2251
 8325              		.syntax unified
 8326              	@ 414 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 8327 026c 85F31088 		MSR primask, r5
 8328              	@ 0 "" 2
 8329              	.LVL686:
 8330              		.loc 5 414 3 is_stmt 0 view .LVU2252
 8331              		.thumb
 8332              		.syntax unified
 8333              	.LBE2983:
 8334              	.LBE2982:
 8335              	.LBE2984:
 8336              	.LBE2985:
 8337              	.LBE2986:
 8338              	.LBE2990:
 374:MotorControl/encoder.cpp **** 
 8339              		.loc 3 374 5 is_stmt 1 view .LVU2253
 374:MotorControl/encoder.cpp **** 
 8340              		.loc 3 374 38 is_stmt 0 view .LVU2254
 8341 0270 206B     		ldr	r0, [r4, #48]
 8342              	.LEHB9:
 8343 0272 FFF7FEFF 		bl	_ZN4Axis26wait_for_control_iterationEv
 8344              	.LVL687:
 376:MotorControl/encoder.cpp **** 
 8345              		.loc 3 376 5 is_stmt 1 view .LVU2255
 8346 0276 236B     		ldr	r3, [r4, #48]
 376:MotorControl/encoder.cpp **** 
 8347              		.loc 3 376 12 is_stmt 0 view .LVU2256
 8348 0278 D3F85801 		ldr	r0, [r3, #344]
 376:MotorControl/encoder.cpp **** 
 8349              		.loc 3 376 22 view .LVU2257
 8350 027c 00F1C801 		add	r1, r0, #200
 8351 0280 FFF7FEFF 		bl	_ZN5Motor3armEP15PhaseControlLawILj3EE
 8352              	.LVL688:
 379:MotorControl/encoder.cpp ****         if (!axis_->motor_.is_armed_) {
ARM GAS  /tmp/cc5nV8qb.s 			page 352


 8353              		.loc 3 379 5 is_stmt 1 view .LVU2258
 8354              	.LBB2991:
 379:MotorControl/encoder.cpp ****         if (!axis_->motor_.is_armed_) {
 8355              		.loc 3 379 17 is_stmt 0 view .LVU2259
 8356 0284 0025     		movs	r5, #0
 8357              	.LVL689:
 8358              	.L409:
 379:MotorControl/encoder.cpp ****         if (!axis_->motor_.is_armed_) {
 8359              		.loc 3 379 26 is_stmt 1 discriminator 1 view .LVU2260
 8360 0286 B5F57A7F 		cmp	r5, #1000
 8361 028a 80F09B80 		bcs	.L407
 380:MotorControl/encoder.cpp ****             return false; // TODO: return "disarmed" error code
 8362              		.loc 3 380 9 view .LVU2261
 380:MotorControl/encoder.cpp ****             return false; // TODO: return "disarmed" error code
 8363              		.loc 3 380 14 is_stmt 0 view .LVU2262
 8364 028e 236B     		ldr	r3, [r4, #48]
 380:MotorControl/encoder.cpp ****             return false; // TODO: return "disarmed" error code
 8365              		.loc 3 380 21 view .LVU2263
 8366 0290 D3F85801 		ldr	r0, [r3, #344]
 380:MotorControl/encoder.cpp ****             return false; // TODO: return "disarmed" error code
 8367              		.loc 3 380 28 view .LVU2264
 8368 0294 90F89C60 		ldrb	r6, [r0, #156]	@ zero_extendqisi2
 380:MotorControl/encoder.cpp ****             return false; // TODO: return "disarmed" error code
 8369              		.loc 3 380 9 view .LVU2265
 8370 0298 002E     		cmp	r6, #0
 8371 029a 00F08780 		beq	.L375
 383:MotorControl/encoder.cpp ****             axis_->motor_.disarm();
 8372              		.loc 3 383 9 is_stmt 1 view .LVU2266
 383:MotorControl/encoder.cpp ****             axis_->motor_.disarm();
 8373              		.loc 3 383 20 is_stmt 0 view .LVU2267
 8374 029e 93F86C32 		ldrb	r3, [r3, #620]	@ zero_extendqisi2
 383:MotorControl/encoder.cpp ****             axis_->motor_.disarm();
 8375              		.loc 3 383 9 view .LVU2268
 8376 02a2 002B     		cmp	r3, #0
 8377 02a4 7ED1     		bne	.L445
 387:MotorControl/encoder.cpp ****     }
 8378              		.loc 3 387 9 is_stmt 1 discriminator 2 view .LVU2269
 387:MotorControl/encoder.cpp ****     }
 8379              		.loc 3 387 16 is_stmt 0 discriminator 2 view .LVU2270
 8380 02a6 0120     		movs	r0, #1
 8381 02a8 FFF7FEFF 		bl	osDelay
 8382              	.LVL690:
 8383              	.LEHE9:
 379:MotorControl/encoder.cpp ****         if (!axis_->motor_.is_armed_) {
 8384              		.loc 3 379 5 is_stmt 1 discriminator 2 view .LVU2271
 8385 02ac 0135     		adds	r5, r5, #1
 8386              	.LVL691:
 379:MotorControl/encoder.cpp ****         if (!axis_->motor_.is_armed_) {
 8387              		.loc 3 379 5 is_stmt 0 discriminator 2 view .LVU2272
 8388 02ae EAE7     		b	.L409
 8389              	.LVL692:
 8390              	.L428:
 379:MotorControl/encoder.cpp ****         if (!axis_->motor_.is_armed_) {
 8391              		.loc 3 379 5 discriminator 2 view .LVU2273
 8392              	.LBE2991:
 333:MotorControl/encoder.cpp ****         return false;
 8393              		.loc 3 333 9 is_stmt 1 view .LVU2274
ARM GAS  /tmp/cc5nV8qb.s 			page 353


 333:MotorControl/encoder.cpp ****         return false;
 8394              		.loc 3 333 18 is_stmt 0 view .LVU2275
 8395 02b0 2021     		movs	r1, #32
 8396 02b2 FFF7FEFF 		bl	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
 8397              	.LVL693:
 334:MotorControl/encoder.cpp ****     }
 8398              		.loc 3 334 9 is_stmt 1 view .LVU2276
 334:MotorControl/encoder.cpp ****     }
 8399              		.loc 3 334 16 is_stmt 0 view .LVU2277
 8400 02b6 79E0     		b	.L375
 8401              	.LVL694:
 8402              	.L429:
 337:MotorControl/encoder.cpp ****         set_error(ERROR_HALL_NOT_CALIBRATED_YET);
 8403              		.loc 3 337 47 discriminator 1 view .LVU2278
 8404 02b8 94F86560 		ldrb	r6, [r4, #101]	@ zero_extendqisi2
 337:MotorControl/encoder.cpp ****         set_error(ERROR_HALL_NOT_CALIBRATED_YET);
 8405              		.loc 3 337 35 discriminator 1 view .LVU2279
 8406 02bc 002E     		cmp	r6, #0
 8407 02be 7FF4AFAE 		bne	.L376
 338:MotorControl/encoder.cpp ****         return false;
 8408              		.loc 3 338 9 is_stmt 1 view .LVU2280
 338:MotorControl/encoder.cpp ****         return false;
 8409              		.loc 3 338 18 is_stmt 0 view .LVU2281
 8410 02c2 4FF40071 		mov	r1, #512
 8411 02c6 2046     		mov	r0, r4
 8412              	.LVL695:
 338:MotorControl/encoder.cpp ****         return false;
 8413              		.loc 3 338 18 view .LVU2282
 8414 02c8 FFF7FEFF 		bl	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
 8415              	.LVL696:
 339:MotorControl/encoder.cpp ****     }
 8416              		.loc 3 339 9 is_stmt 1 view .LVU2283
 339:MotorControl/encoder.cpp ****     }
 8417              		.loc 3 339 16 is_stmt 0 view .LVU2284
 8418 02cc 6EE0     		b	.L375
 8419              	.LVL697:
 8420              	.L421:
 8421              	.LBB2992:
 8422              	.LBB2987:
 357:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_voltage_ = axis_->motor_.config_.motor_type != Motor::M
 8423              		.loc 3 357 117 view .LVU2285
 8424 02ce 0022     		movs	r2, #0
 8425 02d0 F1E6     		b	.L377
 8426              	.L430:
 358:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_vel_ = 0.0f;
 8427              		.loc 3 358 117 discriminator 1 view .LVU2286
 8428 02d2 526A     		ldr	r2, [r2, #36]	@ float
 8429 02d4 FAE6     		b	.L378
 8430              	.LVL698:
 8431              	.L431:
 8432              	.LBB2971:
 8433              	.LBB2714:
 8434              	.LBB2713:
 8435              	.LBB2712:
 8436              	.LBB2711:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8437              		.loc 1 1436 31 view .LVU2287
ARM GAS  /tmp/cc5nV8qb.s 			page 354


 8438 02d6 029B     		ldr	r3, [sp, #8]
 8439              	.LVL699:
 8440              	.LBB2695:
 8441              	.LBI2695:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8442              		.loc 1 1661 5 is_stmt 1 view .LVU2288
 8443              	.LBB2696:
 8444              	.LBB2697:
 8445              	.LBI2697:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 8446              		.loc 1 1571 24 view .LVU2289
 8447              	.LBB2698:
1577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else
 8448              		.loc 1 1577 45 is_stmt 0 view .LVU2290
 8449 02d8 307A     		ldrb	r0, [r6, #8]	@ zero_extendqisi2
 8450              	.LVL700:
1577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else
 8451              		.loc 1 1577 45 view .LVU2291
 8452              	.LBE2698:
 8453              	.LBE2697:
 8454              		.loc 1 1665 7 view .LVU2292
 8455 02da 0228     		cmp	r0, #2
 8456 02dc 02D1     		bne	.L446
 8457              	.LVL701:
 8458              	.LBB2699:
 8459              	.LBI2699:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8460              		.loc 1 276 5 is_stmt 1 view .LVU2293
 8461              	.LBB2700:
 8462              	.LBB2701:
 8463              	.LBI2701:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8464              		.loc 1 267 5 view .LVU2294
 8465              	.LBB2702:
 8466              	.LBB2703:
 8467              	.LBI2703:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8468              		.loc 1 267 5 view .LVU2295
 8469              	.LBB2704:
 8470              	.LBB2705:
 8471              	.LBI2705:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 8472              		.loc 1 262 5 view .LVU2296
 8473              	.LBB2706:
 8474              	.LBI2706:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 8475              		.loc 1 222 24 view .LVU2297
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 8476              		.loc 1 222 24 is_stmt 0 view .LVU2298
 8477              	.LBE2706:
 8478              	.LBE2705:
 8479              	.LBE2704:
 8480              	.LBE2703:
 8481              	.LBE2702:
 8482              	.LBE2701:
 8483              	.LBE2700:
 8484              	.LBE2699:
ARM GAS  /tmp/cc5nV8qb.s 			page 355


 8485              	.LBE2696:
 8486              	.LBE2695:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8487              		.loc 1 1436 31 view .LVU2299
 8488 02de C2F8E430 		str	r3, [r2, #228]
 8489              	.LVL702:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8490              		.loc 1 1436 31 view .LVU2300
 8491 02e2 3DE7     		b	.L381
 8492              	.LVL703:
 8493              	.L446:
 8494              	.LBB2709:
 8495              	.LBB2708:
 8496              	.LBB2707:
 8497              	.LBI2707:
1568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return !this->_M_valid(); }
 8498              		.loc 1 1568 22 is_stmt 1 view .LVU2301
1568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return !this->_M_valid(); }
 8499              		.loc 1 1568 22 is_stmt 0 view .LVU2302
 8500              	.LBE2707:
1666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__throw_bad_variant_access(__v.valueless_by_exception());
 8501              		.loc 1 1666 28 view .LVU2303
 8502 02e4 FF28     		cmp	r0, #255
 8503 02e6 14BF     		ite	ne
 8504 02e8 0020     		movne	r0, #0
 8505 02ea 0120     		moveq	r0, #1
 8506 02ec FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessb
 8507              	.LVL704:
 8508              	.L432:
 8509              		.loc 1 1666 28 view .LVU2304
 8510              	.LBE2708:
 8511              	.LBE2709:
 8512              	.LBB2710:
 8513              	.LBB2694:
 8514              	.LBB2693:
 8515              	.LBB2692:
 8516              	.LBB2691:
 8517              	.LBB2690:
 8518              	.LBI2690:
1568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return !this->_M_valid(); }
 8519              		.loc 1 1568 22 is_stmt 1 view .LVU2305
1568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return !this->_M_valid(); }
 8520              		.loc 1 1568 22 is_stmt 0 view .LVU2306
 8521              	.LBE2690:
 8522              		.loc 1 1666 28 view .LVU2307
 8523 02f0 FF28     		cmp	r0, #255
 8524 02f2 14BF     		ite	ne
 8525 02f4 0020     		movne	r0, #0
 8526 02f6 0120     		moveq	r0, #1
 8527 02f8 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessb
 8528              	.LVL705:
 8529              	.L433:
 8530              		.loc 1 1666 28 view .LVU2308
 8531              	.LBE2691:
 8532              	.LBE2692:
 8533              	.LBE2693:
 8534              	.LBE2694:
ARM GAS  /tmp/cc5nV8qb.s 			page 356


 8535              	.LBE2710:
 8536              	.LBE2711:
 8537              	.LBE2712:
 8538              	.LBE2713:
 8539              	.LBE2714:
 8540              	.LBE2971:
 8541              	.LBB2972:
 8542              	.LBB2755:
 8543              	.LBB2754:
 8544              	.LBB2753:
 8545              	.LBB2752:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8546              		.loc 1 1436 31 view .LVU2309
 8547 02fc 029B     		ldr	r3, [sp, #8]
 8548              	.LVL706:
 8549              	.LBB2736:
 8550              	.LBI2736:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8551              		.loc 1 1661 5 is_stmt 1 view .LVU2310
 8552              	.LBB2737:
 8553              	.LBB2738:
 8554              	.LBI2738:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 8555              		.loc 1 1571 24 view .LVU2311
 8556              	.LBB2739:
1577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else
 8557              		.loc 1 1577 45 is_stmt 0 view .LVU2312
 8558 02fe 307A     		ldrb	r0, [r6, #8]	@ zero_extendqisi2
 8559              	.LVL707:
1577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else
 8560              		.loc 1 1577 45 view .LVU2313
 8561              	.LBE2739:
 8562              	.LBE2738:
1665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__throw_bad_variant_access(__v.valueless_by_exception());
 8563              		.loc 1 1665 7 view .LVU2314
 8564 0300 0228     		cmp	r0, #2
 8565 0302 02D1     		bne	.L447
 8566              	.LVL708:
 8567              	.LBB2740:
 8568              	.LBI2740:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8569              		.loc 1 276 5 is_stmt 1 view .LVU2315
 8570              	.LBB2741:
 8571              	.LBB2742:
 8572              	.LBI2742:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8573              		.loc 1 267 5 view .LVU2316
 8574              	.LBB2743:
 8575              	.LBB2744:
 8576              	.LBI2744:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8577              		.loc 1 267 5 view .LVU2317
 8578              	.LBB2745:
 8579              	.LBB2746:
 8580              	.LBI2746:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 8581              		.loc 1 262 5 view .LVU2318
ARM GAS  /tmp/cc5nV8qb.s 			page 357


 8582              	.LBB2747:
 8583              	.LBI2747:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 8584              		.loc 1 222 24 view .LVU2319
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 8585              		.loc 1 222 24 is_stmt 0 view .LVU2320
 8586              	.LBE2747:
 8587              	.LBE2746:
 8588              	.LBE2745:
 8589              	.LBE2744:
 8590              	.LBE2743:
 8591              	.LBE2742:
 8592              	.LBE2741:
 8593              	.LBE2740:
 8594              	.LBE2737:
 8595              	.LBE2736:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8596              		.loc 1 1436 31 view .LVU2321
 8597 0304 C2F8F030 		str	r3, [r2, #240]
 8598              	.LVL709:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8599              		.loc 1 1436 31 view .LVU2322
 8600 0308 41E7     		b	.L385
 8601              	.LVL710:
 8602              	.L447:
 8603              	.LBB2750:
 8604              	.LBB2749:
 8605              	.LBB2748:
 8606              	.LBI2748:
1568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return !this->_M_valid(); }
 8607              		.loc 1 1568 22 is_stmt 1 view .LVU2323
1568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return !this->_M_valid(); }
 8608              		.loc 1 1568 22 is_stmt 0 view .LVU2324
 8609              	.LBE2748:
 8610              		.loc 1 1666 28 view .LVU2325
 8611 030a FF28     		cmp	r0, #255
 8612 030c 14BF     		ite	ne
 8613 030e 0020     		movne	r0, #0
 8614 0310 0120     		moveq	r0, #1
 8615 0312 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessb
 8616              	.LVL711:
 8617              	.L434:
 8618              		.loc 1 1666 28 view .LVU2326
 8619              	.LBE2749:
 8620              	.LBE2750:
 8621              	.LBB2751:
 8622              	.LBB2735:
 8623              	.LBB2734:
 8624              	.LBB2733:
 8625              	.LBB2732:
 8626              	.LBB2731:
 8627              	.LBI2731:
1568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return !this->_M_valid(); }
 8628              		.loc 1 1568 22 is_stmt 1 view .LVU2327
1568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return !this->_M_valid(); }
 8629              		.loc 1 1568 22 is_stmt 0 view .LVU2328
 8630              	.LBE2731:
ARM GAS  /tmp/cc5nV8qb.s 			page 358


 8631              		.loc 1 1666 28 view .LVU2329
 8632 0316 FF28     		cmp	r0, #255
 8633 0318 14BF     		ite	ne
 8634 031a 0020     		movne	r0, #0
 8635 031c 0120     		moveq	r0, #1
 8636 031e FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessb
 8637              	.LVL712:
 8638              	.L435:
 8639              		.loc 1 1666 28 view .LVU2330
 8640              	.LBE2732:
 8641              	.LBE2733:
 8642              	.LBE2734:
 8643              	.LBE2735:
 8644              	.LBE2751:
 8645              	.LBE2752:
 8646              	.LBE2753:
 8647              	.LBE2754:
 8648              	.LBE2755:
 8649              	.LBE2972:
 8650              	.LBB2973:
 8651              	.LBB2798:
 8652              	.LBB2797:
 8653              	.LBB2796:
 8654              	.LBB2795:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8655              		.loc 1 1436 31 view .LVU2331
 8656 0322 029B     		ldr	r3, [sp, #8]
 8657              	.LVL713:
 8658              	.LBB2778:
 8659              	.LBI2778:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8660              		.loc 1 1661 5 is_stmt 1 view .LVU2332
 8661              	.LBB2779:
 8662              	.LBB2780:
 8663              	.LBI2780:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 8664              		.loc 1 1571 24 view .LVU2333
 8665              	.LBB2781:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8666              		.loc 1 1575 17 is_stmt 0 view .LVU2334
 8667 0324 3179     		ldrb	r1, [r6, #4]	@ zero_extendqisi2
 8668              	.LVL714:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8669              		.loc 1 1575 17 view .LVU2335
 8670              	.LBE2781:
 8671              	.LBE2780:
1665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__throw_bad_variant_access(__v.valueless_by_exception());
 8672              		.loc 1 1665 7 view .LVU2336
 8673 0326 0229     		cmp	r1, #2
 8674 0328 02D1     		bne	.L448
 8675              	.LVL715:
 8676              	.LBB2782:
 8677              	.LBI2782:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8678              		.loc 1 276 5 is_stmt 1 view .LVU2337
 8679              	.LBB2783:
 8680              	.LBB2784:
ARM GAS  /tmp/cc5nV8qb.s 			page 359


 8681              	.LBI2784:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8682              		.loc 1 267 5 view .LVU2338
 8683              	.LBB2785:
 8684              	.LBB2786:
 8685              	.LBI2786:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8686              		.loc 1 267 5 view .LVU2339
 8687              	.LBB2787:
 8688              	.LBB2788:
 8689              	.LBI2788:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 8690              		.loc 1 262 5 view .LVU2340
 8691              	.LBB2789:
 8692              	.LBI2789:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 8693              		.loc 1 222 24 view .LVU2341
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 8694              		.loc 1 222 24 is_stmt 0 view .LVU2342
 8695              	.LBE2789:
 8696              	.LBE2788:
 8697              	.LBE2787:
 8698              	.LBE2786:
 8699              	.LBE2785:
 8700              	.LBE2784:
 8701              	.LBE2783:
 8702              	.LBE2782:
 8703              	.LBE2779:
 8704              	.LBE2778:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8705              		.loc 1 1436 31 view .LVU2343
 8706 032a C2F8FC30 		str	r3, [r2, #252]
 8707              	.LVL716:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8708              		.loc 1 1436 31 view .LVU2344
 8709 032e 45E7     		b	.L389
 8710              	.LVL717:
 8711              	.L448:
 8712              	.LBB2793:
 8713              	.LBB2792:
 8714              	.LBB2790:
 8715              	.LBI2790:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 8716              		.loc 1 1287 3 is_stmt 1 view .LVU2345
 8717              	.LBB2791:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 8718              		.loc 1 1289 5 view .LVU2346
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8719              		.loc 1 1292 7 view .LVU2347
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8720              		.loc 1 1292 33 is_stmt 0 view .LVU2348
 8721 0330 2248     		ldr	r0, .L454+8
 8722 0332 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 8723              	.LVL718:
 8724              	.L436:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8725              		.loc 1 1292 33 view .LVU2349
ARM GAS  /tmp/cc5nV8qb.s 			page 360


 8726              	.LBE2791:
 8727              	.LBE2790:
 8728              	.LBE2792:
 8729              	.LBE2793:
 8730              	.LBB2794:
 8731              	.LBB2777:
 8732              	.LBB2776:
 8733              	.LBB2775:
 8734              	.LBB2774:
 8735              	.LBB2772:
 8736              	.LBI2772:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 8737              		.loc 1 1287 3 is_stmt 1 view .LVU2350
 8738              	.LBB2773:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 8739              		.loc 1 1289 5 view .LVU2351
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8740              		.loc 1 1292 7 view .LVU2352
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8741              		.loc 1 1292 33 is_stmt 0 view .LVU2353
 8742 0336 2148     		ldr	r0, .L454+8
 8743 0338 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 8744              	.LVL719:
 8745              	.L437:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8746              		.loc 1 1292 33 view .LVU2354
 8747              	.LBE2773:
 8748              	.LBE2772:
 8749              	.LBE2774:
 8750              	.LBE2775:
 8751              	.LBE2776:
 8752              	.LBE2777:
 8753              	.LBE2794:
 8754              	.LBE2795:
 8755              	.LBE2796:
 8756              	.LBE2797:
 8757              	.LBE2798:
 8758              	.LBE2973:
 8759              	.LBB2974:
 8760              	.LBB2841:
 8761              	.LBB2840:
 8762              	.LBB2839:
 8763              	.LBB2838:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8764              		.loc 1 1436 31 view .LVU2355
 8765 033c 029A     		ldr	r2, [sp, #8]
 8766              	.LVL720:
 8767              	.LBB2821:
 8768              	.LBI2821:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8769              		.loc 1 1661 5 is_stmt 1 view .LVU2356
 8770              	.LBB2822:
 8771              	.LBB2823:
 8772              	.LBI2823:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 8773              		.loc 1 1571 24 view .LVU2357
 8774              	.LBB2824:
ARM GAS  /tmp/cc5nV8qb.s 			page 361


1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8775              		.loc 1 1575 17 is_stmt 0 view .LVU2358
 8776 033e 3179     		ldrb	r1, [r6, #4]	@ zero_extendqisi2
 8777              	.LVL721:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8778              		.loc 1 1575 17 view .LVU2359
 8779              	.LBE2824:
 8780              	.LBE2823:
1665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__throw_bad_variant_access(__v.valueless_by_exception());
 8781              		.loc 1 1665 7 view .LVU2360
 8782 0340 0229     		cmp	r1, #2
 8783 0342 02D1     		bne	.L449
 8784              	.LVL722:
 8785              	.LBB2825:
 8786              	.LBI2825:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8787              		.loc 1 276 5 is_stmt 1 view .LVU2361
 8788              	.LBB2826:
 8789              	.LBB2827:
 8790              	.LBI2827:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8791              		.loc 1 267 5 view .LVU2362
 8792              	.LBB2828:
 8793              	.LBB2829:
 8794              	.LBI2829:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8795              		.loc 1 267 5 view .LVU2363
 8796              	.LBB2830:
 8797              	.LBB2831:
 8798              	.LBI2831:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 8799              		.loc 1 262 5 view .LVU2364
 8800              	.LBB2832:
 8801              	.LBI2832:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 8802              		.loc 1 222 24 view .LVU2365
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 8803              		.loc 1 222 24 is_stmt 0 view .LVU2366
 8804              	.LBE2832:
 8805              	.LBE2831:
 8806              	.LBE2830:
 8807              	.LBE2829:
 8808              	.LBE2828:
 8809              	.LBE2827:
 8810              	.LBE2826:
 8811              	.LBE2825:
 8812              	.LBE2822:
 8813              	.LBE2821:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8814              		.loc 1 1436 31 view .LVU2367
 8815 0344 C3F8B820 		str	r2, [r3, #184]
 8816              	.LVL723:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8817              		.loc 1 1436 31 view .LVU2368
 8818 0348 4DE7     		b	.L393
 8819              	.LVL724:
 8820              	.L449:
ARM GAS  /tmp/cc5nV8qb.s 			page 362


 8821              	.LBB2836:
 8822              	.LBB2835:
 8823              	.LBB2833:
 8824              	.LBI2833:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 8825              		.loc 1 1287 3 is_stmt 1 view .LVU2369
 8826              	.LBB2834:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 8827              		.loc 1 1289 5 view .LVU2370
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8828              		.loc 1 1292 7 view .LVU2371
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8829              		.loc 1 1292 33 is_stmt 0 view .LVU2372
 8830 034a 1C48     		ldr	r0, .L454+8
 8831 034c FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 8832              	.LVL725:
 8833              	.L438:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8834              		.loc 1 1292 33 view .LVU2373
 8835              	.LBE2834:
 8836              	.LBE2833:
 8837              	.LBE2835:
 8838              	.LBE2836:
 8839              	.LBB2837:
 8840              	.LBB2820:
 8841              	.LBB2819:
 8842              	.LBB2818:
 8843              	.LBB2817:
 8844              	.LBB2815:
 8845              	.LBI2815:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 8846              		.loc 1 1287 3 is_stmt 1 view .LVU2374
 8847              	.LBB2816:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 8848              		.loc 1 1289 5 view .LVU2375
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8849              		.loc 1 1292 7 view .LVU2376
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8850              		.loc 1 1292 33 is_stmt 0 view .LVU2377
 8851 0350 1A48     		ldr	r0, .L454+8
 8852 0352 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 8853              	.LVL726:
 8854              	.L439:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8855              		.loc 1 1292 33 view .LVU2378
 8856              	.LBE2816:
 8857              	.LBE2815:
 8858              	.LBE2817:
 8859              	.LBE2818:
 8860              	.LBE2819:
 8861              	.LBE2820:
 8862              	.LBE2837:
 8863              	.LBE2838:
 8864              	.LBE2839:
 8865              	.LBE2840:
 8866              	.LBE2841:
 8867              	.LBE2974:
ARM GAS  /tmp/cc5nV8qb.s 			page 363


 8868              	.LBB2975:
 8869              	.LBB2884:
 8870              	.LBB2883:
 8871              	.LBB2882:
 8872              	.LBB2881:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8873              		.loc 1 1436 31 view .LVU2379
 8874 0356 029B     		ldr	r3, [sp, #8]
 8875              	.LVL727:
 8876              	.LBB2864:
 8877              	.LBI2864:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8878              		.loc 1 1661 5 is_stmt 1 view .LVU2380
 8879              	.LBB2865:
 8880              	.LBB2866:
 8881              	.LBI2866:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 8882              		.loc 1 1571 24 view .LVU2381
 8883              	.LBB2867:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8884              		.loc 1 1575 17 is_stmt 0 view .LVU2382
 8885 0358 3179     		ldrb	r1, [r6, #4]	@ zero_extendqisi2
 8886              	.LVL728:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8887              		.loc 1 1575 17 view .LVU2383
 8888              	.LBE2867:
 8889              	.LBE2866:
1665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__throw_bad_variant_access(__v.valueless_by_exception());
 8890              		.loc 1 1665 7 view .LVU2384
 8891 035a 0229     		cmp	r1, #2
 8892 035c 02D1     		bne	.L450
 8893              	.LVL729:
 8894              	.LBB2868:
 8895              	.LBI2868:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8896              		.loc 1 276 5 is_stmt 1 view .LVU2385
 8897              	.LBB2869:
 8898              	.LBB2870:
 8899              	.LBI2870:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8900              		.loc 1 267 5 view .LVU2386
 8901              	.LBB2871:
 8902              	.LBB2872:
 8903              	.LBI2872:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8904              		.loc 1 267 5 view .LVU2387
 8905              	.LBB2873:
 8906              	.LBB2874:
 8907              	.LBI2874:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 8908              		.loc 1 262 5 view .LVU2388
 8909              	.LBB2875:
 8910              	.LBI2875:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 8911              		.loc 1 222 24 view .LVU2389
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 8912              		.loc 1 222 24 is_stmt 0 view .LVU2390
ARM GAS  /tmp/cc5nV8qb.s 			page 364


 8913              	.LBE2875:
 8914              	.LBE2874:
 8915              	.LBE2873:
 8916              	.LBE2872:
 8917              	.LBE2871:
 8918              	.LBE2870:
 8919              	.LBE2869:
 8920              	.LBE2868:
 8921              	.LBE2865:
 8922              	.LBE2864:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8923              		.loc 1 1436 31 view .LVU2391
 8924 035e C2F88431 		str	r3, [r2, #388]
 8925              	.LVL730:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8926              		.loc 1 1436 31 view .LVU2392
 8927 0362 57E7     		b	.L397
 8928              	.LVL731:
 8929              	.L450:
 8930              	.LBB2879:
 8931              	.LBB2878:
 8932              	.LBB2876:
 8933              	.LBI2876:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 8934              		.loc 1 1287 3 is_stmt 1 view .LVU2393
 8935              	.LBB2877:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 8936              		.loc 1 1289 5 view .LVU2394
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8937              		.loc 1 1292 7 view .LVU2395
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8938              		.loc 1 1292 33 is_stmt 0 view .LVU2396
 8939 0364 1548     		ldr	r0, .L454+8
 8940 0366 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 8941              	.LVL732:
 8942              	.L440:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8943              		.loc 1 1292 33 view .LVU2397
 8944              	.LBE2877:
 8945              	.LBE2876:
 8946              	.LBE2878:
 8947              	.LBE2879:
 8948              	.LBB2880:
 8949              	.LBB2863:
 8950              	.LBB2862:
 8951              	.LBB2861:
 8952              	.LBB2860:
 8953              	.LBB2858:
 8954              	.LBI2858:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 8955              		.loc 1 1287 3 is_stmt 1 view .LVU2398
 8956              	.LBB2859:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 8957              		.loc 1 1289 5 view .LVU2399
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8958              		.loc 1 1292 7 view .LVU2400
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
ARM GAS  /tmp/cc5nV8qb.s 			page 365


 8959              		.loc 1 1292 33 is_stmt 0 view .LVU2401
 8960 036a 1448     		ldr	r0, .L454+8
 8961 036c FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 8962              	.LVL733:
 8963              	.L441:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 8964              		.loc 1 1292 33 view .LVU2402
 8965              	.LBE2859:
 8966              	.LBE2858:
 8967              	.LBE2860:
 8968              	.LBE2861:
 8969              	.LBE2862:
 8970              	.LBE2863:
 8971              	.LBE2880:
 8972              	.LBE2881:
 8973              	.LBE2882:
 8974              	.LBE2883:
 8975              	.LBE2884:
 8976              	.LBE2975:
 8977              	.LBB2976:
 8978              	.LBB2927:
 8979              	.LBB2926:
 8980              	.LBB2925:
 8981              	.LBB2924:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 8982              		.loc 1 1436 31 view .LVU2403
 8983 0370 029B     		ldr	r3, [sp, #8]
 8984              	.LVL734:
 8985              	.LBB2907:
 8986              	.LBI2907:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 8987              		.loc 1 1661 5 is_stmt 1 view .LVU2404
 8988              	.LBB2908:
 8989              	.LBB2909:
 8990              	.LBI2909:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 8991              		.loc 1 1571 24 view .LVU2405
 8992              	.LBB2910:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8993              		.loc 1 1575 17 is_stmt 0 view .LVU2406
 8994 0372 3179     		ldrb	r1, [r6, #4]	@ zero_extendqisi2
 8995              	.LVL735:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 8996              		.loc 1 1575 17 view .LVU2407
 8997              	.LBE2910:
 8998              	.LBE2909:
1665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__throw_bad_variant_access(__v.valueless_by_exception());
 8999              		.loc 1 1665 7 view .LVU2408
 9000 0374 0229     		cmp	r1, #2
 9001 0376 02D1     		bne	.L451
 9002              	.LVL736:
 9003              	.LBB2911:
 9004              	.LBI2911:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 9005              		.loc 1 276 5 is_stmt 1 view .LVU2409
 9006              	.LBB2912:
 9007              	.LBB2913:
ARM GAS  /tmp/cc5nV8qb.s 			page 366


 9008              	.LBI2913:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 9009              		.loc 1 267 5 view .LVU2410
 9010              	.LBB2914:
 9011              	.LBB2915:
 9012              	.LBI2915:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 9013              		.loc 1 267 5 view .LVU2411
 9014              	.LBB2916:
 9015              	.LBB2917:
 9016              	.LBI2917:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 9017              		.loc 1 262 5 view .LVU2412
 9018              	.LBB2918:
 9019              	.LBI2918:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 9020              		.loc 1 222 24 view .LVU2413
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 9021              		.loc 1 222 24 is_stmt 0 view .LVU2414
 9022              	.LBE2918:
 9023              	.LBE2917:
 9024              	.LBE2916:
 9025              	.LBE2915:
 9026              	.LBE2914:
 9027              	.LBE2913:
 9028              	.LBE2912:
 9029              	.LBE2911:
 9030              	.LBE2908:
 9031              	.LBE2907:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 9032              		.loc 1 1436 31 view .LVU2415
 9033 0378 C2F80431 		str	r3, [r2, #260]
 9034              	.LVL737:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 9035              		.loc 1 1436 31 view .LVU2416
 9036 037c 61E7     		b	.L401
 9037              	.LVL738:
 9038              	.L451:
 9039              	.LBB2922:
 9040              	.LBB2921:
 9041              	.LBB2919:
 9042              	.LBI2919:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 9043              		.loc 1 1287 3 is_stmt 1 view .LVU2417
 9044              	.LBB2920:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 9045              		.loc 1 1289 5 view .LVU2418
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 9046              		.loc 1 1292 7 view .LVU2419
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 9047              		.loc 1 1292 33 is_stmt 0 view .LVU2420
 9048 037e 0F48     		ldr	r0, .L454+8
 9049 0380 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 9050              	.LVL739:
 9051              	.L442:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 9052              		.loc 1 1292 33 view .LVU2421
ARM GAS  /tmp/cc5nV8qb.s 			page 367


 9053              	.LBE2920:
 9054              	.LBE2919:
 9055              	.LBE2921:
 9056              	.LBE2922:
 9057              	.LBB2923:
 9058              	.LBB2906:
 9059              	.LBB2905:
 9060              	.LBB2904:
 9061              	.LBB2903:
 9062              	.LBB2901:
 9063              	.LBI2901:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 9064              		.loc 1 1287 3 is_stmt 1 view .LVU2422
 9065              	.LBB2902:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 9066              		.loc 1 1289 5 view .LVU2423
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 9067              		.loc 1 1292 7 view .LVU2424
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 9068              		.loc 1 1292 33 is_stmt 0 view .LVU2425
 9069 0384 0D48     		ldr	r0, .L454+8
 9070 0386 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 9071              	.LVL740:
 9072              	.L443:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 9073              		.loc 1 1292 33 view .LVU2426
 9074              	.LBE2902:
 9075              	.LBE2901:
 9076              	.LBE2903:
 9077              	.LBE2904:
 9078              	.LBE2905:
 9079              	.LBE2906:
 9080              	.LBE2923:
 9081              	.LBE2924:
 9082              	.LBE2925:
 9083              	.LBE2926:
 9084              	.LBE2927:
 9085              	.LBE2976:
 9086              	.LBB2977:
 9087              	.LBB2970:
 9088              	.LBB2969:
 9089              	.LBB2968:
 9090              	.LBB2967:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 9091              		.loc 1 1436 31 view .LVU2427
 9092 038a 029A     		ldr	r2, [sp, #8]
 9093              	.LVL741:
 9094              	.LBB2950:
 9095              	.LBI2950:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 9096              		.loc 1 1661 5 is_stmt 1 view .LVU2428
 9097              	.LBB2951:
 9098              	.LBB2952:
 9099              	.LBI2952:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 9100              		.loc 1 1571 24 view .LVU2429
 9101              	.LBB2953:
ARM GAS  /tmp/cc5nV8qb.s 			page 368


1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 9102              		.loc 1 1575 17 is_stmt 0 view .LVU2430
 9103 038c 3179     		ldrb	r1, [r6, #4]	@ zero_extendqisi2
 9104              	.LVL742:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 9105              		.loc 1 1575 17 view .LVU2431
 9106              	.LBE2953:
 9107              	.LBE2952:
1665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__throw_bad_variant_access(__v.valueless_by_exception());
 9108              		.loc 1 1665 7 view .LVU2432
 9109 038e 0229     		cmp	r1, #2
 9110 0390 02D1     		bne	.L452
 9111              	.LVL743:
 9112              	.LBB2954:
 9113              	.LBI2954:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 9114              		.loc 1 276 5 is_stmt 1 view .LVU2433
 9115              	.LBB2955:
 9116              	.LBB2956:
 9117              	.LBI2956:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 9118              		.loc 1 267 5 view .LVU2434
 9119              	.LBB2957:
 9120              	.LBB2958:
 9121              	.LBI2958:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 9122              		.loc 1 267 5 view .LVU2435
 9123              	.LBB2959:
 9124              	.LBB2960:
 9125              	.LBI2960:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 9126              		.loc 1 262 5 view .LVU2436
 9127              	.LBB2961:
 9128              	.LBI2961:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 9129              		.loc 1 222 24 view .LVU2437
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 9130              		.loc 1 222 24 is_stmt 0 view .LVU2438
 9131              	.LBE2961:
 9132              	.LBE2960:
 9133              	.LBE2959:
 9134              	.LBE2958:
 9135              	.LBE2957:
 9136              	.LBE2956:
 9137              	.LBE2955:
 9138              	.LBE2954:
 9139              	.LBE2951:
 9140              	.LBE2950:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 9141              		.loc 1 1436 31 view .LVU2439
 9142 0392 C3F8C020 		str	r2, [r3, #192]
 9143              	.LVL744:
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 9144              		.loc 1 1436 31 view .LVU2440
 9145 0396 69E7     		b	.L405
 9146              	.LVL745:
 9147              	.L452:
ARM GAS  /tmp/cc5nV8qb.s 			page 369


 9148              	.LBB2965:
 9149              	.LBB2964:
 9150              	.LBB2962:
 9151              	.LBI2962:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 9152              		.loc 1 1287 3 is_stmt 1 view .LVU2441
 9153              	.LBB2963:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 9154              		.loc 1 1289 5 view .LVU2442
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 9155              		.loc 1 1292 7 view .LVU2443
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 9156              		.loc 1 1292 33 is_stmt 0 view .LVU2444
 9157 0398 0848     		ldr	r0, .L454+8
 9158 039a FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 9159              	.LVL746:
 9160              	.L444:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 9161              		.loc 1 1292 33 view .LVU2445
 9162              	.LBE2963:
 9163              	.LBE2962:
 9164              	.LBE2964:
 9165              	.LBE2965:
 9166              	.LBB2966:
 9167              	.LBB2949:
 9168              	.LBB2948:
 9169              	.LBB2947:
 9170              	.LBB2946:
 9171              	.LBB2944:
 9172              	.LBI2944:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 9173              		.loc 1 1287 3 is_stmt 1 view .LVU2446
 9174              	.LBB2945:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 9175              		.loc 1 1289 5 view .LVU2447
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 9176              		.loc 1 1292 7 view .LVU2448
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 9177              		.loc 1 1292 33 is_stmt 0 view .LVU2449
 9178 039e 0748     		ldr	r0, .L454+8
 9179 03a0 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 9180              	.LVL747:
 9181              	.L445:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 9182              		.loc 1 1292 33 view .LVU2450
 9183              	.LBE2945:
 9184              	.LBE2944:
 9185              	.LBE2946:
 9186              	.LBE2947:
 9187              	.LBE2948:
 9188              	.LBE2949:
 9189              	.LBE2966:
 9190              	.LBE2967:
 9191              	.LBE2968:
 9192              	.LBE2969:
 9193              	.LBE2970:
 9194              	.LBE2977:
ARM GAS  /tmp/cc5nV8qb.s 			page 370


 9195              	.LBE2987:
 9196              	.LBE2992:
 9197              	.LBB2993:
 384:MotorControl/encoder.cpp ****             return false; // TODO: return "aborted" error code
 9198              		.loc 3 384 13 is_stmt 1 view .LVU2451
 384:MotorControl/encoder.cpp ****             return false; // TODO: return "aborted" error code
 9199              		.loc 3 384 33 is_stmt 0 view .LVU2452
 9200 03a4 0021     		movs	r1, #0
 9201              	.LEHB10:
 9202 03a6 FFF7FEFF 		bl	_ZN5Motor6disarmEPb
 9203              	.LVL748:
 385:MotorControl/encoder.cpp ****         }
 9204              		.loc 3 385 13 is_stmt 1 view .LVU2453
 385:MotorControl/encoder.cpp ****         }
 9205              		.loc 3 385 20 is_stmt 0 view .LVU2454
 9206 03aa 0026     		movs	r6, #0
 9207              	.LVL749:
 9208              	.L375:
 385:MotorControl/encoder.cpp ****         }
 9209              		.loc 3 385 20 view .LVU2455
 9210              	.LBE2993:
 463:MotorControl/encoder.cpp **** 
 9211              		.loc 3 463 1 view .LVU2456
 9212 03ac 3046     		mov	r0, r6
 9213 03ae 0CB0     		add	sp, sp, #48
 9214              	.LCFI60:
 9215              		.cfi_remember_state
 9216              		.cfi_def_cfa_offset 24
 9217              		@ sp needed
 9218 03b0 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 9219              	.LVL750:
 9220              	.L455:
 463:MotorControl/encoder.cpp **** 
 9221              		.loc 3 463 1 view .LVU2457
 9222              		.align	2
 9223              	.L454:
 9224 03b4 00000000 		.word	0
 9225 03b8 DB0FC940 		.word	1086918619
 9226 03bc 20000000 		.word	.LC1
 9227 03c0 DB0F4940 		.word	1078530011
 9228              	.LVL751:
 9229              	.L407:
 9230              	.LCFI61:
 9231              		.cfi_restore_state
 391:MotorControl/encoder.cpp ****     uint32_t num_steps = 0;
 9232              		.loc 3 391 5 is_stmt 1 view .LVU2458
 391:MotorControl/encoder.cpp ****     uint32_t num_steps = 0;
 9233              		.loc 3 391 13 is_stmt 0 view .LVU2459
 9234 03c4 D4F89060 		ldr	r6, [r4, #144]
 9235              	.LVL752:
 392:MotorControl/encoder.cpp ****     int64_t encvaluesum = 0;
 9236              		.loc 3 392 5 is_stmt 1 view .LVU2460
 393:MotorControl/encoder.cpp **** 
 9237              		.loc 3 393 5 view .LVU2461
 395:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_vel_ = config_.calib_scan_omega;
 9238              		.loc 3 395 5 view .LVU2462
 9239              	.LBB2994:
ARM GAS  /tmp/cc5nV8qb.s 			page 371


 9240              	.LBB2995:
 9241              	.LBI2995:
  56:./Drivers/STM32/stm32_system.h ****     ~CriticalSectionContext() { cpu_exit_critical(mask_); }
 9242              		.loc 4 56 5 view .LVU2463
 9243              	.LBB2996:
 9244              	.LBB2997:
 9245              	.LBB2998:
 9246              	.LBI2998:
  31:./Drivers/STM32/stm32_system.h ****     uint32_t primask = __get_PRIMASK();
 9247              		.loc 4 31 24 view .LVU2464
 9248              	.LBB2999:
  32:./Drivers/STM32/stm32_system.h ****     __disable_irq();
 9249              		.loc 4 32 5 view .LVU2465
 9250              	.LBB3000:
 9251              	.LBI3000:
 382:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 9252              		.loc 5 382 31 view .LVU2466
 9253              	.LBB3001:
 384:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 9254              		.loc 5 384 3 view .LVU2467
 386:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 9255              		.loc 5 386 3 view .LVU2468
 9256              		.syntax unified
 9257              	@ 386 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 9258 03c8 EFF31083 		MRS r3, primask
 9259              	@ 0 "" 2
 9260              	.LVL753:
 387:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 9261              		.loc 5 387 3 view .LVU2469
 387:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 9262              		.loc 5 387 3 is_stmt 0 view .LVU2470
 9263              		.thumb
 9264              		.syntax unified
 9265              	.LBE3001:
 9266              	.LBE3000:
  33:./Drivers/STM32/stm32_system.h ****     return primask;
 9267              		.loc 4 33 5 is_stmt 1 view .LVU2471
 9268              	.LBB3002:
 9269              	.LBI3002:
 140:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 9270              		.loc 5 140 27 view .LVU2472
 9271              	.LBB3003:
 142:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 9272              		.loc 5 142 3 view .LVU2473
 9273              		.syntax unified
 9274              	@ 142 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 9275 03cc 72B6     		cpsid i
 9276              	@ 0 "" 2
 9277              		.thumb
 9278              		.syntax unified
 9279              	.LBE3003:
 9280              	.LBE3002:
  34:./Drivers/STM32/stm32_system.h **** }
 9281              		.loc 4 34 5 view .LVU2474
 9282              	.LBE2999:
 9283              	.LBE2998:
  56:./Drivers/STM32/stm32_system.h ****     ~CriticalSectionContext() { cpu_exit_critical(mask_); }
ARM GAS  /tmp/cc5nV8qb.s 			page 372


 9284              		.loc 4 56 58 is_stmt 0 view .LVU2475
 9285 03ce 0293     		str	r3, [sp, #8]
 9286 03d0 0027     		movs	r7, #0
 9287 03d2 8DF80C70 		strb	r7, [sp, #12]
 9288              	.LVL754:
  56:./Drivers/STM32/stm32_system.h ****     ~CriticalSectionContext() { cpu_exit_critical(mask_); }
 9289              		.loc 4 56 58 view .LVU2476
 9290              	.LBE2997:
 9291              	.LBE2996:
 9292              	.LBE2995:
 9293              	.LBE2994:
  55:./Drivers/STM32/stm32_system.h ****     CriticalSectionContext() : mask_(cpu_enter_critical()) {}
 9294              		.loc 4 55 23 is_stmt 1 view .LVU2477
 9295              	.LBB3014:
 396:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.total_distance_ = 0.0f;
 9296              		.loc 3 396 9 view .LVU2478
 9297 03d6 226B     		ldr	r2, [r4, #48]
 396:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.total_distance_ = 0.0f;
 9298              		.loc 3 396 60 is_stmt 0 view .LVU2479
 9299 03d8 216C     		ldr	r1, [r4, #64]	@ float
 396:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.total_distance_ = 0.0f;
 9300              		.loc 3 396 50 view .LVU2480
 9301 03da C2F81411 		str	r1, [r2, #276]	@ float
 397:MotorControl/encoder.cpp ****     }
 9302              		.loc 3 397 9 is_stmt 1 view .LVU2481
 9303 03de 226B     		ldr	r2, [r4, #48]
 9304              	.LVL755:
 9305              	.LBB3004:
 9306              	.LBI3004:
  52:./MotorControl/component.hpp ****         content_ = value;
 9307              		.loc 13 52 10 view .LVU2482
 9308              	.LBB3005:
  53:./MotorControl/component.hpp ****         age_ = 0;
 9309              		.loc 13 53 18 is_stmt 0 view .LVU2483
 9310 03e0 0021     		movs	r1, #0
 9311 03e2 C2F85411 		str	r1, [r2, #340]	@ float
  54:./MotorControl/component.hpp ****     }
 9312              		.loc 13 54 14 view .LVU2484
 9313 03e6 C2F85071 		str	r7, [r2, #336]
 9314              	.LVL756:
  54:./MotorControl/component.hpp ****     }
 9315              		.loc 13 54 14 view .LVU2485
 9316              	.LBE3005:
 9317              	.LBE3004:
 9318              	.LBB3006:
 9319              	.LBI3006:
 9320              		.loc 4 57 5 is_stmt 1 view .LVU2486
 9321              	.LBB3007:
 9322              		.loc 4 57 33 view .LVU2487
 9323              	.LBB3008:
 9324              	.LBI3008:
  37:./Drivers/STM32/stm32_system.h ****     __set_PRIMASK(priority_mask);
 9325              		.loc 4 37 20 view .LVU2488
 9326              	.LBE3008:
 9327              	.LBE3007:
 9328              	.LBE3006:
 9329              	.LBE3014:
ARM GAS  /tmp/cc5nV8qb.s 			page 373


  38:./Drivers/STM32/stm32_system.h **** }
 9330              		.loc 4 38 5 view .LVU2489
 9331              	.LBB3015:
 9332              	.LBB3013:
 9333              	.LBB3012:
 9334              	.LBB3011:
 9335              	.LBB3009:
 9336              	.LBI3009:
 412:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 9337              		.loc 5 412 27 view .LVU2490
 9338              	.LBB3010:
 9339              		.loc 5 414 3 view .LVU2491
 9340              		.syntax unified
 9341              	@ 414 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 9342 03ea 83F31088 		MSR primask, r3
 9343              	@ 0 "" 2
 9344              	.LVL757:
 9345              		.loc 5 414 3 is_stmt 0 view .LVU2492
 9346              		.thumb
 9347              		.syntax unified
 9348              	.LBE3010:
 9349              	.LBE3009:
 9350              	.LBE3011:
 9351              	.LBE3012:
 9352              	.LBE3013:
 9353              	.LBE3015:
 393:MotorControl/encoder.cpp **** 
 9354              		.loc 3 393 13 view .LVU2493
 9355 03ee 3D46     		mov	r5, r7
 9356              	.LVL758:
 393:MotorControl/encoder.cpp **** 
 9357              		.loc 3 393 13 view .LVU2494
 9358 03f0 B846     		mov	r8, r7
 9359              	.LVL759:
 9360              	.L412:
 401:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(-INF
 9361              		.loc 3 401 5 is_stmt 1 view .LVU2495
 401:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(-INF
 9362              		.loc 3 401 68 view .LVU2496
 401:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(-INF
 9363              		.loc 3 401 13 is_stmt 0 view .LVU2497
 9364 03f2 236B     		ldr	r3, [r4, #48]
 401:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(-INF
 9365              		.loc 3 401 20 view .LVU2498
 9366 03f4 93F86C22 		ldrb	r2, [r3, #620]	@ zero_extendqisi2
 401:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(-INF
 9367              		.loc 3 401 68 view .LVU2499
 9368 03f8 EAB9     		cbnz	r2, .L410
 401:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(-INF
 9369              		.loc 3 401 78 discriminator 1 view .LVU2500
 9370 03fa D3F85821 		ldr	r2, [r3, #344]
 401:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(-INF
 9371              		.loc 3 401 85 discriminator 1 view .LVU2501
 9372 03fe 92F89C20 		ldrb	r2, [r2, #156]	@ zero_extendqisi2
 401:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(-INF
 9373              		.loc 3 401 68 discriminator 1 view .LVU2502
 9374 0402 C2B1     		cbz	r2, .L410
ARM GAS  /tmp/cc5nV8qb.s 			page 374


 9375              	.LBB3016:
 402:MotorControl/encoder.cpp ****         if (reached_target_dist) {
 9376              		.loc 3 402 9 is_stmt 1 view .LVU2503
 9377              	.LVL760:
 9378              	.LBB3017:
 9379              	.LBI3017:
 102:./MotorControl/component.hpp ****         return content_;
 9380              		.loc 13 102 22 view .LVU2504
 9381              	.LBB3018:
 9382              	.LBB3019:
 9383              	.LBI3019:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 9384              		.loc 14 700 2 view .LVU2505
 9385              	.LBB3020:
 9386              	.LBB3021:
 9387              	.LBB3022:
 9388              	.LBI3022:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9389              		.loc 7 76 5 view .LVU2506
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9390              		.loc 7 76 5 is_stmt 0 view .LVU2507
 9391              	.LBE3022:
 9392              	.LBB3023:
 9393              	.LBI3023:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 9394              		.loc 14 607 28 is_stmt 1 view .LVU2508
 9395              	.LBB3024:
 9396              	.LBB3025:
 9397              	.LBB3026:
 9398              	.LBI3026:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9399              		.loc 7 76 5 view .LVU2509
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9400              		.loc 7 76 5 is_stmt 0 view .LVU2510
 9401              	.LBE3026:
 9402              	.LBB3027:
 9403              	.LBI3027:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 9404              		.loc 14 300 42 is_stmt 1 view .LVU2511
 9405              	.LBB3028:
 9406              	.LBB3029:
 9407              	.LBB3030:
 9408              	.LBI3030:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 9409              		.loc 14 115 2 view .LVU2512
 9410              	.LBB3031:
 9411              	.LBB3032:
 9412              	.LBB3033:
 9413              	.LBI3033:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9414              		.loc 7 76 5 view .LVU2513
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9415              		.loc 7 76 5 is_stmt 0 view .LVU2514
 9416              	.LBE3033:
 9417              	.LBB3034:
 9418              	.LBI3034:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
ARM GAS  /tmp/cc5nV8qb.s 			page 375


 9419              		.loc 14 203 6 is_stmt 1 view .LVU2515
 9420              	.LBB3035:
 9421              	.LBB3036:
 9422              	.LBB3037:
 9423              	.LBI3037:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9424              		.loc 7 76 5 view .LVU2516
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9425              		.loc 7 76 5 is_stmt 0 view .LVU2517
 9426              	.LBE3037:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 9427              		.loc 14 204 47 view .LVU2518
 9428 0404 D3F85431 		ldr	r3, [r3, #340]	@ float
 9429              	.LVL761:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 9430              		.loc 14 204 47 view .LVU2519
 9431 0408 0893     		str	r3, [sp, #32]	@ float
 9432              	.LVL762:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 9433              		.loc 14 204 47 view .LVU2520
 9434              	.LBE3036:
 9435              	.LBE3035:
 9436              	.LBE3034:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 9437              		.loc 14 117 19 view .LVU2521
 9438 040a 0123     		movs	r3, #1
 9439 040c 8DF82430 		strb	r3, [sp, #36]
 9440              	.LVL763:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 9441              		.loc 14 117 19 view .LVU2522
 9442              	.LBE3032:
 9443              	.LBE3031:
 9444              	.LBE3030:
 9445              	.LBE3029:
 9446              	.LBE3028:
 9447              	.LBE3027:
 9448              	.LBE3025:
 9449              	.LBE3024:
 9450              	.LBE3023:
 9451              	.LBE3021:
 9452              	.LBE3020:
 9453              	.LBE3019:
 9454              	.LBE3018:
 9455              	.LBE3017:
 9456              	.LBB3038:
 9457              	.LBI3038:
 9458              		.loc 14 964 2 is_stmt 1 view .LVU2523
 9459              	.LBB3039:
 9460              	.LBB3040:
 9461              	.LBI3040:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 9462              		.loc 14 433 22 view .LVU2524
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 9463              		.loc 14 433 22 is_stmt 0 view .LVU2525
 9464              	.LBE3040:
 9465              	.LBE3039:
 9466              	.LBE3038:
ARM GAS  /tmp/cc5nV8qb.s 			page 376


 402:MotorControl/encoder.cpp ****         if (reached_target_dist) {
 9467              		.loc 3 402 118 view .LVU2526
 9468 0410 94ED0F7A 		vldr.32	s14, [r4, #60]
 9469              	.LVL764:
 403:MotorControl/encoder.cpp ****             break;
 9470              		.loc 3 403 9 is_stmt 1 view .LVU2527
 9471 0414 DDED087A 		vldr.32	s15, [sp, #32]
 9472 0418 B4EEE77A 		vcmpe.f32	s14, s15
 9473 041c F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 9474 0420 09D9     		bls	.L410
 406:MotorControl/encoder.cpp ****         num_steps++;
 9475              		.loc 3 406 9 view .LVU2528
 406:MotorControl/encoder.cpp ****         num_steps++;
 9476              		.loc 3 406 24 is_stmt 0 view .LVU2529
 9477 0422 D4F89030 		ldr	r3, [r4, #144]
 406:MotorControl/encoder.cpp ****         num_steps++;
 9478              		.loc 3 406 21 view .LVU2530
 9479 0426 5D19     		adds	r5, r3, r5
 9480              	.LVL765:
 406:MotorControl/encoder.cpp ****         num_steps++;
 9481              		.loc 3 406 21 view .LVU2531
 9482 0428 48EBE378 		adc	r8, r8, r3, asr #31
 9483              	.LVL766:
 407:MotorControl/encoder.cpp ****         osDelay(1);
 9484              		.loc 3 407 9 is_stmt 1 view .LVU2532
 407:MotorControl/encoder.cpp ****         osDelay(1);
 9485              		.loc 3 407 18 is_stmt 0 view .LVU2533
 9486 042c 0137     		adds	r7, r7, #1
 9487              	.LVL767:
 408:MotorControl/encoder.cpp ****     }
 9488              		.loc 3 408 9 is_stmt 1 view .LVU2534
 408:MotorControl/encoder.cpp ****     }
 9489              		.loc 3 408 16 is_stmt 0 view .LVU2535
 9490 042e 0120     		movs	r0, #1
 9491 0430 FFF7FEFF 		bl	osDelay
 9492              	.LVL768:
 408:MotorControl/encoder.cpp ****     }
 9493              		.loc 3 408 16 view .LVU2536
 9494              	.LBE3016:
 401:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(-INF
 9495              		.loc 3 401 5 view .LVU2537
 9496 0434 DDE7     		b	.L412
 9497              	.L410:
 412:MotorControl/encoder.cpp ****         // motor same dir as encoder
 9498              		.loc 3 412 5 is_stmt 1 view .LVU2538
 412:MotorControl/encoder.cpp ****         // motor same dir as encoder
 9499              		.loc 3 412 9 is_stmt 0 view .LVU2539
 9500 0436 D4F89030 		ldr	r3, [r4, #144]
 412:MotorControl/encoder.cpp ****         // motor same dir as encoder
 9501              		.loc 3 412 38 view .LVU2540
 9502 043a 06F10802 		add	r2, r6, #8
 412:MotorControl/encoder.cpp ****         // motor same dir as encoder
 9503              		.loc 3 412 5 view .LVU2541
 9504 043e 9342     		cmp	r3, r2
 9505 0440 63DD     		ble	.L413
 414:MotorControl/encoder.cpp ****     } else if (shadow_count_ < init_enc_val - 8) {
 9506              		.loc 3 414 9 is_stmt 1 view .LVU2542
ARM GAS  /tmp/cc5nV8qb.s 			page 377


 414:MotorControl/encoder.cpp ****     } else if (shadow_count_ < init_enc_val - 8) {
 9507              		.loc 3 414 27 is_stmt 0 view .LVU2543
 9508 0442 0122     		movs	r2, #1
 9509 0444 E265     		str	r2, [r4, #92]
 9510              	.L414:
 426:MotorControl/encoder.cpp ****     float expected_encoder_delta = config_.calib_scan_distance / elec_rad_per_enc;
 9511              		.loc 3 426 5 is_stmt 1 view .LVU2544
 426:MotorControl/encoder.cpp ****     float expected_encoder_delta = config_.calib_scan_distance / elec_rad_per_enc;
 9512              		.loc 3 426 30 is_stmt 0 view .LVU2545
 9513 0446 226B     		ldr	r2, [r4, #48]
 426:MotorControl/encoder.cpp ****     float expected_encoder_delta = config_.calib_scan_distance / elec_rad_per_enc;
 9514              		.loc 3 426 37 view .LVU2546
 9515 0448 D2F85821 		ldr	r2, [r2, #344]
 426:MotorControl/encoder.cpp ****     float expected_encoder_delta = config_.calib_scan_distance / elec_rad_per_enc;
 9516              		.loc 3 426 52 view .LVU2547
 9517 044c 126A     		ldr	r2, [r2, #32]
 426:MotorControl/encoder.cpp ****     float expected_encoder_delta = config_.calib_scan_distance / elec_rad_per_enc;
 9518              		.loc 3 426 63 view .LVU2548
 9519 044e 5200     		lsls	r2, r2, #1
 9520 0450 07EE902A 		vmov	s15, r2	@ int
 426:MotorControl/encoder.cpp ****     float expected_encoder_delta = config_.calib_scan_distance / elec_rad_per_enc;
 9521              		.loc 3 426 67 view .LVU2549
 9522 0454 F8EEE77A 		vcvt.f32.s32	s15, s15
 9523 0458 1FED277A 		vldr.32	s14, .L454+12
 9524 045c 67EE877A 		vmul.f32	s15, s15, s14
 426:MotorControl/encoder.cpp ****     float expected_encoder_delta = config_.calib_scan_distance / elec_rad_per_enc;
 9525              		.loc 3 426 84 view .LVU2550
 9526 0460 94ED147A 		vldr.32	s14, [r4, #80]	@ int
 9527 0464 B8EEC77A 		vcvt.f32.s32	s14, s14
 426:MotorControl/encoder.cpp ****     float expected_encoder_delta = config_.calib_scan_distance / elec_rad_per_enc;
 9528              		.loc 3 426 82 view .LVU2551
 9529 0468 B7EE006A 		vmov.f32	s12, #1.0e+0
 9530 046c C6EE076A 		vdiv.f32	s13, s12, s14
 426:MotorControl/encoder.cpp ****     float expected_encoder_delta = config_.calib_scan_distance / elec_rad_per_enc;
 9531              		.loc 3 426 11 view .LVU2552
 9532 0470 67EEA67A 		vmul.f32	s15, s15, s13
 9533              	.LVL769:
 427:MotorControl/encoder.cpp ****     calib_scan_response_ = std::abs(shadow_count_ - init_enc_val);
 9534              		.loc 3 427 5 is_stmt 1 view .LVU2553
 427:MotorControl/encoder.cpp ****     calib_scan_response_ = std::abs(shadow_count_ - init_enc_val);
 9535              		.loc 3 427 44 is_stmt 0 view .LVU2554
 9536 0474 D4ED0F6A 		vldr.32	s13, [r4, #60]
 427:MotorControl/encoder.cpp ****     calib_scan_response_ = std::abs(shadow_count_ - init_enc_val);
 9537              		.loc 3 427 11 view .LVU2555
 9538 0478 86EEA77A 		vdiv.f32	s14, s13, s15
 9539              	.LVL770:
 428:MotorControl/encoder.cpp ****     if (std::abs(calib_scan_response_ - expected_encoder_delta) / expected_encoder_delta > config_.
 9540              		.loc 3 428 5 is_stmt 1 view .LVU2556
 428:MotorControl/encoder.cpp ****     if (std::abs(calib_scan_response_ - expected_encoder_delta) / expected_encoder_delta > config_.
 9541              		.loc 3 428 36 is_stmt 0 view .LVU2557
 9542 047c 9B1B     		subs	r3, r3, r6
 9543              	.LVL771:
 9544              	.LBB3041:
 9545              	.LBI3041:
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #endif
 9546              		.loc 22 56 3 is_stmt 1 view .LVU2558
 9547              	.LBB3042:
ARM GAS  /tmp/cc5nV8qb.s 			page 378


  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #endif
 9548              		.loc 22 56 19 view .LVU2559
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #endif
 9549              		.loc 22 56 44 is_stmt 0 view .LVU2560
 9550 047e 002B     		cmp	r3, #0
 9551 0480 B8BF     		it	lt
 9552 0482 5B42     		rsblt	r3, r3, #0
 9553              	.LVL772:
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #endif
 9554              		.loc 22 56 44 view .LVU2561
 9555              	.LBE3042:
 9556              	.LBE3041:
 428:MotorControl/encoder.cpp ****     if (std::abs(calib_scan_response_ - expected_encoder_delta) / expected_encoder_delta > config_.
 9557              		.loc 3 428 26 view .LVU2562
 9558 0484 07EE903A 		vmov	s15, r3	@ int
 9559              	.LVL773:
 428:MotorControl/encoder.cpp ****     if (std::abs(calib_scan_response_ - expected_encoder_delta) / expected_encoder_delta > config_.
 9560              		.loc 3 428 26 view .LVU2563
 9561 0488 F8EEE77A 		vcvt.f32.s32	s15, s15
 9562 048c C4ED317A 		vstr.32	s15, [r4, #196]
 429:MotorControl/encoder.cpp ****         set_error(ERROR_CPR_POLEPAIRS_MISMATCH);
 9563              		.loc 3 429 5 is_stmt 1 view .LVU2564
 429:MotorControl/encoder.cpp ****         set_error(ERROR_CPR_POLEPAIRS_MISMATCH);
 9564              		.loc 3 429 17 is_stmt 0 view .LVU2565
 9565 0490 77EEC77A 		vsub.f32	s15, s15, s14
 9566              	.LVL774:
 9567              	.LBB3043:
 9568              	.LBI3043:
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   { return __builtin_fabsf(__x); }
 9569              		.loc 22 75 3 is_stmt 1 view .LVU2566
 9570              	.LBB3044:
 9571              		.loc 22 76 5 view .LVU2567
 9572              		.loc 22 76 31 is_stmt 0 view .LVU2568
 9573 0494 F0EEE77A 		vabs.f32	s15, s15
 9574              	.LVL775:
 9575              		.loc 22 76 31 view .LVU2569
 9576              	.LBE3044:
 9577              	.LBE3043:
 429:MotorControl/encoder.cpp ****         set_error(ERROR_CPR_POLEPAIRS_MISMATCH);
 9578              		.loc 3 429 65 view .LVU2570
 9579 0498 C7EE876A 		vdiv.f32	s13, s15, s14
 429:MotorControl/encoder.cpp ****         set_error(ERROR_CPR_POLEPAIRS_MISMATCH);
 9580              		.loc 3 429 100 view .LVU2571
 9581 049c D4ED0E7A 		vldr.32	s15, [r4, #56]
 429:MotorControl/encoder.cpp ****         set_error(ERROR_CPR_POLEPAIRS_MISMATCH);
 9582              		.loc 3 429 5 view .LVU2572
 9583 04a0 F4EEE76A 		vcmpe.f32	s13, s15
 9584 04a4 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 9585 04a8 43DC     		bgt	.L453
 435:MotorControl/encoder.cpp ****         axis_->open_loop_controller_.target_vel_ = -config_.calib_scan_omega;
 9586              		.loc 3 435 5 is_stmt 1 view .LVU2573
 9587              	.LVL776:
 9588              	.LBB3045:
 9589              	.LBB3046:
 9590              	.LBI3046:
  56:./Drivers/STM32/stm32_system.h ****     ~CriticalSectionContext() { cpu_exit_critical(mask_); }
 9591              		.loc 4 56 5 view .LVU2574
ARM GAS  /tmp/cc5nV8qb.s 			page 379


 9592              	.LBB3047:
 9593              	.LBB3048:
 9594              	.LBB3049:
 9595              	.LBI3049:
  31:./Drivers/STM32/stm32_system.h ****     uint32_t primask = __get_PRIMASK();
 9596              		.loc 4 31 24 view .LVU2575
 9597              	.LBB3050:
  32:./Drivers/STM32/stm32_system.h ****     __disable_irq();
 9598              		.loc 4 32 5 view .LVU2576
 9599              	.LBB3051:
 9600              	.LBI3051:
 382:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 9601              		.loc 5 382 31 view .LVU2577
 9602              	.LBB3052:
 384:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 9603              		.loc 5 384 3 view .LVU2578
 386:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 9604              		.loc 5 386 3 view .LVU2579
 9605              		.syntax unified
 9606              	@ 386 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 9607 04aa EFF31083 		MRS r3, primask
 9608              	@ 0 "" 2
 9609              	.LVL777:
 387:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 9610              		.loc 5 387 3 view .LVU2580
 387:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 9611              		.loc 5 387 3 is_stmt 0 view .LVU2581
 9612              		.thumb
 9613              		.syntax unified
 9614              	.LBE3052:
 9615              	.LBE3051:
  33:./Drivers/STM32/stm32_system.h ****     return primask;
 9616              		.loc 4 33 5 is_stmt 1 view .LVU2582
 9617              	.LBB3053:
 9618              	.LBI3053:
 140:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 9619              		.loc 5 140 27 view .LVU2583
 9620              	.LBB3054:
 142:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 9621              		.loc 5 142 3 view .LVU2584
 9622              		.syntax unified
 9623              	@ 142 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 9624 04ae 72B6     		cpsid i
 9625              	@ 0 "" 2
 9626              		.thumb
 9627              		.syntax unified
 9628              	.LBE3054:
 9629              	.LBE3053:
  34:./Drivers/STM32/stm32_system.h **** }
 9630              		.loc 4 34 5 view .LVU2585
 9631              	.LBE3050:
 9632              	.LBE3049:
  56:./Drivers/STM32/stm32_system.h ****     ~CriticalSectionContext() { cpu_exit_critical(mask_); }
 9633              		.loc 4 56 58 is_stmt 0 view .LVU2586
 9634 04b0 0293     		str	r3, [sp, #8]
 9635              	.LVL778:
  56:./Drivers/STM32/stm32_system.h ****     ~CriticalSectionContext() { cpu_exit_critical(mask_); }
ARM GAS  /tmp/cc5nV8qb.s 			page 380


 9636              		.loc 4 56 58 view .LVU2587
 9637 04b2 0022     		movs	r2, #0
  56:./Drivers/STM32/stm32_system.h ****     ~CriticalSectionContext() { cpu_exit_critical(mask_); }
 9638              		.loc 4 56 58 view .LVU2588
 9639 04b4 8DF80C20 		strb	r2, [sp, #12]
 9640              	.LVL779:
  56:./Drivers/STM32/stm32_system.h ****     ~CriticalSectionContext() { cpu_exit_critical(mask_); }
 9641              		.loc 4 56 58 view .LVU2589
 9642              	.LBE3048:
 9643              	.LBE3047:
 9644              	.LBE3046:
 9645              	.LBE3045:
  55:./Drivers/STM32/stm32_system.h ****     CriticalSectionContext() : mask_(cpu_enter_critical()) {}
 9646              		.loc 4 55 23 is_stmt 1 view .LVU2590
 9647              	.LBB3063:
 436:MotorControl/encoder.cpp ****     }
 9648              		.loc 3 436 9 view .LVU2591
 436:MotorControl/encoder.cpp ****     }
 9649              		.loc 3 436 61 is_stmt 0 view .LVU2592
 9650 04b8 D4ED107A 		vldr.32	s15, [r4, #64]
 436:MotorControl/encoder.cpp ****     }
 9651              		.loc 3 436 9 view .LVU2593
 9652 04bc 226B     		ldr	r2, [r4, #48]
 436:MotorControl/encoder.cpp ****     }
 9653              		.loc 3 436 52 view .LVU2594
 9654 04be F1EE677A 		vneg.f32	s15, s15
 436:MotorControl/encoder.cpp ****     }
 9655              		.loc 3 436 50 view .LVU2595
 9656 04c2 C2ED457A 		vstr.32	s15, [r2, #276]
 9657              	.LVL780:
 9658              	.LBB3055:
 9659              	.LBI3055:
 9660              		.loc 4 57 5 is_stmt 1 view .LVU2596
 9661              	.LBB3056:
 9662              		.loc 4 57 33 view .LVU2597
 9663              	.LBB3057:
 9664              	.LBI3057:
  37:./Drivers/STM32/stm32_system.h ****     __set_PRIMASK(priority_mask);
 9665              		.loc 4 37 20 view .LVU2598
 9666              	.LBE3057:
 9667              	.LBE3056:
 9668              	.LBE3055:
 9669              	.LBE3063:
  38:./Drivers/STM32/stm32_system.h **** }
 9670              		.loc 4 38 5 view .LVU2599
 9671              	.LBB3064:
 9672              	.LBB3062:
 9673              	.LBB3061:
 9674              	.LBB3060:
 9675              	.LBB3058:
 9676              	.LBI3058:
 412:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 9677              		.loc 5 412 27 view .LVU2600
 9678              	.LBB3059:
 9679              		.loc 5 414 3 view .LVU2601
 9680              		.syntax unified
 9681              	@ 414 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
ARM GAS  /tmp/cc5nV8qb.s 			page 381


 9682 04c6 83F31088 		MSR primask, r3
 9683              	@ 0 "" 2
 9684              	.LVL781:
 9685              		.thumb
 9686              		.syntax unified
 9687              	.L420:
 9688              		.loc 5 414 3 is_stmt 0 view .LVU2602
 9689              	.LBE3059:
 9690              	.LBE3058:
 9691              	.LBE3060:
 9692              	.LBE3061:
 9693              	.LBE3062:
 9694              	.LBE3064:
 440:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(INFI
 9695              		.loc 3 440 5 is_stmt 1 view .LVU2603
 440:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(INFI
 9696              		.loc 3 440 68 view .LVU2604
 440:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(INFI
 9697              		.loc 3 440 13 is_stmt 0 view .LVU2605
 9698 04ca 236B     		ldr	r3, [r4, #48]
 440:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(INFI
 9699              		.loc 3 440 20 view .LVU2606
 9700 04cc 93F86C22 		ldrb	r2, [r3, #620]	@ zero_extendqisi2
 440:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(INFI
 9701              		.loc 3 440 68 view .LVU2607
 9702 04d0 DABB     		cbnz	r2, .L418
 440:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(INFI
 9703              		.loc 3 440 78 discriminator 1 view .LVU2608
 9704 04d2 D3F85821 		ldr	r2, [r3, #344]
 440:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(INFI
 9705              		.loc 3 440 85 discriminator 1 view .LVU2609
 9706 04d6 92F89C20 		ldrb	r2, [r2, #156]	@ zero_extendqisi2
 440:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(INFI
 9707              		.loc 3 440 68 discriminator 1 view .LVU2610
 9708 04da B2B3     		cbz	r2, .L418
 9709              	.LBB3065:
 441:MotorControl/encoder.cpp ****         if (reached_target_dist) {
 9710              		.loc 3 441 9 is_stmt 1 view .LVU2611
 9711              	.LVL782:
 9712              	.LBB3066:
 9713              	.LBI3066:
 102:./MotorControl/component.hpp ****         return content_;
 9714              		.loc 13 102 22 view .LVU2612
 9715              	.LBB3067:
 9716              	.LBB3068:
 9717              	.LBI3068:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 9718              		.loc 14 700 2 view .LVU2613
 9719              	.LBB3069:
 9720              	.LBB3070:
 9721              	.LBB3071:
 9722              	.LBI3071:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9723              		.loc 7 76 5 view .LVU2614
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9724              		.loc 7 76 5 is_stmt 0 view .LVU2615
 9725              	.LBE3071:
ARM GAS  /tmp/cc5nV8qb.s 			page 382


 9726              	.LBB3072:
 9727              	.LBI3072:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 9728              		.loc 14 607 28 is_stmt 1 view .LVU2616
 9729              	.LBB3073:
 9730              	.LBB3074:
 9731              	.LBB3075:
 9732              	.LBI3075:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9733              		.loc 7 76 5 view .LVU2617
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9734              		.loc 7 76 5 is_stmt 0 view .LVU2618
 9735              	.LBE3075:
 9736              	.LBB3076:
 9737              	.LBI3076:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 9738              		.loc 14 300 42 is_stmt 1 view .LVU2619
 9739              	.LBB3077:
 9740              	.LBB3078:
 9741              	.LBB3079:
 9742              	.LBI3079:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 9743              		.loc 14 115 2 view .LVU2620
 9744              	.LBB3080:
 9745              	.LBB3081:
 9746              	.LBB3082:
 9747              	.LBI3082:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9748              		.loc 7 76 5 view .LVU2621
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9749              		.loc 7 76 5 is_stmt 0 view .LVU2622
 9750              	.LBE3082:
 9751              	.LBB3083:
 9752              	.LBI3083:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 9753              		.loc 14 203 6 is_stmt 1 view .LVU2623
 9754              	.LBB3084:
 9755              	.LBB3085:
 9756              	.LBB3086:
 9757              	.LBI3086:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9758              		.loc 7 76 5 view .LVU2624
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return static_cast<_Tp&&>(__t); }
 9759              		.loc 7 76 5 is_stmt 0 view .LVU2625
 9760              	.LBE3086:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 9761              		.loc 14 204 47 view .LVU2626
 9762 04dc D3F85431 		ldr	r3, [r3, #340]	@ float
 9763              	.LVL783:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 9764              		.loc 14 204 47 view .LVU2627
 9765 04e0 0A93     		str	r3, [sp, #40]	@ float
 9766              	.LVL784:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 9767              		.loc 14 204 47 view .LVU2628
 9768              	.LBE3085:
 9769              	.LBE3084:
ARM GAS  /tmp/cc5nV8qb.s 			page 383


 9770              	.LBE3083:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 9771              		.loc 14 117 19 view .LVU2629
 9772 04e2 0123     		movs	r3, #1
 9773 04e4 8DF82C30 		strb	r3, [sp, #44]
 9774              	.LVL785:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 9775              		.loc 14 117 19 view .LVU2630
 9776              	.LBE3081:
 9777              	.LBE3080:
 9778              	.LBE3079:
 9779              	.LBE3078:
 9780              	.LBE3077:
 9781              	.LBE3076:
 9782              	.LBE3074:
 9783              	.LBE3073:
 9784              	.LBE3072:
 9785              	.LBE3070:
 9786              	.LBE3069:
 9787              	.LBE3068:
 9788              	.LBE3067:
 9789              	.LBE3066:
 9790              	.LBB3087:
 9791              	.LBI3087:
 9792              		.loc 14 964 2 is_stmt 1 view .LVU2631
 9793              	.LBB3088:
 9794              	.LBB3089:
 9795              	.LBI3089:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 9796              		.loc 14 433 22 view .LVU2632
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 9797              		.loc 14 433 22 is_stmt 0 view .LVU2633
 9798              	.LBE3089:
 965:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 966:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_move_constructible_v<_Tp>);
 967:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_convertible_v<_Up&&, _Tp>);
 968:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 969:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_is_engaged()
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    ? std::move(this->_M_get())
 9799              		.loc 14 970 6 view .LVU2634
 9800 04e8 DDED0A7A 		vldr.32	s15, [sp, #40]
 9801              	.LVL786:
 9802              		.loc 14 970 6 view .LVU2635
 9803              	.LBE3088:
 9804              	.LBE3087:
 442:MotorControl/encoder.cpp ****             break;
 9805              		.loc 3 442 9 is_stmt 1 view .LVU2636
 9806 04ec F5EEC07A 		vcmpe.f32	s15, #0
 9807 04f0 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 9808 04f4 29D9     		bls	.L418
 445:MotorControl/encoder.cpp ****         num_steps++;
 9809              		.loc 3 445 9 view .LVU2637
 445:MotorControl/encoder.cpp ****         num_steps++;
 9810              		.loc 3 445 24 is_stmt 0 view .LVU2638
 9811 04f6 D4F89030 		ldr	r3, [r4, #144]
 445:MotorControl/encoder.cpp ****         num_steps++;
 9812              		.loc 3 445 21 view .LVU2639
ARM GAS  /tmp/cc5nV8qb.s 			page 384


 9813 04fa 5D19     		adds	r5, r3, r5
 9814              	.LVL787:
 445:MotorControl/encoder.cpp ****         num_steps++;
 9815              		.loc 3 445 21 view .LVU2640
 9816 04fc 48EBE378 		adc	r8, r8, r3, asr #31
 9817              	.LVL788:
 446:MotorControl/encoder.cpp ****         osDelay(1);
 9818              		.loc 3 446 9 is_stmt 1 view .LVU2641
 446:MotorControl/encoder.cpp ****         osDelay(1);
 9819              		.loc 3 446 18 is_stmt 0 view .LVU2642
 9820 0500 0137     		adds	r7, r7, #1
 9821              	.LVL789:
 447:MotorControl/encoder.cpp ****     }
 9822              		.loc 3 447 9 is_stmt 1 view .LVU2643
 447:MotorControl/encoder.cpp ****     }
 9823              		.loc 3 447 16 is_stmt 0 view .LVU2644
 9824 0502 0120     		movs	r0, #1
 9825 0504 FFF7FEFF 		bl	osDelay
 9826              	.LVL790:
 447:MotorControl/encoder.cpp ****     }
 9827              		.loc 3 447 16 view .LVU2645
 9828              	.LBE3065:
 440:MotorControl/encoder.cpp ****         bool reached_target_dist = axis_->open_loop_controller_.total_distance_.any().value_or(INFI
 9829              		.loc 3 440 5 view .LVU2646
 9830 0508 DFE7     		b	.L420
 9831              	.LVL791:
 9832              	.L413:
 415:MotorControl/encoder.cpp ****         // motor opposite dir as encoder
 9833              		.loc 3 415 12 is_stmt 1 view .LVU2647
 415:MotorControl/encoder.cpp ****         // motor opposite dir as encoder
 9834              		.loc 3 415 45 is_stmt 0 view .LVU2648
 9835 050a A6F10802 		sub	r2, r6, #8
 415:MotorControl/encoder.cpp ****         // motor opposite dir as encoder
 9836              		.loc 3 415 12 view .LVU2649
 9837 050e 9342     		cmp	r3, r2
 9838 0510 03DA     		bge	.L415
 417:MotorControl/encoder.cpp ****     } else {
 9839              		.loc 3 417 9 is_stmt 1 view .LVU2650
 417:MotorControl/encoder.cpp ****     } else {
 9840              		.loc 3 417 27 is_stmt 0 view .LVU2651
 9841 0512 4FF0FF32 		mov	r2, #-1
 9842 0516 E265     		str	r2, [r4, #92]
 9843 0518 95E7     		b	.L414
 9844              	.L415:
 420:MotorControl/encoder.cpp ****         axis_->motor_.disarm();
 9845              		.loc 3 420 9 is_stmt 1 view .LVU2652
 420:MotorControl/encoder.cpp ****         axis_->motor_.disarm();
 9846              		.loc 3 420 18 is_stmt 0 view .LVU2653
 9847 051a 0421     		movs	r1, #4
 9848 051c 2046     		mov	r0, r4
 9849 051e FFF7FEFF 		bl	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
 9850              	.LVL792:
 421:MotorControl/encoder.cpp ****         return false;
 9851              		.loc 3 421 9 is_stmt 1 view .LVU2654
 9852 0522 236B     		ldr	r3, [r4, #48]
 421:MotorControl/encoder.cpp ****         return false;
 9853              		.loc 3 421 29 is_stmt 0 view .LVU2655
ARM GAS  /tmp/cc5nV8qb.s 			page 385


 9854 0524 0021     		movs	r1, #0
 9855 0526 D3F85801 		ldr	r0, [r3, #344]
 9856 052a FFF7FEFF 		bl	_ZN5Motor6disarmEPb
 9857              	.LVL793:
 422:MotorControl/encoder.cpp ****     }
 9858              		.loc 3 422 9 is_stmt 1 view .LVU2656
 422:MotorControl/encoder.cpp ****     }
 9859              		.loc 3 422 16 is_stmt 0 view .LVU2657
 9860 052e 0026     		movs	r6, #0
 9861              	.LVL794:
 422:MotorControl/encoder.cpp ****     }
 9862              		.loc 3 422 16 view .LVU2658
 9863 0530 3CE7     		b	.L375
 9864              	.LVL795:
 9865              	.L453:
 430:MotorControl/encoder.cpp ****         axis_->motor_.disarm();
 9866              		.loc 3 430 9 is_stmt 1 view .LVU2659
 430:MotorControl/encoder.cpp ****         axis_->motor_.disarm();
 9867              		.loc 3 430 18 is_stmt 0 view .LVU2660
 9868 0532 0221     		movs	r1, #2
 9869 0534 2046     		mov	r0, r4
 9870 0536 FFF7FEFF 		bl	_ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
 9871              	.LVL796:
 431:MotorControl/encoder.cpp ****         return false;
 9872              		.loc 3 431 9 is_stmt 1 view .LVU2661
 9873 053a 236B     		ldr	r3, [r4, #48]
 431:MotorControl/encoder.cpp ****         return false;
 9874              		.loc 3 431 29 is_stmt 0 view .LVU2662
 9875 053c 0021     		movs	r1, #0
 9876 053e D3F85801 		ldr	r0, [r3, #344]
 9877 0542 FFF7FEFF 		bl	_ZN5Motor6disarmEPb
 9878              	.LVL797:
 432:MotorControl/encoder.cpp ****     }
 9879              		.loc 3 432 9 is_stmt 1 view .LVU2663
 432:MotorControl/encoder.cpp ****     }
 9880              		.loc 3 432 16 is_stmt 0 view .LVU2664
 9881 0546 0026     		movs	r6, #0
 9882              	.LVL798:
 432:MotorControl/encoder.cpp ****     }
 9883              		.loc 3 432 16 view .LVU2665
 9884 0548 30E7     		b	.L375
 9885              	.LVL799:
 9886              	.L418:
 451:MotorControl/encoder.cpp ****         return false;
 9887              		.loc 3 451 5 is_stmt 1 view .LVU2666
 451:MotorControl/encoder.cpp ****         return false;
 9888              		.loc 3 451 10 is_stmt 0 view .LVU2667
 9889 054a 236B     		ldr	r3, [r4, #48]
 451:MotorControl/encoder.cpp ****         return false;
 9890              		.loc 3 451 17 view .LVU2668
 9891 054c D3F85801 		ldr	r0, [r3, #344]
 451:MotorControl/encoder.cpp ****         return false;
 9892              		.loc 3 451 24 view .LVU2669
 9893 0550 90F89C60 		ldrb	r6, [r0, #156]	@ zero_extendqisi2
 9894              	.LVL800:
 451:MotorControl/encoder.cpp ****         return false;
 9895              		.loc 3 451 5 view .LVU2670
ARM GAS  /tmp/cc5nV8qb.s 			page 386


 9896 0554 002E     		cmp	r6, #0
 9897 0556 3FF429AF 		beq	.L375
 455:MotorControl/encoder.cpp **** 
 9898              		.loc 3 455 5 is_stmt 1 view .LVU2671
 455:MotorControl/encoder.cpp **** 
 9899              		.loc 3 455 25 is_stmt 0 view .LVU2672
 9900 055a 0021     		movs	r1, #0
 9901 055c FFF7FEFF 		bl	_ZN5Motor6disarmEPb
 9902              	.LVL801:
 9903              	.LEHE10:
 457:MotorControl/encoder.cpp ****     int32_t residual = encvaluesum - ((int64_t)config_.phase_offset * (int64_t)num_steps);
 9904              		.loc 3 457 5 is_stmt 1 view .LVU2673
 457:MotorControl/encoder.cpp ****     int32_t residual = encvaluesum - ((int64_t)config_.phase_offset * (int64_t)num_steps);
 9905              		.loc 3 457 40 is_stmt 0 view .LVU2674
 9906 0560 3A46     		mov	r2, r7
 9907 0562 0023     		movs	r3, #0
 9908 0564 2846     		mov	r0, r5
 9909 0566 4146     		mov	r1, r8
 9910 0568 FFF7FEFF 		bl	__aeabi_ldivmod
 9911              	.LVL802:
 457:MotorControl/encoder.cpp ****     int32_t residual = encvaluesum - ((int64_t)config_.phase_offset * (int64_t)num_steps);
 9912              		.loc 3 457 26 view .LVU2675
 9913 056c A064     		str	r0, [r4, #72]
 458:MotorControl/encoder.cpp ****     config_.phase_offset_float = (float)residual / (float)num_steps + 0.5f;  // add 0.5 to center-a
 9914              		.loc 3 458 5 is_stmt 1 view .LVU2676
 458:MotorControl/encoder.cpp ****     config_.phase_offset_float = (float)residual / (float)num_steps + 0.5f;  // add 0.5 to center-a
 9915              		.loc 3 458 36 is_stmt 0 view .LVU2677
 9916 056e 07FB1055 		mls	r5, r7, r0, r5
 9917              	.LVL803:
 459:MotorControl/encoder.cpp **** 
 9918              		.loc 3 459 5 is_stmt 1 view .LVU2678
 459:MotorControl/encoder.cpp **** 
 9919              		.loc 3 459 34 is_stmt 0 view .LVU2679
 9920 0572 07EE905A 		vmov	s15, r5	@ int
 9921 0576 F8EEE77A 		vcvt.f32.s32	s15, s15
 459:MotorControl/encoder.cpp **** 
 9922              		.loc 3 459 52 view .LVU2680
 9923 057a 07EE107A 		vmov	s14, r7	@ int
 9924 057e B8EE477A 		vcvt.f32.u32	s14, s14
 459:MotorControl/encoder.cpp **** 
 9925              		.loc 3 459 50 view .LVU2681
 9926 0582 C7EE876A 		vdiv.f32	s13, s15, s14
 459:MotorControl/encoder.cpp **** 
 9927              		.loc 3 459 69 view .LVU2682
 9928 0586 F6EE007A 		vmov.f32	s15, #5.0e-1
 9929 058a 76EEA77A 		vadd.f32	s15, s13, s15
 459:MotorControl/encoder.cpp **** 
 9930              		.loc 3 459 32 view .LVU2683
 9931 058e C4ED137A 		vstr.32	s15, [r4, #76]
 461:MotorControl/encoder.cpp ****     return true;
 9932              		.loc 3 461 5 is_stmt 1 view .LVU2684
 461:MotorControl/encoder.cpp ****     return true;
 9933              		.loc 3 461 15 is_stmt 0 view .LVU2685
 9934 0592 0123     		movs	r3, #1
 9935 0594 84F88F30 		strb	r3, [r4, #143]
 462:MotorControl/encoder.cpp **** }
 9936              		.loc 3 462 5 is_stmt 1 view .LVU2686
ARM GAS  /tmp/cc5nV8qb.s 			page 387


 462:MotorControl/encoder.cpp **** }
 9937              		.loc 3 462 12 is_stmt 0 view .LVU2687
 9938 0598 08E7     		b	.L375
 9939              		.cfi_endproc
 9940              	.LFE5356:
 9941              		.personality	__gxx_personality_v0
 9942              		.handlerdata
 9943              	.LLSDA5356:
 9944 0008 FF       		.byte	0xff
 9945 0009 FF       		.byte	0xff
 9946 000a 01       		.byte	0x1
 9947 000b 0B       		.uleb128 .LLSDACSE5356-.LLSDACSB5356
 9948              	.LLSDACSB5356:
 9949 000c F204     		.uleb128 .LEHB9-.LFB5356
 9950 000e 3A       		.uleb128 .LEHE9-.LEHB9
 9951 000f 00       		.uleb128 0
 9952 0010 00       		.uleb128 0
 9953 0011 A607     		.uleb128 .LEHB10-.LFB5356
 9954 0013 BA03     		.uleb128 .LEHE10-.LEHB10
 9955 0015 00       		.uleb128 0
 9956 0016 00       		.uleb128 0
 9957              	.LLSDACSE5356:
 9958              		.section	.text._ZN7Encoder22run_offset_calibrationEv
 9959              		.fnend
 9961              		.weak	_ZTSSt18bad_variant_access
 9962 059a 00BF     		.section	.rodata._ZTSSt18bad_variant_access,"aG",%progbits,_ZTSSt18bad_variant_access,comdat
 9963              		.align	2
 9966              	_ZTSSt18bad_variant_access:
 9967 0000 53743138 		.ascii	"St18bad_variant_access\000"
 9967      6261645F 
 9967      76617269 
 9967      616E745F 
 9967      61636365 
 9968              		.weak	_ZTISt18bad_variant_access
 9969              		.section	.rodata._ZTISt18bad_variant_access,"aG",%progbits,_ZTISt18bad_variant_access,comdat
 9970              		.align	2
 9973              	_ZTISt18bad_variant_access:
 9974 0000 08000000 		.word	_ZTVN10__cxxabiv120__si_class_type_infoE+8
 9975 0004 00000000 		.word	_ZTSSt18bad_variant_access
 9976 0008 00000000 		.word	_ZTISt9exception
 9977              		.weak	_ZTSN10ODriveIntf11EncoderIntfE
 9978              		.section	.rodata._ZTSN10ODriveIntf11EncoderIntfE,"aG",%progbits,_ZTSN10ODriveIntf11EncoderIntfE,co
 9979              		.align	2
 9982              	_ZTSN10ODriveIntf11EncoderIntfE:
 9983 0000 4E31304F 		.ascii	"N10ODriveIntf11EncoderIntfE\000"
 9983      44726976 
 9983      65496E74 
 9983      66313145 
 9983      6E636F64 
 9984              		.weak	_ZTIN10ODriveIntf11EncoderIntfE
 9985              		.section	.rodata._ZTIN10ODriveIntf11EncoderIntfE,"aG",%progbits,_ZTIN10ODriveIntf11EncoderIntfE,co
 9986              		.align	2
 9989              	_ZTIN10ODriveIntf11EncoderIntfE:
 9990 0000 08000000 		.word	_ZTVN10__cxxabiv117__class_type_infoE+8
 9991 0004 00000000 		.word	_ZTSN10ODriveIntf11EncoderIntfE
 9992              		.global	_ZTS7Encoder
 9993              		.global	_ZTI7Encoder
ARM GAS  /tmp/cc5nV8qb.s 			page 388


 9994              		.weak	_ZTVSt18bad_variant_access
 9995              		.section	.rodata._ZTVSt18bad_variant_access,"aG",%progbits,_ZTVSt18bad_variant_access,comdat
 9996              		.align	2
 9999              	_ZTVSt18bad_variant_access:
 10000 0000 00000000 		.word	0
 10001 0004 00000000 		.word	_ZTISt18bad_variant_access
 10002 0008 00000000 		.word	_ZNSt18bad_variant_accessD1Ev
 10003 000c 00000000 		.word	_ZNSt18bad_variant_accessD0Ev
 10004 0010 00000000 		.word	_ZNKSt18bad_variant_access4whatEv
 10005              		.weak	_ZTVN10ODriveIntf11EncoderIntfE
 10006              		.section	.rodata._ZTVN10ODriveIntf11EncoderIntfE,"aG",%progbits,_ZTVN10ODriveIntf11EncoderIntfE,co
 10007              		.align	2
 10010              	_ZTVN10ODriveIntf11EncoderIntfE:
 10011 0000 00000000 		.word	0
 10012 0004 00000000 		.word	_ZTIN10ODriveIntf11EncoderIntfE
 10013 0008 00000000 		.word	__cxa_pure_virtual
 10014              		.global	_ZTV7Encoder
 10015              		.weak	_ZN7Encoder15ports_to_sampleE
 10016              		.section	.rodata._ZN7Encoder15ports_to_sampleE,"aG",%progbits,_ZN7Encoder15ports_to_sampleE,comdat
 10017              		.align	2
 10020              	_ZN7Encoder15ports_to_sampleE:
 10021 0000 00000240 		.word	1073872896
 10022 0004 00040240 		.word	1073873920
 10023 0008 00080240 		.word	1073874944
 10024              		.weak	_ZN7Encoder18hall_edge_defaultsE
 10025              		.section	.rodata._ZN7Encoder18hall_edge_defaultsE,"aG",%progbits,_ZN7Encoder18hall_edge_defaultsE,
 10026              		.align	2
 10029              	_ZN7Encoder18hall_edge_defaultsE:
 10030 0000 00000000 		.word	0
 10031 0004 0000803F 		.word	1065353216
 10032 0008 00000040 		.word	1073741824
 10033 000c 00004040 		.word	1077936128
 10034 0010 00008040 		.word	1082130432
 10035 0014 0000A040 		.word	1084227584
 10036              		.section	.rodata._ZTI7Encoder,"a"
 10037              		.align	2
 10040              	_ZTI7Encoder:
 10041 0000 08000000 		.word	_ZTVN10__cxxabiv120__si_class_type_infoE+8
 10042 0004 00000000 		.word	_ZTS7Encoder
 10043 0008 00000000 		.word	_ZTIN10ODriveIntf11EncoderIntfE
 10044              		.section	.rodata._ZTIZN7Encoder26run_hall_phase_calibrationEvEUlbE_,"a"
 10045              		.align	2
 10046              		.set	.LANCHOR1,. + 0
 10049              	_ZTIZN7Encoder26run_hall_phase_calibrationEvEUlbE_:
 10050 0000 08000000 		.word	_ZTVN10__cxxabiv117__class_type_infoE+8
 10051 0004 00000000 		.word	_ZTSZN7Encoder26run_hall_phase_calibrationEvEUlbE_
 10052              		.section	.rodata._ZTIZN7Encoder29run_hall_polarity_calibrationEvEUlbE_,"a"
 10053              		.align	2
 10054              		.set	.LANCHOR0,. + 0
 10057              	_ZTIZN7Encoder29run_hall_polarity_calibrationEvEUlbE_:
 10058 0000 08000000 		.word	_ZTVN10__cxxabiv117__class_type_infoE+8
 10059 0004 00000000 		.word	_ZTSZN7Encoder29run_hall_polarity_calibrationEvEUlbE_
 10060              		.section	.rodata._ZTS7Encoder,"a"
 10061              		.align	2
 10064              	_ZTS7Encoder:
 10065 0000 37456E63 		.ascii	"7Encoder\000"
 10065      6F646572 
ARM GAS  /tmp/cc5nV8qb.s 			page 389


 10065      00
 10066              		.section	.rodata._ZTSZN7Encoder26run_hall_phase_calibrationEvEUlbE_,"a"
 10067              		.align	2
 10070              	_ZTSZN7Encoder26run_hall_phase_calibrationEvEUlbE_:
 10071 0000 2A5A4E37 		.ascii	"*ZN7Encoder26run_hall_phase_calibrationEvEUlbE_\000"
 10071      456E636F 
 10071      64657232 
 10071      3672756E 
 10071      5F68616C 
 10072              		.section	.rodata._ZTSZN7Encoder29run_hall_polarity_calibrationEvEUlbE_,"a"
 10073              		.align	2
 10076              	_ZTSZN7Encoder29run_hall_polarity_calibrationEvEUlbE_:
 10077 0000 2A5A4E37 		.ascii	"*ZN7Encoder29run_hall_polarity_calibrationEvEUlbE_\000"
 10077      456E636F 
 10077      64657232 
 10077      3972756E 
 10077      5F68616C 
 10078              		.section	.rodata._ZTV7Encoder,"a"
 10079              		.align	2
 10080              		.set	.LANCHOR2,. + 0
 10083              	_ZTV7Encoder:
 10084 0000 00000000 		.word	0
 10085 0004 00000000 		.word	_ZTI7Encoder
 10086 0008 00000000 		.word	_ZN7Encoder16set_linear_countEl
 10087              		.text
 10088              	.Letext0:
 10089              		.file 24 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/machine/_default_types.h"
 10090              		.file 25 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/_stdint.h"
 10091              		.file 26 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdint.h"
 10092              		.file 27 "ThirdParty/CMSIS/Device/ST/STM32F4xx/Include/stm32f405xx.h"
 10093              		.file 28 "/opt/gcc-arm-none-eabi/lib/gcc/arm-none-eabi/10.3.1/include/stddef.h"
 10094              		.file 29 "/opt/gcc-arm-none-eabi/lib/gcc/arm-none-eabi/10.3.1/include/stdarg.h"
 10095              		.file 30 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/_types.h"
 10096              		.file 31 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/reent.h"
 10097              		.file 32 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/lock.h"
 10098              		.file 33 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdio.h"
 10099              		.file 34 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_def.h"
 10100              		.file 35 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_gpio.h"
 10101              		.file 36 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_dma.h"
 10102              		.file 37 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_spi.h"
 10103              		.file 38 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_tim.h"
 10104              		.file 39 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/basic_string.h"
 10105              		.file 40 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdlib"
 10106              		.file 41 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/cpp_type_traits.h"
 10107              		.file 42 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/type_traits"
 10108              		.file 43 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/arm-none-eabi/thumb/v7e-m+fp/har
 10109              		.file 44 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_iterator_base_types.h"
 10110              		.file 45 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/debug/debug.h"
 10111              		.file 46 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/utility"
 10112              		.file 47 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception_ptr.h"
 10113              		.file 48 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/allocator.h"
 10114              		.file 49 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_iterator.h"
 10115              		.file 50 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/enable_special_members.h"
 10116              		.file 51 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/algorithmfwd.h"
 10117              		.file 52 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional"
 10118              		.file 53 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstring"
 10119              		.file 54 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/parse_numbers.h"
ARM GAS  /tmp/cc5nV8qb.s 			page 390


 10120              		.file 55 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_function.h"
 10121              		.file 56 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/refwrap.h"
 10122              		.file 57 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cwchar"
 10123              		.file 58 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/clocale"
 10124              		.file 59 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/char_traits.h"
 10125              		.file 60 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdint"
 10126              		.file 61 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/string_view"
 10127              		.file 62 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdio"
 10128              		.file 63 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/alloc_traits.h"
 10129              		.file 64 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/initializer_list"
 10130              		.file 65 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/predefined_ops.h"
 10131              		.file 66 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/ext/new_allocator.h"
 10132              		.file 67 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/ext/alloc_traits.h"
 10133              		.file 68 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdlib.h"
 10134              		.file 69 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/stdlib.h"
 10135              		.file 70 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/math.h"
 10136              		.file 71 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/math.h"
 10137              		.file 72 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/string.h"
 10138              		.file 73 "fibre-cpp/include/fibre/cpp_utils.hpp"
 10139              		.file 74 "fibre-cpp/include/fibre/callback.hpp"
 10140              		.file 75 "Board/v3/Inc/board.h"
 10141              		.file 76 "./MotorControl/motor.hpp"
 10142              		.file 77 "MotorControl/axis.hpp"
 10143              		.file 78 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/pstl/execution_defs.h"
 10144              		.file 79 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/wchar.h"
 10145              		.file 80 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/locale.h"
 10146              		.file 81 "MotorControl/low_level.h"
 10147              		.file 82 "ThirdParty/FreeRTOS/Source/CMSIS_RTOS/cmsis_os.h"
 10148              		.file 83 "<built-in>"
ARM GAS  /tmp/cc5nV8qb.s 			page 391


DEFINED SYMBOLS
                            *ABS*:0000000000000000 encoder.cpp
     /tmp/cc5nV8qb.s:20     .text._ZNKSt18bad_variant_access4whatEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:26     .text._ZNKSt18bad_variant_access4whatEv:0000000000000000 _ZNKSt18bad_variant_access4whatEv
.ARM.exidx.text._ZNKSt18bad_variant_access4whatEv:0000000000000000 $d
     /tmp/cc5nV8qb.s:48     .text._ZL8get_gpioj:0000000000000000 $t
     /tmp/cc5nV8qb.s:53     .text._ZL8get_gpioj:0000000000000000 _ZL8get_gpioj
     /tmp/cc5nV8qb.s:92     .text._ZL8get_gpioj:000000000000001c $d
    .ARM.exidx.text._ZL8get_gpioj:0000000000000000 $d
     /tmp/cc5nV8qb.s:99     .text._ZN7Encoder16set_linear_countEl:0000000000000000 $t
     /tmp/cc5nV8qb.s:105    .text._ZN7Encoder16set_linear_countEl:0000000000000000 _ZN7Encoder16set_linear_countEl
.ARM.exidx.text._ZN7Encoder16set_linear_countEl:0000000000000000 $d
     /tmp/cc5nV8qb.s:209    .text._ZL11decode_hallhPl:0000000000000000 $t
     /tmp/cc5nV8qb.s:214    .text._ZL11decode_hallhPl:0000000000000000 _ZL11decode_hallhPl
     /tmp/cc5nV8qb.s:231    .text._ZL11decode_hallhPl:000000000000000a $d
     /tmp/cc5nV8qb.s:237    .text._ZL11decode_hallhPl:0000000000000010 $t
.ARM.exidx.text._ZL11decode_hallhPl:0000000000000000 $d
     /tmp/cc5nV8qb.s:308    .text._ZNSt8functionIFbbEEC2IZN7Encoder29run_hall_polarity_calibrationEvEUlbE_vvEET_:0000000000000000 $t
     /tmp/cc5nV8qb.s:313    .text._ZNSt8functionIFbbEEC2IZN7Encoder29run_hall_polarity_calibrationEvEUlbE_vvEET_:0000000000000000 _ZNSt8functionIFbbEEC2IZN7Encoder29run_hall_polarity_calibrationEvEUlbE_vvEET_
     /tmp/cc5nV8qb.s:386    .text._ZNSt8functionIFbbEEC2IZN7Encoder29run_hall_polarity_calibrationEvEUlbE_vvEET_:0000000000000010 $d
     /tmp/cc5nV8qb.s:484    .text._ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E9_M_invokeERKSt9_Any_dataOb:0000000000000000 _ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E9_M_invokeERKSt9_Any_dataOb
     /tmp/cc5nV8qb.s:605    .text._ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation:0000000000000000 _ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation
.ARM.exidx.text._ZNSt8functionIFbbEEC2IZN7Encoder29run_hall_polarity_calibrationEvEUlbE_vvEET_:0000000000000000 $d
     /tmp/cc5nV8qb.s:313    .text._ZNSt8functionIFbbEEC2IZN7Encoder29run_hall_polarity_calibrationEvEUlbE_vvEET_:0000000000000000 _ZNSt8functionIFbbEEC1IZN7Encoder29run_hall_polarity_calibrationEvEUlbE_vvEET_
     /tmp/cc5nV8qb.s:395    .text._ZNSt8functionIFbbEEC2IZN7Encoder26run_hall_phase_calibrationEvEUlbE_vvEET_:0000000000000000 $t
     /tmp/cc5nV8qb.s:400    .text._ZNSt8functionIFbbEEC2IZN7Encoder26run_hall_phase_calibrationEvEUlbE_vvEET_:0000000000000000 _ZNSt8functionIFbbEEC2IZN7Encoder26run_hall_phase_calibrationEvEUlbE_vvEET_
     /tmp/cc5nV8qb.s:470    .text._ZNSt8functionIFbbEEC2IZN7Encoder26run_hall_phase_calibrationEvEUlbE_vvEET_:0000000000000010 $d
     /tmp/cc5nV8qb.s:545    .text._ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E9_M_invokeERKSt9_Any_dataOb:0000000000000000 _ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E9_M_invokeERKSt9_Any_dataOb
     /tmp/cc5nV8qb.s:760    .text._ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation:0000000000000000 _ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation
.ARM.exidx.text._ZNSt8functionIFbbEEC2IZN7Encoder26run_hall_phase_calibrationEvEUlbE_vvEET_:0000000000000000 $d
     /tmp/cc5nV8qb.s:400    .text._ZNSt8functionIFbbEEC2IZN7Encoder26run_hall_phase_calibrationEvEUlbE_vvEET_:0000000000000000 _ZNSt8functionIFbbEEC1IZN7Encoder26run_hall_phase_calibrationEvEUlbE_vvEET_
     /tmp/cc5nV8qb.s:479    .text._ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E9_M_invokeERKSt9_Any_dataOb:0000000000000000 $t
.ARM.exidx.text._ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E9_M_invokeERKSt9_Any_dataOb:0000000000000000 $d
     /tmp/cc5nV8qb.s:540    .text._ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E9_M_invokeERKSt9_Any_dataOb:0000000000000000 $t
.ARM.exidx.text._ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E9_M_invokeERKSt9_Any_dataOb:0000000000000000 $d
     /tmp/cc5nV8qb.s:600    .text._ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation:0000000000000000 $t
     /tmp/cc5nV8qb.s:630    .text._ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation:0000000000000010 $d
     /tmp/cc5nV8qb.s:634    .text._ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation:0000000000000014 $t
     /tmp/cc5nV8qb.s:746    .text._ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation:0000000000000030 $d
.ARM.exidx.text._ZNSt17_Function_handlerIFbbEZN7Encoder29run_hall_polarity_calibrationEvEUlbE_E10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation:0000000000000000 $d
     /tmp/cc5nV8qb.s:755    .text._ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation:0000000000000000 $t
     /tmp/cc5nV8qb.s:785    .text._ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation:0000000000000010 $d
     /tmp/cc5nV8qb.s:789    .text._ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation:0000000000000014 $t
     /tmp/cc5nV8qb.s:901    .text._ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation:0000000000000030 $d
.ARM.exidx.text._ZNSt17_Function_handlerIFbbEZN7Encoder26run_hall_phase_calibrationEvEUlbE_E10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation:0000000000000000 $d
     /tmp/cc5nV8qb.s:910    .text._ZNSt18bad_variant_accessD2Ev:0000000000000000 $t
     /tmp/cc5nV8qb.s:916    .text._ZNSt18bad_variant_accessD2Ev:0000000000000000 _ZNSt18bad_variant_accessD2Ev
     /tmp/cc5nV8qb.s:946    .text._ZNSt18bad_variant_accessD2Ev:0000000000000010 $d
     /tmp/cc5nV8qb.s:9999   .rodata._ZTVSt18bad_variant_access:0000000000000000 _ZTVSt18bad_variant_access
.ARM.exidx.text._ZNSt18bad_variant_accessD2Ev:0000000000000000 $d
     /tmp/cc5nV8qb.s:916    .text._ZNSt18bad_variant_accessD2Ev:0000000000000000 _ZNSt18bad_variant_accessD1Ev
     /tmp/cc5nV8qb.s:955    .text._ZNSt18bad_variant_accessD0Ev:0000000000000000 $t
     /tmp/cc5nV8qb.s:961    .text._ZNSt18bad_variant_accessD0Ev:0000000000000000 _ZNSt18bad_variant_accessD0Ev
     /tmp/cc5nV8qb.s:999    .text._ZNSt18bad_variant_accessD0Ev:0000000000000018 $d
.ARM.exidx.text._ZNSt18bad_variant_accessD0Ev:0000000000000000 $d
     /tmp/cc5nV8qb.s:1006   .text._ZNSt14_Function_baseD2Ev:0000000000000000 $t
     /tmp/cc5nV8qb.s:1012   .text._ZNSt14_Function_baseD2Ev:0000000000000000 _ZNSt14_Function_baseD2Ev
ARM GAS  /tmp/cc5nV8qb.s 			page 392


.ARM.extab.text._ZNSt14_Function_baseD2Ev:0000000000000000 $d
.ARM.exidx.text._ZNSt14_Function_baseD2Ev:0000000000000000 $d
     /tmp/cc5nV8qb.s:1012   .text._ZNSt14_Function_baseD2Ev:0000000000000000 _ZNSt14_Function_baseD1Ev
     /tmp/cc5nV8qb.s:1065   .text._ZSt26__throw_bad_variant_accessPKc:0000000000000000 $t
     /tmp/cc5nV8qb.s:1071   .text._ZSt26__throw_bad_variant_accessPKc:0000000000000000 _ZSt26__throw_bad_variant_accessPKc
     /tmp/cc5nV8qb.s:1125   .text._ZSt26__throw_bad_variant_accessPKc:000000000000001c $d
     /tmp/cc5nV8qb.s:9973   .rodata._ZTISt18bad_variant_access:0000000000000000 _ZTISt18bad_variant_access
.ARM.exidx.text._ZSt26__throw_bad_variant_accessPKc:0000000000000000 $d
     /tmp/cc5nV8qb.s:1134   .rodata._ZSt26__throw_bad_variant_accessb.str1.4:0000000000000000 $d
     /tmp/cc5nV8qb.s:1141   .text._ZSt26__throw_bad_variant_accessb:0000000000000000 $t
     /tmp/cc5nV8qb.s:1147   .text._ZSt26__throw_bad_variant_accessb:0000000000000000 _ZSt26__throw_bad_variant_accessb
     /tmp/cc5nV8qb.s:1182   .text._ZSt26__throw_bad_variant_accessb:0000000000000010 $d
.ARM.extab.text._ZSt26__throw_bad_variant_accessb:0000000000000000 $d
.ARM.exidx.text._ZSt26__throw_bad_variant_accessb:0000000000000000 $d
     /tmp/cc5nV8qb.s:1189   .text._ZoRRN10ODriveIntf8AxisIntf5ErrorES1_:0000000000000000 $t
     /tmp/cc5nV8qb.s:1195   .text._ZoRRN10ODriveIntf8AxisIntf5ErrorES1_:0000000000000000 _ZoRRN10ODriveIntf8AxisIntf5ErrorES1_
.ARM.exidx.text._ZoRRN10ODriveIntf8AxisIntf5ErrorES1_:0000000000000000 $d
     /tmp/cc5nV8qb.s:1220   .text._ZanN10ODriveIntf11EncoderIntf5ErrorES1_:0000000000000000 $t
     /tmp/cc5nV8qb.s:1226   .text._ZanN10ODriveIntf11EncoderIntf5ErrorES1_:0000000000000000 _ZanN10ODriveIntf11EncoderIntf5ErrorES1_
.ARM.exidx.text._ZanN10ODriveIntf11EncoderIntf5ErrorES1_:0000000000000000 $d
     /tmp/cc5nV8qb.s:1247   .text._ZoRRN10ODriveIntf11EncoderIntf5ErrorES1_:0000000000000000 $t
     /tmp/cc5nV8qb.s:1253   .text._ZoRRN10ODriveIntf11EncoderIntf5ErrorES1_:0000000000000000 _ZoRRN10ODriveIntf11EncoderIntf5ErrorES1_
.ARM.exidx.text._ZoRRN10ODriveIntf11EncoderIntf5ErrorES1_:0000000000000000 $d
     /tmp/cc5nV8qb.s:1277   .text._ZN7EncoderC2EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter:0000000000000000 $t
     /tmp/cc5nV8qb.s:1283   .text._ZN7EncoderC2EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter:0000000000000000 _ZN7EncoderC2EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter
     /tmp/cc5nV8qb.s:1567   .text._ZN7EncoderC2EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter:0000000000000198 $d
     /tmp/cc5nV8qb.s:10010  .rodata._ZTVN10ODriveIntf11EncoderIntfE:0000000000000000 _ZTVN10ODriveIntf11EncoderIntfE
     /tmp/cc5nV8qb.s:10029  .rodata._ZN7Encoder18hall_edge_defaultsE:0000000000000000 _ZN7Encoder18hall_edge_defaultsE
.ARM.exidx.text._ZN7EncoderC2EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter:0000000000000000 $d
     /tmp/cc5nV8qb.s:1283   .text._ZN7EncoderC2EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter:0000000000000000 _ZN7EncoderC1EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter
     /tmp/cc5nV8qb.s:1583   .text._ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE:0000000000000000 $t
     /tmp/cc5nV8qb.s:1589   .text._ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE:0000000000000000 _ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE
.ARM.exidx.text._ZN7Encoder9set_errorEN10ODriveIntf11EncoderIntf5ErrorE:0000000000000000 $d
     /tmp/cc5nV8qb.s:1634   .text._ZN7Encoder9do_checksEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:1640   .text._ZN7Encoder9do_checksEv:0000000000000000 _ZN7Encoder9do_checksEv
.ARM.exidx.text._ZN7Encoder9do_checksEv:0000000000000000 $d
     /tmp/cc5nV8qb.s:1663   .text._ZN7Encoder17set_idx_subscribeEb:0000000000000000 $t
     /tmp/cc5nV8qb.s:1669   .text._ZN7Encoder17set_idx_subscribeEb:0000000000000000 _ZN7Encoder17set_idx_subscribeEb
     /tmp/cc5nV8qb.s:1746   .text._ZN7Encoder17set_idx_subscribeEb:0000000000000040 $d
     /tmp/cc5nV8qb.s:2255   .text._ZL20enc_index_cb_wrapperPv:0000000000000000 _ZL20enc_index_cb_wrapperPv
.ARM.exidx.text._ZN7Encoder17set_idx_subscribeEb:0000000000000000 $d
     /tmp/cc5nV8qb.s:1753   .text._ZN7Encoder16update_pll_gainsEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:1759   .text._ZN7Encoder16update_pll_gainsEv:0000000000000000 _ZN7Encoder16update_pll_gainsEv
     /tmp/cc5nV8qb.s:1809   .text._ZN7Encoder16update_pll_gainsEv:0000000000000040 $d
.ARM.exidx.text._ZN7Encoder16update_pll_gainsEv:0000000000000000 $d
     /tmp/cc5nV8qb.s:1816   .text._ZN7Encoder12apply_configEN10ODriveIntf9MotorIntf9MotorTypeE:0000000000000000 $t
     /tmp/cc5nV8qb.s:1822   .text._ZN7Encoder12apply_configEN10ODriveIntf9MotorIntf9MotorTypeE:0000000000000000 _ZN7Encoder12apply_configEN10ODriveIntf9MotorIntf9MotorTypeE
.ARM.exidx.text._ZN7Encoder12apply_configEN10ODriveIntf9MotorIntf9MotorTypeE:0000000000000000 $d
     /tmp/cc5nV8qb.s:1901   .text._ZN7Encoder20check_pre_calibratedEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:1907   .text._ZN7Encoder20check_pre_calibratedEv:0000000000000000 _ZN7Encoder20check_pre_calibratedEv
.ARM.exidx.text._ZN7Encoder20check_pre_calibratedEv:0000000000000000 $d
     /tmp/cc5nV8qb.s:1956   .text._ZN7Encoder18set_circular_countElb:0000000000000000 $t
     /tmp/cc5nV8qb.s:1962   .text._ZN7Encoder18set_circular_countElb:0000000000000000 _ZN7Encoder18set_circular_countElb
.ARM.exidx.text._ZN7Encoder18set_circular_countElb:0000000000000000 $d
     /tmp/cc5nV8qb.s:2143   .text._ZN7Encoder12enc_index_cbEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:2149   .text._ZN7Encoder12enc_index_cbEv:0000000000000000 _ZN7Encoder12enc_index_cbEv
.ARM.exidx.text._ZN7Encoder12enc_index_cbEv:0000000000000000 $d
ARM GAS  /tmp/cc5nV8qb.s 			page 393


     /tmp/cc5nV8qb.s:2250   .text._ZL20enc_index_cb_wrapperPv:0000000000000000 $t
.ARM.extab.text._ZL20enc_index_cb_wrapperPv:0000000000000000 $d
.ARM.exidx.text._ZL20enc_index_cb_wrapperPv:0000000000000000 $d
     /tmp/cc5nV8qb.s:2281   .text._ZN7Encoder16run_index_searchEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:2287   .text._ZN7Encoder16run_index_searchEv:0000000000000000 _ZN7Encoder16run_index_searchEv
.ARM.extab.text._ZN7Encoder16run_index_searchEv:0000000000000000 $d
.ARM.exidx.text._ZN7Encoder16run_index_searchEv:0000000000000000 $d
     /tmp/cc5nV8qb.s:2435   .text._ZN7Encoder18run_direction_findEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:2441   .text._ZN7Encoder18run_direction_findEv:0000000000000000 _ZN7Encoder18run_direction_findEv
.ARM.extab.text._ZN7Encoder18run_direction_findEv:0000000000000000 $d
.ARM.exidx.text._ZN7Encoder18run_direction_findEv:0000000000000000 $d
     /tmp/cc5nV8qb.s:2644   .text._ZN7Encoder29run_hall_polarity_calibrationEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:2650   .text._ZN7Encoder29run_hall_polarity_calibrationEv:0000000000000000 _ZN7Encoder29run_hall_polarity_calibrationEv
.ARM.extab.text._ZN7Encoder29run_hall_polarity_calibrationEv:0000000000000000 $d
.ARM.exidx.text._ZN7Encoder29run_hall_polarity_calibrationEv:0000000000000000 $d
     /tmp/cc5nV8qb.s:3268   .text._ZN7Encoder26run_hall_phase_calibrationEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:3274   .text._ZN7Encoder26run_hall_phase_calibrationEv:0000000000000000 _ZN7Encoder26run_hall_phase_calibrationEv
     /tmp/cc5nV8qb.s:3936   .text._ZN7Encoder26run_hall_phase_calibrationEv:00000000000001b0 $d
.ARM.extab.text._ZN7Encoder26run_hall_phase_calibrationEv:0000000000000000 $d
.ARM.exidx.text._ZN7Encoder26run_hall_phase_calibrationEv:0000000000000000 $d
     /tmp/cc5nV8qb.s:3965   .text._ZN7Encoder17read_sampled_gpioE9Stm32Gpio:0000000000000000 $t
     /tmp/cc5nV8qb.s:3971   .text._ZN7Encoder17read_sampled_gpioE9Stm32Gpio:0000000000000000 _ZN7Encoder17read_sampled_gpioE9Stm32Gpio
     /tmp/cc5nV8qb.s:4045   .text._ZN7Encoder17read_sampled_gpioE9Stm32Gpio:000000000000003c $d
     /tmp/cc5nV8qb.s:10020  .rodata._ZN7Encoder15ports_to_sampleE:0000000000000000 _ZN7Encoder15ports_to_sampleE
.ARM.exidx.text._ZN7Encoder17read_sampled_gpioE9Stm32Gpio:0000000000000000 $d
     /tmp/cc5nV8qb.s:4052   .text._ZN7Encoder19decode_hall_samplesEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:4058   .text._ZN7Encoder19decode_hall_samplesEv:0000000000000000 _ZN7Encoder19decode_hall_samplesEv
.ARM.exidx.text._ZN7Encoder19decode_hall_samplesEv:0000000000000000 $d
     /tmp/cc5nV8qb.s:4134   .text._ZN7Encoder25abs_spi_start_transactionEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:4140   .text._ZN7Encoder25abs_spi_start_transactionEv:0000000000000000 _ZN7Encoder25abs_spi_start_transactionEv
     /tmp/cc5nV8qb.s:4234   .text._ZN7Encoder25abs_spi_start_transactionEv:0000000000000064 $d
     /tmp/cc5nV8qb.s:4690   .text._ZZN7Encoder25abs_spi_start_transactionEvENUlPvbE_4_FUNES0_b:0000000000000000 _ZZN7Encoder25abs_spi_start_transactionEvENUlPvbE_4_FUNES0_b
.ARM.exidx.text._ZN7Encoder25abs_spi_start_transactionEv:0000000000000000 $d
     /tmp/cc5nV8qb.s:4241   .text._ZN7Encoder10sample_nowEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:4247   .text._ZN7Encoder10sample_nowEv:0000000000000000 _ZN7Encoder10sample_nowEv
     /tmp/cc5nV8qb.s:4410   .text._ZN7Encoder10sample_nowEv:00000000000000a4 $d
.ARM.extab.text._ZN7Encoder10sample_nowEv:0000000000000000 $d
.ARM.exidx.text._ZN7Encoder10sample_nowEv:0000000000000000 $d
     /tmp/cc5nV8qb.s:4416   .text._Z10ams_parityt:0000000000000000 $t
     /tmp/cc5nV8qb.s:4422   .text._Z10ams_parityt:0000000000000000 _Z10ams_parityt
  .ARM.exidx.text._Z10ams_parityt:0000000000000000 $d
     /tmp/cc5nV8qb.s:4459   .text._Z10cui_parityt:0000000000000000 $t
     /tmp/cc5nV8qb.s:4465   .text._Z10cui_parityt:0000000000000000 _Z10cui_parityt
  .ARM.exidx.text._Z10cui_parityt:0000000000000000 $d
     /tmp/cc5nV8qb.s:4501   .text._ZN7Encoder10abs_spi_cbEb:0000000000000000 $t
     /tmp/cc5nV8qb.s:4507   .text._ZN7Encoder10abs_spi_cbEb:0000000000000000 _ZN7Encoder10abs_spi_cbEb
     /tmp/cc5nV8qb.s:4538   .text._ZN7Encoder10abs_spi_cbEb:0000000000000016 $d
.ARM.exidx.text._ZN7Encoder10abs_spi_cbEb:0000000000000000 $d
     /tmp/cc5nV8qb.s:4685   .text._ZZN7Encoder25abs_spi_start_transactionEvENUlPvbE_4_FUNES0_b:0000000000000000 $t
.ARM.extab.text._ZZN7Encoder25abs_spi_start_transactionEvENUlPvbE_4_FUNES0_b:0000000000000000 $d
.ARM.exidx.text._ZZN7Encoder25abs_spi_start_transactionEvENUlPvbE_4_FUNES0_b:0000000000000000 $d
     /tmp/cc5nV8qb.s:4722   .text._ZN7Encoder19abs_spi_cs_pin_initEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:4728   .text._ZN7Encoder19abs_spi_cs_pin_initEv:0000000000000000 _ZN7Encoder19abs_spi_cs_pin_initEv
.ARM.exidx.text._ZN7Encoder19abs_spi_cs_pin_initEv:0000000000000000 $d
     /tmp/cc5nV8qb.s:4803   .text._ZN7Encoder5setupEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:4809   .text._ZN7Encoder5setupEv:0000000000000000 _ZN7Encoder5setupEv
.ARM.exidx.text._ZN7Encoder5setupEv:0000000000000000 $d
ARM GAS  /tmp/cc5nV8qb.s 			page 394


     /tmp/cc5nV8qb.s:4926   .text._ZN7Encoder10hall_modelEf:0000000000000000 $t
     /tmp/cc5nV8qb.s:4932   .text._ZN7Encoder10hall_modelEf:0000000000000000 _ZN7Encoder10hall_modelEf
.ARM.exidx.text._ZN7Encoder10hall_modelEf:0000000000000000 $d
     /tmp/cc5nV8qb.s:5228   .text._ZN7Encoder6updateEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:5234   .text._ZN7Encoder6updateEv:0000000000000000 _ZN7Encoder6updateEv
     /tmp/cc5nV8qb.s:6508   .text._ZN7Encoder6updateEv:00000000000003e8 $d
     /tmp/cc5nV8qb.s:6522   .text._ZN7Encoder6updateEv:0000000000000404 $t
     /tmp/cc5nV8qb.s:7127   .text._ZN7Encoder6updateEv:00000000000005f0 $d
.ARM.extab.text._ZN7Encoder6updateEv:0000000000000000 $d
.ARM.exidx.text._ZN7Encoder6updateEv:0000000000000000 $d
     /tmp/cc5nV8qb.s:7142   .text._ZSt28__variant_construct_by_indexILj2ESt7variantIJSt4pairIffEPS2_P10OutputPortIS2_EEEJRS6_EEvRT0_DpOT1_:0000000000000000 $t
     /tmp/cc5nV8qb.s:7148   .text._ZSt28__variant_construct_by_indexILj2ESt7variantIJSt4pairIffEPS2_P10OutputPortIS2_EEEJRS6_EEvRT0_DpOT1_:0000000000000000 _ZSt28__variant_construct_by_indexILj2ESt7variantIJSt4pairIffEPS2_P10OutputPortIS2_EEEJRS6_EEvRT0_DpOT1_
.ARM.exidx.text._ZSt28__variant_construct_by_indexILj2ESt7variantIJSt4pairIffEPS2_P10OutputPortIS2_EEEJRS6_EEvRT0_DpOT1_:0000000000000000 $d
     /tmp/cc5nV8qb.s:7198   .text._ZSt28__variant_construct_by_indexILj2ESt7variantIJfPfP10OutputPortIfEEEJRS4_EEvRT0_DpOT1_:0000000000000000 $t
     /tmp/cc5nV8qb.s:7204   .text._ZSt28__variant_construct_by_indexILj2ESt7variantIJfPfP10OutputPortIfEEEJRS4_EEvRT0_DpOT1_:0000000000000000 _ZSt28__variant_construct_by_indexILj2ESt7variantIJfPfP10OutputPortIfEEEJRS4_EEvRT0_DpOT1_
.ARM.exidx.text._ZSt28__variant_construct_by_indexILj2ESt7variantIJfPfP10OutputPortIfEEEJRS4_EEvRT0_DpOT1_:0000000000000000 $d
     /tmp/cc5nV8qb.s:7255   .text._ZN7Encoder22run_offset_calibrationEv:0000000000000000 $t
     /tmp/cc5nV8qb.s:7261   .text._ZN7Encoder22run_offset_calibrationEv:0000000000000000 _ZN7Encoder22run_offset_calibrationEv
     /tmp/cc5nV8qb.s:9224   .text._ZN7Encoder22run_offset_calibrationEv:00000000000003b4 $d
     /tmp/cc5nV8qb.s:9234   .text._ZN7Encoder22run_offset_calibrationEv:00000000000003c4 $t
.ARM.extab.text._ZN7Encoder22run_offset_calibrationEv:0000000000000000 $d
.ARM.exidx.text._ZN7Encoder22run_offset_calibrationEv:0000000000000000 $d
     /tmp/cc5nV8qb.s:9966   .rodata._ZTSSt18bad_variant_access:0000000000000000 _ZTSSt18bad_variant_access
     /tmp/cc5nV8qb.s:9963   .rodata._ZTSSt18bad_variant_access:0000000000000000 $d
     /tmp/cc5nV8qb.s:9970   .rodata._ZTISt18bad_variant_access:0000000000000000 $d
     /tmp/cc5nV8qb.s:9982   .rodata._ZTSN10ODriveIntf11EncoderIntfE:0000000000000000 _ZTSN10ODriveIntf11EncoderIntfE
     /tmp/cc5nV8qb.s:9979   .rodata._ZTSN10ODriveIntf11EncoderIntfE:0000000000000000 $d
     /tmp/cc5nV8qb.s:9989   .rodata._ZTIN10ODriveIntf11EncoderIntfE:0000000000000000 _ZTIN10ODriveIntf11EncoderIntfE
     /tmp/cc5nV8qb.s:9986   .rodata._ZTIN10ODriveIntf11EncoderIntfE:0000000000000000 $d
     /tmp/cc5nV8qb.s:10064  .rodata._ZTS7Encoder:0000000000000000 _ZTS7Encoder
     /tmp/cc5nV8qb.s:10040  .rodata._ZTI7Encoder:0000000000000000 _ZTI7Encoder
     /tmp/cc5nV8qb.s:9996   .rodata._ZTVSt18bad_variant_access:0000000000000000 $d
     /tmp/cc5nV8qb.s:10007  .rodata._ZTVN10ODriveIntf11EncoderIntfE:0000000000000000 $d
     /tmp/cc5nV8qb.s:10083  .rodata._ZTV7Encoder:0000000000000000 _ZTV7Encoder
     /tmp/cc5nV8qb.s:10017  .rodata._ZN7Encoder15ports_to_sampleE:0000000000000000 $d
     /tmp/cc5nV8qb.s:10026  .rodata._ZN7Encoder18hall_edge_defaultsE:0000000000000000 $d
     /tmp/cc5nV8qb.s:10037  .rodata._ZTI7Encoder:0000000000000000 $d
     /tmp/cc5nV8qb.s:10045  .rodata._ZTIZN7Encoder26run_hall_phase_calibrationEvEUlbE_:0000000000000000 $d
     /tmp/cc5nV8qb.s:10049  .rodata._ZTIZN7Encoder26run_hall_phase_calibrationEvEUlbE_:0000000000000000 _ZTIZN7Encoder26run_hall_phase_calibrationEvEUlbE_
     /tmp/cc5nV8qb.s:10070  .rodata._ZTSZN7Encoder26run_hall_phase_calibrationEvEUlbE_:0000000000000000 _ZTSZN7Encoder26run_hall_phase_calibrationEvEUlbE_
     /tmp/cc5nV8qb.s:10053  .rodata._ZTIZN7Encoder29run_hall_polarity_calibrationEvEUlbE_:0000000000000000 $d
     /tmp/cc5nV8qb.s:10057  .rodata._ZTIZN7Encoder29run_hall_polarity_calibrationEvEUlbE_:0000000000000000 _ZTIZN7Encoder29run_hall_polarity_calibrationEvEUlbE_
     /tmp/cc5nV8qb.s:10076  .rodata._ZTSZN7Encoder29run_hall_polarity_calibrationEvEUlbE_:0000000000000000 _ZTSZN7Encoder29run_hall_polarity_calibrationEvEUlbE_
     /tmp/cc5nV8qb.s:10061  .rodata._ZTS7Encoder:0000000000000000 $d
     /tmp/cc5nV8qb.s:10067  .rodata._ZTSZN7Encoder26run_hall_phase_calibrationEvEUlbE_:0000000000000000 $d
     /tmp/cc5nV8qb.s:10073  .rodata._ZTSZN7Encoder29run_hall_polarity_calibrationEvEUlbE_:0000000000000000 $d
     /tmp/cc5nV8qb.s:10079  .rodata._ZTV7Encoder:0000000000000000 $d
     /tmp/cc5nV8qb.s:4543   .text._ZN7Encoder10abs_spi_cbEb:000000000000001b $d
     /tmp/cc5nV8qb.s:4543   .text._ZN7Encoder10abs_spi_cbEb:000000000000001c $t
                           .group:0000000000000000 _ZNSt18bad_variant_accessD5Ev
                           .group:0000000000000000 _ZNSt14_Function_baseD5Ev

UNDEFINED SYMBOLS
gpios
_ZNSt9exceptionD2Ev
_ZdlPvj
__gxx_personality_v0
ARM GAS  /tmp/cc5nV8qb.s 			page 395


__cxa_allocate_exception
__cxa_throw
_ZTVSt9exception
__aeabi_unwind_cpp_pr0
__aeabi_unwind_cpp_pr1
_ZN9Stm32Gpio9subscribeEbbPFvPvES0_
_ZN9Stm32Gpio11unsubscribeEv
odrv
_ZN4Axis15run_lockin_spinERKNS_14LockinConfig_tEbSt8functionIFbbEE
__cxa_end_cleanup
_ZN15Stm32SpiArbiter12acquire_taskEPNS_7SpiTaskE
_ZN15Stm32SpiArbiter14transfer_asyncEPNS_7SpiTaskE
get_adc_relative_voltage
_ZN15Stm32SpiArbiter12release_taskEPNS_7SpiTaskE
_ZN9Stm32Gpio6configEmmm
HAL_GPIO_WritePin
HAL_TIM_Encoder_Start
floorf
_Z10fast_atan2ff
__aeabi_ldivmod
_ZN4Axis26wait_for_control_iterationEv
_ZN5Motor3armEP15PhaseControlLawILj3EE
osDelay
_ZN5Motor6disarmEPb
_ZTVN10__cxxabiv120__si_class_type_infoE
_ZTISt9exception
_ZTVN10__cxxabiv117__class_type_infoE
__cxa_pure_virtual
