ARM GAS  /tmp/ccysU9ly.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"board.cpp"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.cpu_enter_critical,"axG",%progbits,_ZN10Stm32Timer24start_synchronously_implILj3EJL
  20              		.align	1
  21              		.p2align 2,,3
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	cpu_enter_critical:
  27              		.fnstart
  28              	.LFB1066:
  29              		.file 1 "./Drivers/STM32/stm32_system.h"
   1:./Drivers/STM32/stm32_system.h **** #ifndef __STM32_SYSTEM_H
   2:./Drivers/STM32/stm32_system.h **** #define __STM32_SYSTEM_H
   3:./Drivers/STM32/stm32_system.h **** 
   4:./Drivers/STM32/stm32_system.h **** #if defined(STM32F405xx)
   5:./Drivers/STM32/stm32_system.h **** #include <stm32f405xx.h>
   6:./Drivers/STM32/stm32_system.h **** #elif defined(STM32F722xx)
   7:./Drivers/STM32/stm32_system.h **** #include <stm32f722xx.h>
   8:./Drivers/STM32/stm32_system.h **** #else
   9:./Drivers/STM32/stm32_system.h **** #error "unknown STM32 microcontroller"
  10:./Drivers/STM32/stm32_system.h **** #endif
  11:./Drivers/STM32/stm32_system.h **** 
  12:./Drivers/STM32/stm32_system.h **** // C/C++ definitions
  13:./Drivers/STM32/stm32_system.h **** 
  14:./Drivers/STM32/stm32_system.h **** #ifdef __cplusplus
  15:./Drivers/STM32/stm32_system.h **** extern "C" {
  16:./Drivers/STM32/stm32_system.h **** #endif
  17:./Drivers/STM32/stm32_system.h **** 
  18:./Drivers/STM32/stm32_system.h **** // Uncomment the following line to sacrifice 1kB of RAM for the ability to
  19:./Drivers/STM32/stm32_system.h **** // monitor the number of times each interrupt fires.
  20:./Drivers/STM32/stm32_system.h **** //#define ENABLE_IRQ_COUNTER
  21:./Drivers/STM32/stm32_system.h **** 
  22:./Drivers/STM32/stm32_system.h **** #ifdef ENABLE_IRQ_COUNTER
  23:./Drivers/STM32/stm32_system.h **** extern uint32_t irq_counters[];
  24:./Drivers/STM32/stm32_system.h **** #define COUNT_IRQ(irqn) (++irq_counters[irqn + 14])
  25:./Drivers/STM32/stm32_system.h **** #define GET_IRQ_COUNTER(irqn) irq_counters[irqn + 14]
  26:./Drivers/STM32/stm32_system.h **** #else
  27:./Drivers/STM32/stm32_system.h **** #define COUNT_IRQ(irqn) ((void)0)
  28:./Drivers/STM32/stm32_system.h **** #define GET_IRQ_COUNTER(irqn) 0
  29:./Drivers/STM32/stm32_system.h **** #endif
ARM GAS  /tmp/ccysU9ly.s 			page 2


  30:./Drivers/STM32/stm32_system.h **** 
  31:./Drivers/STM32/stm32_system.h **** static inline uint32_t cpu_enter_critical() {
  30              		.loc 1 31 45 view -0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 0
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  34              		@ link register save eliminated.
  32:./Drivers/STM32/stm32_system.h ****     uint32_t primask = __get_PRIMASK();
  35              		.loc 1 32 5 view .LVU1
  36              	.LBB428:
  37              	.LBI428:
  38              		.file 2 "ThirdParty/CMSIS/Include/cmsis_gcc.h"
   1:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /*
   8:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  *
  10:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  *
  12:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  *
  16:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  *
  18:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
  24:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
  25:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
  28:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
  34:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  38:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
  39:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  43:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  /tmp/ccysU9ly.s 			page 3


  46:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  49:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  55:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  58:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  61:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  64:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  67:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  70:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  78:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  86:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
  94:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 102:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
ARM GAS  /tmp/ccysU9ly.s 			page 4


 103:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 110:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 113:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 116:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 117:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 118:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:ThirdParty/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   @{
 122:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 123:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 124:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 125:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 129:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 131:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 133:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 134:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 135:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 136:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:ThirdParty/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 140:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 142:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 144:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 145:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 146:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 147:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 148:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 151:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 153:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 155:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 158:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 159:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccysU9ly.s 			page 5


 160:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 162:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 166:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 168:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 170:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 173:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 174:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 175:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 176:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 177:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 181:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 183:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 185:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 186:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 187:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 189:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 193:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 195:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 197:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 198:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 199:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 200:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 201:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 204:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 205:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 207:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 209:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 212:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 213:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 214:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 215:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 216:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
ARM GAS  /tmp/ccysU9ly.s 			page 6


 217:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 219:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 221:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 223:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 226:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 227:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 228:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 229:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 233:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 235:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 237:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 240:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 241:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 242:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 243:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 247:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 249:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 251:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 254:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 255:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 256:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 258:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 261:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 262:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 264:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 266:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 269:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 270:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 271:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 272:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 273:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
ARM GAS  /tmp/ccysU9ly.s 			page 7


 274:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 277:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 279:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 281:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 282:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 283:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 285:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 289:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 291:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 293:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 294:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 295:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 296:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 297:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 301:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 303:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 305:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 308:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 309:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 310:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 312:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 315:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 316:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 318:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 319:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 320:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 323:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 324:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 325:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 326:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 327:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccysU9ly.s 			page 8


 331:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 333:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 335:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 336:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 337:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 339:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 343:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 345:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 347:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 348:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 349:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 350:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 352:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 356:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 358:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 360:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 363:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 364:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 365:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 366:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 370:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 372:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 374:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 375:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 376:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 377:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 378:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 381:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 382:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
  39              		.loc 2 382 31 view .LVU2
  40              	.LBB429:
 383:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 384:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
  41              		.loc 2 384 3 view .LVU3
ARM GAS  /tmp/ccysU9ly.s 			page 9


 385:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 386:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  42              		.loc 2 386 3 view .LVU4
  43              		.syntax unified
  44              	@ 386 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
  45 0000 EFF31080 		MRS r0, primask
  46              	@ 0 "" 2
  47              	.LVL0:
 387:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
  48              		.loc 2 387 3 view .LVU5
  49              		.loc 2 387 3 is_stmt 0 view .LVU6
  50              		.thumb
  51              		.syntax unified
  52              	.LBE429:
  53              	.LBE428:
  33:./Drivers/STM32/stm32_system.h ****     __disable_irq();
  54              		.loc 1 33 5 is_stmt 1 view .LVU7
  55              	.LBB430:
  56              	.LBI430:
 140:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
  57              		.loc 2 140 27 view .LVU8
  58              	.LBB431:
 142:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
  59              		.loc 2 142 3 view .LVU9
  60              		.syntax unified
  61              	@ 142 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
  62 0004 72B6     		cpsid i
  63              	@ 0 "" 2
  64              		.thumb
  65              		.syntax unified
  66              	.LBE431:
  67              	.LBE430:
  34:./Drivers/STM32/stm32_system.h ****     return primask;
  68              		.loc 1 34 5 view .LVU10
  35:./Drivers/STM32/stm32_system.h **** }
  69              		.loc 1 35 1 is_stmt 0 view .LVU11
  70 0006 7047     		bx	lr
  71              		.cfi_endproc
  72              	.LFE1066:
  73              		.cantunwind
  74              		.fnend
  76              		.section	.text.cpu_exit_critical,"axG",%progbits,_ZN10Stm32Timer24start_synchronously_implILj3EJLj
  77              		.align	1
  78              		.p2align 2,,3
  79              		.syntax unified
  80              		.thumb
  81              		.thumb_func
  83              	cpu_exit_critical:
  84              		.fnstart
  85              	.LVL1:
  86              	.LFB1067:
  36:./Drivers/STM32/stm32_system.h **** 
  37:./Drivers/STM32/stm32_system.h **** static inline void cpu_exit_critical(uint32_t priority_mask) {
  87              		.loc 1 37 62 is_stmt 1 view -0
  88              		.cfi_startproc
  89              		@ args = 0, pretend = 0, frame = 0
  90              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccysU9ly.s 			page 10


  91              		@ link register save eliminated.
  38:./Drivers/STM32/stm32_system.h ****     __set_PRIMASK(priority_mask);
  92              		.loc 1 38 5 view .LVU13
  93              	.LBB432:
  94              	.LBI432:
 388:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 389:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 390:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 391:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 393:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 397:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 399:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 401:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 404:ThirdParty/CMSIS/Include/cmsis_gcc.h **** #endif
 405:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 406:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 407:ThirdParty/CMSIS/Include/cmsis_gcc.h **** /**
 408:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:ThirdParty/CMSIS/Include/cmsis_gcc.h ****  */
 412:ThirdParty/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
  95              		.loc 2 412 27 view .LVU14
  96              	.LBB433:
 413:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 414:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  97              		.loc 2 414 3 view .LVU15
  98              		.syntax unified
  99              	@ 414 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 100 0000 80F31088 		MSR primask, r0
 101              	@ 0 "" 2
 102              	.LVL2:
 103              		.loc 2 414 3 is_stmt 0 view .LVU16
 104              		.thumb
 105              		.syntax unified
 106              	.LBE433:
 107              	.LBE432:
  39:./Drivers/STM32/stm32_system.h **** }
 108              		.loc 1 39 1 view .LVU17
 109 0004 7047     		bx	lr
 110              		.cfi_endproc
 111              	.LFE1067:
 112              		.cantunwind
 113              		.fnend
 115 0006 00BF     		.section	.text._ZL8get_gpioj,"ax",%progbits
 116              		.align	1
 117              		.p2align 2,,3
 118              		.syntax unified
 119              		.thumb
ARM GAS  /tmp/ccysU9ly.s 			page 11


 120              		.thumb_func
 122              	_ZL8get_gpioj:
 123              		.fnstart
 124              	.LVL3:
 125              	.LFB5151:
 126              		.file 3 "MotorControl/odrive_main.h"
   1:MotorControl/odrive_main.h **** #ifndef __ODRIVE_MAIN_H
   2:MotorControl/odrive_main.h **** #define __ODRIVE_MAIN_H
   3:MotorControl/odrive_main.h **** 
   4:MotorControl/odrive_main.h **** // Hardware configuration
   5:MotorControl/odrive_main.h **** #include <board.h>
   6:MotorControl/odrive_main.h **** 
   7:MotorControl/odrive_main.h **** #ifdef __cplusplus
   8:MotorControl/odrive_main.h **** #include <communication/interface_usb.h>
   9:MotorControl/odrive_main.h **** #include <communication/interface_i2c.h>
  10:MotorControl/odrive_main.h **** #include <communication/interface_uart.h>
  11:MotorControl/odrive_main.h **** #include <task_timer.hpp>
  12:MotorControl/odrive_main.h **** extern "C" {
  13:MotorControl/odrive_main.h **** #endif
  14:MotorControl/odrive_main.h **** 
  15:MotorControl/odrive_main.h **** // OS includes
  16:MotorControl/odrive_main.h **** #include <cmsis_os.h>
  17:MotorControl/odrive_main.h **** 
  18:MotorControl/odrive_main.h **** // extern const float elec_rad_per_enc;
  19:MotorControl/odrive_main.h **** extern uint32_t _reboot_cookie;
  20:MotorControl/odrive_main.h **** 
  21:MotorControl/odrive_main.h **** extern uint64_t serial_number;
  22:MotorControl/odrive_main.h **** extern char serial_number_str[13];
  23:MotorControl/odrive_main.h **** 
  24:MotorControl/odrive_main.h **** #ifdef __cplusplus
  25:MotorControl/odrive_main.h **** }
  26:MotorControl/odrive_main.h **** 
  27:MotorControl/odrive_main.h **** typedef struct {
  28:MotorControl/odrive_main.h ****     bool fully_booted;
  29:MotorControl/odrive_main.h ****     uint32_t uptime; // [ms]
  30:MotorControl/odrive_main.h ****     uint32_t min_heap_space; // FreeRTOS heap [Bytes]
  31:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_axis; // minimum remaining space since startup [Bytes]
  32:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_usb;
  33:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_uart;
  34:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_startup;
  35:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_can;
  36:MotorControl/odrive_main.h ****     uint32_t max_stack_usage_analog;
  37:MotorControl/odrive_main.h **** 
  38:MotorControl/odrive_main.h ****     uint32_t stack_size_axis;
  39:MotorControl/odrive_main.h ****     uint32_t stack_size_usb;
  40:MotorControl/odrive_main.h ****     uint32_t stack_size_uart;
  41:MotorControl/odrive_main.h ****     uint32_t stack_size_startup;
  42:MotorControl/odrive_main.h ****     uint32_t stack_size_can;
  43:MotorControl/odrive_main.h ****     uint32_t stack_size_analog;
  44:MotorControl/odrive_main.h **** 
  45:MotorControl/odrive_main.h ****     int32_t prio_axis;
  46:MotorControl/odrive_main.h ****     int32_t prio_usb;
  47:MotorControl/odrive_main.h ****     int32_t prio_uart;
  48:MotorControl/odrive_main.h ****     int32_t prio_startup;
  49:MotorControl/odrive_main.h ****     int32_t prio_can;
  50:MotorControl/odrive_main.h ****     int32_t prio_analog;
  51:MotorControl/odrive_main.h **** 
ARM GAS  /tmp/ccysU9ly.s 			page 12


  52:MotorControl/odrive_main.h ****     USBStats_t& usb = usb_stats_;
  53:MotorControl/odrive_main.h ****     I2CStats_t& i2c = i2c_stats_;
  54:MotorControl/odrive_main.h **** } SystemStats_t;
  55:MotorControl/odrive_main.h **** 
  56:MotorControl/odrive_main.h **** struct PWMMapping_t {
  57:MotorControl/odrive_main.h ****     endpoint_ref_t endpoint = {0, 0};
  58:MotorControl/odrive_main.h ****     float min = 0;
  59:MotorControl/odrive_main.h ****     float max = 0;
  60:MotorControl/odrive_main.h **** };
  61:MotorControl/odrive_main.h **** 
  62:MotorControl/odrive_main.h **** // @brief general user configurable board configuration
  63:MotorControl/odrive_main.h **** struct BoardConfig_t {
  64:MotorControl/odrive_main.h ****     ODriveIntf::GpioMode gpio_modes[GPIO_COUNT] = {
  65:MotorControl/odrive_main.h ****         DEFAULT_GPIO_MODES
  66:MotorControl/odrive_main.h ****     };
  67:MotorControl/odrive_main.h **** 
  68:MotorControl/odrive_main.h ****     bool enable_uart_a = true;
  69:MotorControl/odrive_main.h ****     bool enable_uart_b = false;
  70:MotorControl/odrive_main.h ****     bool enable_uart_c = false;
  71:MotorControl/odrive_main.h ****     uint32_t uart_a_baudrate = 115200;
  72:MotorControl/odrive_main.h ****     uint32_t uart_b_baudrate = 115200;
  73:MotorControl/odrive_main.h ****     uint32_t uart_c_baudrate = 115200;
  74:MotorControl/odrive_main.h ****     bool enable_can_a = true;
  75:MotorControl/odrive_main.h ****     bool enable_i2c_a = false;
  76:MotorControl/odrive_main.h ****     ODriveIntf::StreamProtocolType uart0_protocol = ODriveIntf::STREAM_PROTOCOL_TYPE_ASCII_AND_STDO
  77:MotorControl/odrive_main.h ****     ODriveIntf::StreamProtocolType uart1_protocol = ODriveIntf::STREAM_PROTOCOL_TYPE_ASCII_AND_STDO
  78:MotorControl/odrive_main.h ****     ODriveIntf::StreamProtocolType uart2_protocol = ODriveIntf::STREAM_PROTOCOL_TYPE_ASCII_AND_STDO
  79:MotorControl/odrive_main.h ****     ODriveIntf::StreamProtocolType usb_cdc_protocol = ODriveIntf::STREAM_PROTOCOL_TYPE_ASCII_AND_ST
  80:MotorControl/odrive_main.h ****     float max_regen_current = 0.0f;
  81:MotorControl/odrive_main.h ****     float brake_resistance = DEFAULT_BRAKE_RESISTANCE;
  82:MotorControl/odrive_main.h ****     bool enable_brake_resistor = false;
  83:MotorControl/odrive_main.h ****     float dc_bus_undervoltage_trip_level = DEFAULT_MIN_DC_VOLTAGE;      //<! [V] minimum voltage be
  84:MotorControl/odrive_main.h ****     float dc_bus_overvoltage_trip_level = 1.07f * HW_VERSION_VOLTAGE;   //<! [V] maximum voltage ab
  85:MotorControl/odrive_main.h ****                                                                         //<! This protects against 
  86:MotorControl/odrive_main.h ****                                                                         //<! the brake power if the
  87:MotorControl/odrive_main.h ****                                                                         //<! The default is 26V for
  88:MotorControl/odrive_main.h **** 
  89:MotorControl/odrive_main.h ****     /**
  90:MotorControl/odrive_main.h ****      * If enabled, if the measured DC voltage exceeds `dc_bus_overvoltage_ramp_start`,
  91:MotorControl/odrive_main.h ****      * the ODrive will sink more power than usual into the the brake resistor
  92:MotorControl/odrive_main.h ****      * in an attempt to bring the voltage down again.
  93:MotorControl/odrive_main.h ****      * 
  94:MotorControl/odrive_main.h ****      * The brake duty cycle is increased by the following amount:
  95:MotorControl/odrive_main.h ****      *  vbus_voltage == dc_bus_overvoltage_ramp_start  =>  brake_duty_cycle += 0%
  96:MotorControl/odrive_main.h ****      *  vbus_voltage == dc_bus_overvoltage_ramp_end  =>  brake_duty_cycle += 100%
  97:MotorControl/odrive_main.h ****      * 
  98:MotorControl/odrive_main.h ****      * Remarks:
  99:MotorControl/odrive_main.h ****      *  - This feature is active even when all motors are disarmed.
 100:MotorControl/odrive_main.h ****      *  - This feature is disabled if `brake_resistance` is non-positive.
 101:MotorControl/odrive_main.h ****      */
 102:MotorControl/odrive_main.h ****     bool enable_dc_bus_overvoltage_ramp = false;
 103:MotorControl/odrive_main.h ****     float dc_bus_overvoltage_ramp_start = 1.07f * HW_VERSION_VOLTAGE; //!< See `enable_dc_bus_overv
 104:MotorControl/odrive_main.h ****                                                                       //!< Do not set this lower th
 105:MotorControl/odrive_main.h ****                                                                       //!< unless you like fried br
 106:MotorControl/odrive_main.h ****     float dc_bus_overvoltage_ramp_end = 1.07f * HW_VERSION_VOLTAGE; //!< See `enable_dc_bus_overvol
 107:MotorControl/odrive_main.h ****                                                                     //!< Must be larger than `dc_bu
 108:MotorControl/odrive_main.h ****                                                                     //!< otherwise the ramp feature
ARM GAS  /tmp/ccysU9ly.s 			page 13


 109:MotorControl/odrive_main.h **** 
 110:MotorControl/odrive_main.h ****     float dc_max_positive_current = INFINITY; // Max current [A] the power supply can source
 111:MotorControl/odrive_main.h ****     float dc_max_negative_current = -0.01f; // Max current [A] the power supply can sink. You most 
 112:MotorControl/odrive_main.h ****     uint32_t error_gpio_pin = DEFAULT_ERROR_PIN;
 113:MotorControl/odrive_main.h ****     PWMMapping_t pwm_mappings[4];
 114:MotorControl/odrive_main.h ****     PWMMapping_t analog_mappings[GPIO_COUNT];
 115:MotorControl/odrive_main.h **** };
 116:MotorControl/odrive_main.h **** 
 117:MotorControl/odrive_main.h **** struct TaskTimes {
 118:MotorControl/odrive_main.h ****     TaskTimer sampling;
 119:MotorControl/odrive_main.h ****     TaskTimer control_loop_misc;
 120:MotorControl/odrive_main.h ****     TaskTimer control_loop_checks;
 121:MotorControl/odrive_main.h ****     TaskTimer dc_calib_wait;
 122:MotorControl/odrive_main.h **** };
 123:MotorControl/odrive_main.h **** 
 124:MotorControl/odrive_main.h **** 
 125:MotorControl/odrive_main.h **** // Forward Declarations
 126:MotorControl/odrive_main.h **** class Axis;
 127:MotorControl/odrive_main.h **** class Motor;
 128:MotorControl/odrive_main.h **** 
 129:MotorControl/odrive_main.h **** // TODO: move
 130:MotorControl/odrive_main.h **** // this is technically not thread-safe but practically it might be
 131:MotorControl/odrive_main.h **** #define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE) \
 132:MotorControl/odrive_main.h **** inline ENUMTYPE operator | (ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<std:
 133:MotorControl/odrive_main.h **** inline ENUMTYPE operator & (ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<std:
 134:MotorControl/odrive_main.h **** inline ENUMTYPE operator ^ (ENUMTYPE a, ENUMTYPE b) { return static_cast<ENUMTYPE>(static_cast<std:
 135:MotorControl/odrive_main.h **** inline ENUMTYPE &operator |= (ENUMTYPE &a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinter
 136:MotorControl/odrive_main.h **** inline ENUMTYPE &operator &= (ENUMTYPE &a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinter
 137:MotorControl/odrive_main.h **** inline ENUMTYPE &operator ^= (ENUMTYPE &a, ENUMTYPE b) { return reinterpret_cast<ENUMTYPE&>(reinter
 138:MotorControl/odrive_main.h **** inline ENUMTYPE operator ~ (ENUMTYPE a) { return static_cast<ENUMTYPE>(~static_cast<std::underlying
 139:MotorControl/odrive_main.h **** 
 140:MotorControl/odrive_main.h **** #include "autogen/interfaces.hpp"
 141:MotorControl/odrive_main.h **** 
 142:MotorControl/odrive_main.h **** // ODrive specific includes
 143:MotorControl/odrive_main.h **** #include <utils.hpp>
 144:MotorControl/odrive_main.h **** #include <low_level.h>
 145:MotorControl/odrive_main.h **** #include <encoder.hpp>
 146:MotorControl/odrive_main.h **** #include <sensorless_estimator.hpp>
 147:MotorControl/odrive_main.h **** #include <controller.hpp>
 148:MotorControl/odrive_main.h **** #include <current_limiter.hpp>
 149:MotorControl/odrive_main.h **** #include <thermistor.hpp>
 150:MotorControl/odrive_main.h **** #include <trapTraj.hpp>
 151:MotorControl/odrive_main.h **** #include <endstop.hpp>
 152:MotorControl/odrive_main.h **** #include <mechanical_brake.hpp>
 153:MotorControl/odrive_main.h **** #include <axis.hpp>
 154:MotorControl/odrive_main.h **** #include <oscilloscope.hpp>
 155:MotorControl/odrive_main.h **** #include <communication/communication.h>
 156:MotorControl/odrive_main.h **** #include <communication/can/odrive_can.hpp>
 157:MotorControl/odrive_main.h **** 
 158:MotorControl/odrive_main.h **** // Defined in autogen/version.c based on git-derived version numbers
 159:MotorControl/odrive_main.h **** extern "C" {
 160:MotorControl/odrive_main.h **** extern const unsigned char fw_version_major_;
 161:MotorControl/odrive_main.h **** extern const unsigned char fw_version_minor_;
 162:MotorControl/odrive_main.h **** extern const unsigned char fw_version_revision_;
 163:MotorControl/odrive_main.h **** extern const unsigned char fw_version_unreleased_;
 164:MotorControl/odrive_main.h **** }
 165:MotorControl/odrive_main.h **** 
ARM GAS  /tmp/ccysU9ly.s 			page 14


 166:MotorControl/odrive_main.h **** static Stm32Gpio get_gpio(size_t gpio_num) {
 127              		.loc 3 166 44 is_stmt 1 view -0
 128              		.cfi_startproc
 129              		@ args = 0, pretend = 0, frame = 0
 130              		@ frame_needed = 0, uses_anonymous_args = 0
 131              		@ link register save eliminated.
 132              		.loc 3 166 44 is_stmt 0 view .LVU19
 133 0000 0346     		mov	r3, r0
 167:MotorControl/odrive_main.h ****     return (gpio_num < GPIO_COUNT) ? gpios[gpio_num] : GPIO_COUNT ? gpios[0] : Stm32Gpio::none;
 134              		.loc 3 167 5 is_stmt 1 view .LVU20
 135              		.loc 3 167 36 is_stmt 0 view .LVU21
 136 0002 1029     		cmp	r1, #16
 137 0004 07D8     		bhi	.L5
 138              		.loc 3 167 36 discriminator 1 view .LVU22
 139 0006 054A     		ldr	r2, .L6
 140 0008 02EBC101 		add	r1, r2, r1, lsl #3
 141              	.LVL4:
 142              	.L4:
 143              		.loc 3 167 91 discriminator 4 view .LVU23
 144 000c 03C9     		ldm	r1, {r0, r1}
 145              	.LVL5:
 146              		.loc 3 167 91 discriminator 4 view .LVU24
 147 000e 83E80300 		stm	r3, {r0, r1}
 168:MotorControl/odrive_main.h **** }
 148              		.loc 3 168 1 discriminator 4 view .LVU25
 149 0012 1846     		mov	r0, r3
 150 0014 7047     		bx	lr
 151              	.LVL6:
 152              	.L5:
 167:MotorControl/odrive_main.h ****     return (gpio_num < GPIO_COUNT) ? gpios[gpio_num] : GPIO_COUNT ? gpios[0] : Stm32Gpio::none;
 153              		.loc 3 167 36 view .LVU26
 154 0016 0149     		ldr	r1, .L6
 155              	.LVL7:
 167:MotorControl/odrive_main.h ****     return (gpio_num < GPIO_COUNT) ? gpios[gpio_num] : GPIO_COUNT ? gpios[0] : Stm32Gpio::none;
 156              		.loc 3 167 36 view .LVU27
 157 0018 F8E7     		b	.L4
 158              	.L7:
 159 001a 00BF     		.align	2
 160              	.L6:
 161 001c 00000000 		.word	.LANCHOR0
 162              		.cfi_endproc
 163              	.LFE5151:
 164              		.cantunwind
 165              		.fnend
 167              		.section	.text.__tcf_0,"ax",%progbits
 168              		.align	1
 169              		.p2align 2,,3
 170              		.syntax unified
 171              		.thumb
 172              		.thumb_func
 174              	__tcf_0:
 175              		.fnstart
 176              	.LFB6267:
 177              		.file 4 "Board/v3/board.cpp"
   1:Board/v3/board.cpp **** /*
   2:Board/v3/board.cpp **** * @brief Contains board specific variables and initialization functions
   3:Board/v3/board.cpp **** */
ARM GAS  /tmp/ccysU9ly.s 			page 15


   4:Board/v3/board.cpp **** 
   5:Board/v3/board.cpp **** #include <board.h>
   6:Board/v3/board.cpp **** 
   7:Board/v3/board.cpp **** #include <odrive_main.h>
   8:Board/v3/board.cpp **** #include <low_level.h>
   9:Board/v3/board.cpp **** 
  10:Board/v3/board.cpp **** #include <Drivers/STM32/stm32_timer.hpp>
  11:Board/v3/board.cpp **** 
  12:Board/v3/board.cpp **** #include <adc.h>
  13:Board/v3/board.cpp **** #include <dma.h>
  14:Board/v3/board.cpp **** #include <tim.h>
  15:Board/v3/board.cpp **** #include <usart.h>
  16:Board/v3/board.cpp **** #include <freertos_vars.h>
  17:Board/v3/board.cpp **** 
  18:Board/v3/board.cpp **** // this should technically be in task_timer.cpp but let's not make a one-line file
  19:Board/v3/board.cpp **** bool TaskTimer::enabled = false;
  20:Board/v3/board.cpp **** 
  21:Board/v3/board.cpp **** extern "C" void SystemClock_Config(void); // defined in main.c generated by CubeMX
  22:Board/v3/board.cpp **** 
  23:Board/v3/board.cpp **** #define ControlLoop_IRQHandler OTG_HS_IRQHandler
  24:Board/v3/board.cpp **** #define ControlLoop_IRQn OTG_HS_IRQn
  25:Board/v3/board.cpp **** 
  26:Board/v3/board.cpp **** // This array is placed at the very start of the ram (0x20000000) and will be
  27:Board/v3/board.cpp **** // used during manufacturing to test the struct that will go to the OTP before
  28:Board/v3/board.cpp **** // _actually_ putting anything into OTP. This avoids bulk-destroying STM32's if
  29:Board/v3/board.cpp **** // we introduce unintended breakage in our manufacturing scripts.
  30:Board/v3/board.cpp **** uint8_t __attribute__((section(".testdata"))) fake_otp[FLASH_OTP_END + 1 - FLASH_OTP_BASE] = {0, 0,
  31:Board/v3/board.cpp **** 
  32:Board/v3/board.cpp **** Stm32SpiArbiter spi3_arbiter{&hspi3};
  33:Board/v3/board.cpp **** Stm32SpiArbiter& ext_spi_arbiter = spi3_arbiter;
  34:Board/v3/board.cpp **** 
  35:Board/v3/board.cpp **** UART_HandleTypeDef* uart_a = &huart4;
  36:Board/v3/board.cpp **** UART_HandleTypeDef* uart_b = &huart2; // TODO: this could be supported in ODrive v3.6 (or similar) 
  37:Board/v3/board.cpp **** UART_HandleTypeDef* uart_c = nullptr;
  38:Board/v3/board.cpp **** 
  39:Board/v3/board.cpp **** Drv8301 m0_gate_driver{
  40:Board/v3/board.cpp ****     &spi3_arbiter,
  41:Board/v3/board.cpp ****     {M0_nCS_GPIO_Port, M0_nCS_Pin}, // nCS
  42:Board/v3/board.cpp ****     {}, // EN pin (shared between both motors, therefore we actuate it outside of the drv8301 drive
  43:Board/v3/board.cpp ****     {nFAULT_GPIO_Port, nFAULT_Pin} // nFAULT pin (shared between both motors)
  44:Board/v3/board.cpp **** };
  45:Board/v3/board.cpp **** 
  46:Board/v3/board.cpp **** Drv8301 m1_gate_driver{
  47:Board/v3/board.cpp ****     &spi3_arbiter,
  48:Board/v3/board.cpp ****     {M1_nCS_GPIO_Port, M1_nCS_Pin}, // nCS
  49:Board/v3/board.cpp ****     {}, // EN pin (shared between both motors, therefore we actuate it outside of the drv8301 drive
  50:Board/v3/board.cpp ****     {nFAULT_GPIO_Port, nFAULT_Pin} // nFAULT pin (shared between both motors)
  51:Board/v3/board.cpp **** };
  52:Board/v3/board.cpp **** 
  53:Board/v3/board.cpp **** const float fet_thermistor_poly_coeffs[] =
  54:Board/v3/board.cpp ****     {363.93910201f, -462.15369634f, 307.55129571f, -27.72569531f};
  55:Board/v3/board.cpp **** const size_t fet_thermistor_num_coeffs = sizeof(fet_thermistor_poly_coeffs)/sizeof(fet_thermistor_p
  56:Board/v3/board.cpp **** 
  57:Board/v3/board.cpp **** OnboardThermistorCurrentLimiter fet_thermistors[AXIS_COUNT] = {
 178              		.loc 4 57 33 is_stmt 1 view -0
 179              		.cfi_startproc
 180              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccysU9ly.s 			page 16


 181              		@ frame_needed = 0, uses_anonymous_args = 0
 182 0000 10B5     		push	{r4, lr}
 183              	.LCFI0:
 184              		.cfi_def_cfa_offset 8
 185              		.cfi_offset 4, -8
 186              		.cfi_offset 14, -4
 187              		.loc 4 57 33 is_stmt 0 view .LVU29
 188 0002 054C     		ldr	r4, .L13
 189 0004 04E0     		b	.L10
 190              	.L12:
 191              		.loc 4 57 33 discriminator 3 view .LVU30
 192 0006 54F8383D 		ldr	r3, [r4, #-56]!
 193 000a 1B68     		ldr	r3, [r3]
 194 000c 2046     		mov	r0, r4
 195 000e 9847     		blx	r3
 196              	.LVL8:
 197              	.L10:
 198              		.loc 4 57 33 discriminator 4 view .LVU31
 199 0010 024B     		ldr	r3, .L13+4
 200 0012 9C42     		cmp	r4, r3
 201 0014 F7D1     		bne	.L12
 202              		.loc 4 57 33 view .LVU32
 203 0016 10BD     		pop	{r4, pc}
 204              	.L14:
 205              		.align	2
 206              	.L13:
 207 0018 70000000 		.word	.LANCHOR1+112
 208 001c 00000000 		.word	.LANCHOR1
 209              		.cfi_endproc
 210              	.LFE6267:
 211              		.cantunwind
 212              		.fnend
 214              		.section	.text.__tcf_1,"ax",%progbits
 215              		.align	1
 216              		.p2align 2,,3
 217              		.syntax unified
 218              		.thumb
 219              		.thumb_func
 221              	__tcf_1:
 222              		.fnstart
 223              	.LFB6268:
  58:Board/v3/board.cpp ****     {
  59:Board/v3/board.cpp ****         15, // adc_channel
  60:Board/v3/board.cpp ****         &fet_thermistor_poly_coeffs[0], // coefficients
  61:Board/v3/board.cpp ****         fet_thermistor_num_coeffs // num_coeffs
  62:Board/v3/board.cpp ****     }, {
  63:Board/v3/board.cpp **** #if HW_VERSION_MAJOR == 3 && HW_VERSION_MINOR >= 3
  64:Board/v3/board.cpp ****         4, // adc_channel
  65:Board/v3/board.cpp **** #else
  66:Board/v3/board.cpp ****         1, // adc_channel
  67:Board/v3/board.cpp **** #endif
  68:Board/v3/board.cpp ****         &fet_thermistor_poly_coeffs[0], // coefficients
  69:Board/v3/board.cpp ****         fet_thermistor_num_coeffs // num_coeffs
  70:Board/v3/board.cpp ****     }
  71:Board/v3/board.cpp **** };
  72:Board/v3/board.cpp **** 
  73:Board/v3/board.cpp **** OffboardThermistorCurrentLimiter motor_thermistors[AXIS_COUNT];
ARM GAS  /tmp/ccysU9ly.s 			page 17


 224              		.loc 4 73 34 is_stmt 1 view -0
 225              		.cfi_startproc
 226              		@ args = 0, pretend = 0, frame = 0
 227              		@ frame_needed = 0, uses_anonymous_args = 0
 228 0000 10B5     		push	{r4, lr}
 229              	.LCFI1:
 230              		.cfi_def_cfa_offset 8
 231              		.cfi_offset 4, -8
 232              		.cfi_offset 14, -4
 233              		.loc 4 73 34 is_stmt 0 view .LVU34
 234 0002 054C     		ldr	r4, .L20
 235 0004 04E0     		b	.L17
 236              	.L19:
 237              		.loc 4 73 34 discriminator 3 view .LVU35
 238 0006 54F8503D 		ldr	r3, [r4, #-80]!
 239 000a 1B68     		ldr	r3, [r3]
 240 000c 2046     		mov	r0, r4
 241 000e 9847     		blx	r3
 242              	.LVL9:
 243              	.L17:
 244              		.loc 4 73 34 discriminator 4 view .LVU36
 245 0010 024B     		ldr	r3, .L20+4
 246 0012 9C42     		cmp	r4, r3
 247 0014 F7D1     		bne	.L19
 248              		.loc 4 73 34 view .LVU37
 249 0016 10BD     		pop	{r4, pc}
 250              	.L21:
 251              		.align	2
 252              	.L20:
 253 0018 A0000000 		.word	.LANCHOR2+160
 254 001c 00000000 		.word	.LANCHOR2
 255              		.cfi_endproc
 256              	.LFE6268:
 257              		.cantunwind
 258              		.fnend
 260              		.section	.text._Z41__static_initialization_and_destruction_0ii,"ax",%progbits
 261              		.align	1
 262              		.p2align 2,,3
 263              		.syntax unified
 264              		.thumb
 265              		.thumb_func
 267              	_Z41__static_initialization_and_destruction_0ii:
 268              		.fnstart
 269              	.LVL10:
 270              	.LFB6266:
  74:Board/v3/board.cpp **** 
  75:Board/v3/board.cpp **** Motor motors[AXIS_COUNT] = {
  76:Board/v3/board.cpp ****     {
  77:Board/v3/board.cpp ****         &htim1, // timer
  78:Board/v3/board.cpp ****         0b110, // current_sensor_mask
  79:Board/v3/board.cpp ****         1.0f / SHUNT_RESISTANCE, // shunt_conductance [S]
  80:Board/v3/board.cpp ****         m0_gate_driver, // gate_driver
  81:Board/v3/board.cpp ****         m0_gate_driver, // opamp
  82:Board/v3/board.cpp ****         fet_thermistors[0],
  83:Board/v3/board.cpp ****         motor_thermistors[0]
  84:Board/v3/board.cpp ****     },
  85:Board/v3/board.cpp ****     {
ARM GAS  /tmp/ccysU9ly.s 			page 18


  86:Board/v3/board.cpp ****         &htim8, // timer
  87:Board/v3/board.cpp ****         0b110, // current_sensor_mask
  88:Board/v3/board.cpp ****         1.0f / SHUNT_RESISTANCE, // shunt_conductance [S]
  89:Board/v3/board.cpp ****         m1_gate_driver, // gate_driver
  90:Board/v3/board.cpp ****         m1_gate_driver, // opamp
  91:Board/v3/board.cpp ****         fet_thermistors[1],
  92:Board/v3/board.cpp ****         motor_thermistors[1]
  93:Board/v3/board.cpp ****     }
  94:Board/v3/board.cpp **** };
  95:Board/v3/board.cpp **** 
  96:Board/v3/board.cpp **** Encoder encoders[AXIS_COUNT] = {
  97:Board/v3/board.cpp ****     {
  98:Board/v3/board.cpp ****         &htim3, // timer
  99:Board/v3/board.cpp ****         {M0_ENC_Z_GPIO_Port, M0_ENC_Z_Pin}, // index_gpio
 100:Board/v3/board.cpp ****         {M0_ENC_A_GPIO_Port, M0_ENC_A_Pin}, // hallA_gpio
 101:Board/v3/board.cpp ****         {M0_ENC_B_GPIO_Port, M0_ENC_B_Pin}, // hallB_gpio
 102:Board/v3/board.cpp ****         {M0_ENC_Z_GPIO_Port, M0_ENC_Z_Pin}, // hallC_gpio
 103:Board/v3/board.cpp ****         &spi3_arbiter // spi_arbiter
 104:Board/v3/board.cpp ****     },
 105:Board/v3/board.cpp ****     {
 106:Board/v3/board.cpp ****         &htim4, // timer
 107:Board/v3/board.cpp ****         {M1_ENC_Z_GPIO_Port, M1_ENC_Z_Pin}, // index_gpio
 108:Board/v3/board.cpp ****         {M1_ENC_A_GPIO_Port, M1_ENC_A_Pin}, // hallA_gpio
 109:Board/v3/board.cpp ****         {M1_ENC_B_GPIO_Port, M1_ENC_B_Pin}, // hallB_gpio
 110:Board/v3/board.cpp ****         {M1_ENC_Z_GPIO_Port, M1_ENC_Z_Pin}, // hallC_gpio
 111:Board/v3/board.cpp ****         &spi3_arbiter // spi_arbiter
 112:Board/v3/board.cpp ****     }
 113:Board/v3/board.cpp **** };
 114:Board/v3/board.cpp **** 
 115:Board/v3/board.cpp **** // TODO: this has no hardware dependency and should be allocated depending on config
 116:Board/v3/board.cpp **** Endstop endstops[2 * AXIS_COUNT];
 117:Board/v3/board.cpp **** MechanicalBrake mechanical_brakes[AXIS_COUNT];
 118:Board/v3/board.cpp **** 
 119:Board/v3/board.cpp **** SensorlessEstimator sensorless_estimators[AXIS_COUNT];
 120:Board/v3/board.cpp **** Controller controllers[AXIS_COUNT];
 121:Board/v3/board.cpp **** TrapezoidalTrajectory trap[AXIS_COUNT];
 122:Board/v3/board.cpp **** 
 123:Board/v3/board.cpp **** std::array<Axis, AXIS_COUNT> axes{{
 124:Board/v3/board.cpp ****     {
 125:Board/v3/board.cpp ****         0, // axis_num
 126:Board/v3/board.cpp ****         1, // step_gpio_pin
 127:Board/v3/board.cpp ****         2, // dir_gpio_pin
 128:Board/v3/board.cpp ****         (osPriority)(osPriorityHigh + (osPriority)1), // thread_priority
 129:Board/v3/board.cpp ****         encoders[0], // encoder
 130:Board/v3/board.cpp ****         sensorless_estimators[0], // sensorless_estimator
 131:Board/v3/board.cpp ****         controllers[0], // controller
 132:Board/v3/board.cpp ****         motors[0], // motor
 133:Board/v3/board.cpp ****         trap[0], // trap
 134:Board/v3/board.cpp ****         endstops[0], endstops[1], // min_endstop, max_endstop
 135:Board/v3/board.cpp ****         mechanical_brakes[0], // mechanical brake
 136:Board/v3/board.cpp ****     },
 137:Board/v3/board.cpp ****     {
 138:Board/v3/board.cpp ****         1, // axis_num
 139:Board/v3/board.cpp **** #if HW_VERSION_MAJOR == 3 && HW_VERSION_MINOR >= 5
 140:Board/v3/board.cpp ****         7, // step_gpio_pin
 141:Board/v3/board.cpp ****         8, // dir_gpio_pin
 142:Board/v3/board.cpp **** #else
ARM GAS  /tmp/ccysU9ly.s 			page 19


 143:Board/v3/board.cpp ****         3, // step_gpio_pin
 144:Board/v3/board.cpp ****         4, // dir_gpio_pin
 145:Board/v3/board.cpp **** #endif
 146:Board/v3/board.cpp ****         osPriorityHigh, // thread_priority
 147:Board/v3/board.cpp ****         encoders[1], // encoder
 148:Board/v3/board.cpp ****         sensorless_estimators[1], // sensorless_estimator
 149:Board/v3/board.cpp ****         controllers[1], // controller
 150:Board/v3/board.cpp ****         motors[1], // motor
 151:Board/v3/board.cpp ****         trap[1], // trap
 152:Board/v3/board.cpp ****         endstops[2], endstops[3], // min_endstop, max_endstop
 153:Board/v3/board.cpp ****         mechanical_brakes[1], // mechanical brake
 154:Board/v3/board.cpp ****     },
 155:Board/v3/board.cpp **** }};
 156:Board/v3/board.cpp **** 
 157:Board/v3/board.cpp **** 
 158:Board/v3/board.cpp **** 
 159:Board/v3/board.cpp **** #if (HW_VERSION_MINOR == 1) || (HW_VERSION_MINOR == 2)
 160:Board/v3/board.cpp **** Stm32Gpio gpios[] = {
 161:Board/v3/board.cpp ****     {nullptr, 0}, // dummy GPIO0 so that PCB labels and software numbers match
 162:Board/v3/board.cpp **** 
 163:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_2}, // GPIO1
 164:Board/v3/board.cpp ****     {GPIOA, GPIO_PIN_5}, // GPIO2
 165:Board/v3/board.cpp ****     {GPIOA, GPIO_PIN_4}, // GPIO3
 166:Board/v3/board.cpp ****     {GPIOA, GPIO_PIN_3}, // GPIO4
 167:Board/v3/board.cpp ****     {nullptr, 0}, // GPIO5 (doesn't exist on this board)
 168:Board/v3/board.cpp ****     {nullptr, 0}, // GPIO6 (doesn't exist on this board)
 169:Board/v3/board.cpp ****     {nullptr, 0}, // GPIO7 (doesn't exist on this board)
 170:Board/v3/board.cpp ****     {nullptr, 0}, // GPIO8 (doesn't exist on this board)
 171:Board/v3/board.cpp **** 
 172:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_4}, // ENC0_A
 173:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_5}, // ENC0_B
 174:Board/v3/board.cpp ****     {GPIOA, GPIO_PIN_15}, // ENC0_Z
 175:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_6}, // ENC1_A
 176:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_7}, // ENC1_B
 177:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_3}, // ENC1_Z
 178:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_8}, // CAN_R
 179:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_9}, // CAN_D
 180:Board/v3/board.cpp **** };
 181:Board/v3/board.cpp **** #elif (HW_VERSION_MINOR == 3) || (HW_VERSION_MINOR == 4)
 182:Board/v3/board.cpp **** Stm32Gpio gpios[] = {
 183:Board/v3/board.cpp ****     {nullptr, 0}, // dummy GPIO0 so that PCB labels and software numbers match
 184:Board/v3/board.cpp **** 
 185:Board/v3/board.cpp ****     {GPIOA, GPIO_PIN_0}, // GPIO1
 186:Board/v3/board.cpp ****     {GPIOA, GPIO_PIN_1}, // GPIO2
 187:Board/v3/board.cpp ****     {GPIOA, GPIO_PIN_2}, // GPIO3
 188:Board/v3/board.cpp ****     {GPIOA, GPIO_PIN_3}, // GPIO4
 189:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_2}, // GPIO5
 190:Board/v3/board.cpp ****     {nullptr, 0}, // GPIO6 (doesn't exist on this board)
 191:Board/v3/board.cpp ****     {nullptr, 0}, // GPIO7 (doesn't exist on this board)
 192:Board/v3/board.cpp ****     {nullptr, 0}, // GPIO8 (doesn't exist on this board)
 193:Board/v3/board.cpp **** 
 194:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_4}, // ENC0_A
 195:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_5}, // ENC0_B
 196:Board/v3/board.cpp ****     {GPIOA, GPIO_PIN_15}, // ENC0_Z
 197:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_6}, // ENC1_A
 198:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_7}, // ENC1_B
 199:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_3}, // ENC1_Z
ARM GAS  /tmp/ccysU9ly.s 			page 20


 200:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_8}, // CAN_R
 201:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_9}, // CAN_D
 202:Board/v3/board.cpp **** };
 203:Board/v3/board.cpp **** #elif (HW_VERSION_MINOR == 5) || (HW_VERSION_MINOR == 6)
 204:Board/v3/board.cpp **** Stm32Gpio gpios[GPIO_COUNT] = {
 205:Board/v3/board.cpp ****     {nullptr, 0}, // dummy GPIO0 so that PCB labels and software numbers match
 206:Board/v3/board.cpp **** 
 207:Board/v3/board.cpp ****     {GPIOA, GPIO_PIN_0}, // GPIO1
 208:Board/v3/board.cpp ****     {GPIOA, GPIO_PIN_1}, // GPIO2
 209:Board/v3/board.cpp ****     {GPIOA, GPIO_PIN_2}, // GPIO3
 210:Board/v3/board.cpp ****     {GPIOA, GPIO_PIN_3}, // GPIO4
 211:Board/v3/board.cpp ****     {GPIOC, GPIO_PIN_4}, // GPIO5
 212:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_2}, // GPIO6
 213:Board/v3/board.cpp ****     {GPIOA, GPIO_PIN_15}, // GPIO7
 214:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_3}, // GPIO8
 215:Board/v3/board.cpp ****     
 216:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_4}, // ENC0_A
 217:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_5}, // ENC0_B
 218:Board/v3/board.cpp ****     {GPIOC, GPIO_PIN_9}, // ENC0_Z
 219:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_6}, // ENC1_A
 220:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_7}, // ENC1_B
 221:Board/v3/board.cpp ****     {GPIOC, GPIO_PIN_15}, // ENC1_Z
 222:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_8}, // CAN_R
 223:Board/v3/board.cpp ****     {GPIOB, GPIO_PIN_9}, // CAN_D
 224:Board/v3/board.cpp **** };
 225:Board/v3/board.cpp **** #else
 226:Board/v3/board.cpp **** #error "unknown GPIOs"
 227:Board/v3/board.cpp **** #endif
 228:Board/v3/board.cpp **** 
 229:Board/v3/board.cpp **** std::array<GpioFunction, 3> alternate_functions[GPIO_COUNT] = {
 230:Board/v3/board.cpp ****     /* GPIO0 (inexistent): */ {{}},
 231:Board/v3/board.cpp **** 
 232:Board/v3/board.cpp **** #if HW_VERSION_MINOR >= 3
 233:Board/v3/board.cpp ****     /* GPIO1: */ {{{ODrive::GPIO_MODE_UART_A, GPIO_AF8_UART4}, {ODrive::GPIO_MODE_PWM, GPIO_AF2_TIM
 234:Board/v3/board.cpp ****     /* GPIO2: */ {{{ODrive::GPIO_MODE_UART_A, GPIO_AF8_UART4}, {ODrive::GPIO_MODE_PWM, GPIO_AF2_TIM
 235:Board/v3/board.cpp ****     /* GPIO3: */ {{{ODrive::GPIO_MODE_UART_B, GPIO_AF7_USART2}, {ODrive::GPIO_MODE_PWM, GPIO_AF2_TI
 236:Board/v3/board.cpp **** #else
 237:Board/v3/board.cpp ****     /* GPIO1: */ {{}},
 238:Board/v3/board.cpp ****     /* GPIO2: */ {{}},
 239:Board/v3/board.cpp ****     /* GPIO3: */ {{}},
 240:Board/v3/board.cpp **** #endif
 241:Board/v3/board.cpp **** 
 242:Board/v3/board.cpp ****     /* GPIO4: */ {{{ODrive::GPIO_MODE_UART_B, GPIO_AF7_USART2}, {ODrive::GPIO_MODE_PWM, GPIO_AF2_TI
 243:Board/v3/board.cpp ****     /* GPIO5: */ {{}},
 244:Board/v3/board.cpp ****     /* GPIO6: */ {{}},
 245:Board/v3/board.cpp ****     /* GPIO7: */ {{}},
 246:Board/v3/board.cpp ****     /* GPIO8: */ {{}},
 247:Board/v3/board.cpp ****     /* ENC0_A: */ {{{ODrive::GPIO_MODE_ENC0, GPIO_AF2_TIM3}}},
 248:Board/v3/board.cpp ****     /* ENC0_B: */ {{{ODrive::GPIO_MODE_ENC0, GPIO_AF2_TIM3}}},
 249:Board/v3/board.cpp ****     /* ENC0_Z: */ {{}},
 250:Board/v3/board.cpp ****     /* ENC1_A: */ {{{ODrive::GPIO_MODE_I2C_A, GPIO_AF4_I2C1}, {ODrive::GPIO_MODE_ENC1, GPIO_AF2_TIM
 251:Board/v3/board.cpp ****     /* ENC1_B: */ {{{ODrive::GPIO_MODE_I2C_A, GPIO_AF4_I2C1}, {ODrive::GPIO_MODE_ENC1, GPIO_AF2_TIM
 252:Board/v3/board.cpp ****     /* ENC1_Z: */ {{}},
 253:Board/v3/board.cpp ****     /* CAN_R: */ {{{ODrive::GPIO_MODE_CAN_A, GPIO_AF9_CAN1}, {ODrive::GPIO_MODE_I2C_A, GPIO_AF4_I2C
 254:Board/v3/board.cpp ****     /* CAN_D: */ {{{ODrive::GPIO_MODE_CAN_A, GPIO_AF9_CAN1}, {ODrive::GPIO_MODE_I2C_A, GPIO_AF4_I2C
 255:Board/v3/board.cpp **** };
 256:Board/v3/board.cpp **** 
ARM GAS  /tmp/ccysU9ly.s 			page 21


 257:Board/v3/board.cpp **** #if HW_VERSION_MINOR <= 2
 258:Board/v3/board.cpp **** PwmInput pwm0_input{&htim5, {0, 0, 0, 4}}; // 0 means not in use
 259:Board/v3/board.cpp **** #else
 260:Board/v3/board.cpp **** PwmInput pwm0_input{&htim5, {1, 2, 3, 4}};
 261:Board/v3/board.cpp **** #endif
 262:Board/v3/board.cpp **** 
 263:Board/v3/board.cpp **** extern USBD_HandleTypeDef hUsbDeviceFS;
 264:Board/v3/board.cpp **** USBD_HandleTypeDef& usb_dev_handle = hUsbDeviceFS;
 265:Board/v3/board.cpp **** 
 266:Board/v3/board.cpp **** bool check_board_version(const uint8_t* otp_ptr) {
 267:Board/v3/board.cpp ****     return (otp_ptr[3] == HW_VERSION_MAJOR) &&
 268:Board/v3/board.cpp ****            (otp_ptr[4] == HW_VERSION_MINOR) &&
 269:Board/v3/board.cpp ****            (otp_ptr[5] == HW_VERSION_VOLTAGE);
 270:Board/v3/board.cpp **** }
 271:Board/v3/board.cpp **** 
 272:Board/v3/board.cpp **** void system_init() {
 273:Board/v3/board.cpp ****     // Reset of all peripherals, Initializes the Flash interface and the Systick.
 274:Board/v3/board.cpp ****     HAL_Init();
 275:Board/v3/board.cpp **** 
 276:Board/v3/board.cpp ****     // Configure the system clock
 277:Board/v3/board.cpp ****     SystemClock_Config();
 278:Board/v3/board.cpp **** 
 279:Board/v3/board.cpp ****     // If the OTP is pristine, use the fake-otp in RAM instead
 280:Board/v3/board.cpp ****     //! OTP  Flash 
 281:Board/v3/board.cpp ****     const uint8_t* otp_ptr = (const uint8_t*)FLASH_OTP_BASE;
 282:Board/v3/board.cpp ****     if (*otp_ptr == 0xff) {
 283:Board/v3/board.cpp ****         otp_ptr = fake_otp;
 284:Board/v3/board.cpp ****     }
 285:Board/v3/board.cpp **** 
 286:Board/v3/board.cpp ****     // Ensure that the board version for which this firmware is compiled matches
 287:Board/v3/board.cpp ****     // the board we're running on.
 288:Board/v3/board.cpp ****     if (!check_board_version(otp_ptr)) {
 289:Board/v3/board.cpp ****         for (;;);
 290:Board/v3/board.cpp ****     }
 291:Board/v3/board.cpp **** }
 292:Board/v3/board.cpp **** 
 293:Board/v3/board.cpp **** bool board_init() {
 294:Board/v3/board.cpp ****     // Initialize all configured peripherals
 295:Board/v3/board.cpp ****     MX_GPIO_Init();
 296:Board/v3/board.cpp ****     MX_DMA_Init();
 297:Board/v3/board.cpp ****     MX_ADC1_Init();
 298:Board/v3/board.cpp ****     MX_ADC2_Init();
 299:Board/v3/board.cpp ****     MX_TIM1_Init();
 300:Board/v3/board.cpp ****     MX_TIM8_Init();
 301:Board/v3/board.cpp ****     MX_TIM3_Init();
 302:Board/v3/board.cpp ****     MX_TIM4_Init();
 303:Board/v3/board.cpp ****     MX_SPI3_Init();
 304:Board/v3/board.cpp ****     MX_ADC3_Init();
 305:Board/v3/board.cpp ****     MX_TIM2_Init();
 306:Board/v3/board.cpp ****     MX_TIM5_Init();
 307:Board/v3/board.cpp ****     MX_TIM13_Init();
 308:Board/v3/board.cpp **** 
 309:Board/v3/board.cpp ****     // External interrupt lines are individually enabled in stm32_gpio.cpp
 310:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI0_IRQn, 1, 0);
 311:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI0_IRQn);
 312:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI1_IRQn, 1, 0);
 313:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI1_IRQn);
ARM GAS  /tmp/ccysU9ly.s 			page 22


 314:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI2_IRQn, 1, 0);
 315:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI2_IRQn);
 316:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI3_IRQn, 1, 0);
 317:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI3_IRQn);
 318:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI4_IRQn, 1, 0);
 319:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI4_IRQn);
 320:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI9_5_IRQn, 1, 0);
 321:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 322:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI15_10_IRQn, 1, 0);
 323:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 324:Board/v3/board.cpp **** 
 325:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(ControlLoop_IRQn, 5, 0);
 326:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(ControlLoop_IRQn);
 327:Board/v3/board.cpp **** 
 328:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(TIM8_UP_TIM13_IRQn, 0, 0);
 329:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);
 330:Board/v3/board.cpp **** 
 331:Board/v3/board.cpp ****     if (odrv.config_.enable_uart_a) {
 332:Board/v3/board.cpp ****         uart_a->Init.BaudRate = odrv.config_.uart_a_baudrate;
 333:Board/v3/board.cpp ****         MX_UART4_Init();
 334:Board/v3/board.cpp ****     }
 335:Board/v3/board.cpp **** 
 336:Board/v3/board.cpp ****     if (odrv.config_.enable_uart_b) {
 337:Board/v3/board.cpp ****         uart_b->Init.BaudRate = odrv.config_.uart_b_baudrate;
 338:Board/v3/board.cpp ****         MX_USART2_UART_Init();
 339:Board/v3/board.cpp ****     }
 340:Board/v3/board.cpp **** 
 341:Board/v3/board.cpp ****     if (odrv.config_.enable_i2c_a) {
 342:Board/v3/board.cpp ****         // Set up the direction GPIO as input
 343:Board/v3/board.cpp ****         get_gpio(3).config(GPIO_MODE_INPUT, GPIO_PULLUP);
 344:Board/v3/board.cpp ****         get_gpio(4).config(GPIO_MODE_INPUT, GPIO_PULLUP);
 345:Board/v3/board.cpp ****         get_gpio(5).config(GPIO_MODE_INPUT, GPIO_PULLUP);
 346:Board/v3/board.cpp **** 
 347:Board/v3/board.cpp ****         osDelay(1); // This has no effect but was here before.
 348:Board/v3/board.cpp ****         i2c_stats_.addr = (0xD << 3);
 349:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(3).read() ? 0x1 : 0;
 350:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(4).read() ? 0x2 : 0;
 351:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(5).read() ? 0x4 : 0;
 352:Board/v3/board.cpp ****         MX_I2C1_Init(i2c_stats_.addr);
 353:Board/v3/board.cpp ****     }
 354:Board/v3/board.cpp **** 
 355:Board/v3/board.cpp ****     if (odrv.config_.enable_can_a) {
 356:Board/v3/board.cpp ****         // The CAN initialization will (and must) init its own GPIOs before the
 357:Board/v3/board.cpp ****         // GPIO modes are initialized. Therefore we ensure that the later GPIO
 358:Board/v3/board.cpp ****         // mode initialization won't override the CAN mode.
 359:Board/v3/board.cpp ****         if (odrv.config_.gpio_modes[15] != ODriveIntf::GPIO_MODE_CAN_A || odrv.config_.gpio_modes[1
 360:Board/v3/board.cpp ****             odrv.misconfigured_ = true;
 361:Board/v3/board.cpp ****         }
 362:Board/v3/board.cpp ****     }
 363:Board/v3/board.cpp **** 
 364:Board/v3/board.cpp ****     // Ensure that debug halting of the core doesn't leave the motor PWM running
 365:Board/v3/board.cpp ****     __HAL_DBGMCU_FREEZE_TIM1();
 366:Board/v3/board.cpp ****     __HAL_DBGMCU_FREEZE_TIM8();
 367:Board/v3/board.cpp ****     __HAL_DBGMCU_FREEZE_TIM13();
 368:Board/v3/board.cpp **** 
 369:Board/v3/board.cpp ****     Stm32Gpio drv_enable_gpio = {EN_GATE_GPIO_Port, EN_GATE_Pin};
 370:Board/v3/board.cpp **** 
ARM GAS  /tmp/ccysU9ly.s 			page 23


 371:Board/v3/board.cpp ****     // Reset both DRV chips. The enable pin also controls the SPI interface, not
 372:Board/v3/board.cpp ****     // only the driver stages.
 373:Board/v3/board.cpp ****     drv_enable_gpio.write(false);
 374:Board/v3/board.cpp ****     delay_us(40); // mimumum pull-down time for full reset: 20us
 375:Board/v3/board.cpp ****     drv_enable_gpio.write(true);
 376:Board/v3/board.cpp ****     delay_us(20000); // mimumum pull-down time for full reset: 20us
 377:Board/v3/board.cpp **** 
 378:Board/v3/board.cpp ****     return true;
 379:Board/v3/board.cpp **** }
 380:Board/v3/board.cpp **** 
 381:Board/v3/board.cpp **** void start_timers() {
 382:Board/v3/board.cpp ****     CRITICAL_SECTION() {
 383:Board/v3/board.cpp ****         // Temporarily disable ADC triggers so they don't trigger as a side
 384:Board/v3/board.cpp ****         // effect of starting the timers.
 385:Board/v3/board.cpp ****         hadc1.Instance->CR2 &= ~(ADC_CR2_JEXTEN);
 386:Board/v3/board.cpp ****         hadc2.Instance->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_JEXTEN);
 387:Board/v3/board.cpp ****         hadc3.Instance->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_JEXTEN);
 388:Board/v3/board.cpp **** 
 389:Board/v3/board.cpp ****         /*
 390:Board/v3/board.cpp ****         * Synchronize TIM1, TIM8 and TIM13 such that:
 391:Board/v3/board.cpp ****         *  1. The triangle waveform of TIM1 leads the triangle waveform of TIM8 by a
 392:Board/v3/board.cpp ****         *     90 phase shift.
 393:Board/v3/board.cpp ****         *  2. Each TIM13 reload coincides with a TIM1 lower update event.
 394:Board/v3/board.cpp ****         */
 395:Board/v3/board.cpp ****         Stm32Timer::start_synchronously<3>(
 396:Board/v3/board.cpp ****             {&htim1, &htim8, &htim13},
 397:Board/v3/board.cpp ****             {TIM1_INIT_COUNT, 0, TIM1_INIT_COUNT / 2 /* TIM13 is on a clock that's only have as fas
 398:Board/v3/board.cpp ****         );
 399:Board/v3/board.cpp **** 
 400:Board/v3/board.cpp ****         hadc1.Instance->CR2 |= (ADC_EXTERNALTRIGINJECCONVEDGE_RISING);
 401:Board/v3/board.cpp ****         hadc2.Instance->CR2 |= (ADC_EXTERNALTRIGCONVEDGE_RISING | ADC_EXTERNALTRIGINJECCONVEDGE_RIS
 402:Board/v3/board.cpp ****         hadc3.Instance->CR2 |= (ADC_EXTERNALTRIGCONVEDGE_RISING | ADC_EXTERNALTRIGINJECCONVEDGE_RIS
 403:Board/v3/board.cpp **** 
 404:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc1, ADC_FLAG_JEOC);
 405:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_JEOC);
 406:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_JEOC);
 407:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc1, ADC_FLAG_EOC);
 408:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_EOC);
 409:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_EOC);
 410:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc1, ADC_FLAG_OVR);
 411:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_OVR);
 412:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_OVR);
 413:Board/v3/board.cpp ****         
 414:Board/v3/board.cpp ****         __HAL_TIM_CLEAR_IT(&htim8, TIM_IT_UPDATE);
 415:Board/v3/board.cpp ****         __HAL_TIM_ENABLE_IT(&htim8, TIM_IT_UPDATE);
 416:Board/v3/board.cpp ****     }
 417:Board/v3/board.cpp **** }
 418:Board/v3/board.cpp **** 
 419:Board/v3/board.cpp **** static bool fetch_and_reset_adcs(
 420:Board/v3/board.cpp ****         std::optional<Iph_ABC_t>* current0,
 421:Board/v3/board.cpp ****         std::optional<Iph_ABC_t>* current1) {
 422:Board/v3/board.cpp ****     bool all_adcs_done = (ADC1->SR & ADC_SR_JEOC) == ADC_SR_JEOC
 423:Board/v3/board.cpp ****         && (ADC2->SR & (ADC_SR_EOC | ADC_SR_JEOC)) == (ADC_SR_EOC | ADC_SR_JEOC)
 424:Board/v3/board.cpp ****         && (ADC3->SR & (ADC_SR_EOC | ADC_SR_JEOC)) == (ADC_SR_EOC | ADC_SR_JEOC);
 425:Board/v3/board.cpp ****     if (!all_adcs_done) {
 426:Board/v3/board.cpp ****         return false;
 427:Board/v3/board.cpp ****     }
ARM GAS  /tmp/ccysU9ly.s 			page 24


 428:Board/v3/board.cpp **** 
 429:Board/v3/board.cpp ****     vbus_sense_adc_cb(ADC1->JDR1);
 430:Board/v3/board.cpp **** 
 431:Board/v3/board.cpp ****     if (m0_gate_driver.is_ready()) {
 432:Board/v3/board.cpp ****         std::optional<float> phB = motors[0].phase_current_from_adcval(ADC2->JDR1);
 433:Board/v3/board.cpp ****         std::optional<float> phC = motors[0].phase_current_from_adcval(ADC3->JDR1);
 434:Board/v3/board.cpp ****         if (phB.has_value() && phC.has_value()) {
 435:Board/v3/board.cpp ****             *current0 = {-*phB - *phC, *phB, *phC};
 436:Board/v3/board.cpp ****         }
 437:Board/v3/board.cpp ****     }
 438:Board/v3/board.cpp **** 
 439:Board/v3/board.cpp ****     if (m1_gate_driver.is_ready()) {
 440:Board/v3/board.cpp ****         std::optional<float> phB = motors[1].phase_current_from_adcval(ADC2->DR);
 441:Board/v3/board.cpp ****         std::optional<float> phC = motors[1].phase_current_from_adcval(ADC3->DR);
 442:Board/v3/board.cpp ****         if (phB.has_value() && phC.has_value()) {
 443:Board/v3/board.cpp ****             *current1 = {-*phB - *phC, *phB, *phC};
 444:Board/v3/board.cpp ****         }
 445:Board/v3/board.cpp ****     }
 446:Board/v3/board.cpp ****     
 447:Board/v3/board.cpp ****     ADC1->SR = ~(ADC_SR_JEOC);
 448:Board/v3/board.cpp ****     ADC2->SR = ~(ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_OVR);
 449:Board/v3/board.cpp ****     ADC3->SR = ~(ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_OVR);
 450:Board/v3/board.cpp **** 
 451:Board/v3/board.cpp ****     return true;
 452:Board/v3/board.cpp **** }
 453:Board/v3/board.cpp **** 
 454:Board/v3/board.cpp **** extern "C" {
 455:Board/v3/board.cpp **** 
 456:Board/v3/board.cpp **** void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi) {
 457:Board/v3/board.cpp ****     HAL_SPI_TxRxCpltCallback(hspi);
 458:Board/v3/board.cpp **** }
 459:Board/v3/board.cpp **** 
 460:Board/v3/board.cpp **** void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi) {
 461:Board/v3/board.cpp ****     HAL_SPI_TxRxCpltCallback(hspi);
 462:Board/v3/board.cpp **** }
 463:Board/v3/board.cpp **** 
 464:Board/v3/board.cpp **** void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi) {
 465:Board/v3/board.cpp ****     if (hspi == &hspi3) {
 466:Board/v3/board.cpp ****         spi3_arbiter.on_complete();
 467:Board/v3/board.cpp ****     }
 468:Board/v3/board.cpp **** }
 469:Board/v3/board.cpp **** 
 470:Board/v3/board.cpp **** void TIM5_IRQHandler(void) {
 471:Board/v3/board.cpp ****     COUNT_IRQ(TIM5_IRQn);
 472:Board/v3/board.cpp ****     pwm0_input.on_capture();
 473:Board/v3/board.cpp **** }
 474:Board/v3/board.cpp **** 
 475:Board/v3/board.cpp **** volatile uint32_t timestamp_ = 0;
 476:Board/v3/board.cpp **** volatile bool counting_down_ = false;
 477:Board/v3/board.cpp **** 
 478:Board/v3/board.cpp **** void TIM8_UP_TIM13_IRQHandler(void) {
 479:Board/v3/board.cpp ****     COUNT_IRQ(TIM8_UP_TIM13_IRQn);
 480:Board/v3/board.cpp ****     
 481:Board/v3/board.cpp ****     // Entry into this function happens at 21-23 clock cycles after the timer
 482:Board/v3/board.cpp ****     // update event.
 483:Board/v3/board.cpp ****     __HAL_TIM_CLEAR_IT(&htim8, TIM_IT_UPDATE);
 484:Board/v3/board.cpp **** 
ARM GAS  /tmp/ccysU9ly.s 			page 25


 485:Board/v3/board.cpp ****     // If the corresponding timer is counting up, we just sampled in SVM vector 0, i.e. real curren
 486:Board/v3/board.cpp ****     // If we are counting down, we just sampled in SVM vector 7, with zero current
 487:Board/v3/board.cpp ****     bool counting_down = TIM8->CR1 & TIM_CR1_DIR;
 488:Board/v3/board.cpp **** 
 489:Board/v3/board.cpp ****     bool timer_update_missed = (counting_down_ == counting_down);
 490:Board/v3/board.cpp ****     if (timer_update_missed) {
 491:Board/v3/board.cpp ****         motors[0].disarm_with_error(Motor::ERROR_TIMER_UPDATE_MISSED);
 492:Board/v3/board.cpp ****         motors[1].disarm_with_error(Motor::ERROR_TIMER_UPDATE_MISSED);
 493:Board/v3/board.cpp ****         return;
 494:Board/v3/board.cpp ****     }
 495:Board/v3/board.cpp ****     counting_down_ = counting_down;
 496:Board/v3/board.cpp **** 
 497:Board/v3/board.cpp ****     timestamp_ += TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1);
 498:Board/v3/board.cpp **** 
 499:Board/v3/board.cpp ****     if (!counting_down) {
 500:Board/v3/board.cpp ****         TaskTimer::enabled = odrv.task_timers_armed_;
 501:Board/v3/board.cpp ****         // Run sampling handlers and kick off control tasks when TIM8 is
 502:Board/v3/board.cpp ****         // counting up.
 503:Board/v3/board.cpp ****         odrv.sampling_cb();
 504:Board/v3/board.cpp ****         NVIC->STIR = ControlLoop_IRQn;
 505:Board/v3/board.cpp ****     } else {
 506:Board/v3/board.cpp ****         // Tentatively reset all PWM outputs to 50% duty cycles. If the control
 507:Board/v3/board.cpp ****         // loop handler finishes in time then these values will be overridden
 508:Board/v3/board.cpp ****         // before they go into effect.
 509:Board/v3/board.cpp ****         TIM1->CCR1 =
 510:Board/v3/board.cpp ****         TIM1->CCR2 =
 511:Board/v3/board.cpp ****         TIM1->CCR3 =
 512:Board/v3/board.cpp ****         TIM8->CCR1 =
 513:Board/v3/board.cpp ****         TIM8->CCR2 =
 514:Board/v3/board.cpp ****         TIM8->CCR3 =
 515:Board/v3/board.cpp ****             TIM_1_8_PERIOD_CLOCKS / 2;
 516:Board/v3/board.cpp ****     }
 517:Board/v3/board.cpp **** }
 518:Board/v3/board.cpp **** 
 519:Board/v3/board.cpp **** void ControlLoop_IRQHandler(void) {
 520:Board/v3/board.cpp ****     COUNT_IRQ(ControlLoop_IRQn);
 521:Board/v3/board.cpp ****     uint32_t timestamp = timestamp_;
 522:Board/v3/board.cpp **** 
 523:Board/v3/board.cpp ****     // Ensure that all the ADCs are done
 524:Board/v3/board.cpp ****     std::optional<Iph_ABC_t> current0;
 525:Board/v3/board.cpp ****     std::optional<Iph_ABC_t> current1;
 526:Board/v3/board.cpp **** 
 527:Board/v3/board.cpp ****     if (!fetch_and_reset_adcs(&current0, &current1)) {
 528:Board/v3/board.cpp ****         motors[0].disarm_with_error(Motor::ERROR_BAD_TIMING);
 529:Board/v3/board.cpp ****         motors[1].disarm_with_error(Motor::ERROR_BAD_TIMING);
 530:Board/v3/board.cpp ****     }
 531:Board/v3/board.cpp **** 
 532:Board/v3/board.cpp ****     // If the motor FETs are not switching then we can't measure the current
 533:Board/v3/board.cpp ****     // because for this we need the low side FET to conduct.
 534:Board/v3/board.cpp ****     // So for now we guess the current to be 0 (this is not correct shortly after
 535:Board/v3/board.cpp ****     // disarming and when the motor spins fast in idle). Passing an invalid
 536:Board/v3/board.cpp ****     // current reading would create problems with starting FOC.
 537:Board/v3/board.cpp ****     if (!(TIM1->BDTR & TIM_BDTR_MOE_Msk)) {
 538:Board/v3/board.cpp ****         current0 = {0.0f, 0.0f};
 539:Board/v3/board.cpp ****     }
 540:Board/v3/board.cpp ****     if (!(TIM8->BDTR & TIM_BDTR_MOE_Msk)) {
 541:Board/v3/board.cpp ****         current1 = {0.0f, 0.0f};
ARM GAS  /tmp/ccysU9ly.s 			page 26


 542:Board/v3/board.cpp ****     }
 543:Board/v3/board.cpp **** 
 544:Board/v3/board.cpp ****     motors[0].current_meas_cb(timestamp - TIM1_INIT_COUNT, current0);
 545:Board/v3/board.cpp ****     motors[1].current_meas_cb(timestamp, current1);
 546:Board/v3/board.cpp **** 
 547:Board/v3/board.cpp ****     odrv.control_loop_cb(timestamp);
 548:Board/v3/board.cpp **** 
 549:Board/v3/board.cpp ****     // By this time the ADCs for both M0 and M1 should have fired again. But
 550:Board/v3/board.cpp ****     // let's wait for them just to be sure.
 551:Board/v3/board.cpp ****     MEASURE_TIME(odrv.task_times_.dc_calib_wait) {
 552:Board/v3/board.cpp ****         while (!(ADC2->SR & ADC_SR_EOC));
 553:Board/v3/board.cpp ****     }
 554:Board/v3/board.cpp **** 
 555:Board/v3/board.cpp ****     if (!fetch_and_reset_adcs(&current0, &current1)) {
 556:Board/v3/board.cpp ****         motors[0].disarm_with_error(Motor::ERROR_BAD_TIMING);
 557:Board/v3/board.cpp ****         motors[1].disarm_with_error(Motor::ERROR_BAD_TIMING);
 558:Board/v3/board.cpp ****     }
 559:Board/v3/board.cpp **** 
 560:Board/v3/board.cpp ****     motors[0].dc_calib_cb(timestamp + TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1) - TIM1_INIT_COUNT, 
 561:Board/v3/board.cpp ****     motors[1].dc_calib_cb(timestamp + TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1), current1);
 562:Board/v3/board.cpp **** 
 563:Board/v3/board.cpp ****     motors[0].pwm_update_cb(timestamp + 3 * TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1) - TIM1_INIT_C
 564:Board/v3/board.cpp ****     motors[1].pwm_update_cb(timestamp + 3 * TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1));
 565:Board/v3/board.cpp **** 
 566:Board/v3/board.cpp ****     // If we did everything right, the TIM8 update handler should have been
 567:Board/v3/board.cpp ****     // called exactly once between the start of this function and now.
 568:Board/v3/board.cpp **** 
 569:Board/v3/board.cpp ****     if (timestamp_ != timestamp + TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1)) {
 570:Board/v3/board.cpp ****         motors[0].disarm_with_error(Motor::ERROR_CONTROL_DEADLINE_MISSED);
 571:Board/v3/board.cpp ****         motors[1].disarm_with_error(Motor::ERROR_CONTROL_DEADLINE_MISSED);
 572:Board/v3/board.cpp ****     }
 573:Board/v3/board.cpp **** 
 574:Board/v3/board.cpp ****     odrv.task_timers_armed_ = odrv.task_timers_armed_ && !TaskTimer::enabled;
 575:Board/v3/board.cpp ****     TaskTimer::enabled = false;
 576:Board/v3/board.cpp **** }
 577:Board/v3/board.cpp **** 
 578:Board/v3/board.cpp **** void I2C1_EV_IRQHandler(void) {
 579:Board/v3/board.cpp ****     COUNT_IRQ(I2C1_EV_IRQn);
 580:Board/v3/board.cpp ****     HAL_I2C_EV_IRQHandler(&hi2c1);
 581:Board/v3/board.cpp **** }
 582:Board/v3/board.cpp **** 
 583:Board/v3/board.cpp **** void I2C1_ER_IRQHandler(void) {
 584:Board/v3/board.cpp ****     COUNT_IRQ(I2C1_ER_IRQn);
 585:Board/v3/board.cpp ****     HAL_I2C_ER_IRQHandler(&hi2c1);
 586:Board/v3/board.cpp **** }
 587:Board/v3/board.cpp **** 
 588:Board/v3/board.cpp **** extern PCD_HandleTypeDef hpcd_USB_OTG_FS; // defined in usbd_conf.c
 589:Board/v3/board.cpp **** void OTG_FS_IRQHandler(void) {
 590:Board/v3/board.cpp ****     COUNT_IRQ(OTG_FS_IRQn);
 591:Board/v3/board.cpp ****     HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 592:Board/v3/board.cpp **** }
 593:Board/v3/board.cpp **** 
 594:Board/v3/board.cpp **** }
 271              		.loc 4 594 1 is_stmt 1 view -0
 272              		.cfi_startproc
 273              		@ args = 0, pretend = 0, frame = 144
 274              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccysU9ly.s 			page 27


 275              		.loc 4 594 1 is_stmt 0 view .LVU39
 276 0000 0128     		cmp	r0, #1
 277 0002 00D0     		beq	.L48
 278 0004 7047     		bx	lr
 279              	.L48:
 280              		.loc 4 594 1 discriminator 1 view .LVU40
 281 0006 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 282              		.save {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 283              	.LCFI2:
 284              		.cfi_def_cfa_offset 36
 285              		.cfi_offset 4, -36
 286              		.cfi_offset 5, -32
 287              		.cfi_offset 6, -28
 288              		.cfi_offset 7, -24
 289              		.cfi_offset 8, -20
 290              		.cfi_offset 9, -16
 291              		.cfi_offset 10, -12
 292              		.cfi_offset 11, -8
 293              		.cfi_offset 14, -4
 294 000a 2DED028B 		vpush.64	{d8}
 295              		.vsave {d8}
 296              	.LCFI3:
 297              		.cfi_def_cfa_offset 44
 298              		.cfi_offset 80, -44
 299              		.cfi_offset 81, -40
 300              		.pad #188
 301 000e AFB0     		sub	sp, sp, #188
 302              	.LCFI4:
 303              		.cfi_def_cfa_offset 232
 304 0010 0446     		mov	r4, r0
 305              		.loc 4 594 1 discriminator 1 view .LVU41
 306 0012 4FF6FF73 		movw	r3, #65535
 307 0016 9942     		cmp	r1, r3
 308 0018 04D0     		beq	.L49
 309              	.LVL11:
 310              	.L22:
 311              		.loc 4 594 1 view .LVU42
 312 001a 2FB0     		add	sp, sp, #188
 313              	.LCFI5:
 314              		.cfi_remember_state
 315              		.cfi_def_cfa_offset 44
 316              		@ sp needed
 317 001c BDEC028B 		vldm	sp!, {d8}
 318              	.LCFI6:
 319              		.cfi_restore 80
 320              		.cfi_restore 81
 321              		.cfi_def_cfa_offset 36
 322 0020 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 323              	.LVL12:
 324              	.L49:
 325              	.LCFI7:
 326              		.cfi_restore_state
 327              	.LBB705:
 328              	.LBI705:
 329              		.file 5 "./Drivers/STM32/stm32_spi_arbiter.hpp"
   1:./Drivers/STM32/stm32_spi_arbiter.hpp **** #ifndef __STM32_SPI_ARBITER_HPP
   2:./Drivers/STM32/stm32_spi_arbiter.hpp **** #define __STM32_SPI_ARBITER_HPP
ARM GAS  /tmp/ccysU9ly.s 			page 28


   3:./Drivers/STM32/stm32_spi_arbiter.hpp **** 
   4:./Drivers/STM32/stm32_spi_arbiter.hpp **** #include "stm32_gpio.hpp"
   5:./Drivers/STM32/stm32_spi_arbiter.hpp **** 
   6:./Drivers/STM32/stm32_spi_arbiter.hpp **** #include <spi.h>
   7:./Drivers/STM32/stm32_spi_arbiter.hpp **** 
   8:./Drivers/STM32/stm32_spi_arbiter.hpp **** class Stm32SpiArbiter {
   9:./Drivers/STM32/stm32_spi_arbiter.hpp **** public:
  10:./Drivers/STM32/stm32_spi_arbiter.hpp ****     struct SpiTask {
  11:./Drivers/STM32/stm32_spi_arbiter.hpp ****         SPI_InitTypeDef config;
  12:./Drivers/STM32/stm32_spi_arbiter.hpp ****         Stm32Gpio ncs_gpio;
  13:./Drivers/STM32/stm32_spi_arbiter.hpp ****         const uint8_t* tx_buf;
  14:./Drivers/STM32/stm32_spi_arbiter.hpp ****         uint8_t* rx_buf;
  15:./Drivers/STM32/stm32_spi_arbiter.hpp ****         size_t length;
  16:./Drivers/STM32/stm32_spi_arbiter.hpp ****         void (*on_complete)(void*, bool);
  17:./Drivers/STM32/stm32_spi_arbiter.hpp ****         void* on_complete_ctx;
  18:./Drivers/STM32/stm32_spi_arbiter.hpp ****         bool is_in_use = false;
  19:./Drivers/STM32/stm32_spi_arbiter.hpp ****         struct SpiTask* next;
  20:./Drivers/STM32/stm32_spi_arbiter.hpp ****     };
  21:./Drivers/STM32/stm32_spi_arbiter.hpp **** 
  22:./Drivers/STM32/stm32_spi_arbiter.hpp ****     Stm32SpiArbiter(SPI_HandleTypeDef* hspi): hspi_(hspi) {}
 330              		.loc 5 22 5 is_stmt 1 view .LVU43
 331              	.LBB706:
 332              	.LBB707:
 333              		.loc 5 22 57 is_stmt 0 view .LVU44
 334 0024 9E4F     		ldr	r7, .L51
 335 0026 9F4B     		ldr	r3, .L51+4
 336 0028 3B60     		str	r3, [r7]
 337 002a 0026     		movs	r6, #0
 338 002c 7E60     		str	r6, [r7, #4]
 339              	.LVL13:
 340              		.loc 5 22 57 view .LVU45
 341              	.LBE707:
 342              	.LBE706:
 343              	.LBE705:
 344              	.LBB708:
 345              	.LBI708:
 346              		.file 6 "./Drivers/STM32/stm32_gpio.hpp"
   1:./Drivers/STM32/stm32_gpio.hpp **** #ifndef __STM32_GPIO_HPP
   2:./Drivers/STM32/stm32_gpio.hpp **** #define __STM32_GPIO_HPP
   3:./Drivers/STM32/stm32_gpio.hpp **** 
   4:./Drivers/STM32/stm32_gpio.hpp **** #include <gpio.h>
   5:./Drivers/STM32/stm32_gpio.hpp **** 
   6:./Drivers/STM32/stm32_gpio.hpp **** class Stm32Gpio {
   7:./Drivers/STM32/stm32_gpio.hpp **** public:
   8:./Drivers/STM32/stm32_gpio.hpp ****     static const Stm32Gpio none;
   9:./Drivers/STM32/stm32_gpio.hpp **** 
  10:./Drivers/STM32/stm32_gpio.hpp ****     Stm32Gpio() : port_(nullptr), pin_mask_(0) {}
  11:./Drivers/STM32/stm32_gpio.hpp ****     Stm32Gpio(GPIO_TypeDef* port, uint16_t pin) : port_(port), pin_mask_(pin) {}
 347              		.loc 6 11 5 is_stmt 1 view .LVU46
 348              	.LBB709:
 349              	.LBB710:
 350              		.loc 6 11 77 is_stmt 0 view .LVU47
 351 002e DFF8B8A2 		ldr	r10, .L51+72
 352 0032 CDF840A0 		str	r10, [sp, #64]
 353 0036 4FF40053 		mov	r3, #8192
 354 003a ADF84430 		strh	r3, [sp, #68]	@ movhi
 355              	.LVL14:
ARM GAS  /tmp/ccysU9ly.s 			page 29


 356              		.loc 6 11 77 view .LVU48
 357              	.LBE710:
 358              	.LBE709:
 359              	.LBE708:
 360              	.LBB711:
 361              	.LBI711:
  10:./Drivers/STM32/stm32_gpio.hpp ****     Stm32Gpio(GPIO_TypeDef* port, uint16_t pin) : port_(port), pin_mask_(pin) {}
 362              		.loc 6 10 5 is_stmt 1 view .LVU49
 363              	.LBB712:
 364              	.LBB713:
  10:./Drivers/STM32/stm32_gpio.hpp ****     Stm32Gpio(GPIO_TypeDef* port, uint16_t pin) : port_(port), pin_mask_(pin) {}
 365              		.loc 6 10 46 is_stmt 0 view .LVU50
 366 003e 1296     		str	r6, [sp, #72]
 367 0040 ADF84C60 		strh	r6, [sp, #76]	@ movhi
 368              	.LVL15:
  10:./Drivers/STM32/stm32_gpio.hpp ****     Stm32Gpio(GPIO_TypeDef* port, uint16_t pin) : port_(port), pin_mask_(pin) {}
 369              		.loc 6 10 46 view .LVU51
 370              	.LBE713:
 371              	.LBE712:
 372              	.LBE711:
 373              	.LBB714:
 374              	.LBI714:
 375              		.loc 6 11 5 is_stmt 1 view .LVU52
 376              	.LBB715:
 377              	.LBB716:
 378              		.loc 6 11 77 is_stmt 0 view .LVU53
 379 0044 984B     		ldr	r3, .L51+8
 380 0046 1493     		str	r3, [sp, #80]
 381 0048 0423     		movs	r3, #4
 382 004a ADF85430 		strh	r3, [sp, #84]	@ movhi
 383              	.LVL16:
 384              		.loc 6 11 77 view .LVU54
 385 004e 0AAD     		add	r5, sp, #40
 386 0050 1199     		ldr	r1, [sp, #68]
 387              	.LVL17:
 388              		.loc 6 11 77 view .LVU55
 389 0052 5046     		mov	r0, r10
 390              	.LVL18:
 391              		.loc 6 11 77 view .LVU56
 392 0054 85E80300 		stm	r5, {r0, r1}
 393 0058 0DF1300E 		add	lr, sp, #48
 394 005c 1399     		ldr	r1, [sp, #76]
 395 005e 3046     		mov	r0, r6
 396 0060 8EE80300 		stm	lr, {r0, r1}
 397 0064 0DF1380C 		add	ip, sp, #56
 398 0068 1599     		ldr	r1, [sp, #84]
 399 006a 8F48     		ldr	r0, .L51+8
 400 006c 8CE80300 		stm	ip, {r0, r1}
 401              	.LBE716:
 402              	.LBE715:
 403              	.LBE714:
 404              	.LBB717:
 405              	.LBI717:
 406              		.file 7 "./Drivers/DRV8301/drv8301.hpp"
   1:./Drivers/DRV8301/drv8301.hpp **** #ifndef __DRV8301_HPP
   2:./Drivers/DRV8301/drv8301.hpp **** #define __DRV8301_HPP
   3:./Drivers/DRV8301/drv8301.hpp **** 
ARM GAS  /tmp/ccysU9ly.s 			page 30


   4:./Drivers/DRV8301/drv8301.hpp **** #include "stdbool.h"
   5:./Drivers/DRV8301/drv8301.hpp **** #include "stdint.h"
   6:./Drivers/DRV8301/drv8301.hpp **** 
   7:./Drivers/DRV8301/drv8301.hpp **** #include <Drivers/gate_driver.hpp>
   8:./Drivers/DRV8301/drv8301.hpp **** #include <Drivers/STM32/stm32_spi_arbiter.hpp>
   9:./Drivers/DRV8301/drv8301.hpp **** #include <Drivers/STM32/stm32_gpio.hpp>
  10:./Drivers/DRV8301/drv8301.hpp **** 
  11:./Drivers/DRV8301/drv8301.hpp **** 
  12:./Drivers/DRV8301/drv8301.hpp **** class Drv8301 : public GateDriverBase, public OpAmpBase {
  13:./Drivers/DRV8301/drv8301.hpp **** public:
  14:./Drivers/DRV8301/drv8301.hpp ****     typedef enum : uint32_t {
  15:./Drivers/DRV8301/drv8301.hpp ****         FaultType_NoFault  = (0 << 0),  //!< No fault
  16:./Drivers/DRV8301/drv8301.hpp **** 
  17:./Drivers/DRV8301/drv8301.hpp ****         // Status Register 1
  18:./Drivers/DRV8301/drv8301.hpp ****         FaultType_FETLC_OC = (1 << 0),  //!< FET Low side, Phase C Over Current fault
  19:./Drivers/DRV8301/drv8301.hpp ****         FaultType_FETHC_OC = (1 << 1),  //!< FET High side, Phase C Over Current fault
  20:./Drivers/DRV8301/drv8301.hpp ****         FaultType_FETLB_OC = (1 << 2),  //!< FET Low side, Phase B Over Current fault
  21:./Drivers/DRV8301/drv8301.hpp ****         FaultType_FETHB_OC = (1 << 3),  //!< FET High side, Phase B Over Current fault
  22:./Drivers/DRV8301/drv8301.hpp ****         FaultType_FETLA_OC = (1 << 4),  //!< FET Low side, Phase A Over Current fault
  23:./Drivers/DRV8301/drv8301.hpp ****         FaultType_FETHA_OC = (1 << 5),  //!< FET High side, Phase A Over Current fault
  24:./Drivers/DRV8301/drv8301.hpp ****         FaultType_OTW      = (1 << 6),  //!< Over Temperature Warning fault
  25:./Drivers/DRV8301/drv8301.hpp ****         FaultType_OTSD     = (1 << 7),  //!< Over Temperature Shut Down fault
  26:./Drivers/DRV8301/drv8301.hpp ****         FaultType_PVDD_UV  = (1 << 8),  //!< Power supply Vdd Under Voltage fault
  27:./Drivers/DRV8301/drv8301.hpp ****         FaultType_GVDD_UV  = (1 << 9),  //!< DRV8301 Vdd Under Voltage fault
  28:./Drivers/DRV8301/drv8301.hpp ****         FaultType_FAULT    = (1 << 10),
  29:./Drivers/DRV8301/drv8301.hpp **** 
  30:./Drivers/DRV8301/drv8301.hpp ****         // Status Register 2
  31:./Drivers/DRV8301/drv8301.hpp ****         FaultType_GVDD_OV  = (1 << 23)  //!< DRV8301 Vdd Over Voltage fault
  32:./Drivers/DRV8301/drv8301.hpp ****     } FaultType_e;
  33:./Drivers/DRV8301/drv8301.hpp **** 
  34:./Drivers/DRV8301/drv8301.hpp ****     Drv8301(Stm32SpiArbiter* spi_arbiter, Stm32Gpio ncs_gpio,
 407              		.loc 7 34 5 is_stmt 1 view .LVU57
 408              	.LVL19:
 409              	.LBB718:
 410              	.LBB719:
 411              	.LBB720:
 412              	.LBI720:
 413              		.file 8 "./Drivers/gate_driver.hpp"
   1:./Drivers/gate_driver.hpp **** #ifndef __GATE_DRIVER_HPP
   2:./Drivers/gate_driver.hpp **** #define __GATE_DRIVER_HPP
   3:./Drivers/gate_driver.hpp **** 
   4:./Drivers/gate_driver.hpp **** struct GateDriverBase {
 414              		.loc 8 4 8 view .LVU58
 415              	.LBB721:
 416 0070 8E4A     		ldr	r2, .L51+12
 417 0072 8F49     		ldr	r1, .L51+16
 418 0074 1160     		str	r1, [r2]
 419              	.LVL20:
 420              		.loc 8 4 8 is_stmt 0 view .LVU59
 421              	.LBE721:
 422              	.LBE720:
 423              	.LBB722:
 424              	.LBI722:
   5:./Drivers/gate_driver.hpp ****     /**
   6:./Drivers/gate_driver.hpp ****      * @brief Unlocks or locks the gate signals of the gate driver.
   7:./Drivers/gate_driver.hpp ****      * 
   8:./Drivers/gate_driver.hpp ****      * While locked the PWM inputs are ignored and the switches are always in
ARM GAS  /tmp/ccysU9ly.s 			page 31


   9:./Drivers/gate_driver.hpp ****      * OFF state.
  10:./Drivers/gate_driver.hpp ****      * Not all gate drivers implement this function and may return true even if
  11:./Drivers/gate_driver.hpp ****      * the gate driver was not locked.
  12:./Drivers/gate_driver.hpp ****      */
  13:./Drivers/gate_driver.hpp ****     virtual bool set_enabled(bool enabled) = 0;
  14:./Drivers/gate_driver.hpp **** 
  15:./Drivers/gate_driver.hpp ****     /**
  16:./Drivers/gate_driver.hpp ****      * @brief Returns false if the gate driver is in a state where the output
  17:./Drivers/gate_driver.hpp ****      * drive stages are disarmed or not properly configured (e.g. because they
  18:./Drivers/gate_driver.hpp ****      * are not initialized or there was a fault condition).
  19:./Drivers/gate_driver.hpp ****      */
  20:./Drivers/gate_driver.hpp ****     virtual bool is_ready() = 0;
  21:./Drivers/gate_driver.hpp **** };
  22:./Drivers/gate_driver.hpp **** 
  23:./Drivers/gate_driver.hpp **** struct OpAmpBase {
 425              		.loc 8 23 8 is_stmt 1 view .LVU60
 426              	.LBB723:
 427 0076 8F48     		ldr	r0, .L51+20
 428 0078 5060     		str	r0, [r2, #4]
 429              	.LVL21:
 430              		.loc 8 23 8 is_stmt 0 view .LVU61
 431              	.LBE723:
 432              	.LBE722:
  35:./Drivers/DRV8301/drv8301.hpp ****             Stm32Gpio enable_gpio, Stm32Gpio nfault_gpio)
  36:./Drivers/DRV8301/drv8301.hpp ****             : spi_arbiter_(spi_arbiter), ncs_gpio_(ncs_gpio),
  37:./Drivers/DRV8301/drv8301.hpp ****               enable_gpio_(enable_gpio), nfault_gpio_(nfault_gpio) {}
 433              		.loc 7 37 66 view .LVU62
 434 007a DFF89082 		ldr	r8, .L51+108
 435 007e C2F80080 		str	r8, [r2]
 436 0082 08F11809 		add	r9, r8, #24
 437 0086 C2F80490 		str	r9, [r2, #4]
 438 008a 9760     		str	r7, [r2, #8]
 439 008c 02F10C0B 		add	fp, r2, #12
 440 0090 95E80300 		ldm	r5, {r0, r1}
 441 0094 8BE80300 		stm	fp, {r0, r1}
 442 0098 02F1140B 		add	fp, r2, #20
 443 009c 9EE80300 		ldm	lr, {r0, r1}
 444 00a0 8BE80300 		stm	fp, {r0, r1}
 445 00a4 02F11C0B 		add	fp, r2, #28
 446 00a8 9CE80300 		ldm	ip, {r0, r1}
 447 00ac 8BE80300 		stm	fp, {r0, r1}
 448 00b0 82F82C60 		strb	r6, [r2, #44]
 449              	.LVL22:
 450              		.loc 7 37 66 view .LVU63
 451              	.LBE719:
 452              	.LBE718:
 453              	.LBE717:
 454              	.LBB724:
 455              	.LBI724:
 456              		.loc 6 11 5 is_stmt 1 view .LVU64
 457              	.LBB725:
 458              	.LBB726:
 459              		.loc 6 11 77 is_stmt 0 view .LVU65
 460 00b4 CDF858A0 		str	r10, [sp, #88]
 461 00b8 4FF48042 		mov	r2, #16384
 462 00bc ADF85C20 		strh	r2, [sp, #92]	@ movhi
 463              	.LVL23:
ARM GAS  /tmp/ccysU9ly.s 			page 32


 464              		.loc 6 11 77 view .LVU66
 465              	.LBE726:
 466              	.LBE725:
 467              	.LBE724:
 468              	.LBB727:
 469              	.LBI727:
  10:./Drivers/STM32/stm32_gpio.hpp ****     Stm32Gpio(GPIO_TypeDef* port, uint16_t pin) : port_(port), pin_mask_(pin) {}
 470              		.loc 6 10 5 is_stmt 1 view .LVU67
 471              	.LBB728:
 472              	.LBB729:
  10:./Drivers/STM32/stm32_gpio.hpp ****     Stm32Gpio(GPIO_TypeDef* port, uint16_t pin) : port_(port), pin_mask_(pin) {}
 473              		.loc 6 10 46 is_stmt 0 view .LVU68
 474 00c0 1896     		str	r6, [sp, #96]
 475 00c2 ADF86460 		strh	r6, [sp, #100]	@ movhi
 476              	.LVL24:
  10:./Drivers/STM32/stm32_gpio.hpp ****     Stm32Gpio(GPIO_TypeDef* port, uint16_t pin) : port_(port), pin_mask_(pin) {}
 477              		.loc 6 10 46 view .LVU69
 478              	.LBE729:
 479              	.LBE728:
 480              	.LBE727:
 481              	.LBB730:
 482              	.LBI730:
 483              		.loc 6 11 5 is_stmt 1 view .LVU70
 484              	.LBB731:
 485              	.LBB732:
 486              		.loc 6 11 77 is_stmt 0 view .LVU71
 487 00c6 0246     		mov	r2, r0
 488 00c8 1A90     		str	r0, [sp, #104]
 489 00ca ADF86C30 		strh	r3, [sp, #108]	@ movhi
 490              	.LVL25:
 491              		.loc 6 11 77 view .LVU72
 492 00ce 1799     		ldr	r1, [sp, #92]
 493 00d0 5046     		mov	r0, r10
 494 00d2 85E80300 		stm	r5, {r0, r1}
 495 00d6 1999     		ldr	r1, [sp, #100]
 496 00d8 3046     		mov	r0, r6
 497 00da 8EE80300 		stm	lr, {r0, r1}
 498 00de 1B99     		ldr	r1, [sp, #108]
 499 00e0 1046     		mov	r0, r2
 500 00e2 8CE80300 		stm	ip, {r0, r1}
 501              	.LBE732:
 502              	.LBE731:
 503              	.LBE730:
 504              	.LBB733:
 505              	.LBI733:
  34:./Drivers/DRV8301/drv8301.hpp ****             Stm32Gpio enable_gpio, Stm32Gpio nfault_gpio)
 506              		.loc 7 34 5 is_stmt 1 view .LVU73
 507              	.LVL26:
 508              	.LBB734:
 509              	.LBB735:
 510              	.LBB736:
 511              	.LBI736:
   4:./Drivers/gate_driver.hpp ****     /**
 512              		.loc 8 4 8 view .LVU74
 513              	.LBB737:
 514 00e6 744A     		ldr	r2, .L51+24
 515 00e8 7149     		ldr	r1, .L51+16
ARM GAS  /tmp/ccysU9ly.s 			page 33


 516 00ea 1160     		str	r1, [r2]
 517              	.LVL27:
   4:./Drivers/gate_driver.hpp ****     /**
 518              		.loc 8 4 8 is_stmt 0 view .LVU75
 519              	.LBE737:
 520              	.LBE736:
 521              	.LBB738:
 522              	.LBI738:
 523              		.loc 8 23 8 is_stmt 1 view .LVU76
 524              	.LBB739:
 525 00ec 7148     		ldr	r0, .L51+20
 526 00ee 5060     		str	r0, [r2, #4]
 527              	.LVL28:
 528              		.loc 8 23 8 is_stmt 0 view .LVU77
 529              	.LBE739:
 530              	.LBE738:
 531              		.loc 7 37 66 view .LVU78
 532 00f0 C2F80080 		str	r8, [r2]
 533 00f4 C2F80490 		str	r9, [r2, #4]
 534 00f8 9760     		str	r7, [r2, #8]
 535 00fa 02F10C07 		add	r7, r2, #12
 536 00fe 95E80300 		ldm	r5, {r0, r1}
 537 0102 87E80300 		stm	r7, {r0, r1}
 538 0106 02F11405 		add	r5, r2, #20
 539 010a 9EE80300 		ldm	lr, {r0, r1}
 540 010e 85E80300 		stm	r5, {r0, r1}
 541 0112 02F11C05 		add	r5, r2, #28
 542 0116 9CE80300 		ldm	ip, {r0, r1}
 543 011a 85E80300 		stm	r5, {r0, r1}
 544 011e 82F82C60 		strb	r6, [r2, #44]
 545              	.LVL29:
 546              		.loc 7 37 66 view .LVU79
 547              	.LBE735:
 548              	.LBE734:
 549              	.LBE733:
  71:Board/v3/board.cpp **** 
 550              		.loc 4 71 1 view .LVU80
 551 0122 664A     		ldr	r2, .L51+28
 552 0124 0F21     		movs	r1, #15
 553 0126 6648     		ldr	r0, .L51+32
 554              	.LEHB0:
 555 0128 FFF7FEFF 		bl	_ZN31OnboardThermistorCurrentLimiterC1EtPKfj
 556              	.LVL30:
 557              	.LEHE0:
  71:Board/v3/board.cpp **** 
 558              		.loc 4 71 1 discriminator 1 view .LVU81
 559 012c 0423     		movs	r3, #4
 560 012e 634A     		ldr	r2, .L51+28
 561 0130 1946     		mov	r1, r3
 562 0132 6448     		ldr	r0, .L51+36
 563              	.LEHB1:
 564 0134 FFF7FEFF 		bl	_ZN31OnboardThermistorCurrentLimiterC1EtPKfj
 565              	.LVL31:
 566              	.LEHE1:
  57:Board/v3/board.cpp ****     {
 567              		.loc 4 57 33 discriminator 2 view .LVU82
 568 0138 634A     		ldr	r2, .L51+40
ARM GAS  /tmp/ccysU9ly.s 			page 34


 569 013a 6449     		ldr	r1, .L51+44
 570 013c 3046     		mov	r0, r6
 571 013e FFF7FEFF 		bl	__aeabi_atexit
 572              	.LVL32:
  73:Board/v3/board.cpp **** 
 573              		.loc 4 73 62 discriminator 2 view .LVU83
 574 0142 2546     		mov	r5, r4
 575 0144 624E     		ldr	r6, .L51+48
 576 0146 01E0     		b	.L25
 577              	.L50:
  73:Board/v3/board.cpp **** 
 578              		.loc 4 73 62 discriminator 4 view .LVU84
 579 0148 5036     		adds	r6, r6, #80
  73:Board/v3/board.cpp **** 
 580              		.loc 4 73 62 is_stmt 1 discriminator 4 view .LVU85
 581 014a 013D     		subs	r5, r5, #1
 582              	.L25:
  73:Board/v3/board.cpp **** 
 583              		.loc 4 73 62 discriminator 5 view .LVU86
 584 014c 002D     		cmp	r5, #0
 585 014e 03DB     		blt	.L24
  73:Board/v3/board.cpp **** 
 586              		.loc 4 73 62 is_stmt 0 discriminator 3 view .LVU87
 587 0150 3046     		mov	r0, r6
 588              	.LEHB2:
 589 0152 FFF7FEFF 		bl	_ZN32OffboardThermistorCurrentLimiterC1Ev
 590              	.LVL33:
 591              	.LEHE2:
 592 0156 F7E7     		b	.L50
 593              	.L24:
  73:Board/v3/board.cpp **** 
 594              		.loc 4 73 34 discriminator 2 view .LVU88
 595 0158 5B4A     		ldr	r2, .L51+40
 596 015a 5E49     		ldr	r1, .L51+52
 597 015c 0020     		movs	r0, #0
 598 015e FFF7FEFF 		bl	__aeabi_atexit
 599              	.LVL34:
  94:Board/v3/board.cpp **** 
 600              		.loc 4 94 1 discriminator 2 view .LVU89
 601 0162 524B     		ldr	r3, .L51+12
 602 0164 9FED5C8A 		vldr.32	s16, .L51+56
 603 0168 5C4F     		ldr	r7, .L51+60
 604 016a 594E     		ldr	r6, .L51+48
 605 016c 0296     		str	r6, [sp, #8]
 606 016e 544D     		ldr	r5, .L51+32
 607 0170 0195     		str	r5, [sp, #4]
 608 0172 0093     		str	r3, [sp]
 609 0174 B0EE480A 		vmov.f32	s0, s16
 610 0178 0622     		movs	r2, #6
 611 017a 5949     		ldr	r1, .L51+64
 612 017c 3846     		mov	r0, r7
 613              	.LEHB3:
 614 017e FFF7FEFF 		bl	_ZN5MotorC1EP17TIM_HandleTypeDefhfR7Drv8301S3_R31OnboardThermistorCurrentLimiterR32OffboardTher
 615              	.LVL35:
 616 0182 4D4B     		ldr	r3, .L51+24
 617 0184 5036     		adds	r6, r6, #80
 618 0186 0296     		str	r6, [sp, #8]
ARM GAS  /tmp/ccysU9ly.s 			page 35


 619 0188 3835     		adds	r5, r5, #56
 620 018a 0195     		str	r5, [sp, #4]
 621 018c 0093     		str	r3, [sp]
 622 018e B0EE480A 		vmov.f32	s0, s16
 623 0192 0622     		movs	r2, #6
 624 0194 5349     		ldr	r1, .L51+68
 625 0196 07F5D870 		add	r0, r7, #432
 626 019a FFF7FEFF 		bl	_ZN5MotorC1EP17TIM_HandleTypeDefhfR7Drv8301S3_R31OnboardThermistorCurrentLimiterR32OffboardTher
 627              	.LVL36:
 628              	.LBB740:
 629              	.LBI740:
 630              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU90
 631              	.LBB741:
 632              	.LBB742:
 633              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU91
 634 019e 524F     		ldr	r7, .L51+72
 635 01a0 1C97     		str	r7, [sp, #112]
 636 01a2 4FF40073 		mov	r3, #512
 637 01a6 ADF87430 		strh	r3, [sp, #116]	@ movhi
 638              	.LVL37:
 639              		.loc 6 11 77 discriminator 2 view .LVU92
 640              	.LBE742:
 641              	.LBE741:
 642              	.LBE740:
 643              	.LBB743:
 644              	.LBI743:
 645              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU93
 646              	.LBB744:
 647              	.LBB745:
 648              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU94
 649 01aa DFF86481 		ldr	r8, .L51+112
 650 01ae CDF87880 		str	r8, [sp, #120]
 651 01b2 1022     		movs	r2, #16
 652 01b4 ADF87C20 		strh	r2, [sp, #124]	@ movhi
 653              	.LVL38:
 654              		.loc 6 11 77 discriminator 2 view .LVU95
 655              	.LBE745:
 656              	.LBE744:
 657              	.LBE743:
 658              	.LBB746:
 659              	.LBI746:
 660              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU96
 661              	.LBB747:
 662              	.LBB748:
 663              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU97
 664 01b8 CDF88080 		str	r8, [sp, #128]
 665 01bc 2022     		movs	r2, #32
 666 01be ADF88420 		strh	r2, [sp, #132]	@ movhi
 667              	.LVL39:
 668              		.loc 6 11 77 discriminator 2 view .LVU98
 669              	.LBE748:
 670              	.LBE747:
 671              	.LBE746:
 672              	.LBB749:
 673              	.LBI749:
 674              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU99
 675              	.LBB750:
ARM GAS  /tmp/ccysU9ly.s 			page 36


 676              	.LBB751:
 677              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU100
 678 01c2 2297     		str	r7, [sp, #136]
 679 01c4 ADF88C30 		strh	r3, [sp, #140]	@ movhi
 680              	.LVL40:
 681              		.loc 6 11 77 discriminator 2 view .LVU101
 682              	.LBE751:
 683              	.LBE750:
 684              	.LBE749:
 113:Board/v3/board.cpp **** 
 685              		.loc 4 113 1 discriminator 2 view .LVU102
 686 01c8 DFF84891 		ldr	r9, .L51+116
 687 01cc DFF8D0A0 		ldr	r10, .L51
 688 01d0 CDF818A0 		str	r10, [sp, #24]
 689 01d4 04AE     		add	r6, sp, #16
 690 01d6 2399     		ldr	r1, [sp, #140]
 691 01d8 3846     		mov	r0, r7
 692 01da 86E80300 		stm	r6, {r0, r1}
 693 01de 02AD     		add	r5, sp, #8
 694 01e0 2199     		ldr	r1, [sp, #132]
 695 01e2 2098     		ldr	r0, [sp, #128]
 696 01e4 85E80300 		stm	r5, {r0, r1}
 697 01e8 1F99     		ldr	r1, [sp, #124]
 698 01ea 1E98     		ldr	r0, [sp, #120]
 699 01ec 8DE80300 		stm	sp, {r0, r1}
 700 01f0 1D9B     		ldr	r3, [sp, #116]
 701 01f2 1C9A     		ldr	r2, [sp, #112]
 702 01f4 3D49     		ldr	r1, .L51+76
 703 01f6 4846     		mov	r0, r9
 704 01f8 FFF7FEFF 		bl	_ZN7EncoderC1EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter
 705              	.LVL41:
 706              	.LBB752:
 707              	.LBI752:
 708              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU103
 709              	.LBB753:
 710              	.LBB754:
 711              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU104
 712 01fc 2497     		str	r7, [sp, #144]
 713 01fe 4FF40043 		mov	r3, #32768
 714 0202 ADF89430 		strh	r3, [sp, #148]	@ movhi
 715              	.LVL42:
 716              		.loc 6 11 77 discriminator 2 view .LVU105
 717              	.LBE754:
 718              	.LBE753:
 719              	.LBE752:
 720              	.LBB755:
 721              	.LBI755:
 722              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU106
 723              	.LBB756:
 724              	.LBB757:
 725              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU107
 726 0206 CDF89880 		str	r8, [sp, #152]
 727 020a 4022     		movs	r2, #64
 728 020c ADF89C20 		strh	r2, [sp, #156]	@ movhi
 729              	.LVL43:
 730              		.loc 6 11 77 discriminator 2 view .LVU108
 731              	.LBE757:
ARM GAS  /tmp/ccysU9ly.s 			page 37


 732              	.LBE756:
 733              	.LBE755:
 734              	.LBB758:
 735              	.LBI758:
 736              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU109
 737              	.LBB759:
 738              	.LBB760:
 739              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU110
 740 0210 CDF8A080 		str	r8, [sp, #160]
 741 0214 8022     		movs	r2, #128
 742 0216 ADF8A420 		strh	r2, [sp, #164]	@ movhi
 743              	.LVL44:
 744              		.loc 6 11 77 discriminator 2 view .LVU111
 745              	.LBE760:
 746              	.LBE759:
 747              	.LBE758:
 748              	.LBB761:
 749              	.LBI761:
 750              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU112
 751              	.LBB762:
 752              	.LBB763:
 753              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU113
 754 021a 2A97     		str	r7, [sp, #168]
 755 021c ADF8AC30 		strh	r3, [sp, #172]	@ movhi
 756              	.LVL45:
 757              		.loc 6 11 77 discriminator 2 view .LVU114
 758              	.LBE763:
 759              	.LBE762:
 760              	.LBE761:
 113:Board/v3/board.cpp **** 
 761              		.loc 4 113 1 discriminator 2 view .LVU115
 762 0220 CDF818A0 		str	r10, [sp, #24]
 763 0224 2B99     		ldr	r1, [sp, #172]
 764 0226 3846     		mov	r0, r7
 765 0228 86E80300 		stm	r6, {r0, r1}
 766 022c 2999     		ldr	r1, [sp, #164]
 767 022e 2898     		ldr	r0, [sp, #160]
 768 0230 85E80300 		stm	r5, {r0, r1}
 769 0234 2799     		ldr	r1, [sp, #156]
 770 0236 2698     		ldr	r0, [sp, #152]
 771 0238 8DE80300 		stm	sp, {r0, r1}
 772 023c 259B     		ldr	r3, [sp, #148]
 773 023e 249A     		ldr	r2, [sp, #144]
 774 0240 2B49     		ldr	r1, .L51+80
 775 0242 09F5D070 		add	r0, r9, #416
 776 0246 FFF7FEFF 		bl	_ZN7EncoderC1EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter
 777              	.LVL46:
 117:Board/v3/board.cpp **** 
 778              		.loc 4 117 45 discriminator 2 view .LVU116
 779 024a 2146     		mov	r1, r4
 780 024c 294B     		ldr	r3, .L51+84
 781              	.L27:
 117:Board/v3/board.cpp **** 
 782              		.loc 4 117 45 is_stmt 1 discriminator 4 view .LVU117
 783 024e 0029     		cmp	r1, #0
 784 0250 0CDB     		blt	.L38
 785              	.LVL47:
ARM GAS  /tmp/ccysU9ly.s 			page 38


 786              	.LBB764:
 787              	.LBI764:
 788              		.file 9 "MotorControl/mechanical_brake.hpp"
   1:MotorControl/mechanical_brake.hpp **** #ifndef __MECHANICAL_BRAKE_HPP
   2:MotorControl/mechanical_brake.hpp **** #define __MECHANICAL_BRAKE_HPP
   3:MotorControl/mechanical_brake.hpp **** 
   4:MotorControl/mechanical_brake.hpp **** #include <autogen/interfaces.hpp>
   5:MotorControl/mechanical_brake.hpp **** 
   6:MotorControl/mechanical_brake.hpp **** class MechanicalBrake : public ODriveIntf::MechanicalBrakeIntf  {
   7:MotorControl/mechanical_brake.hpp ****    public:
   8:MotorControl/mechanical_brake.hpp ****     struct Config_t {
   9:MotorControl/mechanical_brake.hpp ****         uint16_t gpio_num = 0;
  10:MotorControl/mechanical_brake.hpp ****         bool is_active_low = true;
  11:MotorControl/mechanical_brake.hpp **** 
  12:MotorControl/mechanical_brake.hpp ****         // custom setters
  13:MotorControl/mechanical_brake.hpp ****         MechanicalBrake* parent = nullptr;
  14:MotorControl/mechanical_brake.hpp ****         void set_gpio_num(uint16_t value) { gpio_num = value; }
  15:MotorControl/mechanical_brake.hpp ****     };
  16:MotorControl/mechanical_brake.hpp **** 
  17:MotorControl/mechanical_brake.hpp ****     MechanicalBrake() {}
 789              		.loc 9 17 5 view .LVU118
 790              	.LBB765:
 791              	.LBB766:
 792              	.LBI766:
 793              		.file 10 "./autogen/interfaces.hpp"
   1:./autogen/interfaces.hpp **** /*
   2:./autogen/interfaces.hpp ****  * ============================ WARNING ============================
   3:./autogen/interfaces.hpp ****  * ==== This is an autogenerated file.                          ====
   4:./autogen/interfaces.hpp ****  * ==== Any changes to this file will be lost when recompiling. ====
   5:./autogen/interfaces.hpp ****  * =================================================================
   6:./autogen/interfaces.hpp ****  *
   7:./autogen/interfaces.hpp ****  * This file contains base classes that correspond to the interfaces defined in
   8:./autogen/interfaces.hpp ****  * your interface file. The objects you publish should inherit from these
   9:./autogen/interfaces.hpp ****  * interfaces.
  10:./autogen/interfaces.hpp ****  *
  11:./autogen/interfaces.hpp ****  */
  12:./autogen/interfaces.hpp **** #ifndef __FIBRE_INTERFACES_HPP
  13:./autogen/interfaces.hpp **** #define __FIBRE_INTERFACES_HPP
  14:./autogen/interfaces.hpp **** 
  15:./autogen/interfaces.hpp **** #include <tuple>
  16:./autogen/interfaces.hpp **** using float2D = std::pair<float, float>;
  17:./autogen/interfaces.hpp **** struct Iph_ABC_t { float phA; float phB; float phC; };
  18:./autogen/interfaces.hpp **** 
  19:./autogen/interfaces.hpp **** 
  20:./autogen/interfaces.hpp **** #include <fibre/../../protocol.hpp>
  21:./autogen/interfaces.hpp **** 
  22:./autogen/interfaces.hpp **** #pragma GCC push_options
  23:./autogen/interfaces.hpp **** #pragma GCC optimize ("s")
  24:./autogen/interfaces.hpp **** 
  25:./autogen/interfaces.hpp **** 
  26:./autogen/interfaces.hpp **** 
  27:./autogen/interfaces.hpp **** class ODriveIntf {
  28:./autogen/interfaces.hpp **** public:
  29:./autogen/interfaces.hpp ****     class ConfigIntf {
  30:./autogen/interfaces.hpp ****     public:
  31:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_a(T* obj) { return Property<bool>{&
  32:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_a(T* obj, void* ptr) { new (ptr) Pr
ARM GAS  /tmp/ccysU9ly.s 			page 39


  33:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_b(T* obj) { return Property<bool>{&
  34:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_b(T* obj, void* ptr) { new (ptr) Pr
  35:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_c(T* obj) { return Property<bool>{&
  36:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_c(T* obj, void* ptr) { new (ptr) Pr
  37:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_a_baudrate(T* obj) { return Property<uint3
  38:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_a_baudrate(T* obj, void* ptr) { new (ptr) 
  39:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_b_baudrate(T* obj) { return Property<uint3
  40:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_b_baudrate(T* obj, void* ptr) { new (ptr) 
  41:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_c_baudrate(T* obj) { return Property<uint3
  42:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_c_baudrate(T* obj, void* ptr) { new (ptr) 
  43:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_can_a(T* obj) { return Property<bool>{&o
  44:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_can_a(T* obj, void* ptr) { new (ptr) Pro
  45:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_i2c_a(T* obj) { return Property<bool>{&o
  46:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_i2c_a(T* obj, void* ptr) { new (ptr) Pro
  47:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_usb_cdc_protocol(T* obj) { return Property<ODri
  48:./autogen/interfaces.hpp ****         template<typename T> static inline void get_usb_cdc_protocol(T* obj, void* ptr) { new (ptr)
  49:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart0_protocol(T* obj) { return Property<ODrive
  50:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart0_protocol(T* obj, void* ptr) { new (ptr) P
  51:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart1_protocol(T* obj) { return Property<ODrive
  52:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart1_protocol(T* obj, void* ptr) { new (ptr) P
  53:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart2_protocol(T* obj) { return Property<ODrive
  54:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart2_protocol(T* obj, void* ptr) { new (ptr) P
  55:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_regen_current(T* obj) { return Property<flo
  56:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_regen_current(T* obj, void* ptr) { new (ptr
  57:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_brake_resistance(T* obj) { return Property<floa
  58:./autogen/interfaces.hpp ****         template<typename T> static inline void get_brake_resistance(T* obj, void* ptr) { new (ptr)
  59:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_brake_resistor(T* obj) { return Property
  60:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_brake_resistor(T* obj, void* ptr) { new 
  61:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_undervoltage_trip_level(T* obj) { return
  62:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_undervoltage_trip_level(T* obj, void* pt
  63:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_trip_level(T* obj) { return 
  64:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_trip_level(T* obj, void* ptr
  65:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_dc_bus_overvoltage_ramp(T* obj) { return
  66:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_dc_bus_overvoltage_ramp(T* obj, void* pt
  67:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_ramp_start(T* obj) { return 
  68:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_ramp_start(T* obj, void* ptr
  69:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_ramp_end(T* obj) { return Pr
  70:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_ramp_end(T* obj, void* ptr) 
  71:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_max_positive_current(T* obj) { return Proper
  72:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_max_positive_current(T* obj, void* ptr) { ne
  73:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_max_negative_current(T* obj) { return Proper
  74:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_max_negative_current(T* obj, void* ptr) { ne
  75:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error_gpio_pin(T* obj) { return Property<uint32
  76:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error_gpio_pin(T* obj, void* ptr) { new (ptr) P
  77:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio3_analog_mapping(T* obj) { return &obj->ana
  78:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio4_analog_mapping(T* obj) { return &obj->ana
  79:./autogen/interfaces.hpp ****     };
  80:./autogen/interfaces.hpp ****     class CanIntf {
  81:./autogen/interfaces.hpp ****     public:
  82:./autogen/interfaces.hpp ****         class ConfigIntf {
  83:./autogen/interfaces.hpp ****         public:
  84:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_baud_rate(T* obj) { return Property<uint32_
  85:./autogen/interfaces.hpp ****             template<typename T> static inline void get_baud_rate(T* obj, void* ptr) { new (ptr) Pr
  86:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_protocol(T* obj) { return Property<ODriveIn
  87:./autogen/interfaces.hpp ****             template<typename T> static inline void get_protocol(T* obj, void* ptr) { new (ptr) Pro
  88:./autogen/interfaces.hpp ****         };
  89:./autogen/interfaces.hpp ****         enum Error {
ARM GAS  /tmp/ccysU9ly.s 			page 40


  90:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
  91:./autogen/interfaces.hpp ****             ERROR_DUPLICATE_CAN_IDS          = 0x00000001,
  92:./autogen/interfaces.hpp ****         };
  93:./autogen/interfaces.hpp ****         enum Protocol {
  94:./autogen/interfaces.hpp ****             PROTOCOL_SIMPLE                  = 0x00000001,
  95:./autogen/interfaces.hpp ****         };
  96:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Can
  97:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
  98:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
  99:./autogen/interfaces.hpp ****     };
 100:./autogen/interfaces.hpp ****     class EndpointIntf {
 101:./autogen/interfaces.hpp ****     public:
 102:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_endpoint(T* obj) { return Property<endpoint_ref
 103:./autogen/interfaces.hpp ****         template<typename T> static inline void get_endpoint(T* obj, void* ptr) { new (ptr) Propert
 104:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_min(T* obj) { return Property<float>{&obj->min}
 105:./autogen/interfaces.hpp ****         template<typename T> static inline void get_min(T* obj, void* ptr) { new (ptr) Property<flo
 106:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max(T* obj) { return Property<float>{&obj->max}
 107:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max(T* obj, void* ptr) { new (ptr) Property<flo
 108:./autogen/interfaces.hpp ****     };
 109:./autogen/interfaces.hpp ****     class AxisIntf {
 110:./autogen/interfaces.hpp ****     public:
 111:./autogen/interfaces.hpp ****         class LockinConfigIntf {
 112:./autogen/interfaces.hpp ****         public:
 113:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current(T* obj) { return Property<float>{&o
 114:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current(T* obj, void* ptr) { new (ptr) Prop
 115:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ramp_time(T* obj) { return Property<float>{
 116:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ramp_time(T* obj, void* ptr) { new (ptr) Pr
 117:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ramp_distance(T* obj) { return Property<flo
 118:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ramp_distance(T* obj, void* ptr) { new (ptr
 119:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_accel(T* obj) { return Property<float>{&obj
 120:./autogen/interfaces.hpp ****             template<typename T> static inline void get_accel(T* obj, void* ptr) { new (ptr) Proper
 121:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel(T* obj) { return Property<float>{&obj->
 122:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel(T* obj, void* ptr) { new (ptr) Property
 123:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_distance(T* obj) { return Property<f
 124:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_distance(T* obj, void* ptr) { new (p
 125:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_vel(T* obj) { return Property<boo
 126:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_vel(T* obj, void* ptr) { new (ptr
 127:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_distance(T* obj) { return Propert
 128:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_distance(T* obj, void* ptr) { new
 129:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_enc_idx(T* obj) { return Property
 130:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_enc_idx(T* obj, void* ptr) { new 
 131:./autogen/interfaces.hpp ****         };
 132:./autogen/interfaces.hpp ****         class CanConfigIntf {
 133:./autogen/interfaces.hpp ****         public:
 134:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_node_id(T* obj) { return Property<uint32_t>
 135:./autogen/interfaces.hpp ****             template<typename T> static inline void get_node_id(T* obj, void* ptr) { new (ptr) Prop
 136:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_is_extended(T* obj) { return Property<bool>
 137:./autogen/interfaces.hpp ****             template<typename T> static inline void get_is_extended(T* obj, void* ptr) { new (ptr) 
 138:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_heartbeat_rate_ms(T* obj) { return Property
 139:./autogen/interfaces.hpp ****             template<typename T> static inline void get_heartbeat_rate_ms(T* obj, void* ptr) { new 
 140:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_rate_ms(T* obj) { return Property<u
 141:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_rate_ms(T* obj, void* ptr) { new (p
 142:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_error_rate_ms(T* obj) { return Proper
 143:./autogen/interfaces.hpp ****             template<typename T> static inline void get_motor_error_rate_ms(T* obj, void* ptr) { ne
 144:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_error_rate_ms(T* obj) { return Prop
 145:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_error_rate_ms(T* obj, void* ptr) { 
 146:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_controller_error_rate_ms(T* obj) { return P
ARM GAS  /tmp/ccysU9ly.s 			page 41


 147:./autogen/interfaces.hpp ****             template<typename T> static inline void get_controller_error_rate_ms(T* obj, void* ptr)
 148:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_error_rate_ms(T* obj) { return P
 149:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sensorless_error_rate_ms(T* obj, void* ptr)
 150:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_count_rate_ms(T* obj) { return Prop
 151:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_count_rate_ms(T* obj, void* ptr) { 
 152:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_iq_rate_ms(T* obj) { return Property<uint32
 153:./autogen/interfaces.hpp ****             template<typename T> static inline void get_iq_rate_ms(T* obj, void* ptr) { new (ptr) P
 154:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_rate_ms(T* obj) { return Propert
 155:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sensorless_rate_ms(T* obj, void* ptr) { new
 156:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bus_vi_rate_ms(T* obj) { return Property<ui
 157:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bus_vi_rate_ms(T* obj, void* ptr) { new (pt
 158:./autogen/interfaces.hpp ****         };
 159:./autogen/interfaces.hpp ****         class ConfigIntf {
 160:./autogen/interfaces.hpp ****         public:
 161:./autogen/interfaces.hpp ****             class CalibrationLockinIntf {
 162:./autogen/interfaces.hpp ****             public:
 163:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_current(T* obj) { return Property<float
 164:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_current(T* obj, void* ptr) { new (ptr) 
 165:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_ramp_time(T* obj) { return Property<flo
 166:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_ramp_time(T* obj, void* ptr) { new (ptr
 167:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_ramp_distance(T* obj) { return Property
 168:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_ramp_distance(T* obj, void* ptr) { new 
 169:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_accel(T* obj) { return Property<float>{
 170:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_accel(T* obj, void* ptr) { new (ptr) Pr
 171:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_vel(T* obj) { return Property<float>{&o
 172:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_vel(T* obj, void* ptr) { new (ptr) Prop
 173:./autogen/interfaces.hpp ****             };
 174:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_motor_calibration(T* obj) { return 
 175:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_motor_calibration(T* obj, void* ptr
 176:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_encoder_index_search(T* obj) { retu
 177:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_encoder_index_search(T* obj, void* 
 178:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_encoder_offset_calibration(T* obj) 
 179:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_encoder_offset_calibration(T* obj, 
 180:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_closed_loop_control(T* obj) { retur
 181:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_closed_loop_control(T* obj, void* p
 182:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_homing(T* obj) { return Property<bo
 183:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_homing(T* obj, void* ptr) { new (pt
 184:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_step_dir(T* obj) { return Property<b
 185:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_step_dir(T* obj, void* ptr) { new (p
 186:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_step_dir_always_on(T* obj) { return Propert
 187:./autogen/interfaces.hpp ****             template<typename T> static inline void get_step_dir_always_on(T* obj, void* ptr) { new
 188:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_sensorless_mode(T* obj) { return Pro
 189:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_sensorless_mode(T* obj, void* ptr) {
 190:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_watchdog_timeout(T* obj) { return Property<
 191:./autogen/interfaces.hpp ****             template<typename T> static inline void get_watchdog_timeout(T* obj, void* ptr) { new (
 192:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_watchdog(T* obj) { return Property<b
 193:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_watchdog(T* obj, void* ptr) { new (p
 194:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_step_gpio_pin(T* obj) { return Property<uin
 195:./autogen/interfaces.hpp ****             template<typename T> static inline void get_step_gpio_pin(T* obj, void* ptr) { new (ptr
 196:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dir_gpio_pin(T* obj) { return Property<uint
 197:./autogen/interfaces.hpp ****             template<typename T> static inline void get_dir_gpio_pin(T* obj, void* ptr) { new (ptr)
 198:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calibration_lockin(T* obj) { return &obj->c
 199:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_ramp(T* obj) { return &obj->sens
 200:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_general_lockin(T* obj) { return &obj->gener
 201:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_can(T* obj) { return &obj->can; }
 202:./autogen/interfaces.hpp ****         };
 203:./autogen/interfaces.hpp ****         class TaskTimesIntf {
ARM GAS  /tmp/ccysU9ly.s 			page 42


 204:./autogen/interfaces.hpp ****         public:
 205:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_thermistor_update(T* obj) { return &obj->th
 206:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_update(T* obj) { return &obj->encod
 207:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_estimator_update(T* obj) { retur
 208:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_endstop_update(T* obj) { return &obj->endst
 209:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_can_heartbeat(T* obj) { return &obj->can_he
 210:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_controller_update(T* obj) { return &obj->co
 211:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_open_loop_controller_update(T* obj) { retur
 212:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_estimator_update(T* obj) { return &obj
 213:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_update(T* obj) { return &obj->motor_u
 214:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_controller_update(T* obj) { return 
 215:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dc_calib(T* obj) { return &obj->dc_calib; }
 216:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_sense(T* obj) { return &obj->curren
 217:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pwm_update(T* obj) { return &obj->pwm_updat
 218:./autogen/interfaces.hpp ****         };
 219:./autogen/interfaces.hpp ****         enum Error {
 220:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 221:./autogen/interfaces.hpp ****             ERROR_INVALID_STATE              = 0x00000001,
 222:./autogen/interfaces.hpp ****             ERROR_MOTOR_FAILED               = 0x00000040,
 223:./autogen/interfaces.hpp ****             ERROR_SENSORLESS_ESTIMATOR_FAILED = 0x00000080,
 224:./autogen/interfaces.hpp ****             ERROR_ENCODER_FAILED             = 0x00000100,
 225:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_FAILED          = 0x00000200,
 226:./autogen/interfaces.hpp ****             ERROR_WATCHDOG_TIMER_EXPIRED     = 0x00000800,
 227:./autogen/interfaces.hpp ****             ERROR_MIN_ENDSTOP_PRESSED        = 0x00001000,
 228:./autogen/interfaces.hpp ****             ERROR_MAX_ENDSTOP_PRESSED        = 0x00002000,
 229:./autogen/interfaces.hpp ****             ERROR_ESTOP_REQUESTED            = 0x00004000,
 230:./autogen/interfaces.hpp ****             ERROR_HOMING_WITHOUT_ENDSTOP     = 0x00020000,
 231:./autogen/interfaces.hpp ****             ERROR_OVER_TEMP                  = 0x00040000,
 232:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_POSITION           = 0x00080000,
 233:./autogen/interfaces.hpp ****         };
 234:./autogen/interfaces.hpp ****         enum AxisState {
 235:./autogen/interfaces.hpp ****             AXIS_STATE_UNDEFINED             = 0,
 236:./autogen/interfaces.hpp ****             AXIS_STATE_IDLE                  = 1,
 237:./autogen/interfaces.hpp ****             AXIS_STATE_STARTUP_SEQUENCE      = 2,
 238:./autogen/interfaces.hpp ****             AXIS_STATE_FULL_CALIBRATION_SEQUENCE = 3,
 239:./autogen/interfaces.hpp ****             AXIS_STATE_MOTOR_CALIBRATION     = 4,
 240:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_INDEX_SEARCH  = 6,
 241:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_OFFSET_CALIBRATION = 7,
 242:./autogen/interfaces.hpp ****             AXIS_STATE_CLOSED_LOOP_CONTROL   = 8,
 243:./autogen/interfaces.hpp ****             AXIS_STATE_LOCKIN_SPIN           = 9,
 244:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_DIR_FIND      = 10,
 245:./autogen/interfaces.hpp ****             AXIS_STATE_HOMING                = 11,
 246:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_HALL_POLARITY_CALIBRATION = 12,
 247:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_HALL_PHASE_CALIBRATION = 13,
 248:./autogen/interfaces.hpp ****         };
 249:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Axi
 250:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 251:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_step_dir_active(T* obj) { return Property<const
 252:./autogen/interfaces.hpp ****         template<typename T> static inline void get_step_dir_active(T* obj, void* ptr) { new (ptr) 
 253:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_drv_fault(T* obj) { return Property<const 
 254:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_drv_fault(T* obj, void* ptr) { new (ptr) P
 255:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_steps(T* obj) { return Property<const int64_t>{
 256:./autogen/interfaces.hpp ****         template<typename T> static inline void get_steps(T* obj, void* ptr) { new (ptr) Property<c
 257:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_state(T* obj) { return Property<const O
 258:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_state(T* obj, void* ptr) { new (ptr) Pr
 259:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_requested_state(T* obj) { return Property<ODriv
 260:./autogen/interfaces.hpp ****         template<typename T> static inline void get_requested_state(T* obj, void* ptr) { new (ptr) 
ARM GAS  /tmp/ccysU9ly.s 			page 43


 261:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_homed(T* obj) { return Property<bool>{&obj->
 262:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_homed(T* obj, void* ptr) { new (ptr) Propert
 263:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 264:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_motor(T* obj) { return &obj->motor_; }
 265:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_controller(T* obj) { return &obj->controller_; 
 266:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_encoder(T* obj) { return &obj->encoder_; }
 267:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_acim_estimator(T* obj) { return &obj->acim_esti
 268:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_sensorless_estimator(T* obj) { return &obj->sen
 269:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_trap_traj(T* obj) { return &obj->trap_traj_; }
 270:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_min_endstop(T* obj) { return &obj->min_endstop_
 271:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_endstop(T* obj) { return &obj->max_endstop_
 272:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_mechanical_brake(T* obj) { return &obj->mechani
 273:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_task_times(T* obj) { return &obj->task_times_; 
 274:./autogen/interfaces.hpp ****         virtual void watchdog_feed() = 0;
 275:./autogen/interfaces.hpp ****     };
 276:./autogen/interfaces.hpp ****     class ThermistorCurrentLimiterIntf {
 277:./autogen/interfaces.hpp ****     public:
 278:./autogen/interfaces.hpp ****     };
 279:./autogen/interfaces.hpp ****     class OnboardThermistorCurrentLimiterIntf {
 280:./autogen/interfaces.hpp ****     public:
 281:./autogen/interfaces.hpp ****         class ConfigIntf {
 282:./autogen/interfaces.hpp ****         public:
 283:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_lower(T* obj) { return Property<
 284:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_lower(T* obj, void* ptr) { new (
 285:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_upper(T* obj) { return Property<
 286:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_upper(T* obj, void* ptr) { new (
 287:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{&ob
 288:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
 289:./autogen/interfaces.hpp ****         };
 290:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_temperature(T* obj) { return Property<const flo
 291:./autogen/interfaces.hpp ****         template<typename T> static inline void get_temperature(T* obj, void* ptr) { new (ptr) Prop
 292:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 293:./autogen/interfaces.hpp ****     };
 294:./autogen/interfaces.hpp ****     class OffboardThermistorCurrentLimiterIntf {
 295:./autogen/interfaces.hpp ****     public:
 296:./autogen/interfaces.hpp ****         class ConfigIntf {
 297:./autogen/interfaces.hpp ****         public:
 298:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gpio_pin(T* obj) { return Property<uint16_t
 299:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gpio_pin(T* obj, void* ptr) { new (ptr) Pro
 300:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_0(T* obj) { return Propert
 301:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_0(T* obj, void* ptr) { new
 302:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_1(T* obj) { return Propert
 303:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_1(T* obj, void* ptr) { new
 304:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_2(T* obj) { return Propert
 305:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_2(T* obj, void* ptr) { new
 306:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_3(T* obj) { return Propert
 307:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_3(T* obj, void* ptr) { new
 308:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_lower(T* obj) { return Property<
 309:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_lower(T* obj, void* ptr) { new (
 310:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_upper(T* obj) { return Property<
 311:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_upper(T* obj, void* ptr) { new (
 312:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{&ob
 313:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
 314:./autogen/interfaces.hpp ****         };
 315:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_temperature(T* obj) { return Property<const flo
 316:./autogen/interfaces.hpp ****         template<typename T> static inline void get_temperature(T* obj, void* ptr) { new (ptr) Prop
 317:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
ARM GAS  /tmp/ccysU9ly.s 			page 44


 318:./autogen/interfaces.hpp ****     };
 319:./autogen/interfaces.hpp ****     class MotorIntf {
 320:./autogen/interfaces.hpp ****     public:
 321:./autogen/interfaces.hpp ****         class CurrentControlIntf {
 322:./autogen/interfaces.hpp ****         public:
 323:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_p_gain(T* obj) { return Property<const floa
 324:./autogen/interfaces.hpp ****             template<typename T> static inline void get_p_gain(T* obj, void* ptr) { new (ptr) Prope
 325:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_i_gain(T* obj) { return Property<const floa
 326:./autogen/interfaces.hpp ****             template<typename T> static inline void get_i_gain(T* obj, void* ptr) { new (ptr) Prope
 327:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_measured_report_filter_k(T* obj) { return
 328:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_measured_report_filter_k(T* obj, void* pt
 329:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Id_setpoint(T* obj) { return Property<const
 330:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Id_setpoint(T* obj, void* ptr) { new (ptr) 
 331:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Iq_setpoint(T* obj) { return Property<const
 332:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Iq_setpoint(T* obj, void* ptr) { new (ptr) 
 333:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Vd_setpoint(T* obj) { return Property<const
 334:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Vd_setpoint(T* obj, void* ptr) { new (ptr) 
 335:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Vq_setpoint(T* obj) { return Property<const
 336:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Vq_setpoint(T* obj, void* ptr) { new (ptr) 
 337:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase(T* obj) { return Property<const float
 338:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Proper
 339:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_vel(T* obj) { return Property<const f
 340:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_vel(T* obj, void* ptr) { new (ptr) Pr
 341:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Ialpha_measured(T* obj) { return Property<c
 342:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Ialpha_measured(T* obj, void* ptr) { new (p
 343:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Ibeta_measured(T* obj) { return Property<co
 344:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Ibeta_measured(T* obj, void* ptr) { new (pt
 345:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Id_measured(T* obj) { return Property<const
 346:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Id_measured(T* obj, void* ptr) { new (ptr) 
 347:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Iq_measured(T* obj) { return Property<const
 348:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Iq_measured(T* obj, void* ptr) { new (ptr) 
 349:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_power(T* obj) { return Property<const float
 350:./autogen/interfaces.hpp ****             template<typename T> static inline void get_power(T* obj, void* ptr) { new (ptr) Proper
 351:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_v_current_control_integral_d(T* obj) { retu
 352:./autogen/interfaces.hpp ****             template<typename T> static inline void get_v_current_control_integral_d(T* obj, void* 
 353:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_v_current_control_integral_q(T* obj) { retu
 354:./autogen/interfaces.hpp ****             template<typename T> static inline void get_v_current_control_integral_q(T* obj, void* 
 355:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_final_v_alpha(T* obj) { return Property<con
 356:./autogen/interfaces.hpp ****             template<typename T> static inline void get_final_v_alpha(T* obj, void* ptr) { new (ptr
 357:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_final_v_beta(T* obj) { return Property<cons
 358:./autogen/interfaces.hpp ****             template<typename T> static inline void get_final_v_beta(T* obj, void* ptr) { new (ptr)
 359:./autogen/interfaces.hpp ****         };
 360:./autogen/interfaces.hpp ****         class ConfigIntf {
 361:./autogen/interfaces.hpp ****         public:
 362:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bo
 363:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (pt
 364:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pole_pairs(T* obj) { return Property<int32_
 365:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pole_pairs(T* obj, void* ptr) { new (ptr) P
 366:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calibration_current(T* obj) { return Proper
 367:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calibration_current(T* obj, void* ptr) { ne
 368:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_resistance_calib_max_voltage(T* obj) { retu
 369:./autogen/interfaces.hpp ****             template<typename T> static inline void get_resistance_calib_max_voltage(T* obj, void* 
 370:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_inductance(T* obj) { return Property<
 371:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_inductance(T* obj, void* ptr) { new (
 372:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_resistance(T* obj) { return Property<
 373:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_resistance(T* obj, void* ptr) { new (
 374:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_constant(T* obj) { return Property<f
ARM GAS  /tmp/ccysU9ly.s 			page 45


 375:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_constant(T* obj, void* ptr) { new (p
 376:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_type(T* obj) { return Property<ODrive
 377:./autogen/interfaces.hpp ****             template<typename T> static inline void get_motor_type(T* obj, void* ptr) { new (ptr) P
 378:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_lim(T* obj) { return Property<float
 379:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_lim(T* obj, void* ptr) { new (ptr) 
 380:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_lim_margin(T* obj) { return Propert
 381:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_lim_margin(T* obj, void* ptr) { new
 382:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_lim(T* obj) { return Property<float>
 383:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_lim(T* obj, void* ptr) { new (ptr) P
 384:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inverter_temp_limit_lower(T* obj) { return 
 385:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inverter_temp_limit_lower(T* obj, void* ptr
 386:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inverter_temp_limit_upper(T* obj) { return 
 387:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inverter_temp_limit_upper(T* obj, void* ptr
 388:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_requested_current_range(T* obj) { return Pr
 389:./autogen/interfaces.hpp ****             template<typename T> static inline void get_requested_current_range(T* obj, void* ptr) 
 390:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_control_bandwidth(T* obj) { return 
 391:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_control_bandwidth(T* obj, void* ptr
 392:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_gain_min_flux(T* obj) { return Propert
 393:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_gain_min_flux(T* obj, void* ptr) { new
 394:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_min_Id(T* obj) { return Prope
 395:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_min_Id(T* obj, void* ptr) { n
 396:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_enable(T* obj) { return Prope
 397:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_enable(T* obj, void* ptr) { n
 398:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_attack_gain(T* obj) { return 
 399:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_attack_gain(T* obj, void* ptr
 400:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_decay_gain(T* obj) { return P
 401:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_decay_gain(T* obj, void* ptr)
 402:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_R_wL_FF_enable(T* obj) { return Property<bo
 403:./autogen/interfaces.hpp ****             template<typename T> static inline void get_R_wL_FF_enable(T* obj, void* ptr) { new (pt
 404:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bEMF_FF_enable(T* obj) { return Property<bo
 405:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bEMF_FF_enable(T* obj, void* ptr) { new (pt
 406:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_bus_hard_min(T* obj) { return Property<fl
 407:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_bus_hard_min(T* obj, void* ptr) { new (pt
 408:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_bus_hard_max(T* obj) { return Property<fl
 409:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_bus_hard_max(T* obj, void* ptr) { new (pt
 410:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_leak_max(T* obj) { return Property<float>
 411:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_leak_max(T* obj, void* ptr) { new (ptr) P
 412:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dc_calib_tau(T* obj) { return Property<floa
 413:./autogen/interfaces.hpp ****             template<typename T> static inline void get_dc_calib_tau(T* obj, void* ptr) { new (ptr)
 414:./autogen/interfaces.hpp ****         };
 415:./autogen/interfaces.hpp ****         enum Error {
 416:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 417:./autogen/interfaces.hpp ****             ERROR_PHASE_RESISTANCE_OUT_OF_RANGE = 0x00000001,
 418:./autogen/interfaces.hpp ****             ERROR_PHASE_INDUCTANCE_OUT_OF_RANGE = 0x00000002,
 419:./autogen/interfaces.hpp ****             ERROR_DRV_FAULT                  = 0x00000008,
 420:./autogen/interfaces.hpp ****             ERROR_CONTROL_DEADLINE_MISSED    = 0x00000010,
 421:./autogen/interfaces.hpp ****             ERROR_MODULATION_MAGNITUDE       = 0x00000080,
 422:./autogen/interfaces.hpp ****             ERROR_CURRENT_SENSE_SATURATION   = 0x00000400,
 423:./autogen/interfaces.hpp ****             ERROR_CURRENT_LIMIT_VIOLATION    = 0x00001000,
 424:./autogen/interfaces.hpp ****             ERROR_MODULATION_IS_NAN          = 0x00010000,
 425:./autogen/interfaces.hpp ****             ERROR_MOTOR_THERMISTOR_OVER_TEMP = 0x00020000,
 426:./autogen/interfaces.hpp ****             ERROR_FET_THERMISTOR_OVER_TEMP   = 0x00040000,
 427:./autogen/interfaces.hpp ****             ERROR_TIMER_UPDATE_MISSED        = 0x00080000,
 428:./autogen/interfaces.hpp ****             ERROR_CURRENT_MEASUREMENT_UNAVAILABLE = 0x00100000,
 429:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_FAILED          = 0x00200000,
 430:./autogen/interfaces.hpp ****             ERROR_I_BUS_OUT_OF_RANGE         = 0x00400000,
 431:./autogen/interfaces.hpp ****             ERROR_BRAKE_RESISTOR_DISARMED    = 0x00800000,
ARM GAS  /tmp/ccysU9ly.s 			page 46


 432:./autogen/interfaces.hpp ****             ERROR_SYSTEM_LEVEL               = 0x01000000,
 433:./autogen/interfaces.hpp ****             ERROR_BAD_TIMING                 = 0x02000000,
 434:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_PHASE_ESTIMATE     = 0x04000000,
 435:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_PHASE_VEL          = 0x08000000,
 436:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_TORQUE             = 0x10000000,
 437:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_COMMAND    = 0x20000000,
 438:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x40000000,
 439:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_VBUS_VOLTAGE       = 0x80000000,
 440:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_VOLTAGE_COMMAND    = 0x100000000,
 441:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_GAINS              = 0x200000000,
 442:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_INITIALIZING    = 0x400000000,
 443:./autogen/interfaces.hpp ****             ERROR_UNBALANCED_PHASES          = 0x800000000,
 444:./autogen/interfaces.hpp ****         };
 445:./autogen/interfaces.hpp ****         enum MotorType {
 446:./autogen/interfaces.hpp ****             MOTOR_TYPE_HIGH_CURRENT          = 0,
 447:./autogen/interfaces.hpp ****             MOTOR_TYPE_GIMBAL                = 2,
 448:./autogen/interfaces.hpp ****             MOTOR_TYPE_ACIM                  = 3,
 449:./autogen/interfaces.hpp ****         };
 450:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_error_time(T* obj) { return Property<float
 451:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_error_time(T* obj, void* ptr) { new (ptr) 
 452:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Mot
 453:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 454:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_armed(T* obj) { return Property<const bool>{
 455:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_armed(T* obj, void* ptr) { new (ptr) Propert
 456:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_calibrated(T* obj) { return Property<const b
 457:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_calibrated(T* obj, void* ptr) { new (ptr) Pr
 458:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phA(T* obj) { return Property<cons
 459:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phA(T* obj, void* ptr) { new (ptr)
 460:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phB(T* obj) { return Property<cons
 461:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phB(T* obj, void* ptr) { new (ptr)
 462:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phC(T* obj) { return Property<cons
 463:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phC(T* obj, void* ptr) { new (ptr)
 464:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phA(T* obj) { return Property<float>{&
 465:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phA(T* obj, void* ptr) { new (ptr) Pro
 466:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phB(T* obj) { return Property<float>{&
 467:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phB(T* obj, void* ptr) { new (ptr) Pro
 468:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phC(T* obj) { return Property<float>{&
 469:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phC(T* obj, void* ptr) { new (ptr) Pro
 470:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_I_bus(T* obj) { return Property<const float>{&o
 471:./autogen/interfaces.hpp ****         template<typename T> static inline void get_I_bus(T* obj, void* ptr) { new (ptr) Property<c
 472:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_current_rev_gain(T* obj) { return Propert
 473:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_current_rev_gain(T* obj, void* ptr) { new
 474:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_effective_current_lim(T* obj) { return Property
 475:./autogen/interfaces.hpp ****         template<typename T> static inline void get_effective_current_lim(T* obj, void* ptr) { new 
 476:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_allowed_current(T* obj) { return Property<c
 477:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_allowed_current(T* obj, void* ptr) { new (p
 478:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_dc_calib(T* obj) { return Property<const fl
 479:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_dc_calib(T* obj, void* ptr) { new (ptr) Pro
 480:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_fet_thermistor(T* obj) { return &obj->fet_therm
 481:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_motor_thermistor(T* obj) { return &obj->motor_t
 482:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_control(T* obj) { return &obj->current_
 483:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_n_evt_current_measurement(T* obj) { return Prop
 484:./autogen/interfaces.hpp ****         template<typename T> static inline void get_n_evt_current_measurement(T* obj, void* ptr) { 
 485:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_n_evt_pwm_update(T* obj) { return Property<cons
 486:./autogen/interfaces.hpp ****         template<typename T> static inline void get_n_evt_pwm_update(T* obj, void* ptr) { new (ptr)
 487:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 488:./autogen/interfaces.hpp ****     };
ARM GAS  /tmp/ccysU9ly.s 			page 47


 489:./autogen/interfaces.hpp ****     class OscilloscopeIntf {
 490:./autogen/interfaces.hpp ****     public:
 491:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_size(T* obj) { return Property<const uint32_t>{
 492:./autogen/interfaces.hpp ****         template<typename T> static inline void get_size(T* obj, void* ptr) { new (ptr) Property<co
 493:./autogen/interfaces.hpp ****         virtual float get_val(uint32_t index) = 0;
 494:./autogen/interfaces.hpp ****         uint32_t get_val_in_index_; // for internal use by Fibre
 495:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_val_in_index_(T* obj) { return Property<uint32_t>{
 496:./autogen/interfaces.hpp ****         template<typename T> static void get_get_val_in_index_(T* obj, void* ptr) { new (ptr) Prope
 497:./autogen/interfaces.hpp ****         float get_val_out_val_; // for internal use by Fibre
 498:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_val_out_val_(T* obj) { return Property<const float
 499:./autogen/interfaces.hpp ****         template<typename T> static void get_get_val_out_val_(T* obj, void* ptr) { new (ptr) Proper
 500:./autogen/interfaces.hpp ****     };
 501:./autogen/interfaces.hpp ****     class AcimEstimatorIntf {
 502:./autogen/interfaces.hpp ****     public:
 503:./autogen/interfaces.hpp ****         class ConfigIntf {
 504:./autogen/interfaces.hpp ****         public:
 505:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_slip_velocity(T* obj) { return Property<flo
 506:./autogen/interfaces.hpp ****             template<typename T> static inline void get_slip_velocity(T* obj, void* ptr) { new (ptr
 507:./autogen/interfaces.hpp ****         };
 508:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_rotor_flux(T* obj) { return Property<const floa
 509:./autogen/interfaces.hpp ****         template<typename T> static inline void get_rotor_flux(T* obj, void* ptr) { new (ptr) Prope
 510:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_slip_vel(T* obj) { return Property<const float>
 511:./autogen/interfaces.hpp ****         template<typename T> static inline void get_slip_vel(T* obj, void* ptr) { new (ptr) Propert
 512:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_offset(T* obj) { return Property<const fl
 513:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_offset(T* obj, void* ptr) { new (ptr) Pro
 514:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stator_phase_vel(T* obj) { return Property<cons
 515:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stator_phase_vel(T* obj, void* ptr) { new (ptr)
 516:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stator_phase(T* obj) { return Property<const fl
 517:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stator_phase(T* obj, void* ptr) { new (ptr) Pro
 518:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 519:./autogen/interfaces.hpp ****     };
 520:./autogen/interfaces.hpp ****     class ControllerIntf {
 521:./autogen/interfaces.hpp ****     public:
 522:./autogen/interfaces.hpp ****         class ConfigIntf {
 523:./autogen/interfaces.hpp ****         public:
 524:./autogen/interfaces.hpp ****             class AnticoggingIntf {
 525:./autogen/interfaces.hpp ****             public:
 526:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_index(T* obj) { return Property<const u
 527:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_index(T* obj, void* ptr) { new (ptr) Pr
 528:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_pre_calibrated(T* obj) { return Propert
 529:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new
 530:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_anticogging(T* obj) { return Prop
 531:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_anticogging(T* obj, void* ptr) { 
 532:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_pos_threshold(T* obj) { return Pr
 533:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_pos_threshold(T* obj, void* ptr) 
 534:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_vel_threshold(T* obj) { return Pr
 535:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_vel_threshold(T* obj, void* ptr) 
 536:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_cogging_ratio(T* obj) { return Property
 537:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_cogging_ratio(T* obj, void* ptr) { new 
 538:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_anticogging_enabled(T* obj) { return Pr
 539:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_anticogging_enabled(T* obj, void* ptr) 
 540:./autogen/interfaces.hpp ****             };
 541:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gain_scheduling_width(T* obj) { return Prop
 542:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gain_scheduling_width(T* obj, void* ptr) { 
 543:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_vel_limit(T* obj) { return Property<
 544:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_vel_limit(T* obj, void* ptr) { new (
 545:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_torque_mode_vel_limit(T* obj) { retu
ARM GAS  /tmp/ccysU9ly.s 			page 48


 546:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_torque_mode_vel_limit(T* obj, void* 
 547:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_gain_scheduling(T* obj) { return Pro
 548:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_gain_scheduling(T* obj, void* ptr) {
 549:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_overspeed_error(T* obj) { return Pro
 550:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_overspeed_error(T* obj, void* ptr) {
 551:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_control_mode(T* obj) { return Property<ODri
 552:./autogen/interfaces.hpp ****             template<typename T> static inline void get_control_mode(T* obj, void* ptr) { new (ptr)
 553:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_input_mode(T* obj) { return Property<ODrive
 554:./autogen/interfaces.hpp ****             template<typename T> static inline void get_input_mode(T* obj, void* ptr) { new (ptr) P
 555:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pos_gain(T* obj) { return Property<float>{&
 556:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pos_gain(T* obj, void* ptr) { new (ptr) Pro
 557:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_gain(T* obj) { return Property<float>{&
 558:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_gain(T* obj, void* ptr) { new (ptr) Pro
 559:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_integrator_gain(T* obj) { return Proper
 560:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_integrator_gain(T* obj, void* ptr) { ne
 561:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_integrator_limit(T* obj) { return Prope
 562:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_integrator_limit(T* obj, void* ptr) { n
 563:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit(T* obj) { return Property<float>{
 564:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit(T* obj, void* ptr) { new (ptr) Pr
 565:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit_tolerance(T* obj) { return Proper
 566:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit_tolerance(T* obj, void* ptr) { ne
 567:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_ramp_rate(T* obj) { return Property<flo
 568:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_ramp_rate(T* obj, void* ptr) { new (ptr
 569:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_ramp_rate(T* obj) { return Property<
 570:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_ramp_rate(T* obj, void* ptr) { new (
 571:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_circular_setpoints(T* obj) { return Propert
 572:./autogen/interfaces.hpp ****             template<typename T> static inline void get_circular_setpoints(T* obj, void* ptr) { new
 573:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_circular_setpoint_range(T* obj) { return Pr
 574:./autogen/interfaces.hpp ****             template<typename T> static inline void get_circular_setpoint_range(T* obj, void* ptr) 
 575:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_steps_per_circular_range(T* obj) { return P
 576:./autogen/interfaces.hpp ****             template<typename T> static inline void get_steps_per_circular_range(T* obj, void* ptr)
 577:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_homing_speed(T* obj) { return Property<floa
 578:./autogen/interfaces.hpp ****             template<typename T> static inline void get_homing_speed(T* obj, void* ptr) { new (ptr)
 579:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inertia(T* obj) { return Property<float>{&o
 580:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inertia(T* obj, void* ptr) { new (ptr) Prop
 581:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_axis_to_mirror(T* obj) { return Property<ui
 582:./autogen/interfaces.hpp ****             template<typename T> static inline void get_axis_to_mirror(T* obj, void* ptr) { new (pt
 583:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mirror_ratio(T* obj) { return Property<floa
 584:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mirror_ratio(T* obj, void* ptr) { new (ptr)
 585:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_mirror_ratio(T* obj) { return Proper
 586:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_mirror_ratio(T* obj, void* ptr) { ne
 587:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_load_encoder_axis(T* obj) { return Property
 588:./autogen/interfaces.hpp ****             template<typename T> static inline void get_load_encoder_axis(T* obj, void* ptr) { new 
 589:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_input_filter_bandwidth(T* obj) { return Pro
 590:./autogen/interfaces.hpp ****             template<typename T> static inline void get_input_filter_bandwidth(T* obj, void* ptr) {
 591:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_anticogging(T* obj) { return &obj->anticogg
 592:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mechanical_power_bandwidth(T* obj) { return
 593:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mechanical_power_bandwidth(T* obj, void* pt
 594:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_electrical_power_bandwidth(T* obj) { return
 595:./autogen/interfaces.hpp ****             template<typename T> static inline void get_electrical_power_bandwidth(T* obj, void* pt
 596:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_spinout_mechanical_power_threshold(T* obj) 
 597:./autogen/interfaces.hpp ****             template<typename T> static inline void get_spinout_mechanical_power_threshold(T* obj, 
 598:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_spinout_electrical_power_threshold(T* obj) 
 599:./autogen/interfaces.hpp ****             template<typename T> static inline void get_spinout_electrical_power_threshold(T* obj, 
 600:./autogen/interfaces.hpp ****         };
 601:./autogen/interfaces.hpp ****         class AutotuningIntf {
 602:./autogen/interfaces.hpp ****         public:
ARM GAS  /tmp/ccysU9ly.s 			page 49


 603:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_frequency(T* obj) { return Property<float>{
 604:./autogen/interfaces.hpp ****             template<typename T> static inline void get_frequency(T* obj, void* ptr) { new (ptr) Pr
 605:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pos_amplitude(T* obj) { return Property<flo
 606:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pos_amplitude(T* obj, void* ptr) { new (ptr
 607:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_amplitude(T* obj) { return Property<flo
 608:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_amplitude(T* obj, void* ptr) { new (ptr
 609:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_amplitude(T* obj) { return Property<
 610:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_amplitude(T* obj, void* ptr) { new (
 611:./autogen/interfaces.hpp ****         };
 612:./autogen/interfaces.hpp ****         enum Error {
 613:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 614:./autogen/interfaces.hpp ****             ERROR_OVERSPEED                  = 0x00000001,
 615:./autogen/interfaces.hpp ****             ERROR_INVALID_INPUT_MODE         = 0x00000002,
 616:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000004,
 617:./autogen/interfaces.hpp ****             ERROR_INVALID_MIRROR_AXIS        = 0x00000008,
 618:./autogen/interfaces.hpp ****             ERROR_INVALID_LOAD_ENCODER       = 0x00000010,
 619:./autogen/interfaces.hpp ****             ERROR_INVALID_ESTIMATE           = 0x00000020,
 620:./autogen/interfaces.hpp ****             ERROR_INVALID_CIRCULAR_RANGE     = 0x00000040,
 621:./autogen/interfaces.hpp ****             ERROR_SPINOUT_DETECTED           = 0x00000080,
 622:./autogen/interfaces.hpp ****         };
 623:./autogen/interfaces.hpp ****         enum ControlMode {
 624:./autogen/interfaces.hpp ****             CONTROL_MODE_VOLTAGE_CONTROL     = 0,
 625:./autogen/interfaces.hpp ****             CONTROL_MODE_TORQUE_CONTROL      = 1,
 626:./autogen/interfaces.hpp ****             CONTROL_MODE_VELOCITY_CONTROL    = 2,
 627:./autogen/interfaces.hpp ****             CONTROL_MODE_POSITION_CONTROL    = 3,
 628:./autogen/interfaces.hpp ****         };
 629:./autogen/interfaces.hpp ****         enum InputMode {
 630:./autogen/interfaces.hpp ****             INPUT_MODE_INACTIVE              = 0,
 631:./autogen/interfaces.hpp ****             INPUT_MODE_PASSTHROUGH           = 1,
 632:./autogen/interfaces.hpp ****             INPUT_MODE_VEL_RAMP              = 2,
 633:./autogen/interfaces.hpp ****             INPUT_MODE_POS_FILTER            = 3,
 634:./autogen/interfaces.hpp ****             INPUT_MODE_MIX_CHANNELS          = 4,
 635:./autogen/interfaces.hpp ****             INPUT_MODE_TRAP_TRAJ             = 5,
 636:./autogen/interfaces.hpp ****             INPUT_MODE_TORQUE_RAMP           = 6,
 637:./autogen/interfaces.hpp ****             INPUT_MODE_MIRROR                = 7,
 638:./autogen/interfaces.hpp ****             INPUT_MODE_TUNING                = 8,
 639:./autogen/interfaces.hpp ****         };
 640:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Con
 641:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 642:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_error_time(T* obj) { return Property<float
 643:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_error_time(T* obj, void* ptr) { new (ptr) 
 644:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_pos(T* obj) { return Property<float>{obj,
 645:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_pos(T* obj, void* ptr) { new (ptr) Proper
 646:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_vel(T* obj) { return Property<float>{&obj
 647:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_vel(T* obj, void* ptr) { new (ptr) Proper
 648:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_torque(T* obj) { return Property<float>{&
 649:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_torque(T* obj, void* ptr) { new (ptr) Pro
 650:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_setpoint(T* obj) { return Property<const fl
 651:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_setpoint(T* obj, void* ptr) { new (ptr) Pro
 652:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_setpoint(T* obj) { return Property<const fl
 653:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_setpoint(T* obj, void* ptr) { new (ptr) Pro
 654:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_torque_setpoint(T* obj) { return Property<const
 655:./autogen/interfaces.hpp ****         template<typename T> static inline void get_torque_setpoint(T* obj, void* ptr) { new (ptr) 
 656:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_trajectory_done(T* obj) { return Property<const
 657:./autogen/interfaces.hpp ****         template<typename T> static inline void get_trajectory_done(T* obj, void* ptr) { new (ptr) 
 658:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_integrator_torque(T* obj) { return Property
 659:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_integrator_torque(T* obj, void* ptr) { new 
ARM GAS  /tmp/ccysU9ly.s 			page 50


 660:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_anticogging_valid(T* obj) { return Property<boo
 661:./autogen/interfaces.hpp ****         template<typename T> static inline void get_anticogging_valid(T* obj, void* ptr) { new (ptr
 662:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_autotuning_phase(T* obj) { return Property<floa
 663:./autogen/interfaces.hpp ****         template<typename T> static inline void get_autotuning_phase(T* obj, void* ptr) { new (ptr)
 664:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 665:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_autotuning(T* obj) { return &obj->autotuning_; 
 666:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_mechanical_power(T* obj) { return Property<cons
 667:./autogen/interfaces.hpp ****         template<typename T> static inline void get_mechanical_power(T* obj, void* ptr) { new (ptr)
 668:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_electrical_power(T* obj) { return Property<cons
 669:./autogen/interfaces.hpp ****         template<typename T> static inline void get_electrical_power(T* obj, void* ptr) { new (ptr)
 670:./autogen/interfaces.hpp ****         virtual void move_incremental(float displacement, bool from_input_pos) = 0;
 671:./autogen/interfaces.hpp ****         virtual void start_anticogging_calibration() = 0;
 672:./autogen/interfaces.hpp ****         virtual float remove_anticogging_bias() = 0;
 673:./autogen/interfaces.hpp ****         virtual float get_anticogging_value(uint32_t index) = 0;
 674:./autogen/interfaces.hpp ****         float move_incremental_in_displacement_; // for internal use by Fibre
 675:./autogen/interfaces.hpp ****         template<typename T> static auto get_move_incremental_in_displacement_(T* obj) { return Pro
 676:./autogen/interfaces.hpp ****         template<typename T> static void get_move_incremental_in_displacement_(T* obj, void* ptr) {
 677:./autogen/interfaces.hpp ****         bool move_incremental_in_from_input_pos_; // for internal use by Fibre
 678:./autogen/interfaces.hpp ****         template<typename T> static auto get_move_incremental_in_from_input_pos_(T* obj) { return P
 679:./autogen/interfaces.hpp ****         template<typename T> static void get_move_incremental_in_from_input_pos_(T* obj, void* ptr)
 680:./autogen/interfaces.hpp ****         float remove_anticogging_bias_out_val_; // for internal use by Fibre
 681:./autogen/interfaces.hpp ****         template<typename T> static auto get_remove_anticogging_bias_out_val_(T* obj) { return Prop
 682:./autogen/interfaces.hpp ****         template<typename T> static void get_remove_anticogging_bias_out_val_(T* obj, void* ptr) { 
 683:./autogen/interfaces.hpp ****         uint32_t get_anticogging_value_in_index_; // for internal use by Fibre
 684:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_anticogging_value_in_index_(T* obj) { return Prope
 685:./autogen/interfaces.hpp ****         template<typename T> static void get_get_anticogging_value_in_index_(T* obj, void* ptr) { n
 686:./autogen/interfaces.hpp ****         float get_anticogging_value_out_val_; // for internal use by Fibre
 687:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_anticogging_value_out_val_(T* obj) { return Proper
 688:./autogen/interfaces.hpp ****         template<typename T> static void get_get_anticogging_value_out_val_(T* obj, void* ptr) { ne
 689:./autogen/interfaces.hpp ****     };
 690:./autogen/interfaces.hpp ****     class EncoderIntf {
 691:./autogen/interfaces.hpp ****     public:
 692:./autogen/interfaces.hpp ****         class ConfigIntf {
 693:./autogen/interfaces.hpp ****         public:
 694:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mode(T* obj) { return Property<ODriveIntf::
 695:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mode(T* obj, void* ptr) { new (ptr) Propert
 696:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_use_index(T* obj) { return Property<bool>{o
 697:./autogen/interfaces.hpp ****             template<typename T> static inline void get_use_index(T* obj, void* ptr) { new (ptr) Pr
 698:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_index_offset(T* obj) { return Property<floa
 699:./autogen/interfaces.hpp ****             template<typename T> static inline void get_index_offset(T* obj, void* ptr) { new (ptr)
 700:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_use_index_offset(T* obj) { return Property<
 701:./autogen/interfaces.hpp ****             template<typename T> static inline void get_use_index_offset(T* obj, void* ptr) { new (
 702:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_find_idx_on_lockin_only(T* obj) { return Pr
 703:./autogen/interfaces.hpp ****             template<typename T> static inline void get_find_idx_on_lockin_only(T* obj, void* ptr) 
 704:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_abs_spi_cs_gpio_pin(T* obj) { return Proper
 705:./autogen/interfaces.hpp ****             template<typename T> static inline void get_abs_spi_cs_gpio_pin(T* obj, void* ptr) { ne
 706:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_cpr(T* obj) { return Property<int32_t>{&obj
 707:./autogen/interfaces.hpp ****             template<typename T> static inline void get_cpr(T* obj, void* ptr) { new (ptr) Property
 708:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_offset(T* obj) { return Property<int3
 709:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_offset(T* obj, void* ptr) { new (ptr)
 710:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_offset_float(T* obj) { return Propert
 711:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_offset_float(T* obj, void* ptr) { new
 712:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_direction(T* obj) { return Property<int32_t
 713:./autogen/interfaces.hpp ****             template<typename T> static inline void get_direction(T* obj, void* ptr) { new (ptr) Pr
 714:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bo
 715:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (pt
 716:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_phase_interpolation(T* obj) { return
ARM GAS  /tmp/ccysU9ly.s 			page 51


 717:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_phase_interpolation(T* obj, void* pt
 718:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bandwidth(T* obj) { return Property<float>{
 719:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bandwidth(T* obj, void* ptr) { new (ptr) Pr
 720:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_range(T* obj) { return Property<float
 721:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_range(T* obj, void* ptr) { new (ptr) 
 722:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_scan_distance(T* obj) { return Proper
 723:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_scan_distance(T* obj, void* ptr) { ne
 724:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_scan_omega(T* obj) { return Property<
 725:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_scan_omega(T* obj, void* ptr) { new (
 726:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ignore_illegal_hall_state(T* obj) { return 
 727:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ignore_illegal_hall_state(T* obj, void* ptr
 728:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_hall_polarity(T* obj) { return Property<uin
 729:./autogen/interfaces.hpp ****             template<typename T> static inline void get_hall_polarity(T* obj, void* ptr) { new (ptr
 730:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_hall_polarity_calibrated(T* obj) { return P
 731:./autogen/interfaces.hpp ****             template<typename T> static inline void get_hall_polarity_calibrated(T* obj, void* ptr)
 732:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sincos_gpio_pin_sin(T* obj) { return Proper
 733:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sincos_gpio_pin_sin(T* obj, void* ptr) { ne
 734:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sincos_gpio_pin_cos(T* obj) { return Proper
 735:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sincos_gpio_pin_cos(T* obj, void* ptr) { ne
 736:./autogen/interfaces.hpp ****         };
 737:./autogen/interfaces.hpp ****         enum Error {
 738:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 739:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000001,
 740:./autogen/interfaces.hpp ****             ERROR_CPR_POLEPAIRS_MISMATCH     = 0x00000002,
 741:./autogen/interfaces.hpp ****             ERROR_NO_RESPONSE                = 0x00000004,
 742:./autogen/interfaces.hpp ****             ERROR_UNSUPPORTED_ENCODER_MODE   = 0x00000008,
 743:./autogen/interfaces.hpp ****             ERROR_ILLEGAL_HALL_STATE         = 0x00000010,
 744:./autogen/interfaces.hpp ****             ERROR_INDEX_NOT_FOUND_YET        = 0x00000020,
 745:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_TIMEOUT            = 0x00000040,
 746:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_COM_FAIL           = 0x00000080,
 747:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_NOT_READY          = 0x00000100,
 748:./autogen/interfaces.hpp ****             ERROR_HALL_NOT_CALIBRATED_YET    = 0x00000200,
 749:./autogen/interfaces.hpp ****         };
 750:./autogen/interfaces.hpp ****         enum Mode {
 751:./autogen/interfaces.hpp ****             MODE_INCREMENTAL                 = 0,
 752:./autogen/interfaces.hpp ****             MODE_HALL                        = 1,
 753:./autogen/interfaces.hpp ****             MODE_SINCOS                      = 2,
 754:./autogen/interfaces.hpp ****             MODE_SPI_ABS_CUI                 = 256,
 755:./autogen/interfaces.hpp ****             MODE_SPI_ABS_AMS                 = 257,
 756:./autogen/interfaces.hpp ****             MODE_SPI_ABS_AEAT                = 258,
 757:./autogen/interfaces.hpp ****             MODE_SPI_ABS_RLS                 = 259,
 758:./autogen/interfaces.hpp ****             MODE_SPI_ABS_MA732               = 260,
 759:./autogen/interfaces.hpp ****         };
 760:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Enc
 761:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 762:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_ready(T* obj) { return Property<const bool>{
 763:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_ready(T* obj, void* ptr) { new (ptr) Propert
 764:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_index_found(T* obj) { return Property<const boo
 765:./autogen/interfaces.hpp ****         template<typename T> static inline void get_index_found(T* obj, void* ptr) { new (ptr) Prop
 766:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_shadow_count(T* obj) { return Property<const in
 767:./autogen/interfaces.hpp ****         template<typename T> static inline void get_shadow_count(T* obj, void* ptr) { new (ptr) Pro
 768:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_count_in_cpr(T* obj) { return Property<const in
 769:./autogen/interfaces.hpp ****         template<typename T> static inline void get_count_in_cpr(T* obj, void* ptr) { new (ptr) Pro
 770:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_interpolation(T* obj) { return Property<const f
 771:./autogen/interfaces.hpp ****         template<typename T> static inline void get_interpolation(T* obj, void* ptr) { new (ptr) Pr
 772:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase(T* obj) { return Property<const float>{ob
 773:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<c
ARM GAS  /tmp/ccysU9ly.s 			page 52


 774:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_estimate(T* obj) { return Property<const fl
 775:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_estimate(T* obj, void* ptr) { new (ptr) Pro
 776:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_estimate_counts(T* obj) { return Property<c
 777:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_estimate_counts(T* obj, void* ptr) { new (p
 778:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_circular(T* obj) { return Property<const fl
 779:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_circular(T* obj, void* ptr) { new (ptr) Pro
 780:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_cpr_counts(T* obj) { return Property<const 
 781:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_cpr_counts(T* obj, void* ptr) { new (ptr) P
 782:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_delta_pos_cpr_counts(T* obj) { return Property<
 783:./autogen/interfaces.hpp ****         template<typename T> static inline void get_delta_pos_cpr_counts(T* obj, void* ptr) { new (
 784:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_hall_state(T* obj) { return Property<const uint
 785:./autogen/interfaces.hpp ****         template<typename T> static inline void get_hall_state(T* obj, void* ptr) { new (ptr) Prope
 786:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate(T* obj) { return Property<const fl
 787:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate(T* obj, void* ptr) { new (ptr) Pro
 788:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate_counts(T* obj) { return Property<c
 789:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate_counts(T* obj, void* ptr) { new (p
 790:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_calib_scan_response(T* obj) { return Property<c
 791:./autogen/interfaces.hpp ****         template<typename T> static inline void get_calib_scan_response(T* obj, void* ptr) { new (p
 792:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_abs(T* obj) { return Property<int32_t>{&obj
 793:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_abs(T* obj, void* ptr) { new (ptr) Property
 794:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_spi_error_rate(T* obj) { return Property<const 
 795:./autogen/interfaces.hpp ****         template<typename T> static inline void get_spi_error_rate(T* obj, void* ptr) { new (ptr) P
 796:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 797:./autogen/interfaces.hpp ****         virtual void set_linear_count(int32_t count) = 0;
 798:./autogen/interfaces.hpp ****         int32_t set_linear_count_in_count_; // for internal use by Fibre
 799:./autogen/interfaces.hpp ****         template<typename T> static auto get_set_linear_count_in_count_(T* obj) { return Property<i
 800:./autogen/interfaces.hpp ****         template<typename T> static void get_set_linear_count_in_count_(T* obj, void* ptr) { new (p
 801:./autogen/interfaces.hpp ****     };
 802:./autogen/interfaces.hpp ****     class SensorlessEstimatorIntf {
 803:./autogen/interfaces.hpp ****     public:
 804:./autogen/interfaces.hpp ****         class ConfigIntf {
 805:./autogen/interfaces.hpp ****         public:
 806:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_observer_gain(T* obj) { return Property<flo
 807:./autogen/interfaces.hpp ****             template<typename T> static inline void get_observer_gain(T* obj, void* ptr) { new (ptr
 808:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pll_bandwidth(T* obj) { return Property<flo
 809:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pll_bandwidth(T* obj, void* ptr) { new (ptr
 810:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pm_flux_linkage(T* obj) { return Property<f
 811:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pm_flux_linkage(T* obj, void* ptr) { new (p
 812:./autogen/interfaces.hpp ****         };
 813:./autogen/interfaces.hpp ****         enum Error {
 814:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 815:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000001,
 816:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x00000002,
 817:./autogen/interfaces.hpp ****         };
 818:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Sen
 819:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 820:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase(T* obj) { return Property<const float>{ob
 821:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<c
 822:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pll_pos(T* obj) { return Property<const float>{
 823:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pll_pos(T* obj, void* ptr) { new (ptr) Property
 824:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_vel(T* obj) { return Property<const float
 825:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_vel(T* obj, void* ptr) { new (ptr) Proper
 826:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate(T* obj) { return Property<const fl
 827:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate(T* obj, void* ptr) { new (ptr) Pro
 828:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 829:./autogen/interfaces.hpp ****     };
 830:./autogen/interfaces.hpp ****     class TrapezoidalTrajectoryIntf {
ARM GAS  /tmp/ccysU9ly.s 			page 53


 831:./autogen/interfaces.hpp ****     public:
 832:./autogen/interfaces.hpp ****         class ConfigIntf {
 833:./autogen/interfaces.hpp ****         public:
 834:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit(T* obj) { return Property<float>{
 835:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit(T* obj, void* ptr) { new (ptr) Pr
 836:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_accel_limit(T* obj) { return Property<float
 837:./autogen/interfaces.hpp ****             template<typename T> static inline void get_accel_limit(T* obj, void* ptr) { new (ptr) 
 838:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_decel_limit(T* obj) { return Property<float
 839:./autogen/interfaces.hpp ****             template<typename T> static inline void get_decel_limit(T* obj, void* ptr) { new (ptr) 
 840:./autogen/interfaces.hpp ****         };
 841:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 842:./autogen/interfaces.hpp ****     };
 843:./autogen/interfaces.hpp ****     class EndstopIntf {
 844:./autogen/interfaces.hpp ****     public:
 845:./autogen/interfaces.hpp ****         class ConfigIntf {
 846:./autogen/interfaces.hpp ****         public:
 847:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gpio_num(T* obj) { return Property<uint16_t
 848:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gpio_num(T* obj, void* ptr) { new (ptr) Pro
 849:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{obj
 850:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
 851:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_offset(T* obj) { return Property<float>{&ob
 852:./autogen/interfaces.hpp ****             template<typename T> static inline void get_offset(T* obj, void* ptr) { new (ptr) Prope
 853:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_is_active_high(T* obj) { return Property<bo
 854:./autogen/interfaces.hpp ****             template<typename T> static inline void get_is_active_high(T* obj, void* ptr) { new (pt
 855:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_debounce_ms(T* obj) { return Property<uint3
 856:./autogen/interfaces.hpp ****             template<typename T> static inline void get_debounce_ms(T* obj, void* ptr) { new (ptr) 
 857:./autogen/interfaces.hpp ****         };
 858:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_endstop_state(T* obj) { return Property<const b
 859:./autogen/interfaces.hpp ****         template<typename T> static inline void get_endstop_state(T* obj, void* ptr) { new (ptr) Pr
 860:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 861:./autogen/interfaces.hpp ****     };
 862:./autogen/interfaces.hpp ****     class MechanicalBrakeIntf {
 794              		.loc 10 862 11 view .LVU119
 795              	.LBB767:
 796 0252 294A     		ldr	r2, .L51+88
 797 0254 1A60     		str	r2, [r3]
 798              	.LVL48:
 799              		.loc 10 862 11 is_stmt 0 view .LVU120
 800              	.LBE767:
 801              	.LBE766:
 802              		.loc 9 17 23 view .LVU121
 803 0256 294A     		ldr	r2, .L51+92
 804 0258 1A60     		str	r2, [r3]
 805              	.LVL49:
 806              	.LBB768:
 807              	.LBI768:
   8:MotorControl/mechanical_brake.hpp ****         uint16_t gpio_num = 0;
 808              		.loc 9 8 12 is_stmt 1 view .LVU122
 809              	.LBB769:
 810 025a 0022     		movs	r2, #0
 811 025c 9A80     		strh	r2, [r3, #4]	@ movhi
 812 025e 0120     		movs	r0, #1
 813 0260 9871     		strb	r0, [r3, #6]
 814 0262 9A60     		str	r2, [r3, #8]
 815              	.LVL50:
   8:MotorControl/mechanical_brake.hpp ****         uint16_t gpio_num = 0;
 816              		.loc 9 8 12 is_stmt 0 view .LVU123
ARM GAS  /tmp/ccysU9ly.s 			page 54


 817              	.LBE769:
 818              	.LBE768:
 819              		.loc 9 17 23 view .LVU124
 820 0264 DA60     		str	r2, [r3, #12]
 821              	.LVL51:
 822              		.loc 9 17 23 view .LVU125
 823              	.LBE765:
 824              	.LBE764:
 117:Board/v3/board.cpp **** 
 825              		.loc 4 117 45 view .LVU126
 826 0266 1033     		adds	r3, r3, #16
 117:Board/v3/board.cpp **** 
 827              		.loc 4 117 45 is_stmt 1 view .LVU127
 828 0268 0139     		subs	r1, r1, #1
 829 026a F0E7     		b	.L27
 830              	.L38:
 119:Board/v3/board.cpp **** Controller controllers[AXIS_COUNT];
 831              		.loc 4 119 53 is_stmt 0 view .LVU128
 832 026c 2646     		mov	r6, r4
 833 026e 244D     		ldr	r5, .L51+96
 834              	.L26:
 119:Board/v3/board.cpp **** Controller controllers[AXIS_COUNT];
 835              		.loc 4 119 53 is_stmt 1 discriminator 4 view .LVU129
 836 0270 002E     		cmp	r6, #0
 837 0272 51DB     		blt	.L39
 119:Board/v3/board.cpp **** Controller controllers[AXIS_COUNT];
 838              		.loc 4 119 53 is_stmt 0 discriminator 3 view .LVU130
 839 0274 4022     		movs	r2, #64
 840 0276 0021     		movs	r1, #0
 841 0278 2846     		mov	r0, r5
 842 027a FFF7FEFF 		bl	memset
 843              	.LVL52:
 844              	.LBB770:
 845              	.LBI770:
 846              		.file 11 "MotorControl/sensorless_estimator.hpp"
   1:MotorControl/sensorless_estimator.hpp **** #ifndef __SENSORLESS_ESTIMATOR_HPP
   2:MotorControl/sensorless_estimator.hpp **** #define __SENSORLESS_ESTIMATOR_HPP
   3:MotorControl/sensorless_estimator.hpp **** 
   4:MotorControl/sensorless_estimator.hpp **** #include "component.hpp"
   5:MotorControl/sensorless_estimator.hpp **** 
   6:MotorControl/sensorless_estimator.hpp **** class SensorlessEstimator : public ODriveIntf::SensorlessEstimatorIntf {
 847              		.loc 11 6 7 is_stmt 1 discriminator 3 view .LVU131
 848              	.LBB771:
 849              	.LBI771:
   7:MotorControl/sensorless_estimator.hpp **** public:
   8:MotorControl/sensorless_estimator.hpp ****     struct Config_t {
 850              		.loc 11 8 12 discriminator 3 view .LVU132
 851              	.LBB772:
 852 027e 214B     		ldr	r3, .L51+100
 853 0280 6B60     		str	r3, [r5, #4]	@ float
 854 0282 AB60     		str	r3, [r5, #8]	@ float
 855 0284 204B     		ldr	r3, .L51+104
 856 0286 EB60     		str	r3, [r5, #12]	@ float
 857              	.LVL53:
 858              		.loc 11 8 12 is_stmt 0 discriminator 3 view .LVU133
 859              	.LBE772:
 860              	.LBE771:
ARM GAS  /tmp/ccysU9ly.s 			page 55


 861              	.LBB773:
 862              	.LBI773:
 863              		.file 12 "./MotorControl/component.hpp"
   1:./MotorControl/component.hpp **** #ifndef __COMPONENT_HPP
   2:./MotorControl/component.hpp **** #define __COMPONENT_HPP
   3:./MotorControl/component.hpp **** 
   4:./MotorControl/component.hpp **** #include <stdint.h>
   5:./MotorControl/component.hpp **** #include <optional>
   6:./MotorControl/component.hpp **** #include <variant>
   7:./MotorControl/component.hpp **** 
   8:./MotorControl/component.hpp **** class ComponentBase {
   9:./MotorControl/component.hpp **** public:
  10:./MotorControl/component.hpp ****     /**
  11:./MotorControl/component.hpp ****      * @brief Shall run the update action of this component.
  12:./MotorControl/component.hpp ****      * 
  13:./MotorControl/component.hpp ****      * This function gets called in a low priority interrupt context and is
  14:./MotorControl/component.hpp ****      * allowed to call CMSIS functions.
  15:./MotorControl/component.hpp ****      * 
  16:./MotorControl/component.hpp ****      * @param timestamp: The timestamp (in HCLK ticks) for which this update
  17:./MotorControl/component.hpp ****      * is run.
  18:./MotorControl/component.hpp ****      */
  19:./MotorControl/component.hpp ****     virtual void update(uint32_t timestamp) = 0;
  20:./MotorControl/component.hpp **** };
  21:./MotorControl/component.hpp **** 
  22:./MotorControl/component.hpp **** 
  23:./MotorControl/component.hpp **** template<typename T>
  24:./MotorControl/component.hpp **** class InputPort;
  25:./MotorControl/component.hpp **** 
  26:./MotorControl/component.hpp **** /**
  27:./MotorControl/component.hpp ****  * @brief An output port stores a value for consumption by a connecting input
  28:./MotorControl/component.hpp ****  * port.
  29:./MotorControl/component.hpp ****  * 
  30:./MotorControl/component.hpp ****  * Output ports are supposed to be reset at the beginning of a control loop
  31:./MotorControl/component.hpp ****  * iteration. This ensures that connecting input ports don't use an outdated
  32:./MotorControl/component.hpp ****  * value and, more importantly, ensures proper handling if the producer of the
  33:./MotorControl/component.hpp ****  * value is incapable of producing the value for any reason.
  34:./MotorControl/component.hpp ****  * 
  35:./MotorControl/component.hpp ****  * Member functions of this class are not thread-safe unless noted otherwise.
  36:./MotorControl/component.hpp ****  */
  37:./MotorControl/component.hpp **** template<typename T>
  38:./MotorControl/component.hpp **** class OutputPort {
  39:./MotorControl/component.hpp **** public:
  40:./MotorControl/component.hpp ****     /**
  41:./MotorControl/component.hpp ****      * @brief Initializes the output port with the specified value.
  42:./MotorControl/component.hpp ****      * 
  43:./MotorControl/component.hpp ****      * An initialization value is required for any() to work properly.
  44:./MotorControl/component.hpp ****      * present() and previous() cannot be used to fetch the
  45:./MotorControl/component.hpp ****      * initialization value.
  46:./MotorControl/component.hpp ****      */
  47:./MotorControl/component.hpp ****     OutputPort(T val) : content_(val) {}
 864              		.loc 12 47 5 is_stmt 1 discriminator 3 view .LVU134
 865              	.LBB774:
 866              		.loc 12 47 37 is_stmt 0 discriminator 3 view .LVU135
 867 0288 0222     		movs	r2, #2
 868 028a AA62     		str	r2, [r5, #40]
 869 028c 0023     		movs	r3, #0
 870 028e EB62     		str	r3, [r5, #44]	@ float
ARM GAS  /tmp/ccysU9ly.s 			page 56


 871              	.LVL54:
 872              		.loc 12 47 37 discriminator 3 view .LVU136
 873              	.LBE774:
 874              	.LBE773:
 875              	.LBB775:
 876              	.LBI775:
 877              		.loc 12 47 5 is_stmt 1 discriminator 3 view .LVU137
 878              	.LBB776:
 879              		.loc 12 47 37 is_stmt 0 discriminator 3 view .LVU138
 880 0290 2A63     		str	r2, [r5, #48]
 881 0292 6B63     		str	r3, [r5, #52]	@ float
 882              	.LVL55:
 883              		.loc 12 47 37 discriminator 3 view .LVU139
 884              	.LBE776:
 885              	.LBE775:
 886              	.LBB777:
 887              	.LBI777:
 888              		.loc 12 47 5 is_stmt 1 discriminator 3 view .LVU140
 889              	.LBB778:
 890              		.loc 12 47 37 is_stmt 0 discriminator 3 view .LVU141
 891 0294 AA63     		str	r2, [r5, #56]
 892 0296 EB63     		str	r3, [r5, #60]	@ float
 893              	.LVL56:
 894              		.loc 12 47 37 discriminator 3 view .LVU142
 895              	.LBE778:
 896              	.LBE777:
 897              	.LBE770:
 119:Board/v3/board.cpp **** Controller controllers[AXIS_COUNT];
 898              		.loc 4 119 53 discriminator 3 view .LVU143
 899 0298 4035     		adds	r5, r5, #64
 119:Board/v3/board.cpp **** Controller controllers[AXIS_COUNT];
 900              		.loc 4 119 53 is_stmt 1 discriminator 3 view .LVU144
 901 029a 013E     		subs	r6, r6, #1
 902 029c E8E7     		b	.L26
 903              	.L52:
 904 029e 00BF     		.align	2
 905              	.L51:
 906 02a0 00000000 		.word	.LANCHOR6
 907 02a4 00000000 		.word	hspi3
 908 02a8 000C0240 		.word	1073875968
 909 02ac 00000000 		.word	.LANCHOR7
 910 02b0 08000000 		.word	_ZTV14GateDriverBase+8
 911 02b4 08000000 		.word	_ZTV9OpAmpBase+8
 912 02b8 00000000 		.word	.LANCHOR8
 913 02bc 00000000 		.word	.LANCHOR9
 914 02c0 00000000 		.word	.LANCHOR1
 915 02c4 38000000 		.word	.LANCHOR1+56
 916 02c8 00000000 		.word	__dso_handle
 917 02cc 00000000 		.word	__tcf_0
 918 02d0 00000000 		.word	.LANCHOR2
 919 02d4 00000000 		.word	__tcf_1
 920 02d8 FFFFF944 		.word	1157234687
 921 02dc 00000000 		.word	.LANCHOR10
 922 02e0 00000000 		.word	htim1
 923 02e4 00000000 		.word	htim8
 924 02e8 00080240 		.word	1073874944
 925 02ec 00000000 		.word	htim3
ARM GAS  /tmp/ccysU9ly.s 			page 57


 926 02f0 00000000 		.word	htim4
 927 02f4 00000000 		.word	.LANCHOR3
 928 02f8 08000000 		.word	_ZTVN10ODriveIntf19MechanicalBrakeIntfE+8
 929 02fc 08000000 		.word	_ZTV15MechanicalBrake+8
 930 0300 00000000 		.word	.LANCHOR4
 931 0304 00007A44 		.word	1148846080
 932 0308 0118CF3A 		.word	986650625
 933 030c 08000000 		.word	_ZTV7Drv8301+8
 934 0310 00040240 		.word	1073873920
 935 0314 00000000 		.word	.LANCHOR11
 936              	.L39:
 120:Board/v3/board.cpp **** TrapezoidalTrajectory trap[AXIS_COUNT];
 937              		.loc 4 120 34 is_stmt 0 view .LVU145
 938 0318 2746     		mov	r7, r4
 939 031a BD48     		ldr	r0, .L53
 940              	.L28:
 120:Board/v3/board.cpp **** TrapezoidalTrajectory trap[AXIS_COUNT];
 941              		.loc 4 120 34 is_stmt 1 discriminator 4 view .LVU146
 942 031c 002F     		cmp	r7, #0
 943 031e C0F2C780 		blt	.L40
 944              	.LVL57:
 945              	.LBB779:
 946              	.LBI779:
 947              		.file 13 "MotorControl/controller.hpp"
   1:MotorControl/controller.hpp **** #ifndef __CONTROLLER_HPP
   2:MotorControl/controller.hpp **** #define __CONTROLLER_HPP
   3:MotorControl/controller.hpp **** 
   4:MotorControl/controller.hpp **** class Controller : public ODriveIntf::ControllerIntf {
 948              		.loc 13 4 7 view .LVU147
 949              	.LBB780:
 950              	.LBB781:
 951              	.LBI781:
 520:./autogen/interfaces.hpp ****     public:
 952              		.loc 10 520 11 view .LVU148
 953              	.LBB782:
 954 0322 BC4B     		ldr	r3, .L53+4
 955 0324 0360     		str	r3, [r0]
 956              	.LVL58:
 520:./autogen/interfaces.hpp ****     public:
 957              		.loc 10 520 11 is_stmt 0 view .LVU149
 958              	.LBE782:
 959              	.LBE781:
 960              		.loc 13 4 7 view .LVU150
 961 0326 0346     		mov	r3, r0
 962 0328 BB4A     		ldr	r2, .L53+8
 963 032a 43F8182B 		str	r2, [r3], #24
 964              	.LVL59:
 965              	.LBB783:
 966              	.LBI783:
   5:MotorControl/controller.hpp **** public:
   6:MotorControl/controller.hpp ****     struct Anticogging_t {
   7:MotorControl/controller.hpp ****         uint32_t index = 0;
   8:MotorControl/controller.hpp ****         float cogging_map[3600];
   9:MotorControl/controller.hpp ****         bool pre_calibrated = false;
  10:MotorControl/controller.hpp ****         bool calib_anticogging = false;
  11:MotorControl/controller.hpp ****         float calib_pos_threshold = 1.0f;
  12:MotorControl/controller.hpp ****         float calib_vel_threshold = 1.0f;
ARM GAS  /tmp/ccysU9ly.s 			page 58


  13:MotorControl/controller.hpp ****         float cogging_ratio = 1.0f;
  14:MotorControl/controller.hpp ****         bool anticogging_enabled = true;
  15:MotorControl/controller.hpp ****     };
  16:MotorControl/controller.hpp **** 
  17:MotorControl/controller.hpp ****     struct Autotuning_t {
  18:MotorControl/controller.hpp ****         float frequency = 0.0f;
  19:MotorControl/controller.hpp ****         float pos_amplitude = 0.0f;
  20:MotorControl/controller.hpp ****         float vel_amplitude = 0.0f;
  21:MotorControl/controller.hpp ****         float torque_amplitude = 0.0f;
  22:MotorControl/controller.hpp ****     };
  23:MotorControl/controller.hpp **** 
  24:MotorControl/controller.hpp ****     struct Config_t {
 967              		.loc 13 24 12 is_stmt 1 view .LVU151
 968              	.LBB784:
 969 032e 0322     		movs	r2, #3
 970 0330 0276     		strb	r2, [r0, #24]
 971 0332 0125     		movs	r5, #1
 972 0334 5D70     		strb	r5, [r3, #1]
 973 0336 DFF830C3 		ldr	ip, .L53+88
 974 033a C3F804C0 		str	ip, [r3, #4]	@ float
 975 033e B74A     		ldr	r2, .L53+12
 976 0340 9A60     		str	r2, [r3, #8]	@ float
 977 0342 B74A     		ldr	r2, .L53+16
 978 0344 DA60     		str	r2, [r3, #12]	@ float
 979 0346 4FF0804E 		mov	lr, #1073741824
 980 034a C3F810E0 		str	lr, [r3, #16]	@ float
 981 034e B54A     		ldr	r2, .L53+20
 982 0350 5A61     		str	r2, [r3, #20]	@ float
 983 0352 4FF0FF42 		mov	r2, #2139095040
 984 0356 9A61     		str	r2, [r3, #24]	@ float
 985 0358 4FF07E56 		mov	r6, #1065353216
 986 035c DE61     		str	r6, [r3, #28]	@ float
 987 035e B24A     		ldr	r2, .L53+24
 988 0360 1A62     		str	r2, [r3, #32]	@ float
 989 0362 0021     		movs	r1, #0
 990 0364 83F82410 		strb	r1, [r3, #36]
 991 0368 9E62     		str	r6, [r3, #40]	@ float
 992 036a 4FF48062 		mov	r2, #1024
 993 036e DA62     		str	r2, [r3, #44]
 994 0370 0022     		movs	r2, #0
 995 0372 1A63     		str	r2, [r3, #48]	@ float
 996 0374 C3F834E0 		str	lr, [r3, #52]	@ float
 997 0378 4FF07A5E 		mov	lr, #1048576000
 998 037c C3F838E0 		str	lr, [r3, #56]	@ float
 999              	.LVL60:
 1000              	.LBB785:
 1001              	.LBI785:
   6:MotorControl/controller.hpp ****         uint32_t index = 0;
 1002              		.loc 13 6 12 view .LVU152
 1003              	.LBB786:
 1004 0380 D963     		str	r1, [r3, #60]
 1005 0382 03F54053 		add	r3, r3, #12288
 1006              	.LVL61:
   6:MotorControl/controller.hpp ****         uint32_t index = 0;
 1007              		.loc 13 6 12 is_stmt 0 view .LVU153
 1008 0386 83F88018 		strb	r1, [r3, #2176]
 1009 038a 83F88118 		strb	r1, [r3, #2177]
ARM GAS  /tmp/ccysU9ly.s 			page 59


 1010 038e 03F6840E 		addw	lr, r3, #2180
 1011 0392 CEF80060 		str	r6, [lr]	@ float
 1012 0396 03F6880E 		addw	lr, r3, #2184
 1013 039a CEF80060 		str	r6, [lr]	@ float
 1014 039e 03F68C0E 		addw	lr, r3, #2188
 1015 03a2 CEF80060 		str	r6, [lr]	@ float
 1016 03a6 83F89058 		strb	r5, [r3, #2192]
 1017              	.LVL62:
   6:MotorControl/controller.hpp ****         uint32_t index = 0;
 1018              		.loc 13 6 12 view .LVU154
 1019              	.LBE786:
 1020              	.LBE785:
 1021              		.loc 13 24 12 view .LVU155
 1022 03aa 03F69408 		addw	r8, r3, #2196
 1023 03ae DFF8BCE2 		ldr	lr, .L53+92
 1024 03b2 C8F800E0 		str	lr, [r8]	@ float
 1025 03b6 83F89818 		strb	r1, [r3, #2200]
 1026 03ba 83F89958 		strb	r5, [r3, #2201]
 1027 03be 83F89A58 		strb	r5, [r3, #2202]
 1028 03c2 83F89B58 		strb	r5, [r3, #2203]
 1029 03c6 4FF0FF08 		mov	r8, #255
 1030 03ca 83F89C88 		strb	r8, [r3, #2204]
 1031 03ce 03F50A69 		add	r9, r3, #2208
 1032 03d2 C9F80060 		str	r6, [r9]	@ float
 1033 03d6 03F6A406 		addw	r6, r3, #2212
 1034 03da 3260     		str	r2, [r6]	@ float
 1035 03dc 83F8A888 		strb	r8, [r3, #2216]
 1036 03e0 03F6AC06 		addw	r6, r3, #2220
 1037 03e4 C6F800C0 		str	ip, [r6]	@ float
 1038 03e8 03F50B66 		add	r6, r3, #2224
 1039 03ec C6F800C0 		str	ip, [r6]	@ float
 1040 03f0 03F6B406 		addw	r6, r3, #2228
 1041 03f4 C6F800E0 		str	lr, [r6]	@ float
 1042 03f8 03F6B803 		addw	r3, r3, #2232
 1043              	.LVL63:
 1044              		.loc 13 24 12 view .LVU156
 1045 03fc 8B4E     		ldr	r6, .L53+28
 1046 03fe 1E60     		str	r6, [r3]	@ float
 1047              	.LVL64:
 1048              		.loc 13 24 12 view .LVU157
 1049              	.LBE784:
 1050              	.LBE783:
   4:MotorControl/controller.hpp **** public:
 1051              		.loc 13 4 7 view .LVU158
 1052 0400 00F54053 		add	r3, r0, #12288
 1053 0404 C3F8D818 		str	r1, [r3, #2264]
 1054 0408 83F8DC18 		strb	r1, [r3, #2268]
 1055 040c 03F50E66 		add	r6, r3, #2272
 1056 0410 3260     		str	r2, [r6]	@ float
 1057              	.LVL65:
 1058              	.LBB787:
 1059              	.LBI787:
  48:./MotorControl/component.hpp ****     
  49:./MotorControl/component.hpp ****     /**
  50:./MotorControl/component.hpp ****      * @brief Updates the underlying value of this output port.
  51:./MotorControl/component.hpp ****      */
  52:./MotorControl/component.hpp ****     void operator=(T value) {
ARM GAS  /tmp/ccysU9ly.s 			page 60


  53:./MotorControl/component.hpp ****         content_ = value;
  54:./MotorControl/component.hpp ****         age_ = 0;
  55:./MotorControl/component.hpp ****     }
  56:./MotorControl/component.hpp **** 
  57:./MotorControl/component.hpp ****     /**
  58:./MotorControl/component.hpp ****      * @brief Marks the contained value as outdated. The value is not actually
  59:./MotorControl/component.hpp ****      * deleted and can still be accessed through some of the member functions
  60:./MotorControl/component.hpp ****      * of this class.
  61:./MotorControl/component.hpp ****      */
  62:./MotorControl/component.hpp ****     void reset() {
  63:./MotorControl/component.hpp ****         // This will eventually overflow to 0 so present() could
  64:./MotorControl/component.hpp ****         // theoretically return a very old value however it is very likely that
  65:./MotorControl/component.hpp ****         // the motor will be long disarmed by then.
  66:./MotorControl/component.hpp ****         age_++;
  67:./MotorControl/component.hpp ****     }
  68:./MotorControl/component.hpp **** 
  69:./MotorControl/component.hpp ****     /**
  70:./MotorControl/component.hpp ****      * @brief Returns the value from this control loop iteration or std::nullopt
  71:./MotorControl/component.hpp ****      * if the value was not yet set during this control loop iteration.
  72:./MotorControl/component.hpp ****      */
  73:./MotorControl/component.hpp ****     std::optional<T> present() {
  74:./MotorControl/component.hpp ****         if (age_ == 0) {
  75:./MotorControl/component.hpp ****             return content_;
  76:./MotorControl/component.hpp ****         } else {
  77:./MotorControl/component.hpp ****             return std::nullopt;
  78:./MotorControl/component.hpp ****         }
  79:./MotorControl/component.hpp ****     }
  80:./MotorControl/component.hpp **** 
  81:./MotorControl/component.hpp ****     /**
  82:./MotorControl/component.hpp ****      * @brief Returns the value from exactly the previous control loop iteration.
  83:./MotorControl/component.hpp ****      * 
  84:./MotorControl/component.hpp ****      * If during the last iteration no value was set or the value was already
  85:./MotorControl/component.hpp ****      * overwritten during this control loop iteration then this function returns
  86:./MotorControl/component.hpp ****      * std::nullopt.
  87:./MotorControl/component.hpp ****      */
  88:./MotorControl/component.hpp ****     std::optional<T> previous() {
  89:./MotorControl/component.hpp ****         if (age_ == 1) {
  90:./MotorControl/component.hpp ****             return content_;
  91:./MotorControl/component.hpp ****         } else {
  92:./MotorControl/component.hpp ****             return std::nullopt;
  93:./MotorControl/component.hpp ****         }
  94:./MotorControl/component.hpp ****     }
  95:./MotorControl/component.hpp **** 
  96:./MotorControl/component.hpp ****     /**
  97:./MotorControl/component.hpp ****      * @brief Returns the value contained in this output port with disregard of
  98:./MotorControl/component.hpp ****      * when the value was set.
  99:./MotorControl/component.hpp ****      * 
 100:./MotorControl/component.hpp ****      * This function is thread-safe if load/store operations of T are atomic.
 101:./MotorControl/component.hpp ****      */
 102:./MotorControl/component.hpp ****     std::optional<T> any() {
 103:./MotorControl/component.hpp ****         return content_;
 104:./MotorControl/component.hpp ****     }
 105:./MotorControl/component.hpp ****     
 106:./MotorControl/component.hpp **** private:
 107:./MotorControl/component.hpp ****     uint32_t age_ = 2; // Age in number of control loop iterations
 108:./MotorControl/component.hpp ****     T content_;
 109:./MotorControl/component.hpp **** };
ARM GAS  /tmp/ccysU9ly.s 			page 61


 110:./MotorControl/component.hpp **** 
 111:./MotorControl/component.hpp **** /**
 112:./MotorControl/component.hpp ****  * @brief An input port provides a value from the source to which it's configured.
 113:./MotorControl/component.hpp ****  * 
 114:./MotorControl/component.hpp ****  * The source can be one of:
 115:./MotorControl/component.hpp ****  *  - an internally stored value
 116:./MotorControl/component.hpp ****  *  - an externally stored value (referenced by a pointer)
 117:./MotorControl/component.hpp ****  *  - an external OutputPort (referenced by a pointer)
 118:./MotorControl/component.hpp ****  *  - none (all queries will return std::nullopt)
 119:./MotorControl/component.hpp ****  * 
 120:./MotorControl/component.hpp ****  * Member functions of this class are not thread-safe unless otherwise noted.
 121:./MotorControl/component.hpp ****  */
 122:./MotorControl/component.hpp **** template<typename T>
 123:./MotorControl/component.hpp **** class InputPort {
 1060              		.loc 12 123 7 is_stmt 1 view .LVU159
 1061              	.LBB788:
 1062              	.LBI788:
 1063              		.file 14 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // <variant> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // Copyright (C) 2016-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** /** @file variant
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****  *  This is the `<variant>` C++ Library header.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****  */
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #ifndef _GLIBCXX_VARIANT
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define _GLIBCXX_VARIANT 1
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #pragma GCC system_header
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #if __cplusplus >= 201703L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <type_traits>
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <utility>
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/enable_special_members.h>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/functexcept.h>
ARM GAS  /tmp/ccysU9ly.s 			page 62


  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/move.h>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/functional_hash.h>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/invoke.h>
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <ext/aligned_buffer.h>
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/parse_numbers.h>
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/stl_iterator_base_types.h>
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/stl_iterator_base_funcs.h>
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/stl_construct.h>
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #if __cplusplus > 201703L
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** # include <compare>
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #endif
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace std _GLIBCXX_VISIBILITY(default)
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __detail
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __variant
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Nth_type;
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _First, typename... _Rest>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Nth_type<_Np, _First, _Rest...>
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _Nth_type<_Np-1, _Rest...> { };
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _First, typename... _Rest>
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Nth_type<0, _First, _Rest...>
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = _First; };
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __variant
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __detail
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define __cpp_lib_variant 201606L
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types> class tuple;
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types> class variant;
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename> struct hash;
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size;
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<const _Variant> : variant_size<_Variant> {};
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<volatile _Variant> : variant_size<_Variant> {};
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<const volatile _Variant> : variant_size<_Variant> {};
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<variant<_Types...>>
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : std::integral_constant<size_t, sizeof...(_Types)> {};
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
ARM GAS  /tmp/ccysU9ly.s 			page 63


  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr size_t variant_size_v = variant_size<_Variant>::value;
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative;
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _First, typename... _Rest>
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, variant<_First, _Rest...>>
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : variant_alternative<_Np-1, variant<_Rest...>> {};
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _First, typename... _Rest>
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<0, variant<_First, _Rest...>>
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = _First; };
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using variant_alternative_t =
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       typename variant_alternative<_Np, _Variant>::type;
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, const _Variant>
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = add_const_t<variant_alternative_t<_Np, _Variant>>; };
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, volatile _Variant>
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = add_volatile_t<variant_alternative_t<_Np, _Variant>>; };
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, const volatile _Variant>
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = add_cv_t<variant_alternative_t<_Np, _Variant>>; };
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   inline constexpr size_t variant_npos = -1;
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>>&
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(variant<_Types...>&);
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>>&&
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(variant<_Types...>&&);
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>> const&
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(const variant<_Types...>&);
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>> const&&
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(const variant<_Types...>&&);
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, typename... _Variants>
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __do_visit(_Visitor&& __visitor, _Variants&&... __variants);
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename... _Types, typename _Tp>
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     decltype(auto)
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __variant_cast(_Tp&& __rhs)
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if constexpr (is_lvalue_reference_v<_Tp>)
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
ARM GAS  /tmp/ccysU9ly.s 			page 64


 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (is_const_v<remove_reference_t<_Tp>>)
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return static_cast<const variant<_Types...>&>(__rhs);
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return static_cast<variant<_Types...>&>(__rhs);
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       else
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         return static_cast<variant<_Types...>&&>(__rhs);
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __detail
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __variant
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns the first appearence of _Tp in _Types.
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns sizeof...(_Types) if _Tp is not in _Types.
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __index_of : std::integral_constant<size_t, 0> {};
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr size_t __index_of_v = __index_of<_Tp, _Types...>::value;
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _First, typename... _Rest>
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __index_of<_Tp, _First, _Rest...> :
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       std::integral_constant<size_t, is_same_v<_Tp, _First>
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	? 0 : __index_of_v<_Tp, _Rest...> + 1> {};
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // used for raw visitation
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   struct __variant_cookie {};
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // used for raw visitation with indices passed in
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   struct __variant_idx_cookie { using type = __variant_idx_cookie; };
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Used to enable deduction (and same-type checking) for std::visit:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename> struct __deduce_visit_result { };
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Visit variants that might be valueless.
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr void
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __raw_visit(_Visitor&& __visitor, _Variants&&... __variants)
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       std::__do_visit<__variant_cookie>(std::forward<_Visitor>(__visitor),
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				        std::forward<_Variants>(__variants)...);
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Visit variants that might be valueless, passing indices to the visitor.
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr void
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __raw_idx_visit(_Visitor&& __visitor, _Variants&&... __variants)
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       std::__do_visit<__variant_idx_cookie>(std::forward<_Visitor>(__visitor),
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  std::forward<_Variants>(__variants)...);
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // _Uninitialized<T> is guaranteed to be a trivially destructible type,
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // even if T is not.
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Type, bool = std::is_trivially_destructible_v<_Type>>
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Uninitialized;
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Type>
ARM GAS  /tmp/ccysU9ly.s 			page 65


 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Uninitialized<_Type, true>
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Uninitialized(in_place_index_t<0>, _Args&&... __args)
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_storage(std::forward<_Args>(__args)...)
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr const _Type& _M_get() const & noexcept
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr _Type& _M_get() & noexcept
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr const _Type&& _M_get() const && noexcept
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(_M_storage); }
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr _Type&& _M_get() && noexcept
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(_M_storage); }
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Type _M_storage;
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Type>
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Uninitialized<_Type, false>
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Uninitialized(in_place_index_t<0>, _Args&&... __args)
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  ::new ((void*)std::addressof(_M_storage))
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    _Type(std::forward<_Args>(__args)...);
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       const _Type& _M_get() const & noexcept
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return *_M_storage._M_ptr(); }
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Type& _M_get() & noexcept
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return *_M_storage._M_ptr(); }
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       const _Type&& _M_get() const && noexcept
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(*_M_storage._M_ptr()); }
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Type&& _M_get() && noexcept
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(*_M_storage._M_ptr()); }
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __gnu_cxx::__aligned_membuf<_Type> _M_storage;
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Union>
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __get(in_place_index_t<0>, _Union&& __u) noexcept
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Union>
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __get(in_place_index_t<_Np>, _Union&& __u) noexcept
ARM GAS  /tmp/ccysU9ly.s 			page 66


 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __variant::__get(in_place_index<_Np-1>,
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			      std::forward<_Union>(__u)._M_rest);
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns the typed storage for __v.
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __get(_Variant&& __v) noexcept
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __variant::__get(std::in_place_index<_Np>,
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			      std::forward<_Variant>(__v)._M_u);
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Traits
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_default_ctor =
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  is_default_constructible_v<typename _Nth_type<0, _Types...>::type>;
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_copy_ctor =
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_copy_constructible_v<_Types> && ...);
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_move_ctor =
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_move_constructible_v<_Types> && ...);
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_copy_assign =
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_copy_ctor
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_copy_assignable_v<_Types> && ...);
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_move_assign =
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_move_ctor
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_move_assignable_v<_Types> && ...);
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_dtor =
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_trivially_destructible_v<_Types> && ...);
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_copy_ctor =
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_trivially_copy_constructible_v<_Types> && ...);
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_move_ctor =
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_trivially_move_constructible_v<_Types> && ...);
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_copy_assign =
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_trivial_dtor && _S_trivial_copy_ctor
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_trivially_copy_assignable_v<_Types> && ...);
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_move_assign =
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_trivial_dtor && _S_trivial_move_ctor
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_trivially_move_assignable_v<_Types> && ...);
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // The following nothrow traits are for non-trivial SMFs. Trivial SMFs
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // are always nothrow.
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_default_ctor =
 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  is_nothrow_default_constructible_v<
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      typename _Nth_type<0, _Types...>::type>;
 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_copy_ctor = false;
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_move_ctor =
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_nothrow_move_constructible_v<_Types> && ...);
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_copy_assign = false;
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_move_assign =
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_nothrow_move_ctor
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_nothrow_move_assignable_v<_Types> && ...);
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/ccysU9ly.s 			page 67


 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Defines members and ctors.
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     union _Variadic_union { };
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _First, typename... _Rest>
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     union _Variadic_union<_First, _Rest...>
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr _Variadic_union() : _M_rest() { }
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr _Variadic_union(in_place_index_t<0>, _Args&&... __args)
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_first(in_place_index<0>, std::forward<_Args>(__args)...)
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr _Variadic_union(in_place_index_t<_Np>, _Args&&... __args)
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_rest(in_place_index<_Np-1>, std::forward<_Args>(__args)...)
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Uninitialized<_First> _M_first;
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variadic_union<_Rest...> _M_rest;
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // _Never_valueless_alt is true for variant alternatives that can
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // always be placed in a variant without it becoming valueless.
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // For suitably-small, trivially copyable types we can create temporaries
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // on the stack and then memcpy them into place.
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp>
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Never_valueless_alt
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : __and_<bool_constant<sizeof(_Tp) <= 256>, is_trivially_copyable<_Tp>>
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { };
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Specialize _Never_valueless_alt for other types which have a
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // non-throwing and cheap move construction and move assignment operator,
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // so that emplacing the type will provide the strong exception-safety
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // guarantee, by creating and moving a temporary.
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Whether _Never_valueless_alt<T> is true or not affects the ABI of a
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // variant using that alternative, so we can't change the value later!
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // True if every alternative in _Types... can be emplaced in a variant
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // without it becoming valueless. If this is true, variant<_Types...>
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // can never be valueless, which enables some minor optimizations.
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename... _Types>
 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr bool __never_valueless()
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return _Traits<_Types...>::_S_move_assign
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	&& (_Never_valueless_alt<_Types>::value && ...);
 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Defines index and the dtor, possibly trivial.
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool __trivially_destructible, typename... _Types>
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_storage;
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename... _Types>
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using __select_index =
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       typename __select_int::_Select_int_base<sizeof...(_Types),
ARM GAS  /tmp/ccysU9ly.s 			page 68


 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					      unsigned char,
 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					      unsigned short>::type::value_type;
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_storage<false, _Types...>
 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_storage()
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       : _M_index(static_cast<__index_type>(variant_npos))
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { }
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
 397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_index{_Np}
 398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void _M_reset()
 401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if (!_M_valid()) [[unlikely]]
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return;
 404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::__do_visit<void>([](auto&& __this_mem) mutable
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::_Destroy(std::__addressof(__this_mem));
 408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __variant_cast<_Types...>(*this));
 409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_index = static_cast<__index_type>(variant_npos);
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       ~_Variant_storage()
 414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_reset(); }
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void*
 417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_storage() const noexcept
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return const_cast<void*>(static_cast<const void*>(
 420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::addressof(_M_u)));
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr bool
 424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_valid() const noexcept
 425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (__variant::__never_valueless<_Types...>())
 427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return true;
 428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return this->_M_index != __index_type(variant_npos);
 429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variadic_union<_Types...> _M_u;
 432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using __index_type = __select_index<_Types...>;
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __index_type _M_index;
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_storage<true, _Types...>
 438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
ARM GAS  /tmp/ccysU9ly.s 			page 69


 439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr
 440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_storage()
 441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       : _M_index(static_cast<__index_type>(variant_npos))
 442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { }
 443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
 447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_index{_Np}
 449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void _M_reset() noexcept
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_index = static_cast<__index_type>(variant_npos); }
 453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void*
 455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_storage() const noexcept
 456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return const_cast<void*>(static_cast<const void*>(
 458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::addressof(_M_u)));
 459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr bool
 462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_valid() const noexcept
 463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (__variant::__never_valueless<_Types...>())
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return true;
 466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return this->_M_index != static_cast<__index_type>(variant_npos);
 467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variadic_union<_Types...> _M_u;
 470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using __index_type = __select_index<_Types...>;
 471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __index_type _M_index;
 472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Variant_storage_alias =
 476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_storage<_Traits<_Types...>::_S_trivial_dtor, _Types...>;
 477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Up>
 479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void __variant_construct_single(_Tp&& __lhs, _Up&& __rhs_mem)
 480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void* __storage = std::addressof(__lhs._M_u);
 482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Type = remove_reference_t<decltype(__rhs_mem)>;
 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if constexpr (!is_same_v<_Type, __variant_cookie>)
 484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         ::new (__storage)
 485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Type(std::forward<decltype(__rhs_mem)>(__rhs_mem));
 486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types, typename _Tp, typename _Up>
 489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void __variant_construct(_Tp&& __lhs, _Up&& __rhs)
 490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __lhs._M_index = __rhs._M_index;
 492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __variant::__raw_visit([&__lhs](auto&& __rhs_mem) mutable
 493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(std::forward<_Tp>(__lhs),
 495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      std::forward<decltype(__rhs_mem)>(__rhs_mem));
ARM GAS  /tmp/ccysU9ly.s 			page 70


 496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}, __variant_cast<_Types...>(std::forward<_Up>(__rhs)));
 497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The following are (Copy|Move) (ctor|assign) layers for forwarding
 500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // triviality and handling non-trivial SMF behaviors.
 501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_ctor_base : _Variant_storage_alias<_Types...>
 504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Variant_storage_alias<_Types...>;
 506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base(const _Copy_ctor_base& __rhs)
 509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_copy_ctor)
 510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant_construct<_Types...>(*this, __rhs);
 512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base(_Copy_ctor_base&&) = default;
 515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base& operator=(const _Copy_ctor_base&) = default;
 516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base& operator=(_Copy_ctor_base&&) = default;
 517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_ctor_base<true, _Types...> : _Variant_storage_alias<_Types...>
 521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Variant_storage_alias<_Types...>;
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Copy_ctor_alias =
 528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Copy_ctor_base<_Traits<_Types...>::_S_trivial_copy_ctor, _Types...>;
 529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_ctor_base : _Copy_ctor_alias<_Types...>
 532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_ctor_alias<_Types...>;
 534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base(_Move_ctor_base&& __rhs)
 537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_move_ctor)
 538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant_construct<_Types...>(*this, std::move(__rhs));
 540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)
 544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, std::forward<_Up>(__rhs));
 547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)
 552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
ARM GAS  /tmp/ccysU9ly.s 			page 71


 553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, __rhs);
 555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base(const _Move_ctor_base&) = default;
 559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base& operator=(const _Move_ctor_base&) = default;
 560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base& operator=(_Move_ctor_base&&) = default;
 561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_ctor_base<true, _Types...> : _Copy_ctor_alias<_Types...>
 565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_ctor_alias<_Types...>;
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)
 571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, std::forward<_Up>(__rhs));
 574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)
 579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, __rhs);
 582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Move_ctor_alias =
 588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Move_ctor_base<_Traits<_Types...>::_S_trivial_move_ctor, _Types...>;
 589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_assign_base : _Move_ctor_alias<_Types...>
 592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Move_ctor_alias<_Types...>;
 594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base&
 597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       operator=(const _Copy_assign_base& __rhs)
 598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_copy_assign)
 599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant::__raw_idx_visit(
 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  [this](auto&& __rhs_mem, auto __rhs_index) mutable
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
 603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    if constexpr (__rhs_index != variant_npos)
 604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      {
 605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		if (this->_M_index == __rhs_index)
 606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant::__get<__rhs_index>(*this) = __rhs_mem;
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		else
 608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  {
 609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    using __rhs_type = __remove_cvref_t<decltype(__rhs_mem)>;
ARM GAS  /tmp/ccysU9ly.s 			page 72


 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    if constexpr (is_nothrow_copy_constructible_v<__rhs_type>
 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			|| !is_nothrow_move_constructible_v<__rhs_type>)
 612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // The standard says this->emplace<__rhs_type>(__rhs_mem)
 613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // should be used here, but _M_destructive_copy is
 614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // equivalent in this case. Either copy construction
 615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // doesn't throw, so _M_destructive_copy gives strong
 616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // exception safety guarantee, or both copy construction
 617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // and move construction can throw, so emplace only gives
 618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // basic exception safety anyway.
 619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      this->_M_destructive_copy(__rhs_index, __rhs_mem);
 620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    else
 621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      __variant_cast<_Types...>(*this)
 622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			= variant<_Types...>(std::in_place_index<__rhs_index>,
 623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					     __rhs_mem);
 624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  }
 625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      }
 626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    else
 627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
 628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __variant_cast<_Types...>(__rhs));
 629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return *this;
 630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base(const _Copy_assign_base&) = default;
 633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base(_Copy_assign_base&&) = default;
 634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base& operator=(_Copy_assign_base&&) = default;
 635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_assign_base<true, _Types...> : _Move_ctor_alias<_Types...>
 639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Move_ctor_alias<_Types...>;
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Copy_assign_alias =
 646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base<_Traits<_Types...>::_S_trivial_copy_assign, _Types...>;
 647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_assign_base : _Copy_assign_alias<_Types...>
 650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_assign_alias<_Types...>;
 652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base&
 655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       operator=(_Move_assign_base&& __rhs)
 656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_move_assign)
 657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant::__raw_idx_visit(
 659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  [this](auto&& __rhs_mem, auto __rhs_index) mutable
 660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
 661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    if constexpr (__rhs_index != variant_npos)
 662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      {
 663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		if (this->_M_index == __rhs_index)
 664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant::__get<__rhs_index>(*this) = std::move(__rhs_mem);
 665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		else
 666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant_cast<_Types...>(*this)
ARM GAS  /tmp/ccysU9ly.s 			page 73


 667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    .template emplace<__rhs_index>(std::move(__rhs_mem));
 668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      }
 669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    else
 670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
 671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __variant_cast<_Types...>(__rhs));
 672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return *this;
 673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base(const _Move_assign_base&) = default;
 676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base(_Move_assign_base&&) = default;
 677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base& operator=(const _Move_assign_base&) = default;
 678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_assign_base<true, _Types...> : _Copy_assign_alias<_Types...>
 682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_assign_alias<_Types...>;
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Move_assign_alias =
 689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base<_Traits<_Types...>::_S_trivial_move_assign, _Types...>;
 690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_base : _Move_assign_alias<_Types...>
 693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Move_assign_alias<_Types...>;
 695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base()
 698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_default_ctor)
 699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       : _Variant_base(in_place_index<0>) { }
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_base(in_place_index_t<_Np> __i, _Args&&... __args)
 704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _Base(__i, std::forward<_Args>(__args)...)
 705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base(const _Variant_base&) = default;
 708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base(_Variant_base&&) = default;
 709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base& operator=(const _Variant_base&) = default;
 710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base& operator=(_Variant_base&&) = default;
 711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // For how many times does _Tp appear in _Tuple?
 714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Tuple>
 715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __tuple_count;
 716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Tuple>
 718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr size_t __tuple_count_v =
 719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __tuple_count<_Tp, _Tuple>::value;
 720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __tuple_count<_Tp, tuple<_Types...>>
 723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : integral_constant<size_t, 0> { };
ARM GAS  /tmp/ccysU9ly.s 			page 74


 724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _First, typename... _Rest>
 726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __tuple_count<_Tp, tuple<_First, _Rest...>>
 727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : integral_constant<
 728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	size_t,
 729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__tuple_count_v<_Tp, tuple<_Rest...>> + is_same_v<_Tp, _First>> { };
 730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // TODO: Reuse this in <tuple> ?
 732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr bool __exactly_once =
 734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __tuple_count_v<_Tp, tuple<_Types...>> == 1;
 735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Helper used to check for valid conversions that don't involve narrowing.
 737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Ti> struct _Arr { _Ti _M_x[1]; };
 738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Build an imaginary function FUN(Ti) for each alternative type Ti
 740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Ind, typename _Tp, typename _Ti,
 741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   bool _Ti_is_cv_bool = is_same_v<remove_cv_t<_Ti>, bool>,
 742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename = void>
 743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUN
 744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // This function means 'using _Build_FUN<I, T, Ti>::_S_fun;' is valid,
 746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // but only static functions will be considered in the call below.
 747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void _S_fun();
 748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // ... for which Ti x[] = {std::forward<T>(t)}; is well-formed,
 751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Ind, typename _Tp, typename _Ti>
 752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUN<_Ind, _Tp, _Ti, false,
 753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      void_t<decltype(_Arr<_Ti>{{std::declval<_Tp>()}})>>
 754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // This is the FUN function for type _Ti, with index _Ind
 756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static integral_constant<size_t, _Ind> _S_fun(_Ti);
 757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // ... and if Ti is cv bool, remove_cvref_t<T> is bool.
 760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Ind, typename _Tp, typename _Ti>
 761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUN<_Ind, _Tp, _Ti, true,
 762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      enable_if_t<is_same_v<__remove_cvref_t<_Tp>, bool>>>
 763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // This is the FUN function for when _Ti is cv bool, with index _Ind
 765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static integral_constant<size_t, _Ind> _S_fun(_Ti);
 766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant,
 769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename = make_index_sequence<variant_size_v<_Variant>>>
 770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUNs;
 771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Ti, size_t... _Ind>
 773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUNs<_Tp, variant<_Ti...>, index_sequence<_Ind...>>
 774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _Build_FUN<_Ind, _Tp, _Ti>...
 775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Build_FUN<_Ind, _Tp, _Ti>::_S_fun...;
 777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The index j of the overload FUN(Tj) selected by overload resolution
 780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // for FUN(std::forward<_Tp>(t))
ARM GAS  /tmp/ccysU9ly.s 			page 75


 781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant>
 782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _FUN_type
 783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       = decltype(_Build_FUNs<_Tp, _Variant>::_S_fun(std::declval<_Tp>()));
 784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The index selected for FUN(std::forward<T>(t)), or variant_npos if none.
 786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant, typename = void>
 787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __accepted_index
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : integral_constant<size_t, variant_npos>
 789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { };
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant>
 792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __accepted_index<_Tp, _Variant, void_t<_FUN_type<_Tp, _Variant>>>
 793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _FUN_type<_Tp, _Variant>
 794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { };
 795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns the raw storage for __v.
 797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
 798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void* __get_storage(_Variant&& __v) noexcept
 799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return __v._M_storage(); }
 800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename _Maybe_variant_cookie, typename _Variant>
 802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Extra_visit_slot_needed
 803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename> struct _Variant_never_valueless;
 805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Types>
 807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct _Variant_never_valueless<variant<_Types...>>
 808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: bool_constant<__variant::__never_valueless<_Types...>()> {};
 809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool value =
 811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	(is_same_v<_Maybe_variant_cookie, __variant_cookie>
 812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	 || is_same_v<_Maybe_variant_cookie, __variant_idx_cookie>)
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	&& !_Variant_never_valueless<__remove_cvref_t<_Variant>>::value;
 814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Used for storing a multi-dimensional vtable.
 817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, size_t... _Dimensions>
 818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Multi_array;
 819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Partial specialization with rank zero, stores a single _Tp element.
 821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp>
 822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Multi_array<_Tp>
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename>
 825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result
 826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
 827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = _Tp; };
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Args>
 830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<const void(*)(_Args...)>
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
 832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = void(*)(_Args...); };
 833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Args>
 835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<__variant_cookie(*)(_Args...)>
 836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
 837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = void(*)(_Args...); };
ARM GAS  /tmp/ccysU9ly.s 			page 76


 838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Args>
 840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<__variant_idx_cookie(*)(_Args...)>
 841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
 842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = void(*)(_Args...); };
 843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename _Res, typename... _Args>
 845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<__deduce_visit_result<_Res>(*)(_Args...)>
 846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: true_type
 847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = _Res(*)(_Args...); };
 848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using __result_is_deduced = __untag_result<_Tp>;
 850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr const typename __untag_result<_Tp>::element_type&
 852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_access() const
 853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_data; }
 854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       typename __untag_result<_Tp>::element_type _M_data;
 856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Partial specialization with rank >= 1.
 859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Ret,
 860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename _Visitor,
 861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename... _Variants,
 862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   size_t __first, size_t... __rest>
 863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Multi_array<_Ret(*)(_Visitor, _Variants...), __first, __rest...>
 864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr size_t __index =
 866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	sizeof...(_Variants) - sizeof...(__rest) - 1;
 867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Variant = typename _Nth_type<__index, _Variants...>::type;
 869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr int __do_cookie =
 871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Extra_visit_slot_needed<_Ret, _Variant>::value ? 1 : 0;
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Tp = _Ret(*)(_Visitor, _Variants...);
 874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr decltype(auto)
 877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_access(size_t __first_index, _Args... __rest_indices) const
 878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return _M_arr[__first_index + __do_cookie]
 880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    ._M_access(__rest_indices...);
 881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Multi_array<_Tp, __rest...> _M_arr[__first + __do_cookie];
 884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Creates a multi-dimensional vtable recursively.
 887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //
 888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // For example,
 889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // visit([](auto, auto){},
 890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //       variant<int, char>(),  // typedef'ed as V1
 891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //       variant<float, double, long double>())  // typedef'ed as V2
 892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // will trigger instantiations of:
 893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 2, 3>,
 894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                   tuple<V1&&, V2&&>, std::index_sequence<>>
ARM GAS  /tmp/ccysU9ly.s 			page 77


 895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //   __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 3>,
 896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                     tuple<V1&&, V2&&>, std::index_sequence<0>>
 897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 0>>
 899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 1>>
 901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 2>>
 903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //   __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 3>,
 904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                     tuple<V1&&, V2&&>, std::index_sequence<1>>
 905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 0>>
 907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 1>>
 909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 2>>
 911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The returned multi-dimensional vtable can be fast accessed by the visitor
 912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // using index calculation.
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Array_type, typename _Index_seq>
 914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable_impl;
 915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Defines the _S_apply() member that returns a _Multi_array populated
 917:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // with function pointers that perform the visitation expressions e(m)
 918:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // for each valid pack of indexes into the variant types _Variants.
 919:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //
 920:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // This partial specialization builds up the index sequences by recursively
 921:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // calling _S_apply() on the next specialization of __gen_vtable_impl.
 922:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The base case of the recursion defines the actual function pointers.
 923:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, size_t... __dimensions,
 924:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename... _Variants, size_t... __indices>
 925:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable_impl<
 926:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Multi_array<_Result_type (*)(_Visitor, _Variants...), __dimensions...>,
 927:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::index_sequence<__indices...>>
 928:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 929:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Next =
 930:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  remove_reference_t<typename _Nth_type<sizeof...(__indices),
 931:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			     _Variants...>::type>;
 932:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Array_type =
 933:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Multi_array<_Result_type (*)(_Visitor, _Variants...),
 934:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		       __dimensions...>;
 935:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 936:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr _Array_type
 937:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _S_apply()
 938:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 939:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Array_type __vtable{};
 940:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_S_apply_all_alts(
 941:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __vtable, make_index_sequence<variant_size_v<_Next>>());
 942:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return __vtable;
 943:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 944:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 945:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t... __var_indices>
 946:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr void
 947:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_S_apply_all_alts(_Array_type& __vtable,
 948:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			  std::index_sequence<__var_indices...>)
 949:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 950:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (_Extra_visit_slot_needed<_Result_type, _Next>::value)
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    (_S_apply_single_alt<true, __var_indices>(
ARM GAS  /tmp/ccysU9ly.s 			page 78


 952:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __vtable._M_arr[__var_indices + 1],
 953:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      &(__vtable._M_arr[0])), ...);
 954:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 955:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    (_S_apply_single_alt<false, __var_indices>(
 956:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __vtable._M_arr[__var_indices]), ...);
 957:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 958:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 959:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<bool __do_cookie, size_t __index, typename _Tp>
 960:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr void
 961:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_S_apply_single_alt(_Tp& __element, _Tp* __cookie_element = nullptr)
 962:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 963:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__do_cookie)
 964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
 965:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element = __gen_vtable_impl<
 966:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		_Tp,
 967:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::index_sequence<__indices..., __index>>::_S_apply();
 968:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      *__cookie_element = __gen_vtable_impl<
 969:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		_Tp,
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::index_sequence<__indices..., variant_npos>>::_S_apply();
 971:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
 972:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 973:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
 974:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element = __gen_vtable_impl<
 975:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		remove_reference_t<decltype(__element)>,
 976:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::index_sequence<__indices..., __index>>::_S_apply();
 977:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
 978:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 979:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 980:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 981:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // This partial specialization is the base case for the recursion.
 982:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // It populates a _Multi_array element with the address of a function
 983:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // that invokes the visitor with the alternatives specified by __indices.
 984:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, typename... _Variants,
 985:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   size_t... __indices>
 986:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable_impl<
 987:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Multi_array<_Result_type (*)(_Visitor, _Variants...)>,
 988:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		   std::index_sequence<__indices...>>
 989:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 990:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Array_type =
 991:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Multi_array<_Result_type (*)(_Visitor, _Variants...)>;
 992:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 993:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t __index, typename _Variant>
 994:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr decltype(auto)
 995:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__element_by_index_or_cookie(_Variant&& __var) noexcept
 996:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 997:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__index != variant_npos)
 998:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return __variant::__get<__index>(std::forward<_Variant>(__var));
 999:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
1000:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return __variant_cookie{};
1001:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1002:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1003:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr decltype(auto)
1004:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __visit_invoke(_Visitor&& __visitor, _Variants... __vars)
1005:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
1006:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (is_same_v<_Result_type, __variant_idx_cookie>)
1007:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // For raw visitation using indices, pass the indices to the visitor
1008:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // and discard the return value:
ARM GAS  /tmp/ccysU9ly.s 			page 79


1009:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  std::__invoke(std::forward<_Visitor>(__visitor),
1010:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element_by_index_or_cookie<__indices>(
1011:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::forward<_Variants>(__vars))...,
1012:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      integral_constant<size_t, __indices>()...);
1013:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (is_same_v<_Result_type, __variant_cookie>)
1014:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // For raw visitation without indices, and discard the return value:
1015:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  std::__invoke(std::forward<_Visitor>(__visitor),
1016:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element_by_index_or_cookie<__indices>(
1017:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::forward<_Variants>(__vars))...);
1018:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (_Array_type::__result_is_deduced::value)
1019:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // For the usual std::visit case deduce the return value:
1020:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return std::__invoke(std::forward<_Visitor>(__visitor),
1021:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element_by_index_or_cookie<__indices>(
1022:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::forward<_Variants>(__vars))...);
1023:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else // for std::visit<R> use INVOKE<R>
1024:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return std::__invoke_r<_Result_type>(
1025:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      std::forward<_Visitor>(__visitor),
1026:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __variant::__get<__indices>(std::forward<_Variants>(__vars))...);
1027:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
1028:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1029:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr auto
1030:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _S_apply()
1031:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _Array_type{&__visit_invoke}; }
1032:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
1033:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1034:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, typename... _Variants>
1035:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable
1036:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1037:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Array_type =
1038:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Multi_array<_Result_type (*)(_Visitor, _Variants...),
1039:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		       variant_size_v<remove_reference_t<_Variants>>...>;
1040:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1041:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr _Array_type _S_vtable
1042:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	= __gen_vtable_impl<_Array_type, std::index_sequence<>>::_S_apply();
1043:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
1044:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1045:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Tp>
1046:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Base_dedup : public _Tp { };
1047:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1048:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant, typename __indices>
1049:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_hash_base;
1050:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1051:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types, size_t... __indices>
1052:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_hash_base<variant<_Types...>,
1053:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			      std::index_sequence<__indices...>>
1054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _Base_dedup<__indices, __poison_hash<remove_const_t<_Types>>>... { };
1055:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1056:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
1057:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using __get_t = decltype(std::get<_Np>(std::declval<_Variant>()));
1058:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1059:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Return type of std::visit.
1060:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
1061:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using __visit_result_t
1062:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       = invoke_result_t<_Visitor, __get_t<0, _Variants>...>;
1063:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1064:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __variant
1065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __detail
ARM GAS  /tmp/ccysU9ly.s 			page 80


1066:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1067:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant, typename... _Args>
1068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void __variant_construct_by_index(_Variant& __v, _Args&&... __args)
1069:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __v._M_index = _Np;
1071:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       auto&& __storage = __detail::__variant::__get<_Np>(__v);
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       ::new ((void*)std::addressof(__storage))
1073:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         remove_reference_t<decltype(__storage)>
1074:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (std::forward<_Args>(__args)...);
1075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1076:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1077:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1078:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr bool
1079:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     holds_alternative(const variant<_Types...>& __v) noexcept
1080:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1081:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1082:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1083:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __v.index() == __detail::__variant::__index_of_v<_Tp, _Types...>;
1084:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1085:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1086:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1087:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr _Tp& get(variant<_Types...>& __v)
1088:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1089:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1090:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1091:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1092:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
1093:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1094:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1095:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1096:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr _Tp&& get(variant<_Types...>&& __v)
1097:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1098:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1099:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::move(__v));
1103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr const _Tp& get(const variant<_Types...>& __v)
1107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
1112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr const _Tp&& get(const variant<_Types...>&& __v)
1116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::move(__v));
1122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
ARM GAS  /tmp/ccysU9ly.s 			page 81


1123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
1125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr add_pointer_t<variant_alternative_t<_Np, variant<_Types...>>>
1126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(variant<_Types...>* __ptr) noexcept
1127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
1129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(_Np < sizeof...(_Types),
1130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "The index must be in [0, number of alternatives)");
1131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Alternative_type>, "_Tp must not be void");
1132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if (__ptr && __ptr->index() == _Np)
1133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return std::addressof(__detail::__variant::__get<_Np>(*__ptr));
1134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return nullptr;
1135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
1138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr
1139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     add_pointer_t<const variant_alternative_t<_Np, variant<_Types...>>>
1140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(const variant<_Types...>* __ptr) noexcept
1141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
1143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(_Np < sizeof...(_Types),
1144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "The index must be in [0, number of alternatives)");
1145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Alternative_type>, "_Tp must not be void");
1146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if (__ptr && __ptr->index() == _Np)
1147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return std::addressof(__detail::__variant::__get<_Np>(*__ptr));
1148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return nullptr;
1149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr add_pointer_t<_Tp>
1153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(variant<_Types...>* __ptr) noexcept
1154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __ptr);
1160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr add_pointer_t<const _Tp>
1164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(const variant<_Types...>* __ptr) noexcept
1165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __ptr);
1171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   struct monostate { };
1174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP, __NAME) \
1176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types> \
1177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr bool operator __OP(const variant<_Types...>& __lhs, \
1178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				 const variant<_Types...>& __rhs) \
1179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { \
ARM GAS  /tmp/ccysU9ly.s 			page 82


1180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       bool __ret = true; \
1181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __detail::__variant::__raw_idx_visit( \
1182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         [&__ret, &__lhs] (auto&& __rhs_mem, auto __rhs_index) mutable \
1183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         { \
1184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__rhs_index != variant_npos) \
1185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    { \
1186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      if (__lhs.index() == __rhs_index) \
1187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	        { \
1188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  auto& __this_mem = std::get<__rhs_index>(__lhs);	\
1189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****                   __ret = __this_mem __OP __rhs_mem; \
1190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****                 } \
1191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      else \
1192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		__ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \
1193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****             } \
1194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****           else \
1195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****             __ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \
1196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}, __rhs); \
1197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __ret; \
1198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(<, less)
1201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(<=, less_equal)
1202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(==, equal)
1203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(!=, not_equal)
1204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(>=, greater_equal)
1205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(>, greater)
1206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #undef _VARIANT_RELATION_FUNCTION_TEMPLATE
1208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator==(monostate, monostate) noexcept { return true; }
1210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #ifdef __cpp_lib_three_way_comparison
1212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     requires (three_way_comparable<_Types> && ...)
1214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr
1215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     common_comparison_category_t<compare_three_way_result_t<_Types>...>
1216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     operator<=>(const variant<_Types...>& __v, const variant<_Types...>& __w)
1217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       common_comparison_category_t<compare_three_way_result_t<_Types>...> __ret
1219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	= strong_ordering::equal;
1220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __detail::__variant::__raw_idx_visit(
1222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	[&__ret, &__v] (auto&& __w_mem, auto __w_index) mutable
1223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__w_index != variant_npos)
1225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      if (__v.index() == __w_index)
1227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  auto& __this_mem = std::get<__w_index>(__v);
1229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __ret = __this_mem <=> __w_mem;
1230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  return;
1231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __ret = (__v.index() + 1) <=> (__w_index + 1);
1234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}, __w);
1235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __ret;
1236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
ARM GAS  /tmp/ccysU9ly.s 			page 83


1237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr strong_ordering
1239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   operator<=>(monostate, monostate) noexcept { return strong_ordering::equal; }
1240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #else
1241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator!=(monostate, monostate) noexcept { return false; }
1242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator<(monostate, monostate) noexcept { return false; }
1243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator>(monostate, monostate) noexcept { return false; }
1244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator<=(monostate, monostate) noexcept { return true; }
1245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator>=(monostate, monostate) noexcept { return true; }
1246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #endif
1247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
1249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
1250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     visit(_Visitor&&, _Variants&&...);
1251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline enable_if_t<(is_move_constructible_v<_Types> && ...)
1254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			&& (is_swappable_v<_Types> && ...)>
1255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     swap(variant<_Types...>& __lhs, variant<_Types...>& __rhs)
1256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     noexcept(noexcept(__lhs.swap(__rhs)))
1257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { __lhs.swap(__rhs); }
1258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     enable_if_t<!((is_move_constructible_v<_Types> && ...)
1261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		   && (is_swappable_v<_Types> && ...))>
1262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     swap(variant<_Types...>&, variant<_Types...>&) = delete;
1263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   class bad_variant_access : public exception
1265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
1266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   public:
1267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     bad_variant_access() noexcept { }
1268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     const char* what() const noexcept override
1270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return _M_reason; }
1271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   private:
1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     bad_variant_access(const char* __reason) noexcept : _M_reason(__reason) { }
1274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     // Must point to a string with static storage duration:
1276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     const char* _M_reason = "bad variant access";
1277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     friend void __throw_bad_variant_access(const char* __what);
1279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   };
1280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Must only be called with a string literal
1282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   inline void
1283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   __throw_bad_variant_access(const char* __what)
1284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   { _GLIBCXX_THROW_OR_ABORT(bad_variant_access(__what)); }
1285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   inline void
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   __throw_bad_variant_access(bool __valueless)
1288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     if (__valueless) [[__unlikely__]]
1290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
1291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     else
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: wrong index for variant");
1293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
ARM GAS  /tmp/ccysU9ly.s 			page 84


1294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     class variant
1297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : private __detail::__variant::_Variant_base<_Types...>,
1298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       private _Enable_default_constructor<
1299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_default_ctor,
1300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  variant<_Types...>>,
1301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       private _Enable_copy_move<
1302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_copy_ctor,
1303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_copy_assign,
1304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_move_ctor,
1305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_move_assign,
1306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant<_Types...>>
1307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     private:
1309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _UTypes, typename _Tp>
1310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend decltype(auto) __variant_cast(_Tp&&);
1311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename _Variant, typename... _Args>
1312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend void __variant_construct_by_index(_Variant& __v,
1313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						 _Args&&... __args);
1314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(sizeof...(_Types) > 0,
1316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "variant must have at least one alternative");
1317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!(std::is_reference_v<_Types> || ...),
1318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "variant must have no reference alternative");
1319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!(std::is_void_v<_Types> || ...),
1320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "variant must have no void alternative");
1321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = __detail::__variant::_Variant_base<_Types...>;
1323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Default_ctor_enabler =
1324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Enable_default_constructor<
1325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __detail::__variant::_Traits<_Types...>::_S_default_ctor,
1326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    variant<_Types...>>;
1327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr bool __not_self
1330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  = !is_same_v<__remove_cvref_t<_Tp>, variant>;
1331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr bool
1334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__exactly_once = __detail::__variant::__exactly_once<_Tp, _Types...>;
1335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr size_t __accepted_index
1338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  = __detail::__variant::__accepted_index<_Tp, variant>::value;
1339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename = enable_if_t<(_Np < sizeof...(_Types))>>
1341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	using __to_type = variant_alternative_t<_Np, variant>;
1342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename = enable_if_t<__not_self<_Tp>>>
1344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	using __accepted_type = __to_type<__accepted_index<_Tp>>;
1345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr size_t __index_of =
1348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __detail::__variant::__index_of_v<_Tp, _Types...>;
1349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Traits = __detail::__variant::_Traits<_Types...>;
ARM GAS  /tmp/ccysU9ly.s 			page 85


1351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __is_in_place_tag : false_type { };
1354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __is_in_place_tag<in_place_type_t<_Tp>> : true_type { };
1356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np>
1357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __is_in_place_tag<in_place_index_t<_Np>> : true_type { };
1358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr bool __not_in_place_tag
1361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  = !__is_in_place_tag<__remove_cvref_t<_Tp>>::value;
1362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     public:
1364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant() = default;
 1064              		.loc 14 1364 7 view .LVU160
 1065              	.LBB789:
 1066 0412 00F56356 		add	r6, r0, #14528
 1067              	.LVL66:
 1068              	.LBB790:
 1069              	.LBI790:
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_default_ctor)
 1070              		.loc 14 697 7 view .LVU161
 1071              	.LBB791:
 1072              	.LBB792:
 1073              	.LBI792:
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _Base(__i, std::forward<_Args>(__args)...)
 1074              		.loc 14 703 2 view .LVU162
 1075              	.LBB793:
 1076              	.LBB794:
 1077              	.LBI794:
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 1078              		.loc 14 684 20 view .LVU163
 1079              	.LBB795:
 1080              	.LBB796:
 1081              	.LBI796:
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 1082              		.loc 14 641 20 view .LVU164
 1083              	.LBB797:
 1084              	.LBB798:
 1085              	.LBI798:
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 1086              		.loc 14 567 20 view .LVU165
 1087              	.LBB799:
 1088              	.LBB800:
 1089              	.LBI800:
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 1090              		.loc 14 523 20 view .LVU166
 1091              	.LBB801:
 1092              	.LBB802:
 1093              	.LBI802:
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
 1094              		.loc 14 446 2 view .LVU167
 1095              	.LBB803:
 1096              	.LBB804:
 1097              	.LBI804:
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_first(in_place_index<0>, std::forward<_Args>(__args)...)
 1098              		.loc 14 335 12 view .LVU168
ARM GAS  /tmp/ccysU9ly.s 			page 86


 1099              	.LBB805:
 1100              	.LBB806:
 1101              	.LBI806:
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_storage(std::forward<_Args>(__args)...)
 1102              		.loc 14 215 2 view .LVU169
 1103              	.LBB807:
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1104              		.loc 14 216 45 is_stmt 0 view .LVU170
 1105 0416 7262     		str	r2, [r6, #36]	@ float
 1106              	.LVL67:
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1107              		.loc 14 216 45 view .LVU171
 1108              	.LBE807:
 1109              	.LBE806:
 1110              	.LBE805:
 1111              	.LBE804:
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1112              		.loc 14 448 14 view .LVU172
 1113 0418 86F82810 		strb	r1, [r6, #40]
 1114              	.LVL68:
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1115              		.loc 14 448 14 view .LVU173
 1116              	.LBE803:
 1117              	.LBE802:
 1118              	.LBE801:
 1119              	.LBE800:
 1120              	.LBE799:
 1121              	.LBE798:
 1122              	.LBE797:
 1123              	.LBE796:
 1124              	.LBE795:
 1125              	.LBE794:
 1126              	.LBE793:
 1127              	.LBE792:
 1128              	.LBE791:
 1129              	.LBE790:
 1130              	.LBE789:
 1131              	.LBE788:
 1132              	.LBE787:
 1133              	.LBB808:
 1134              	.LBI808:
 1135              		.loc 12 123 7 is_stmt 1 view .LVU174
 1136              	.LBB809:
 1137              	.LBI809:
 1138              		.loc 14 1364 7 view .LVU175
 1139              	.LBB810:
 1140 041c 00F56356 		add	r6, r0, #14528
 1141              	.LVL69:
 1142              	.LBB811:
 1143              	.LBI811:
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_default_ctor)
 1144              		.loc 14 697 7 view .LVU176
 1145              	.LBB812:
 1146              	.LBB813:
 1147              	.LBI813:
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _Base(__i, std::forward<_Args>(__args)...)
 1148              		.loc 14 703 2 view .LVU177
ARM GAS  /tmp/ccysU9ly.s 			page 87


 1149              	.LBB814:
 1150              	.LBB815:
 1151              	.LBI815:
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 1152              		.loc 14 684 20 view .LVU178
 1153              	.LBB816:
 1154              	.LBB817:
 1155              	.LBI817:
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 1156              		.loc 14 641 20 view .LVU179
 1157              	.LBB818:
 1158              	.LBB819:
 1159              	.LBI819:
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 1160              		.loc 14 567 20 view .LVU180
 1161              	.LBB820:
 1162              	.LBB821:
 1163              	.LBI821:
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 1164              		.loc 14 523 20 view .LVU181
 1165              	.LBB822:
 1166              	.LBB823:
 1167              	.LBI823:
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
 1168              		.loc 14 446 2 view .LVU182
 1169              	.LBB824:
 1170              	.LBB825:
 1171              	.LBI825:
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_first(in_place_index<0>, std::forward<_Args>(__args)...)
 1172              		.loc 14 335 12 view .LVU183
 1173              	.LBB826:
 1174              	.LBB827:
 1175              	.LBI827:
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_storage(std::forward<_Args>(__args)...)
 1176              		.loc 14 215 2 view .LVU184
 1177              	.LBB828:
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1178              		.loc 14 216 45 is_stmt 0 view .LVU185
 1179 0420 F262     		str	r2, [r6, #44]	@ float
 1180              	.LVL70:
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1181              		.loc 14 216 45 view .LVU186
 1182              	.LBE828:
 1183              	.LBE827:
 1184              	.LBE826:
 1185              	.LBE825:
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1186              		.loc 14 448 14 view .LVU187
 1187 0422 86F83010 		strb	r1, [r6, #48]
 1188              	.LVL71:
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1189              		.loc 14 448 14 view .LVU188
 1190              	.LBE824:
 1191              	.LBE823:
 1192              	.LBE822:
 1193              	.LBE821:
 1194              	.LBE820:
ARM GAS  /tmp/ccysU9ly.s 			page 88


 1195              	.LBE819:
 1196              	.LBE818:
 1197              	.LBE817:
 1198              	.LBE816:
 1199              	.LBE815:
 1200              	.LBE814:
 1201              	.LBE813:
 1202              	.LBE812:
 1203              	.LBE811:
 1204              	.LBE810:
 1205              	.LBE809:
 1206              	.LBE808:
 1207              	.LBB829:
 1208              	.LBI829:
 1209              		.loc 12 123 7 is_stmt 1 view .LVU189
 1210              	.LBB830:
 1211              	.LBI830:
 1212              		.loc 14 1364 7 view .LVU190
 1213              	.LBB831:
 1214 0426 00F56356 		add	r6, r0, #14528
 1215              	.LVL72:
 1216              	.LBB832:
 1217              	.LBI832:
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_default_ctor)
 1218              		.loc 14 697 7 view .LVU191
 1219              	.LBB833:
 1220              	.LBB834:
 1221              	.LBI834:
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _Base(__i, std::forward<_Args>(__args)...)
 1222              		.loc 14 703 2 view .LVU192
 1223              	.LBB835:
 1224              	.LBB836:
 1225              	.LBI836:
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 1226              		.loc 14 684 20 view .LVU193
 1227              	.LBB837:
 1228              	.LBB838:
 1229              	.LBI838:
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 1230              		.loc 14 641 20 view .LVU194
 1231              	.LBB839:
 1232              	.LBB840:
 1233              	.LBI840:
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 1234              		.loc 14 567 20 view .LVU195
 1235              	.LBB841:
 1236              	.LBB842:
 1237              	.LBI842:
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 1238              		.loc 14 523 20 view .LVU196
 1239              	.LBB843:
 1240              	.LBB844:
 1241              	.LBI844:
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
 1242              		.loc 14 446 2 view .LVU197
 1243              	.LBB845:
 1244              	.LBB846:
ARM GAS  /tmp/ccysU9ly.s 			page 89


 1245              	.LBI846:
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_first(in_place_index<0>, std::forward<_Args>(__args)...)
 1246              		.loc 14 335 12 view .LVU198
 1247              	.LBB847:
 1248              	.LBB848:
 1249              	.LBI848:
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_storage(std::forward<_Args>(__args)...)
 1250              		.loc 14 215 2 view .LVU199
 1251              	.LBB849:
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1252              		.loc 14 216 45 is_stmt 0 view .LVU200
 1253 042a 7263     		str	r2, [r6, #52]	@ float
 1254              	.LVL73:
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1255              		.loc 14 216 45 view .LVU201
 1256              	.LBE849:
 1257              	.LBE848:
 1258              	.LBE847:
 1259              	.LBE846:
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1260              		.loc 14 448 14 view .LVU202
 1261 042c 86F83810 		strb	r1, [r6, #56]
 1262              	.LVL74:
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1263              		.loc 14 448 14 view .LVU203
 1264              	.LBE845:
 1265              	.LBE844:
 1266              	.LBE843:
 1267              	.LBE842:
 1268              	.LBE841:
 1269              	.LBE840:
 1270              	.LBE839:
 1271              	.LBE838:
 1272              	.LBE837:
 1273              	.LBE836:
 1274              	.LBE835:
 1275              	.LBE834:
 1276              	.LBE833:
 1277              	.LBE832:
 1278              	.LBE831:
 1279              	.LBE830:
 1280              	.LBE829:
 1281              	.LBB850:
 1282              	.LBI850:
 1283              		.loc 12 123 7 is_stmt 1 view .LVU204
 1284              	.LBB851:
 1285              	.LBI851:
 1286              		.loc 14 1364 7 view .LVU205
 1287              	.LBB852:
 1288 0430 00F56356 		add	r6, r0, #14528
 1289              	.LVL75:
 1290              	.LBB853:
 1291              	.LBI853:
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_default_ctor)
 1292              		.loc 14 697 7 view .LVU206
 1293              	.LBB854:
 1294              	.LBB855:
ARM GAS  /tmp/ccysU9ly.s 			page 90


 1295              	.LBI855:
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _Base(__i, std::forward<_Args>(__args)...)
 1296              		.loc 14 703 2 view .LVU207
 1297              	.LBB856:
 1298              	.LBB857:
 1299              	.LBI857:
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 1300              		.loc 14 684 20 view .LVU208
 1301              	.LBB858:
 1302              	.LBB859:
 1303              	.LBI859:
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 1304              		.loc 14 641 20 view .LVU209
 1305              	.LBB860:
 1306              	.LBB861:
 1307              	.LBI861:
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 1308              		.loc 14 567 20 view .LVU210
 1309              	.LBB862:
 1310              	.LBB863:
 1311              	.LBI863:
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 1312              		.loc 14 523 20 view .LVU211
 1313              	.LBB864:
 1314              	.LBB865:
 1315              	.LBI865:
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
 1316              		.loc 14 446 2 view .LVU212
 1317              	.LBB866:
 1318              	.LBB867:
 1319              	.LBI867:
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_first(in_place_index<0>, std::forward<_Args>(__args)...)
 1320              		.loc 14 335 12 view .LVU213
 1321              	.LBB868:
 1322              	.LBB869:
 1323              	.LBI869:
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_storage(std::forward<_Args>(__args)...)
 1324              		.loc 14 215 2 view .LVU214
 1325              	.LBB870:
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1326              		.loc 14 216 45 is_stmt 0 view .LVU215
 1327 0434 F263     		str	r2, [r6, #60]	@ float
 1328              	.LVL76:
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1329              		.loc 14 216 45 view .LVU216
 1330              	.LBE870:
 1331              	.LBE869:
 1332              	.LBE868:
 1333              	.LBE867:
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1334              		.loc 14 448 14 view .LVU217
 1335 0436 86F84010 		strb	r1, [r6, #64]
 1336              	.LVL77:
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 1337              		.loc 14 448 14 view .LVU218
 1338              	.LBE866:
 1339              	.LBE865:
ARM GAS  /tmp/ccysU9ly.s 			page 91


 1340              	.LBE864:
 1341              	.LBE863:
 1342              	.LBE862:
 1343              	.LBE861:
 1344              	.LBE860:
 1345              	.LBE859:
 1346              	.LBE858:
 1347              	.LBE857:
 1348              	.LBE856:
 1349              	.LBE855:
 1350              	.LBE854:
 1351              	.LBE853:
 1352              	.LBE852:
 1353              	.LBE851:
 1354              	.LBE850:
   4:MotorControl/controller.hpp **** public:
 1355              		.loc 13 4 7 view .LVU219
 1356 043a 03F60416 		addw	r6, r3, #2308
 1357 043e 3260     		str	r2, [r6]	@ float
 1358 0440 03F60816 		addw	r6, r3, #2312
 1359 0444 3260     		str	r2, [r6]	@ float
 1360 0446 03F60C16 		addw	r6, r3, #2316
 1361 044a 3260     		str	r2, [r6]	@ float
 1362 044c 03F51166 		add	r6, r3, #2320
 1363 0450 3260     		str	r2, [r6]	@ float
 1364 0452 03F61416 		addw	r6, r3, #2324
 1365 0456 3260     		str	r2, [r6]	@ float
 1366 0458 03F61816 		addw	r6, r3, #2328
 1367 045c 3260     		str	r2, [r6]	@ float
 1368 045e 03F61C16 		addw	r6, r3, #2332
 1369 0462 3260     		str	r2, [r6]	@ float
 1370 0464 03F51266 		add	r6, r3, #2336
 1371 0468 3260     		str	r2, [r6]	@ float
 1372 046a 03F62416 		addw	r6, r3, #2340
 1373 046e 3260     		str	r2, [r6]	@ float
 1374              	.LVL78:
 1375              	.LBB871:
 1376              	.LBI871:
  17:MotorControl/controller.hpp ****         float frequency = 0.0f;
 1377              		.loc 13 17 12 is_stmt 1 view .LVU220
 1378              	.LBB872:
 1379 0470 03F62816 		addw	r6, r3, #2344
 1380 0474 3260     		str	r2, [r6]	@ float
 1381 0476 7260     		str	r2, [r6, #4]	@ float
 1382 0478 B260     		str	r2, [r6, #8]	@ float
 1383 047a F260     		str	r2, [r6, #12]	@ float
 1384              	.LVL79:
  17:MotorControl/controller.hpp ****         float frequency = 0.0f;
 1385              		.loc 13 17 12 is_stmt 0 view .LVU221
 1386              	.LBE872:
 1387              	.LBE871:
   4:MotorControl/controller.hpp **** public:
 1388              		.loc 13 4 7 view .LVU222
 1389 047c 03F63816 		addw	r6, r3, #2360
 1390 0480 3260     		str	r2, [r6]	@ float
 1391 0482 83F83C19 		strb	r1, [r3, #2364]
 1392 0486 83F83D59 		strb	r5, [r3, #2365]
ARM GAS  /tmp/ccysU9ly.s 			page 92


 1393 048a 83F83E19 		strb	r1, [r3, #2366]
 1394 048e 00F56551 		add	r1, r0, #14656
 1395 0492 0A60     		str	r2, [r1]	@ float
 1396 0494 03F64411 		addw	r1, r3, #2372
 1397 0498 0A60     		str	r2, [r1]	@ float
 1398              	.LVL80:
 1399              	.LBB873:
 1400              	.LBI873:
  47:./MotorControl/component.hpp ****     
 1401              		.loc 12 47 5 is_stmt 1 view .LVU223
 1402              	.LBB874:
  47:./MotorControl/component.hpp ****     
 1403              		.loc 12 47 37 is_stmt 0 view .LVU224
 1404 049a 0221     		movs	r1, #2
 1405 049c C3F84819 		str	r1, [r3, #2376]
 1406 04a0 03F64813 		addw	r3, r3, #2376
 1407 04a4 5A60     		str	r2, [r3, #4]	@ float
 1408              	.LVL81:
  47:./MotorControl/component.hpp ****     
 1409              		.loc 12 47 37 view .LVU225
 1410              	.LBE874:
 1411              	.LBE873:
 1412              	.LBE780:
 1413              	.LBE779:
 120:Board/v3/board.cpp **** TrapezoidalTrajectory trap[AXIS_COUNT];
 1414              		.loc 4 120 34 view .LVU226
 1415 04a6 00F56550 		add	r0, r0, #14656
 1416 04aa 1030     		adds	r0, r0, #16
 120:Board/v3/board.cpp **** TrapezoidalTrajectory trap[AXIS_COUNT];
 1417              		.loc 4 120 34 is_stmt 1 view .LVU227
 1418 04ac 013F     		subs	r7, r7, #1
 1419 04ae 35E7     		b	.L28
 1420              	.L40:
 121:Board/v3/board.cpp **** 
 1421              		.loc 4 121 38 is_stmt 0 view .LVU228
 1422 04b0 5F4B     		ldr	r3, .L53+32
 1423              	.LVL82:
 1424              	.L29:
 121:Board/v3/board.cpp **** 
 1425              		.loc 4 121 38 is_stmt 1 discriminator 4 view .LVU229
 1426 04b2 002C     		cmp	r4, #0
 1427 04b4 0BDB     		blt	.L30
 1428              	.LVL83:
 1429              	.LBB875:
 1430              	.LBI875:
 1431              		.file 15 "MotorControl/trapTraj.hpp"
   1:MotorControl/trapTraj.hpp **** #ifndef _TRAP_TRAJ_H
   2:MotorControl/trapTraj.hpp **** #define _TRAP_TRAJ_H
   3:MotorControl/trapTraj.hpp **** 
   4:MotorControl/trapTraj.hpp **** class TrapezoidalTrajectory {
 1432              		.loc 15 4 7 view .LVU230
 1433              	.LBB876:
 1434 04b6 0022     		movs	r2, #0
 1435 04b8 1A60     		str	r2, [r3]
 1436              	.LVL84:
 1437              	.LBB877:
 1438              	.LBI877:
ARM GAS  /tmp/ccysU9ly.s 			page 93


   5:MotorControl/trapTraj.hpp **** public:
   6:MotorControl/trapTraj.hpp ****     struct Config_t {
 1439              		.loc 15 6 12 view .LVU231
 1440              	.LBB878:
 1441 04ba 4FF08042 		mov	r2, #1073741824
 1442 04be 5A60     		str	r2, [r3, #4]	@ float
 1443 04c0 4FF07C52 		mov	r2, #1056964608
 1444 04c4 9A60     		str	r2, [r3, #8]	@ float
 1445 04c6 DA60     		str	r2, [r3, #12]	@ float
 1446              	.LVL85:
 1447              		.loc 15 6 12 is_stmt 0 view .LVU232
 1448              	.LBE878:
 1449              	.LBE877:
 1450              	.LBE876:
 1451              	.LBE875:
 121:Board/v3/board.cpp **** 
 1452              		.loc 4 121 38 view .LVU233
 1453 04c8 4033     		adds	r3, r3, #64
 121:Board/v3/board.cpp **** 
 1454              		.loc 4 121 38 is_stmt 1 view .LVU234
 1455 04ca 013C     		subs	r4, r4, #1
 1456 04cc F1E7     		b	.L29
 1457              	.L30:
 155:Board/v3/board.cpp **** 
 1458              		.loc 4 155 2 is_stmt 0 discriminator 2 view .LVU235
 1459 04ce DFF8A081 		ldr	r8, .L53+96
 1460 04d2 DFF8A0A1 		ldr	r10, .L53+100
 1461 04d6 CDF820A0 		str	r10, [sp, #32]
 1462 04da 564C     		ldr	r4, .L53+36
 1463 04dc 04F12C03 		add	r3, r4, #44
 1464 04e0 0793     		str	r3, [sp, #28]
 1465 04e2 0694     		str	r4, [sp, #24]
 1466 04e4 DFF84891 		ldr	r9, .L53+32
 1467 04e8 CDF81490 		str	r9, [sp, #20]
 1468 04ec 524F     		ldr	r7, .L53+40
 1469 04ee 0497     		str	r7, [sp, #16]
 1470 04f0 474B     		ldr	r3, .L53
 1471 04f2 0393     		str	r3, [sp, #12]
 1472 04f4 514E     		ldr	r6, .L53+44
 1473 04f6 0296     		str	r6, [sp, #8]
 1474 04f8 514D     		ldr	r5, .L53+48
 1475 04fa 0195     		str	r5, [sp, #4]
 1476 04fc 0323     		movs	r3, #3
 1477 04fe 0093     		str	r3, [sp]
 1478 0500 0223     		movs	r3, #2
 1479 0502 0122     		movs	r2, #1
 1480 0504 0021     		movs	r1, #0
 1481 0506 4046     		mov	r0, r8
 1482 0508 FFF7FEFF 		bl	_ZN4AxisC1Eitt10osPriorityR7EncoderR19SensorlessEstimatorR10ControllerR5MotorR21TrapezoidalTraj
 1483              	.LVL86:
 1484 050c 0AF11003 		add	r3, r10, #16
 1485 0510 0893     		str	r3, [sp, #32]
 1486 0512 04F18403 		add	r3, r4, #132
 1487 0516 0793     		str	r3, [sp, #28]
 1488 0518 5834     		adds	r4, r4, #88
 1489 051a 0694     		str	r4, [sp, #24]
 1490 051c 09F14003 		add	r3, r9, #64
ARM GAS  /tmp/ccysU9ly.s 			page 94


 1491 0520 0593     		str	r3, [sp, #20]
 1492 0522 07F5D877 		add	r7, r7, #432
 1493 0526 0497     		str	r7, [sp, #16]
 1494 0528 464B     		ldr	r3, .L53+52
 1495 052a 0393     		str	r3, [sp, #12]
 1496 052c 4036     		adds	r6, r6, #64
 1497 052e 0296     		str	r6, [sp, #8]
 1498 0530 05F5D075 		add	r5, r5, #416
 1499 0534 0195     		str	r5, [sp, #4]
 1500 0536 0224     		movs	r4, #2
 1501 0538 0094     		str	r4, [sp]
 1502 053a 0823     		movs	r3, #8
 1503 053c 0722     		movs	r2, #7
 1504 053e 0121     		movs	r1, #1
 1505 0540 08F52C70 		add	r0, r8, #688
 1506 0544 FFF7FEFF 		bl	_ZN4AxisC1Eitt10osPriorityR7EncoderR19SensorlessEstimatorR10ControllerR5MotorR21TrapezoidalTraj
 1507              	.LVL87:
 1508              	.LBB879:
 1509              	.LBI879:
 1510              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU236
 1511              	.LBB880:
 1512              	.LBB881:
 1513              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU237
 1514 0548 3F4B     		ldr	r3, .L53+56
 1515 054a 0022     		movs	r2, #0
 1516 054c 1A60     		str	r2, [r3]
 1517 054e 9A80     		strh	r2, [r3, #4]	@ movhi
 1518              	.LVL88:
 1519              		.loc 6 11 77 discriminator 2 view .LVU238
 1520              	.LBE881:
 1521              	.LBE880:
 1522              	.LBE879:
 1523              	.LBB882:
 1524              	.LBI882:
 1525              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU239
 1526              	.LBB883:
 1527              	.LBB884:
 1528              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU240
 1529 0550 3E49     		ldr	r1, .L53+60
 1530 0552 9960     		str	r1, [r3, #8]
 1531 0554 0122     		movs	r2, #1
 1532 0556 9A81     		strh	r2, [r3, #12]	@ movhi
 1533              	.LVL89:
 1534              		.loc 6 11 77 discriminator 2 view .LVU241
 1535              	.LBE884:
 1536              	.LBE883:
 1537              	.LBE882:
 1538              	.LBB885:
 1539              	.LBI885:
 1540              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU242
 1541              	.LBB886:
 1542              	.LBB887:
 1543              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU243
 1544 0558 1961     		str	r1, [r3, #16]
 1545 055a 9C82     		strh	r4, [r3, #20]	@ movhi
 1546              	.LVL90:
 1547              		.loc 6 11 77 discriminator 2 view .LVU244
ARM GAS  /tmp/ccysU9ly.s 			page 95


 1548              	.LBE887:
 1549              	.LBE886:
 1550              	.LBE885:
 1551              	.LBB888:
 1552              	.LBI888:
 1553              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU245
 1554              	.LBB889:
 1555              	.LBB890:
 1556              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU246
 1557 055c 9961     		str	r1, [r3, #24]
 1558 055e 0424     		movs	r4, #4
 1559 0560 9C83     		strh	r4, [r3, #28]	@ movhi
 1560              	.LVL91:
 1561              		.loc 6 11 77 discriminator 2 view .LVU247
 1562              	.LBE890:
 1563              	.LBE889:
 1564              	.LBE888:
 1565              	.LBB891:
 1566              	.LBI891:
 1567              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU248
 1568              	.LBB892:
 1569              	.LBB893:
 1570              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU249
 1571 0562 1962     		str	r1, [r3, #32]
 1572 0564 0826     		movs	r6, #8
 1573 0566 9E84     		strh	r6, [r3, #36]	@ movhi
 1574              	.LVL92:
 1575              		.loc 6 11 77 discriminator 2 view .LVU250
 1576              	.LBE893:
 1577              	.LBE892:
 1578              	.LBE891:
 1579              	.LBB894:
 1580              	.LBI894:
 1581              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU251
 1582              	.LBB895:
 1583              	.LBB896:
 1584              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU252
 1585 0568 3948     		ldr	r0, .L53+64
 1586 056a 9862     		str	r0, [r3, #40]
 1587 056c 1025     		movs	r5, #16
 1588 056e 9D85     		strh	r5, [r3, #44]	@ movhi
 1589              	.LVL93:
 1590              		.loc 6 11 77 discriminator 2 view .LVU253
 1591              	.LBE896:
 1592              	.LBE895:
 1593              	.LBE894:
 1594              	.LBB897:
 1595              	.LBI897:
 1596              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU254
 1597              	.LBB898:
 1598              	.LBB899:
 1599              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU255
 1600 0570 384A     		ldr	r2, .L53+68
 1601 0572 1A63     		str	r2, [r3, #48]
 1602 0574 9C86     		strh	r4, [r3, #52]	@ movhi
 1603              	.LVL94:
 1604              		.loc 6 11 77 discriminator 2 view .LVU256
ARM GAS  /tmp/ccysU9ly.s 			page 96


 1605              	.LBE899:
 1606              	.LBE898:
 1607              	.LBE897:
 1608              	.LBB900:
 1609              	.LBI900:
 1610              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU257
 1611              	.LBB901:
 1612              	.LBB902:
 1613              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU258
 1614 0576 9963     		str	r1, [r3, #56]
 1615 0578 4FF40044 		mov	r4, #32768
 1616 057c 9C87     		strh	r4, [r3, #60]	@ movhi
 1617              	.LVL95:
 1618              		.loc 6 11 77 discriminator 2 view .LVU259
 1619              	.LBE902:
 1620              	.LBE901:
 1621              	.LBE900:
 1622              	.LBB903:
 1623              	.LBI903:
 1624              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU260
 1625              	.LBB904:
 1626              	.LBB905:
 1627              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU261
 1628 057e 1A64     		str	r2, [r3, #64]
 1629 0580 A3F84460 		strh	r6, [r3, #68]	@ movhi
 1630              	.LVL96:
 1631              		.loc 6 11 77 discriminator 2 view .LVU262
 1632              	.LBE905:
 1633              	.LBE904:
 1634              	.LBE903:
 1635              	.LBB906:
 1636              	.LBI906:
 1637              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU263
 1638              	.LBB907:
 1639              	.LBB908:
 1640              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU264
 1641 0584 9A64     		str	r2, [r3, #72]
 1642 0586 A3F84C50 		strh	r5, [r3, #76]	@ movhi
 1643              	.LVL97:
 1644              		.loc 6 11 77 discriminator 2 view .LVU265
 1645              	.LBE908:
 1646              	.LBE907:
 1647              	.LBE906:
 1648              	.LBB909:
 1649              	.LBI909:
 1650              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU266
 1651              	.LBB910:
 1652              	.LBB911:
 1653              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU267
 1654 058a 1A65     		str	r2, [r3, #80]
 1655 058c 2021     		movs	r1, #32
 1656 058e A3F85410 		strh	r1, [r3, #84]	@ movhi
 1657              	.LVL98:
 1658              		.loc 6 11 77 discriminator 2 view .LVU268
 1659              	.LBE911:
 1660              	.LBE910:
 1661              	.LBE909:
ARM GAS  /tmp/ccysU9ly.s 			page 97


 1662              	.LBB912:
 1663              	.LBI912:
 1664              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU269
 1665              	.LBB913:
 1666              	.LBB914:
 1667              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU270
 1668 0592 9865     		str	r0, [r3, #88]
 1669 0594 4FF40071 		mov	r1, #512
 1670 0598 A3F85C10 		strh	r1, [r3, #92]	@ movhi
 1671              	.LVL99:
 1672              		.loc 6 11 77 discriminator 2 view .LVU271
 1673              	.LBE914:
 1674              	.LBE913:
 1675              	.LBE912:
 1676              	.LBB915:
 1677              	.LBI915:
 1678              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU272
 1679              	.LBB916:
 1680              	.LBB917:
 1681              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU273
 1682 059c 1A66     		str	r2, [r3, #96]
 1683 059e 4025     		movs	r5, #64
 1684 05a0 A3F86450 		strh	r5, [r3, #100]	@ movhi
 1685              	.LVL100:
 1686              		.loc 6 11 77 discriminator 2 view .LVU274
 1687              	.LBE917:
 1688              	.LBE916:
 1689              	.LBE915:
 1690              	.LBB918:
 1691              	.LBI918:
 1692              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU275
 1693              	.LBB919:
 1694              	.LBB920:
 1695              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU276
 1696 05a4 9A66     		str	r2, [r3, #104]
 1697 05a6 8025     		movs	r5, #128
 1698 05a8 A3F86C50 		strh	r5, [r3, #108]	@ movhi
 1699              	.LVL101:
 1700              		.loc 6 11 77 discriminator 2 view .LVU277
 1701              	.LBE920:
 1702              	.LBE919:
 1703              	.LBE918:
 1704              	.LBB921:
 1705              	.LBI921:
 1706              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU278
 1707              	.LBB922:
 1708              	.LBB923:
 1709              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU279
 1710 05ac 1867     		str	r0, [r3, #112]
 1711 05ae A3F87440 		strh	r4, [r3, #116]	@ movhi
 1712              	.LVL102:
 1713              		.loc 6 11 77 discriminator 2 view .LVU280
 1714              	.LBE923:
 1715              	.LBE922:
 1716              	.LBE921:
 1717              	.LBB924:
 1718              	.LBI924:
ARM GAS  /tmp/ccysU9ly.s 			page 98


 1719              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU281
 1720              	.LBB925:
 1721              	.LBB926:
 1722              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU282
 1723 05b2 9A67     		str	r2, [r3, #120]
 1724 05b4 4FF48070 		mov	r0, #256
 1725 05b8 A3F87C00 		strh	r0, [r3, #124]	@ movhi
 1726              	.LVL103:
 1727              		.loc 6 11 77 discriminator 2 view .LVU283
 1728              	.LBE926:
 1729              	.LBE925:
 1730              	.LBE924:
 1731              	.LBB927:
 1732              	.LBI927:
 1733              		.loc 6 11 5 is_stmt 1 discriminator 2 view .LVU284
 1734              	.LBB928:
 1735              	.LBB929:
 1736              		.loc 6 11 77 is_stmt 0 discriminator 2 view .LVU285
 1737 05bc C3F88020 		str	r2, [r3, #128]
 1738 05c0 A3F88410 		strh	r1, [r3, #132]	@ movhi
 1739              	.LVL104:
 1740              		.loc 6 11 77 discriminator 2 view .LVU286
 1741              	.LBE929:
 1742              	.LBE928:
 1743              	.LBE927:
 260:Board/v3/board.cpp **** #endif
 1744              		.loc 4 260 41 discriminator 2 view .LVU287
 1745 05c4 244A     		ldr	r2, .L53+72
 1746 05c6 2CAB     		add	r3, sp, #176
 1747 05c8 92E80300 		ldm	r2, {r0, r1}
 1748 05cc 83E80300 		stm	r3, {r0, r1}
 1749              	.LVL105:
 260:Board/v3/board.cpp **** #endif
 1750              		.loc 4 260 41 discriminator 2 view .LVU288
 1751 05d0 0EAA     		add	r2, sp, #56
 1752 05d2 82E80300 		stm	r2, {r0, r1}
 1753              	.LBB930:
 1754              	.LBI930:
 1755              		.file 16 "./MotorControl/pwm_input.hpp"
   1:./MotorControl/pwm_input.hpp **** #ifndef __PWM_INPUT_HPP
   2:./MotorControl/pwm_input.hpp **** #define __PWM_INPUT_HPP
   3:./MotorControl/pwm_input.hpp **** 
   4:./MotorControl/pwm_input.hpp **** #include <tim.h>
   5:./MotorControl/pwm_input.hpp **** #include <array>
   6:./MotorControl/pwm_input.hpp **** 
   7:./MotorControl/pwm_input.hpp **** class PwmInput {
   8:./MotorControl/pwm_input.hpp **** public:
   9:./MotorControl/pwm_input.hpp ****     PwmInput(TIM_HandleTypeDef* htim, std::array<uint16_t, 4> gpios)
 1756              		.loc 16 9 5 is_stmt 1 discriminator 2 view .LVU289
 1757              	.LBB931:
 1758              	.LBB932:
  10:./MotorControl/pwm_input.hpp ****             : htim_(htim), gpios_(gpios) {}
 1759              		.loc 16 10 40 is_stmt 0 discriminator 2 view .LVU290
 1760 05d6 214B     		ldr	r3, .L53+76
 1761 05d8 2149     		ldr	r1, .L53+80
 1762 05da 43F8041B 		str	r1, [r3], #4
 1763 05de 92E80300 		ldm	r2, {r0, r1}
ARM GAS  /tmp/ccysU9ly.s 			page 99


 1764 05e2 83E80300 		stm	r3, {r0, r1}
 1765              	.LVL106:
 1766              		.loc 16 10 40 discriminator 2 view .LVU291
 1767              	.LBE932:
 1768              	.LBE931:
 1769              	.LBE930:
 1770              		.loc 4 594 1 discriminator 2 view .LVU292
 1771 05e6 18E5     		b	.L22
 1772              	.LVL107:
 1773              	.L43:
  71:Board/v3/board.cpp **** 
 1774              		.loc 4 71 1 view .LVU293
 1775 05e8 0024     		movs	r4, #0
 1776              	.LVL108:
 1777              	.L32:
  71:Board/v3/board.cpp **** 
 1778              		.loc 4 71 1 view .LVU294
 1779 05ea C4F10104 		rsb	r4, r4, #1
 1780 05ee 1D4B     		ldr	r3, .L53+84
 1781 05f0 3822     		movs	r2, #56
 1782 05f2 02FB0434 		mla	r4, r2, r4, r3
 1783              	.L34:
 1784 05f6 1B4B     		ldr	r3, .L53+84
 1785 05f8 9C42     		cmp	r4, r3
 1786 05fa 06D0     		beq	.L33
 1787 05fc 54F8383D 		ldr	r3, [r4, #-56]!
 1788 0600 1B68     		ldr	r3, [r3]
 1789 0602 2046     		mov	r0, r4
 1790 0604 9847     		blx	r3
 1791              	.LVL109:
 1792 0606 F6E7     		b	.L34
 1793              	.LVL110:
 1794              	.L41:
  71:Board/v3/board.cpp **** 
 1795              		.loc 4 71 1 view .LVU295
 1796 0608 EFE7     		b	.L32
 1797              	.LVL111:
 1798              	.L33:
  71:Board/v3/board.cpp **** 
 1799              		.loc 4 71 1 view .LVU296
 1800 060a FFF7FEFF 		bl	__cxa_end_cleanup
 1801              	.LVL112:
 1802              	.L54:
 1803 060e 00BF     		.align	2
 1804              	.L53:
 1805 0610 00000000 		.word	controllers
 1806 0614 08000000 		.word	_ZTVN10ODriveIntf14ControllerIntfE+8
 1807 0618 08000000 		.word	_ZTV10Controller+8
 1808 061c ABAA2A3E 		.word	1042983595
 1809 0620 ABAAAA3E 		.word	1051372203
 1810 0624 9A99993F 		.word	1067030938
 1811 0628 0AD7233C 		.word	1008981770
 1812 062c 000020C1 		.word	-1054867456
 1813 0630 00000000 		.word	.LANCHOR5
 1814 0634 00000000 		.word	.LANCHOR13
 1815 0638 00000000 		.word	.LANCHOR10
 1816 063c 00000000 		.word	.LANCHOR4
ARM GAS  /tmp/ccysU9ly.s 			page 100


 1817 0640 00000000 		.word	.LANCHOR11
 1818 0644 50390000 		.word	controllers+14672
 1819 0648 00000000 		.word	.LANCHOR0
 1820 064c 00000240 		.word	1073872896
 1821 0650 00080240 		.word	1073874944
 1822 0654 00040240 		.word	1073873920
 1823 0658 00000000 		.word	.LANCHOR14
 1824 065c 00000000 		.word	.LANCHOR15
 1825 0660 00000000 		.word	htim5
 1826 0664 00000000 		.word	.LANCHOR1
 1827 0668 0000A041 		.word	1101004800
 1828 066c 00002041 		.word	1092616192
 1829 0670 00000000 		.word	.LANCHOR12
 1830 0674 00000000 		.word	.LANCHOR3
 1831              	.LVL113:
 1832              	.L42:
  73:Board/v3/board.cpp **** 
 1833              		.loc 4 73 62 view .LVU297
 1834 0678 C5F10105 		rsb	r5, r5, #1
 1835 067c 074B     		ldr	r3, .L55
 1836 067e 5022     		movs	r2, #80
 1837 0680 02FB0535 		mla	r5, r2, r5, r3
 1838              	.L37:
 1839 0684 054B     		ldr	r3, .L55
 1840 0686 9D42     		cmp	r5, r3
 1841 0688 05D0     		beq	.L36
 1842 068a 55F8503D 		ldr	r3, [r5, #-80]!
 1843 068e 1B68     		ldr	r3, [r3]
 1844 0690 2846     		mov	r0, r5
 1845 0692 9847     		blx	r3
 1846              	.LVL114:
 1847 0694 F6E7     		b	.L37
 1848              	.L36:
 1849 0696 FFF7FEFF 		bl	__cxa_end_cleanup
 1850              	.LVL115:
 1851              	.LEHE3:
 1852              	.L56:
 1853 069a 00BF     		.align	2
 1854              	.L55:
 1855 069c 00000000 		.word	.LANCHOR2
 1856              		.cfi_endproc
 1857              	.LFE6266:
 1858              		.global	__gxx_personality_v0
 1859              		.personality	__gxx_personality_v0
 1860              		.handlerdata
 1861              	.LLSDA6266:
 1862 000c FF       		.byte	0xff
 1863 000d FF       		.byte	0xff
 1864 000e 01       		.byte	0x1
 1865 000f 18       		.uleb128 .LLSDACSE6266-.LLSDACSB6266
 1866              	.LLSDACSB6266:
 1867 0010 A802     		.uleb128 .LEHB0-.LFB6266
 1868 0012 04       		.uleb128 .LEHE0-.LEHB0
 1869 0013 880C     		.uleb128 .L41-.LFB6266
 1870 0015 00       		.uleb128 0
 1871 0016 B402     		.uleb128 .LEHB1-.LFB6266
 1872 0018 04       		.uleb128 .LEHE1-.LEHB1
ARM GAS  /tmp/ccysU9ly.s 			page 101


 1873 0019 E80B     		.uleb128 .L43-.LFB6266
 1874 001b 00       		.uleb128 0
 1875 001c D202     		.uleb128 .LEHB2-.LFB6266
 1876 001e 04       		.uleb128 .LEHE2-.LEHB2
 1877 001f F80C     		.uleb128 .L42-.LFB6266
 1878 0021 00       		.uleb128 0
 1879 0022 FE02     		.uleb128 .LEHB3-.LFB6266
 1880 0024 9C0A     		.uleb128 .LEHE3-.LEHB3
 1881 0026 00       		.uleb128 0
 1882 0027 00       		.uleb128 0
 1883              	.LLSDACSE6266:
 1884              		.section	.text._Z41__static_initialization_and_destruction_0ii
 1885              		.fnend
 1887              		.section	.text._ZL20fetch_and_reset_adcsPSt8optionalI9Iph_ABC_tES2_,"ax",%progbits
 1888              		.align	1
 1889              		.p2align 2,,3
 1890              		.syntax unified
 1891              		.thumb
 1892              		.thumb_func
 1894              	_ZL20fetch_and_reset_adcsPSt8optionalI9Iph_ABC_tES2_:
 1895              		.fnstart
 1896              	.LVL116:
 1897              	.LFB5224:
 421:Board/v3/board.cpp ****     bool all_adcs_done = (ADC1->SR & ADC_SR_JEOC) == ADC_SR_JEOC
 1898              		.loc 4 421 45 is_stmt 1 view -0
 1899              		.cfi_startproc
 1900              		@ args = 0, pretend = 0, frame = 40
 1901              		@ frame_needed = 0, uses_anonymous_args = 0
 422:Board/v3/board.cpp ****         && (ADC2->SR & (ADC_SR_EOC | ADC_SR_JEOC)) == (ADC_SR_EOC | ADC_SR_JEOC)
 1902              		.loc 4 422 5 view .LVU299
 422:Board/v3/board.cpp ****         && (ADC2->SR & (ADC_SR_EOC | ADC_SR_JEOC)) == (ADC_SR_EOC | ADC_SR_JEOC)
 1903              		.loc 4 422 33 is_stmt 0 view .LVU300
 1904 0000 4E4B     		ldr	r3, .L77
 1905 0002 1B68     		ldr	r3, [r3]
 424:Board/v3/board.cpp ****     if (!all_adcs_done) {
 1906              		.loc 4 424 9 view .LVU301
 1907 0004 13F0040F 		tst	r3, #4
 1908 0008 00F09380 		beq	.L67
 421:Board/v3/board.cpp ****     bool all_adcs_done = (ADC1->SR & ADC_SR_JEOC) == ADC_SR_JEOC
 1909              		.loc 4 421 45 view .LVU302
 1910 000c 70B5     		push	{r4, r5, r6, lr}
 1911              		.save {r4, r5, r6, lr}
 1912              	.LCFI8:
 1913              		.cfi_def_cfa_offset 16
 1914              		.cfi_offset 4, -16
 1915              		.cfi_offset 5, -12
 1916              		.cfi_offset 6, -8
 1917              		.cfi_offset 14, -4
 1918              		.pad #40
 1919 000e 8AB0     		sub	sp, sp, #40
 1920              	.LCFI9:
 1921              		.cfi_def_cfa_offset 56
 1922 0010 0546     		mov	r5, r0
 1923 0012 0C46     		mov	r4, r1
 423:Board/v3/board.cpp ****         && (ADC3->SR & (ADC_SR_EOC | ADC_SR_JEOC)) == (ADC_SR_EOC | ADC_SR_JEOC);
 1924              		.loc 4 423 19 view .LVU303
 1925 0014 4A4B     		ldr	r3, .L77+4
ARM GAS  /tmp/ccysU9ly.s 			page 102


 1926 0016 1B68     		ldr	r3, [r3]
 423:Board/v3/board.cpp ****         && (ADC3->SR & (ADC_SR_EOC | ADC_SR_JEOC)) == (ADC_SR_EOC | ADC_SR_JEOC);
 1927              		.loc 4 423 22 view .LVU304
 1928 0018 03F00603 		and	r3, r3, #6
 423:Board/v3/board.cpp ****         && (ADC3->SR & (ADC_SR_EOC | ADC_SR_JEOC)) == (ADC_SR_EOC | ADC_SR_JEOC);
 1929              		.loc 4 423 9 view .LVU305
 1930 001c 062B     		cmp	r3, #6
 1931 001e 40F08A80 		bne	.L68
 424:Board/v3/board.cpp ****     if (!all_adcs_done) {
 1932              		.loc 4 424 19 discriminator 3 view .LVU306
 1933 0022 484B     		ldr	r3, .L77+8
 1934 0024 1B68     		ldr	r3, [r3]
 424:Board/v3/board.cpp ****     if (!all_adcs_done) {
 1935              		.loc 4 424 22 discriminator 3 view .LVU307
 1936 0026 03F00603 		and	r3, r3, #6
 424:Board/v3/board.cpp ****     if (!all_adcs_done) {
 1937              		.loc 4 424 9 discriminator 3 view .LVU308
 1938 002a 062B     		cmp	r3, #6
 1939 002c 01D0     		beq	.L74
 426:Board/v3/board.cpp ****     }
 1940              		.loc 4 426 16 view .LVU309
 1941 002e 0020     		movs	r0, #0
 1942              	.LVL117:
 426:Board/v3/board.cpp ****     }
 1943              		.loc 4 426 16 view .LVU310
 1944 0030 82E0     		b	.L58
 1945              	.LVL118:
 1946              	.L74:
 425:Board/v3/board.cpp ****         return false;
 1947              		.loc 4 425 5 is_stmt 1 view .LVU311
 429:Board/v3/board.cpp **** 
 1948              		.loc 4 429 5 view .LVU312
 429:Board/v3/board.cpp **** 
 1949              		.loc 4 429 29 is_stmt 0 view .LVU313
 1950 0032 424B     		ldr	r3, .L77
 1951 0034 D86B     		ldr	r0, [r3, #60]
 1952              	.LVL119:
 429:Board/v3/board.cpp **** 
 1953              		.loc 4 429 22 view .LVU314
 1954 0036 FFF7FEFF 		bl	vbus_sense_adc_cb
 1955              	.LVL120:
 431:Board/v3/board.cpp ****         std::optional<float> phB = motors[0].phase_current_from_adcval(ADC2->JDR1);
 1956              		.loc 4 431 5 is_stmt 1 view .LVU315
 1957              	.LBB961:
 431:Board/v3/board.cpp ****         std::optional<float> phB = motors[0].phase_current_from_adcval(ADC2->JDR1);
 1958              		.loc 4 431 32 is_stmt 0 view .LVU316
 1959 003a 4348     		ldr	r0, .L77+12
 1960 003c FFF7FEFF 		bl	_ZN7Drv83018is_readyEv
 1961              	.LVL121:
 431:Board/v3/board.cpp ****         std::optional<float> phB = motors[0].phase_current_from_adcval(ADC2->JDR1);
 1962              		.loc 4 431 5 view .LVU317
 1963 0040 88B9     		cbnz	r0, .L75
 1964              	.L59:
 1965              	.LBE961:
 439:Board/v3/board.cpp ****         std::optional<float> phB = motors[1].phase_current_from_adcval(ADC2->DR);
 1966              		.loc 4 439 5 is_stmt 1 view .LVU318
 1967              	.LBB979:
ARM GAS  /tmp/ccysU9ly.s 			page 103


 439:Board/v3/board.cpp ****         std::optional<float> phB = motors[1].phase_current_from_adcval(ADC2->DR);
 1968              		.loc 4 439 32 is_stmt 0 view .LVU319
 1969 0042 4248     		ldr	r0, .L77+16
 1970 0044 FFF7FEFF 		bl	_ZN7Drv83018is_readyEv
 1971              	.LVL122:
 439:Board/v3/board.cpp ****         std::optional<float> phB = motors[1].phase_current_from_adcval(ADC2->DR);
 1972              		.loc 4 439 5 view .LVU320
 1973 0048 0028     		cmp	r0, #0
 1974 004a 3FD1     		bne	.L76
 1975              	.LVL123:
 1976              	.L63:
 439:Board/v3/board.cpp ****         std::optional<float> phB = motors[1].phase_current_from_adcval(ADC2->DR);
 1977              		.loc 4 439 5 view .LVU321
 1978              	.LBE979:
 447:Board/v3/board.cpp ****     ADC2->SR = ~(ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_OVR);
 1979              		.loc 4 447 5 is_stmt 1 view .LVU322
 447:Board/v3/board.cpp ****     ADC2->SR = ~(ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_OVR);
 1980              		.loc 4 447 14 is_stmt 0 view .LVU323
 1981 004c 3B4B     		ldr	r3, .L77
 1982 004e 6FF00402 		mvn	r2, #4
 1983 0052 1A60     		str	r2, [r3]
 448:Board/v3/board.cpp ****     ADC3->SR = ~(ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_OVR);
 1984              		.loc 4 448 5 is_stmt 1 view .LVU324
 448:Board/v3/board.cpp ****     ADC3->SR = ~(ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_OVR);
 1985              		.loc 4 448 14 is_stmt 0 view .LVU325
 1986 0054 6FF02603 		mvn	r3, #38
 1987 0058 394A     		ldr	r2, .L77+4
 1988 005a 1360     		str	r3, [r2]
 449:Board/v3/board.cpp **** 
 1989              		.loc 4 449 5 is_stmt 1 view .LVU326
 449:Board/v3/board.cpp **** 
 1990              		.loc 4 449 14 is_stmt 0 view .LVU327
 1991 005c 02F58072 		add	r2, r2, #256
 1992 0060 1360     		str	r3, [r2]
 451:Board/v3/board.cpp **** }
 1993              		.loc 4 451 5 is_stmt 1 view .LVU328
 451:Board/v3/board.cpp **** }
 1994              		.loc 4 451 12 is_stmt 0 view .LVU329
 1995 0062 0120     		movs	r0, #1
 1996 0064 68E0     		b	.L58
 1997              	.LVL124:
 1998              	.L75:
 1999              	.LBB997:
 2000              	.LBB962:
 432:Board/v3/board.cpp ****         std::optional<float> phC = motors[0].phase_current_from_adcval(ADC3->JDR1);
 2001              		.loc 4 432 9 is_stmt 1 view .LVU330
 432:Board/v3/board.cpp ****         std::optional<float> phC = motors[0].phase_current_from_adcval(ADC3->JDR1);
 2002              		.loc 4 432 78 is_stmt 0 view .LVU331
 2003 0066 364B     		ldr	r3, .L77+4
 2004 0068 DA6B     		ldr	r2, [r3, #60]
 432:Board/v3/board.cpp ****         std::optional<float> phC = motors[0].phase_current_from_adcval(ADC3->JDR1);
 2005              		.loc 4 432 82 view .LVU332
 2006 006a 394E     		ldr	r6, .L77+20
 2007 006c 3146     		mov	r1, r6
 2008 006e 6846     		mov	r0, sp
 2009 0070 FFF7FEFF 		bl	_ZN5Motor25phase_current_from_adcvalEm
 2010              	.LVL125:
ARM GAS  /tmp/ccysU9ly.s 			page 104


 433:Board/v3/board.cpp ****         if (phB.has_value() && phC.has_value()) {
 2011              		.loc 4 433 9 is_stmt 1 view .LVU333
 433:Board/v3/board.cpp ****         if (phB.has_value() && phC.has_value()) {
 2012              		.loc 4 433 78 is_stmt 0 view .LVU334
 2013 0074 334B     		ldr	r3, .L77+8
 2014 0076 DA6B     		ldr	r2, [r3, #60]
 433:Board/v3/board.cpp ****         if (phB.has_value() && phC.has_value()) {
 2015              		.loc 4 433 82 view .LVU335
 2016 0078 3146     		mov	r1, r6
 2017 007a 02A8     		add	r0, sp, #8
 2018 007c FFF7FEFF 		bl	_ZN5Motor25phase_current_from_adcvalEm
 2019              	.LVL126:
 434:Board/v3/board.cpp ****             *current0 = {-*phB - *phC, *phB, *phC};
 2020              		.loc 4 434 9 is_stmt 1 view .LVU336
 2021              	.LBB963:
 2022              	.LBI963:
 2023              		.file 17 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // <optional> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Copyright (C) 2013-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** /** @file include/optional
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****  *  This is a Standard C++ Library header.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****  */
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #ifndef _GLIBCXX_OPTIONAL
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #define _GLIBCXX_OPTIONAL 1
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #pragma GCC system_header
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #if __cplusplus >= 201703L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <utility>
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <type_traits>
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <exception>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <new>
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <initializer_list>
ARM GAS  /tmp/ccysU9ly.s 			page 105


  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/exception_defines.h>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/functional_hash.h>
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/enable_special_members.h>
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #if __cplusplus > 201703L
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** # include <compare>
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #endif
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** namespace std _GLIBCXX_VISIBILITY(default)
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** {
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @addtogroup utilities
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @{
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    */
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #define __cpp_lib_optional 201606L
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class optional;
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /// Tag type to disengage optional objects.
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   struct nullopt_t
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   {
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Do not user-declare default constructor at all for
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // optional_value = {} syntax to work.
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // nullopt_t() = delete;
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Used for constructing nullopt.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     enum class _Construct { _Token };
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Must be constexpr for nullopt_t to be literal.
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     explicit constexpr nullopt_t(_Construct) { }
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   };
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /// Tag to disengage optional objects.
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   inline constexpr nullopt_t nullopt { nullopt_t::_Construct::_Token };
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @brief Exception class thrown when a disengaged optional object is
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  dereferenced.
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @ingroup exceptions
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    */
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   class bad_optional_access : public exception
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   {
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   public:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     bad_optional_access() = default;
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     virtual ~bad_optional_access() = default;
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     const char* what() const noexcept override
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return "bad optional access"; }
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   };
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   void
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __throw_bad_optional_access()
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __attribute__((__noreturn__));
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/ccysU9ly.s 			page 106


  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // XXX Does not belong here.
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   inline void
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __throw_bad_optional_access()
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   { _GLIBCXX_THROW_OR_ABORT(bad_optional_access()); }
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // This class template manages construction/destruction of
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // the contained value for a std::optional.
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload_base
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Stored_type = remove_const_t<_Tp>;
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base() = default;
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_Optional_payload_base(in_place_t __tag, _Args&&... __args)
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_engaged(true)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args>
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_Optional_payload_base(std::initializer_list<_Up> __il,
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			       _Args&&... __args)
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__il, std::forward<_Args>(__args)...),
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_engaged(true)
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructor used by _Optional_base copy constructor when the
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // contained value is not trivially copy constructible.
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(bool __engaged,
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			     const _Optional_payload_base& __other)
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (__other._M_engaged)
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(__other._M_get());
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructor used by _Optional_base move constructor when the
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // contained value is not trivially move constructible.
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(bool __engaged,
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			     _Optional_payload_base&& __other)
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (__other._M_engaged)
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(std::move(__other._M_get()));
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy constructor is only used to when the contained value is
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // trivially copy constructible.
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(const _Optional_payload_base&) = default;
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Move constructor is only used to when the contained value is
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // trivially copy constructible.
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(_Optional_payload_base&&) = default;
ARM GAS  /tmp/ccysU9ly.s 			page 107


 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base&
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload_base&) = default;
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base&
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload_base&&) = default;
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // used to perform non-trivial copy assignment.
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_copy_assign(const _Optional_payload_base& __other)
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         if (this->_M_engaged && __other._M_engaged)
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           this->_M_get() = __other._M_get();
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         else
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    if (__other._M_engaged)
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_construct(__other._M_get());
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    else
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // used to perform non-trivial move assignment.
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_move_assign(_Optional_payload_base&& __other)
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_engaged && __other._M_engaged)
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_get() = std::move(__other._M_get());
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    if (__other._M_engaged)
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_construct(std::move(__other._M_get()));
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    else
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       struct _Empty_byte { };
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, bool = is_trivially_destructible_v<_Up>>
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	union _Storage
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  constexpr _Storage() noexcept : _M_empty() { }
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename... _Args>
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(in_place_t, _Args&&... __args)
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename _Vp, typename... _Args>
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(__il, std::forward<_Args>(__args)...)
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
ARM GAS  /tmp/ccysU9ly.s 			page 108


 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _Empty_byte _M_empty;
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           _Up _M_value;
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	};
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	union _Storage<_Up, false>
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  constexpr _Storage() noexcept : _M_empty() { }
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename... _Args>
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(in_place_t, _Args&&... __args)
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename _Vp, typename... _Args>
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(__il, std::forward<_Args>(__args)...)
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  // User-provided destructor is needed when _Up has non-trivial dtor.
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ~_Storage() { }
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _Empty_byte _M_empty;
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           _Up _M_value;
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	};
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Storage<_Stored_type> _M_payload;
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       bool _M_engaged = false;
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         void
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         _M_construct(_Args&&... __args)
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         {
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           ::new ((void *) std::__addressof(this->_M_payload))
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****             _Stored_type(std::forward<_Args>(__args)...);
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           this->_M_engaged = true;
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         }
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_destroy() noexcept
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_engaged = false;
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_payload._M_value.~_Stored_type();
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_get() operations have _M_engaged as a precondition.
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // They exist to access the contained value with the appropriate
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // const-qualification, because _M_payload has had the const removed.
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() noexcept
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_payload._M_value; }
ARM GAS  /tmp/ccysU9ly.s 			page 109


 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() const noexcept
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_payload._M_value; }
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // _M_reset is a 'safe' operation with no precondition.
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_reset() noexcept
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_engaged)
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_destroy();
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Class template that manages the payload for optionals.
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp,
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialDestructor*/ =
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_destructible_v<_Tp>,
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialCopy */ =
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_copy_assignable_v<_Tp>
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      && is_trivially_copy_constructible_v<_Tp>,
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialMove */ =
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_move_assignable_v<_Tp>
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      && is_trivially_move_constructible_v<_Tp>>
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload;
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for potentially-constexpr optionals (trivial copy/move/destroy).
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, true, true>
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial copy construction/assignment.
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, false, true>
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(_Optional_payload&&) = default;
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial copy assignment.
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload& __other)
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_copy_assign(__other);
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
ARM GAS  /tmp/ccysU9ly.s 			page 110


 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial move construction/assignment.
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, true, false>
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(const _Optional_payload&) = default;
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial move assignment.
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload&& __other)
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_move_assign(std::move(__other));
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial copy and move assignment.
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, false, false>
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial copy assignment.
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload& __other)
 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_copy_assign(__other);
 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial move assignment.
 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload&& __other)
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_move_assign(std::move(__other));
 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
ARM GAS  /tmp/ccysU9ly.s 			page 111


 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial destructors.
 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp, bool _Copy, bool _Move>
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, false, _Copy, _Move>
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload<_Tp, true, false, false>
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Base class implements all the constructors and assignment operators:
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload<_Tp, true, false, false>::_Optional_payload;
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(const _Optional_payload&) = default;
 397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(_Optional_payload&&) = default;
 398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Destructor needs to destroy the contained value:
 400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() { this->_M_reset(); }
 401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Common base class for _Optional_base<T> to avoid repeating these
 404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // member functions in each specialization.
 405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Dp>
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class _Optional_base_impl
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     protected:
 409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Stored_type = remove_const_t<_Tp>;
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_construct operation has !_M_engaged as a precondition
 412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // while _M_destruct has _M_engaged as a precondition.
 413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	void
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_construct(_Args&&... __args)
 416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ::new
 419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    (std::__addressof(static_cast<_Dp*>(this)->_M_payload._M_payload))
 420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Stored_type(std::forward<_Args>(__args)...);
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_cast<_Dp*>(this)->_M_payload._M_engaged = true;
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       void
 425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_destruct() noexcept
 426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { static_cast<_Dp*>(this)->_M_payload._M_destroy(); }
 427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // _M_reset is a 'safe' operation with no precondition.
 429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_reset() noexcept
 431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { static_cast<_Dp*>(this)->_M_payload._M_reset(); }
 432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr bool _M_is_engaged() const noexcept
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_get operations have _M_engaged as a precondition.
 437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() noexcept
 439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
ARM GAS  /tmp/ccysU9ly.s 			page 112


 440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__glibcxx_assert(this->_M_is_engaged());
 441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return static_cast<_Dp*>(this)->_M_payload._M_get();
 442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() const noexcept
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__glibcxx_assert(this->_M_is_engaged());
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return static_cast<const _Dp*>(this)->_M_payload._M_get();
 449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
 453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @brief Class template that provides copy/move constructors of optional.
 454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * Such a separate base class template is necessary in order to
 456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * conditionally make copy/move constructors trivial.
 457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * When the contained value is trivially copy/move constructible,
 459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * the copy/move constructors of _Optional_base will invoke the
 460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * trivial copy/move constructor of _Optional_payload. Otherwise,
 461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * they will invoke _Optional_payload(bool, const _Optional_payload&)
 462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * or _Optional_payload(bool, _Optional_payload&&) to initialize
 463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * the contained value, if copying/moving an engaged optional.
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * Whether the other special members are trivial is determined by the
 466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * _Optional_payload<_Tp> specialization used for the _M_payload member.
 467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @see optional, _Enable_special_members
 469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     */
 470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp,
 471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	   bool = is_trivially_copy_constructible_v<_Tp>,
 472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	   bool = is_trivially_move_constructible_v<_Tp>>
 473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base
 474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/ccysU9ly.s 			page 113


 497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other)
 499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __other._M_payload)
 501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other)
 504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>)
 505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::move(__other._M_payload))
 507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, false, true>
 518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other)
 543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __other._M_payload)
 545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other) = default;
 548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
ARM GAS  /tmp/ccysU9ly.s 			page 114


 554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, true, false>
 558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other) = default;
 583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other)
 585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>)
 586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::move(__other._M_payload))
 588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, true, true>
 599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/ccysU9ly.s 			page 115


 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other) = default;
 624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other) = default;
 625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   class optional;
 635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __converts_from_optional =
 638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       __or_<is_constructible<_Tp, const optional<_Up>&>,
 639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, optional<_Up>&>,
 640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, const optional<_Up>&&>,
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, optional<_Up>&&>,
 642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<const optional<_Up>&, _Tp>,
 643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<optional<_Up>&, _Tp>,
 644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<const optional<_Up>&&, _Tp>,
 645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<optional<_Up>&&, _Tp>>;
 646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __assigns_from_optional =
 649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       __or_<is_assignable<_Tp&, const optional<_Up>&>,
 650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, optional<_Up>&>,
 651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, const optional<_Up>&&>,
 652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, optional<_Up>&&>>;
 653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
 655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @brief Class template for optional values.
 656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     */
 657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class optional
 659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : private _Optional_base<_Tp>,
 660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       private _Enable_copy_move<
 661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Copy constructor.
 662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	is_copy_constructible_v<_Tp>,
 663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Copy assignment.
 664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__and_v<is_copy_constructible<_Tp>, is_copy_assignable<_Tp>>,
 665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Move constructor.
 666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	is_move_constructible_v<_Tp>,
 667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Move assignment.
ARM GAS  /tmp/ccysU9ly.s 			page 116


 668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__and_v<is_move_constructible<_Tp>, is_move_assignable<_Tp>>,
 669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Unique tag type.
 670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional<_Tp>>
 671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_same_v<remove_cv_t<_Tp>, nullopt_t>);
 673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_same_v<remove_cv_t<_Tp>, in_place_t>);
 674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_reference_v<_Tp>);
 675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     private:
 677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Base = _Optional_base<_Tp>;
 678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // SFINAE helpers
 680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using __not_self = __not_<is_same<optional, __remove_cvref_t<_Up>>>;
 682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using __not_tag = __not_<is_same<in_place_t, __remove_cvref_t<_Up>>>;
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Cond>
 685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using _Requires = enable_if_t<__and_v<_Cond...>, bool>;
 686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     public:
 688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using value_type = _Tp;
 689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr optional() = default;
 691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr optional(nullopt_t) noexcept { }
 693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Converting constructors for engaged optionals.
 695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp,
 696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_self<_Up>, __not_tag<_Up>,
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, _Up&&>,
 698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_convertible<_Up&&, _Tp>> = true>
 699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(_Up&& __t)
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp,
 704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_self<_Up>, __not_tag<_Up>,
 705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, _Up&&>,
 706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<is_convertible<_Up&&, _Tp>>> = false>
 707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(_Up&& __t)
 709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _Base(std::in_place, std::forward<_Up>(__t)) { }
 710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up,
 712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_<is_same<_Tp, _Up>>,
 713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, const _Up&>,
 714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_convertible<const _Up&, _Tp>,
 715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<__converts_from_optional<_Tp, _Up>>> = true>
 716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(const optional<_Up>& __t)
 718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(*__t);
 721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up,
 724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_<is_same<_Tp, _Up>>,
ARM GAS  /tmp/ccysU9ly.s 			page 117


 725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, const _Up&>,
 726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<is_convertible<const _Up&, _Tp>>,
 727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<__converts_from_optional<_Tp, _Up>>> = false>
 728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(const optional<_Up>& __t)
 730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(*__t);
 733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template <typename _Up,
 736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		_Requires<__not_<is_same<_Tp, _Up>>,
 737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_constructible<_Tp, _Up&&>,
 738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_convertible<_Up&&, _Tp>,
 739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<__converts_from_optional<_Tp, _Up>>> = true>
 740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(optional<_Up>&& __t)
 742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(std::move(*__t));
 745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template <typename _Up,
 748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		_Requires<__not_<is_same<_Tp, _Up>>,
 749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_constructible<_Tp, _Up&&>,
 750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<is_convertible<_Up&&, _Tp>>,
 751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<__converts_from_optional<_Tp, _Up>>> = false>
 752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(optional<_Up>&& __t)
 754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(std::move(*__t));
 757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<is_constructible<_Tp, _Args&&...>> = false>
 761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(in_place_t, _Args&&... __args)
 763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Args>(__args)...) { }
 764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<is_constructible<_Tp,
 767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  initializer_list<_Up>&,
 768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  _Args&&...>> = false>
 769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(in_place_t, initializer_list<_Up> __il, _Args&&... __args)
 771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, __il, std::forward<_Args>(__args)...) { }
 772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       optional&
 775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(nullopt_t) noexcept
 776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_reset();
 778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp>
ARM GAS  /tmp/ccysU9ly.s 			page 118


 782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<__and_v<__not_self<_Up>,
 783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__and_<is_scalar<_Tp>,
 784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  is_same<_Tp, decay_t<_Up>>>>,
 785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, _Up>,
 786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, _Up>>,
 787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(_Up&& __u)
 789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (this->_M_is_engaged())
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_get() = std::forward<_Up>(__u);
 792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_construct(std::forward<_Up>(__u));
 794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
 796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
 800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, const _Up&>,
 801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, const _Up&>,
 802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__converts_from_optional<_Tp, _Up>>,
 803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__assigns_from_optional<_Tp, _Up>>>,
 804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(const optional<_Up>& __u)
 806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__u)
 808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      if (this->_M_is_engaged())
 810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_get() = *__u;
 811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      else
 812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_construct(*__u);
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
 819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, _Up>,
 824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, _Up>,
 825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__converts_from_optional<_Tp, _Up>>,
 826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__assigns_from_optional<_Tp, _Up>>>,
 827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(optional<_Up>&& __u)
 829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__u)
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      if (this->_M_is_engaged())
 833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_get() = std::move(*__u);
 834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      else
 835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_construct(std::move(*__u));
 836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
ARM GAS  /tmp/ccysU9ly.s 			page 119


 839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
 843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<is_constructible_v<_Tp, _Args&&...>, _Tp&>
 847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	emplace(_Args&&... __args)
 848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_reset();
 850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(std::forward<_Args>(__args)...);
 851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_get();
 852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args>
 855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&,
 856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 				       _Args&&...>, _Tp&>
 857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	emplace(initializer_list<_Up> __il, _Args&&... __args)
 858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_reset();
 860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(__il, std::forward<_Args>(__args)...);
 861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_get();
 862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Destructor is implicit, implemented in _Optional_base.
 865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Swap.
 867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       void
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       swap(optional& __other)
 869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>
 870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       && is_nothrow_swappable_v<_Tp>)
 871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using std::swap;
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_is_engaged() && __other._M_is_engaged())
 875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  swap(this->_M_get(), __other._M_get());
 876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else if (this->_M_is_engaged())
 877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    __other._M_construct(std::move(this->_M_get()));
 879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_destruct();
 880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else if (__other._M_is_engaged())
 882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_construct(std::move(__other._M_get()));
 884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    __other._M_destruct();
 885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Observers.
 889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp*
 890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator->() const
 891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::__addressof(this->_M_get()); }
 892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp*
 894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator->()
 895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::__addressof(this->_M_get()); }
ARM GAS  /tmp/ccysU9ly.s 			page 120


 896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*() const&
 899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_get(); }
 900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*()&
 903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_get(); }
 904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&&
 906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*()&&
 907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::move(this->_M_get()); }
 908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&&
 910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*() const&&
 911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::move(this->_M_get()); }
 912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr explicit operator bool() const noexcept
 914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr bool has_value() const noexcept
 2024              		.loc 17 916 22 view .LVU337
 2025              	.LBB964:
 2026              	.LBI964:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 2027              		.loc 17 433 22 view .LVU338
 2028              	.LBB965:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2029              		.loc 17 434 58 is_stmt 0 view .LVU339
 2030 0080 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 2031              	.LVL127:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2032              		.loc 17 434 58 view .LVU340
 2033              	.LBE965:
 2034              	.LBE964:
 2035              	.LBE963:
 434:Board/v3/board.cpp ****             *current0 = {-*phB - *phC, *phB, *phC};
 2036              		.loc 4 434 29 view .LVU341
 2037 0084 002B     		cmp	r3, #0
 2038 0086 DCD0     		beq	.L59
 2039              	.LVL128:
 2040              	.LBB966:
 2041              	.LBI966:
 2042              		.loc 17 916 22 is_stmt 1 view .LVU342
 2043              	.LBB967:
 2044              	.LBI967:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 2045              		.loc 17 433 22 view .LVU343
 2046              	.LBB968:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2047              		.loc 17 434 58 is_stmt 0 view .LVU344
 2048 0088 9DF80C30 		ldrb	r3, [sp, #12]	@ zero_extendqisi2
 2049              	.LVL129:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2050              		.loc 17 434 58 view .LVU345
 2051              	.LBE968:
 2052              	.LBE967:
ARM GAS  /tmp/ccysU9ly.s 			page 121


 2053              	.LBE966:
 434:Board/v3/board.cpp ****             *current0 = {-*phB - *phC, *phB, *phC};
 2054              		.loc 4 434 29 view .LVU346
 2055 008c 002B     		cmp	r3, #0
 2056 008e D8D0     		beq	.L59
 435:Board/v3/board.cpp ****         }
 2057              		.loc 4 435 13 is_stmt 1 view .LVU347
 435:Board/v3/board.cpp ****         }
 2058              		.loc 4 435 26 is_stmt 0 view .LVU348
 2059 0090 DDED006A 		vldr.32	s13, [sp]
 2060 0094 F1EE667A 		vneg.f32	s15, s13
 435:Board/v3/board.cpp ****         }
 2061              		.loc 4 435 34 view .LVU349
 2062 0098 9DED027A 		vldr.32	s14, [sp, #8]
 435:Board/v3/board.cpp ****         }
 2063              		.loc 4 435 32 view .LVU350
 2064 009c 77EEC77A 		vsub.f32	s15, s15, s14
 435:Board/v3/board.cpp ****         }
 2065              		.loc 4 435 50 view .LVU351
 2066 00a0 CDED047A 		vstr.32	s15, [sp, #16]
 2067 00a4 CDED056A 		vstr.32	s13, [sp, #20]
 2068 00a8 8DED067A 		vstr.32	s14, [sp, #24]
 2069              	.LVL130:
 2070              	.LBB969:
 2071              	.LBI969:
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 2072              		.loc 17 788 2 is_stmt 1 view .LVU352
 2073              	.LBB970:
 2074              	.LBB971:
 2075              	.LBI971:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 2076              		.loc 17 433 22 view .LVU353
 2077              	.LBB972:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2078              		.loc 17 434 58 is_stmt 0 view .LVU354
 2079 00ac 2B7B     		ldrb	r3, [r5, #12]	@ zero_extendqisi2
 2080              	.LVL131:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2081              		.loc 17 434 58 view .LVU355
 2082              	.LBE972:
 2083              	.LBE971:
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_get() = std::forward<_Up>(__u);
 2084              		.loc 17 790 4 view .LVU356
 2085 00ae 2BB1     		cbz	r3, .L61
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 2086              		.loc 17 791 6 view .LVU357
 2087 00b0 04AB     		add	r3, sp, #16
 2088              	.LVL132:
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 2089              		.loc 17 791 6 view .LVU358
 2090 00b2 93E80700 		ldm	r3, {r0, r1, r2}
 2091 00b6 85E80700 		stm	r5, {r0, r1, r2}
 2092 00ba C2E7     		b	.L59
 2093              	.LVL133:
 2094              	.L61:
 2095              	.LBB973:
 2096              	.LBI973:
ARM GAS  /tmp/ccysU9ly.s 			page 122


 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 2097              		.loc 17 415 2 is_stmt 1 view .LVU359
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 2098              		.loc 17 415 2 is_stmt 0 view .LVU360
 2099              	.LBE973:
 2100              	.LBE970:
 2101              	.LBE969:
 2102              	.LBE962:
 2103              	.LBE997:
 2104              		.file 18 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // The -*- C++ -*- dynamic memory management header.
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // Copyright (C) 1994-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // This file is part of GCC.
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** //
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // GCC is free software; you can redistribute it and/or modify
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // it under the terms of the GNU General Public License as published by
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // the Free Software Foundation; either version 3, or (at your option)
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // any later version.
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // 
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // GCC is distributed in the hope that it will be useful,
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // GNU General Public License for more details.
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // 
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // Under Section 7 of GPL version 3, you are granted additional
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // permissions described in the GCC Runtime Library Exception, version
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // 3.1, as published by the Free Software Foundation.
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // You should have received a copy of the GNU General Public License and
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // a copy of the GCC Runtime Library Exception along with this program;
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // <http://www.gnu.org/licenses/>.
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** /** @file new
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  This is a Standard C++ Library header.
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  The header @c new defines several functions to manage dynamic memory and
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  handling memory allocation errors; see
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/dynamic_memory.html
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  for more.
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  */
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #ifndef _NEW
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #define _NEW
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #pragma GCC system_header
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #include <bits/c++config.h>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #include <exception>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #pragma GCC visibility push(default)
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** extern "C++" {
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** namespace std 
ARM GAS  /tmp/ccysU9ly.s 			page 123


  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** {
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /**
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  @brief  Exception possibly thrown by @c new.
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  @ingroup exceptions
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  @c bad_alloc (or classes derived from it) is used to report allocation
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  errors from the throwing forms of @c new.  */
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   class bad_alloc : public exception 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   {
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   public:
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_alloc() throw() { }
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_alloc(const bad_alloc&) = default;
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_alloc& operator=(const bad_alloc&) = default;
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // This declaration is not useless:
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual ~bad_alloc() throw();
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // See comment in eh_exception.cc.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual const char* what() const throw();
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   };
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   class bad_array_new_length : public bad_alloc
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   {
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   public:
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     bad_array_new_length() throw() { }
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // This declaration is not useless:
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual ~bad_array_new_length() throw();
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     // See comment in eh_exception.cc.
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     virtual const char* what() const throw();
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   };
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_aligned_new
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   enum class align_val_t: size_t {};
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   struct nothrow_t
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   {
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****     explicit nothrow_t() = default;
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   };
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   extern const nothrow_t nothrow;
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /** If you write your own error handler to be called by @c new, it must
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****    *  be of this type.  */
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   typedef void (*new_handler)();
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
ARM GAS  /tmp/ccysU9ly.s 			page 124


 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /// Takes a replacement handler as the argument, returns the
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /// previous handler.
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   new_handler set_new_handler(new_handler) throw();
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cplusplus >= 201103L
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   /// Return the current new handler.
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   new_handler get_new_handler() noexcept;
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** } // namespace std
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** //@{
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** /** These are replaceable signatures:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - normal array new and delete (same)
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - @c nothrow single new and delete (take a @c nothrow argument, return
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *    @c NULL on error)
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  - @c nothrow array new and delete (same)
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  Placement new and delete signatures (take a memory address argument,
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****  *  does nothing) may not be replaced by a user's program.
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** */
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t) _GLIBCXX_THROW (std::bad_alloc)
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*) _GLIBCXX_USE_NOEXCEPT
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*) _GLIBCXX_USE_NOEXCEPT
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_sized_deallocation
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__, __malloc__));
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__, __malloc__));
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_aligned_new
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t)
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __malloc__));
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::align_val_t)
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::align_val_t, const std::nothrow_t&)
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t)
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   __attribute__((__externally_visible__));
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __malloc__));
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::align_val_t)
ARM GAS  /tmp/ccysU9ly.s 			page 125


 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #if __cpp_sized_deallocation
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete(void*, std::size_t, std::align_val_t)
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** void operator delete[](void*, std::size_t, std::align_val_t)
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new ****   _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif // __cpp_sized_deallocation
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** #endif // __cpp_aligned_new
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** 
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** // Default placement versions of operator new.
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** _GLIBCXX_NODISCARD inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new **** { return __p; }
 2105              		.loc 18 175 3 is_stmt 1 view .LVU361
 2106              	.LBB998:
 2107              	.LBB978:
 2108              	.LBB977:
 2109              	.LBB976:
 2110              	.LBB975:
 2111              	.LBB974:
 2112              		.loc 18 175 3 is_stmt 0 view .LVU362
 2113 00bc 04AB     		add	r3, sp, #16
 2114              	.LVL134:
 2115              		.loc 18 175 3 view .LVU363
 2116 00be 93E80700 		ldm	r3, {r0, r1, r2}
 2117 00c2 85E80700 		stm	r5, {r0, r1, r2}
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 2118              		.loc 17 421 51 view .LVU364
 2119 00c6 0123     		movs	r3, #1
 2120              	.LVL135:
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 2121              		.loc 17 421 51 view .LVU365
 2122 00c8 2B73     		strb	r3, [r5, #12]
 2123              	.LVL136:
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2124              		.loc 17 422 2 view .LVU366
 2125 00ca BAE7     		b	.L59
 2126              	.L76:
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2127              		.loc 17 422 2 view .LVU367
 2128              	.LBE974:
 2129              	.LBE975:
 2130              	.LBE976:
 2131              	.LBE977:
 2132              	.LBE978:
 2133              	.LBE998:
 2134              	.LBB999:
 2135              	.LBB980:
 440:Board/v3/board.cpp ****         std::optional<float> phC = motors[1].phase_current_from_adcval(ADC3->DR);
 2136              		.loc 4 440 9 is_stmt 1 view .LVU368
 440:Board/v3/board.cpp ****         std::optional<float> phC = motors[1].phase_current_from_adcval(ADC3->DR);
 2137              		.loc 4 440 78 is_stmt 0 view .LVU369
 2138 00cc 1C4B     		ldr	r3, .L77+4
 2139 00ce DA6C     		ldr	r2, [r3, #76]
 440:Board/v3/board.cpp ****         std::optional<float> phC = motors[1].phase_current_from_adcval(ADC3->DR);
 2140              		.loc 4 440 80 view .LVU370
ARM GAS  /tmp/ccysU9ly.s 			page 126


 2141 00d0 204D     		ldr	r5, .L77+24
 2142              	.LVL137:
 440:Board/v3/board.cpp ****         std::optional<float> phC = motors[1].phase_current_from_adcval(ADC3->DR);
 2143              		.loc 4 440 80 view .LVU371
 2144 00d2 2946     		mov	r1, r5
 2145 00d4 6846     		mov	r0, sp
 2146 00d6 FFF7FEFF 		bl	_ZN5Motor25phase_current_from_adcvalEm
 2147              	.LVL138:
 441:Board/v3/board.cpp ****         if (phB.has_value() && phC.has_value()) {
 2148              		.loc 4 441 9 is_stmt 1 view .LVU372
 441:Board/v3/board.cpp ****         if (phB.has_value() && phC.has_value()) {
 2149              		.loc 4 441 78 is_stmt 0 view .LVU373
 2150 00da 1A4B     		ldr	r3, .L77+8
 2151 00dc DA6C     		ldr	r2, [r3, #76]
 441:Board/v3/board.cpp ****         if (phB.has_value() && phC.has_value()) {
 2152              		.loc 4 441 80 view .LVU374
 2153 00de 2946     		mov	r1, r5
 2154 00e0 02A8     		add	r0, sp, #8
 2155 00e2 FFF7FEFF 		bl	_ZN5Motor25phase_current_from_adcvalEm
 2156              	.LVL139:
 442:Board/v3/board.cpp ****             *current1 = {-*phB - *phC, *phB, *phC};
 2157              		.loc 4 442 9 is_stmt 1 view .LVU375
 2158              	.LBB981:
 2159              	.LBI981:
 2160              		.loc 17 916 22 view .LVU376
 2161              	.LBB982:
 2162              	.LBI982:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 2163              		.loc 17 433 22 view .LVU377
 2164              	.LBB983:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2165              		.loc 17 434 58 is_stmt 0 view .LVU378
 2166 00e6 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 2167              	.LVL140:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2168              		.loc 17 434 58 view .LVU379
 2169              	.LBE983:
 2170              	.LBE982:
 2171              	.LBE981:
 442:Board/v3/board.cpp ****             *current1 = {-*phB - *phC, *phB, *phC};
 2172              		.loc 4 442 29 view .LVU380
 2173 00ea 002B     		cmp	r3, #0
 2174 00ec AED0     		beq	.L63
 2175              	.LVL141:
 2176              	.LBB984:
 2177              	.LBI984:
 2178              		.loc 17 916 22 is_stmt 1 view .LVU381
 2179              	.LBB985:
 2180              	.LBI985:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 2181              		.loc 17 433 22 view .LVU382
 2182              	.LBB986:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2183              		.loc 17 434 58 is_stmt 0 view .LVU383
 2184 00ee 9DF80C30 		ldrb	r3, [sp, #12]	@ zero_extendqisi2
 2185              	.LVL142:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/ccysU9ly.s 			page 127


 2186              		.loc 17 434 58 view .LVU384
 2187              	.LBE986:
 2188              	.LBE985:
 2189              	.LBE984:
 442:Board/v3/board.cpp ****             *current1 = {-*phB - *phC, *phB, *phC};
 2190              		.loc 4 442 29 view .LVU385
 2191 00f2 002B     		cmp	r3, #0
 2192 00f4 AAD0     		beq	.L63
 443:Board/v3/board.cpp ****         }
 2193              		.loc 4 443 13 is_stmt 1 view .LVU386
 443:Board/v3/board.cpp ****         }
 2194              		.loc 4 443 26 is_stmt 0 view .LVU387
 2195 00f6 DDED006A 		vldr.32	s13, [sp]
 2196 00fa F1EE667A 		vneg.f32	s15, s13
 443:Board/v3/board.cpp ****         }
 2197              		.loc 4 443 34 view .LVU388
 2198 00fe 9DED027A 		vldr.32	s14, [sp, #8]
 443:Board/v3/board.cpp ****         }
 2199              		.loc 4 443 32 view .LVU389
 2200 0102 77EEC77A 		vsub.f32	s15, s15, s14
 443:Board/v3/board.cpp ****         }
 2201              		.loc 4 443 50 view .LVU390
 2202 0106 CDED077A 		vstr.32	s15, [sp, #28]
 2203 010a CDED086A 		vstr.32	s13, [sp, #32]
 2204 010e 8DED097A 		vstr.32	s14, [sp, #36]
 2205              	.LVL143:
 2206              	.LBB987:
 2207              	.LBI987:
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 2208              		.loc 17 788 2 is_stmt 1 view .LVU391
 2209              	.LBB988:
 2210              	.LBB989:
 2211              	.LBI989:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 2212              		.loc 17 433 22 view .LVU392
 2213              	.LBB990:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2214              		.loc 17 434 58 is_stmt 0 view .LVU393
 2215 0112 237B     		ldrb	r3, [r4, #12]	@ zero_extendqisi2
 2216              	.LVL144:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2217              		.loc 17 434 58 view .LVU394
 2218              	.LBE990:
 2219              	.LBE989:
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_get() = std::forward<_Up>(__u);
 2220              		.loc 17 790 4 view .LVU395
 2221 0114 2BB1     		cbz	r3, .L65
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 2222              		.loc 17 791 6 view .LVU396
 2223 0116 0AAB     		add	r3, sp, #40
 2224 0118 13E90700 		ldmdb	r3, {r0, r1, r2}
 2225 011c 84E80700 		stm	r4, {r0, r1, r2}
 2226 0120 94E7     		b	.L63
 2227              	.L65:
 2228              	.LVL145:
 2229              	.LBB991:
 2230              	.LBI991:
ARM GAS  /tmp/ccysU9ly.s 			page 128


 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 2231              		.loc 17 415 2 is_stmt 1 view .LVU397
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 2232              		.loc 17 415 2 is_stmt 0 view .LVU398
 2233              	.LBE991:
 2234              	.LBE988:
 2235              	.LBE987:
 2236              	.LBE980:
 2237              	.LBE999:
 2238              		.loc 18 175 3 is_stmt 1 view .LVU399
 2239              	.LBB1000:
 2240              	.LBB996:
 2241              	.LBB995:
 2242              	.LBB994:
 2243              	.LBB993:
 2244              	.LBB992:
 2245              		.loc 18 175 3 is_stmt 0 view .LVU400
 2246 0122 0AAB     		add	r3, sp, #40
 2247 0124 13E90700 		ldmdb	r3, {r0, r1, r2}
 2248 0128 84E80700 		stm	r4, {r0, r1, r2}
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 2249              		.loc 17 421 51 view .LVU401
 2250 012c 0123     		movs	r3, #1
 2251 012e 2373     		strb	r3, [r4, #12]
 2252              	.LVL146:
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2253              		.loc 17 422 2 view .LVU402
 2254 0130 8CE7     		b	.L63
 2255              	.LVL147:
 2256              	.L67:
 2257              	.LCFI10:
 2258              		.cfi_def_cfa_offset 0
 2259              		.cfi_restore 4
 2260              		.cfi_restore 5
 2261              		.cfi_restore 6
 2262              		.cfi_restore 14
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2263              		.loc 17 422 2 view .LVU403
 2264              	.LBE992:
 2265              	.LBE993:
 2266              	.LBE994:
 2267              	.LBE995:
 2268              	.LBE996:
 2269              	.LBE1000:
 426:Board/v3/board.cpp ****     }
 2270              		.loc 4 426 16 view .LVU404
 2271 0132 0020     		movs	r0, #0
 2272              	.LVL148:
 452:Board/v3/board.cpp **** 
 2273              		.loc 4 452 1 view .LVU405
 2274 0134 7047     		bx	lr
 2275              	.LVL149:
 2276              	.L68:
 2277              	.LCFI11:
 2278              		.cfi_def_cfa_offset 56
 2279              		.cfi_offset 4, -16
 2280              		.cfi_offset 5, -12
ARM GAS  /tmp/ccysU9ly.s 			page 129


 2281              		.cfi_offset 6, -8
 2282              		.cfi_offset 14, -4
 426:Board/v3/board.cpp ****     }
 2283              		.loc 4 426 16 view .LVU406
 2284 0136 0020     		movs	r0, #0
 2285              	.LVL150:
 2286              	.L58:
 452:Board/v3/board.cpp **** 
 2287              		.loc 4 452 1 view .LVU407
 2288 0138 0AB0     		add	sp, sp, #40
 2289              	.LCFI12:
 2290              		.cfi_def_cfa_offset 16
 2291              		@ sp needed
 2292 013a 70BD     		pop	{r4, r5, r6, pc}
 2293              	.LVL151:
 2294              	.L78:
 452:Board/v3/board.cpp **** 
 2295              		.loc 4 452 1 view .LVU408
 2296              		.align	2
 2297              	.L77:
 2298 013c 00200140 		.word	1073815552
 2299 0140 00210140 		.word	1073815808
 2300 0144 00220140 		.word	1073816064
 2301 0148 00000000 		.word	.LANCHOR7
 2302 014c 00000000 		.word	.LANCHOR8
 2303 0150 00000000 		.word	.LANCHOR10
 2304 0154 B0010000 		.word	.LANCHOR10+432
 2305              		.cfi_endproc
 2306              	.LFE5224:
 2307              		.fnend
 2309              		.section	.text._Z19check_board_versionPKh,"ax",%progbits
 2310              		.align	1
 2311              		.p2align 2,,3
 2312              		.global	_Z19check_board_versionPKh
 2313              		.syntax unified
 2314              		.thumb
 2315              		.thumb_func
 2317              	_Z19check_board_versionPKh:
 2318              		.fnstart
 2319              	.LVL152:
 2320              	.LFB5220:
 266:Board/v3/board.cpp ****     return (otp_ptr[3] == HW_VERSION_MAJOR) &&
 2321              		.loc 4 266 50 is_stmt 1 view -0
 2322              		.cfi_startproc
 2323              		@ args = 0, pretend = 0, frame = 0
 2324              		@ frame_needed = 0, uses_anonymous_args = 0
 2325              		@ link register save eliminated.
 267:Board/v3/board.cpp ****            (otp_ptr[4] == HW_VERSION_MINOR) &&
 2326              		.loc 4 267 5 view .LVU410
 267:Board/v3/board.cpp ****            (otp_ptr[4] == HW_VERSION_MINOR) &&
 2327              		.loc 4 267 22 is_stmt 0 view .LVU411
 2328 0000 C378     		ldrb	r3, [r0, #3]	@ zero_extendqisi2
 268:Board/v3/board.cpp ****            (otp_ptr[5] == HW_VERSION_VOLTAGE);
 2329              		.loc 4 268 45 view .LVU412
 2330 0002 032B     		cmp	r3, #3
 2331 0004 01D0     		beq	.L84
 2332 0006 0020     		movs	r0, #0
ARM GAS  /tmp/ccysU9ly.s 			page 130


 2333              	.LVL153:
 268:Board/v3/board.cpp ****            (otp_ptr[5] == HW_VERSION_VOLTAGE);
 2334              		.loc 4 268 45 view .LVU413
 2335 0008 7047     		bx	lr
 2336              	.LVL154:
 2337              	.L84:
 268:Board/v3/board.cpp ****            (otp_ptr[5] == HW_VERSION_VOLTAGE);
 2338              		.loc 4 268 22 discriminator 1 view .LVU414
 2339 000a 0379     		ldrb	r3, [r0, #4]	@ zero_extendqisi2
 267:Board/v3/board.cpp ****            (otp_ptr[4] == HW_VERSION_MINOR) &&
 2340              		.loc 4 267 45 discriminator 1 view .LVU415
 2341 000c 062B     		cmp	r3, #6
 2342 000e 01D0     		beq	.L85
 268:Board/v3/board.cpp ****            (otp_ptr[5] == HW_VERSION_VOLTAGE);
 2343              		.loc 4 268 45 view .LVU416
 2344 0010 0020     		movs	r0, #0
 2345              	.LVL155:
 268:Board/v3/board.cpp ****            (otp_ptr[5] == HW_VERSION_VOLTAGE);
 2346              		.loc 4 268 45 view .LVU417
 2347 0012 7047     		bx	lr
 2348              	.LVL156:
 2349              	.L85:
 269:Board/v3/board.cpp **** }
 2350              		.loc 4 269 22 discriminator 4 view .LVU418
 2351 0014 4379     		ldrb	r3, [r0, #5]	@ zero_extendqisi2
 268:Board/v3/board.cpp ****            (otp_ptr[5] == HW_VERSION_VOLTAGE);
 2352              		.loc 4 268 45 discriminator 4 view .LVU419
 2353 0016 382B     		cmp	r3, #56
 2354 0018 01D0     		beq	.L83
 268:Board/v3/board.cpp ****            (otp_ptr[5] == HW_VERSION_VOLTAGE);
 2355              		.loc 4 268 45 view .LVU420
 2356 001a 0020     		movs	r0, #0
 2357              	.LVL157:
 268:Board/v3/board.cpp ****            (otp_ptr[5] == HW_VERSION_VOLTAGE);
 2358              		.loc 4 268 45 view .LVU421
 2359 001c 7047     		bx	lr
 2360              	.LVL158:
 2361              	.L83:
 268:Board/v3/board.cpp ****            (otp_ptr[5] == HW_VERSION_VOLTAGE);
 2362              		.loc 4 268 45 view .LVU422
 2363 001e 0120     		movs	r0, #1
 2364              	.LVL159:
 270:Board/v3/board.cpp **** 
 2365              		.loc 4 270 1 view .LVU423
 2366 0020 7047     		bx	lr
 2367              		.cfi_endproc
 2368              	.LFE5220:
 2369              		.cantunwind
 2370              		.fnend
 2372 0022 00BF     		.section	.text._Z11system_initv,"ax",%progbits
 2373              		.align	1
 2374              		.p2align 2,,3
 2375              		.global	_Z11system_initv
 2376              		.syntax unified
 2377              		.thumb
 2378              		.thumb_func
 2380              	_Z11system_initv:
ARM GAS  /tmp/ccysU9ly.s 			page 131


 2381              		.fnstart
 2382              	.LFB5221:
 272:Board/v3/board.cpp ****     // Reset of all peripherals, Initializes the Flash interface and the Systick.
 2383              		.loc 4 272 20 is_stmt 1 view -0
 2384              		.cfi_startproc
 2385              		@ args = 0, pretend = 0, frame = 0
 2386              		@ frame_needed = 0, uses_anonymous_args = 0
 2387 0000 08B5     		push	{r3, lr}
 2388              		.save {r3, lr}
 2389              	.LCFI13:
 2390              		.cfi_def_cfa_offset 8
 2391              		.cfi_offset 3, -8
 2392              		.cfi_offset 14, -4
 274:Board/v3/board.cpp **** 
 2393              		.loc 4 274 5 view .LVU425
 274:Board/v3/board.cpp **** 
 2394              		.loc 4 274 13 is_stmt 0 view .LVU426
 2395 0002 FFF7FEFF 		bl	HAL_Init
 2396              	.LVL160:
 277:Board/v3/board.cpp **** 
 2397              		.loc 4 277 5 is_stmt 1 view .LVU427
 277:Board/v3/board.cpp **** 
 2398              		.loc 4 277 23 is_stmt 0 view .LVU428
 2399 0006 FFF7FEFF 		bl	SystemClock_Config
 2400              	.LVL161:
 281:Board/v3/board.cpp ****     if (*otp_ptr == 0xff) {
 2401              		.loc 4 281 5 is_stmt 1 view .LVU429
 282:Board/v3/board.cpp ****         otp_ptr = fake_otp;
 2402              		.loc 4 282 5 view .LVU430
 282:Board/v3/board.cpp ****         otp_ptr = fake_otp;
 2403              		.loc 4 282 9 is_stmt 0 view .LVU431
 2404 000a 064B     		ldr	r3, .L92
 2405 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 282:Board/v3/board.cpp ****         otp_ptr = fake_otp;
 2406              		.loc 4 282 5 view .LVU432
 2407 000e FF2B     		cmp	r3, #255
 2408 0010 04D0     		beq	.L90
 281:Board/v3/board.cpp ****     if (*otp_ptr == 0xff) {
 2409              		.loc 4 281 20 view .LVU433
 2410 0012 0448     		ldr	r0, .L92
 2411              	.L87:
 2412              	.LVL162:
 288:Board/v3/board.cpp ****         for (;;);
 2413              		.loc 4 288 5 is_stmt 1 view .LVU434
 288:Board/v3/board.cpp ****         for (;;);
 2414              		.loc 4 288 29 is_stmt 0 view .LVU435
 2415 0014 FFF7FEFF 		bl	_Z19check_board_versionPKh
 2416              	.LVL163:
 288:Board/v3/board.cpp ****         for (;;);
 2417              		.loc 4 288 5 view .LVU436
 2418 0018 10B9     		cbnz	r0, .L86
 2419              	.L89:
 289:Board/v3/board.cpp ****     }
 2420              		.loc 4 289 9 is_stmt 1 discriminator 1 view .LVU437
 289:Board/v3/board.cpp ****     }
 2421              		.loc 4 289 9 discriminator 1 view .LVU438
 2422 001a FEE7     		b	.L89
ARM GAS  /tmp/ccysU9ly.s 			page 132


 2423              	.LVL164:
 2424              	.L90:
 283:Board/v3/board.cpp ****     }
 2425              		.loc 4 283 17 is_stmt 0 view .LVU439
 2426 001c 0248     		ldr	r0, .L92+4
 2427 001e F9E7     		b	.L87
 2428              	.LVL165:
 2429              	.L86:
 291:Board/v3/board.cpp **** 
 2430              		.loc 4 291 1 view .LVU440
 2431 0020 08BD     		pop	{r3, pc}
 2432              	.L93:
 2433 0022 00BF     		.align	2
 2434              	.L92:
 2435 0024 0078FF1F 		.word	536836096
 2436 0028 00000000 		.word	.LANCHOR16
 2437              		.cfi_endproc
 2438              	.LFE5221:
 2439              		.fnend
 2441              		.section	.text._Z10board_initv,"ax",%progbits
 2442              		.align	1
 2443              		.p2align 2,,3
 2444              		.global	_Z10board_initv
 2445              		.syntax unified
 2446              		.thumb
 2447              		.thumb_func
 2449              	_Z10board_initv:
 2450              		.fnstart
 2451              	.LFB5222:
 293:Board/v3/board.cpp ****     // Initialize all configured peripherals
 2452              		.loc 4 293 19 is_stmt 1 view -0
 2453              		.cfi_startproc
 2454              		@ args = 0, pretend = 0, frame = 56
 2455              		@ frame_needed = 0, uses_anonymous_args = 0
 2456 0000 10B5     		push	{r4, lr}
 2457              		.save {r4, lr}
 2458              	.LCFI14:
 2459              		.cfi_def_cfa_offset 8
 2460              		.cfi_offset 4, -8
 2461              		.cfi_offset 14, -4
 2462              		.pad #56
 2463 0002 8EB0     		sub	sp, sp, #56
 2464              	.LCFI15:
 2465              		.cfi_def_cfa_offset 64
 295:Board/v3/board.cpp ****     MX_DMA_Init();
 2466              		.loc 4 295 5 view .LVU442
 295:Board/v3/board.cpp ****     MX_DMA_Init();
 2467              		.loc 4 295 17 is_stmt 0 view .LVU443
 2468 0004 FFF7FEFF 		bl	MX_GPIO_Init
 2469              	.LVL166:
 296:Board/v3/board.cpp ****     MX_ADC1_Init();
 2470              		.loc 4 296 5 is_stmt 1 view .LVU444
 296:Board/v3/board.cpp ****     MX_ADC1_Init();
 2471              		.loc 4 296 16 is_stmt 0 view .LVU445
 2472 0008 FFF7FEFF 		bl	MX_DMA_Init
 2473              	.LVL167:
 297:Board/v3/board.cpp ****     MX_ADC2_Init();
ARM GAS  /tmp/ccysU9ly.s 			page 133


 2474              		.loc 4 297 5 is_stmt 1 view .LVU446
 297:Board/v3/board.cpp ****     MX_ADC2_Init();
 2475              		.loc 4 297 17 is_stmt 0 view .LVU447
 2476 000c FFF7FEFF 		bl	MX_ADC1_Init
 2477              	.LVL168:
 298:Board/v3/board.cpp ****     MX_TIM1_Init();
 2478              		.loc 4 298 5 is_stmt 1 view .LVU448
 298:Board/v3/board.cpp ****     MX_TIM1_Init();
 2479              		.loc 4 298 17 is_stmt 0 view .LVU449
 2480 0010 FFF7FEFF 		bl	MX_ADC2_Init
 2481              	.LVL169:
 299:Board/v3/board.cpp ****     MX_TIM8_Init();
 2482              		.loc 4 299 5 is_stmt 1 view .LVU450
 299:Board/v3/board.cpp ****     MX_TIM8_Init();
 2483              		.loc 4 299 17 is_stmt 0 view .LVU451
 2484 0014 FFF7FEFF 		bl	MX_TIM1_Init
 2485              	.LVL170:
 300:Board/v3/board.cpp ****     MX_TIM3_Init();
 2486              		.loc 4 300 5 is_stmt 1 view .LVU452
 300:Board/v3/board.cpp ****     MX_TIM3_Init();
 2487              		.loc 4 300 17 is_stmt 0 view .LVU453
 2488 0018 FFF7FEFF 		bl	MX_TIM8_Init
 2489              	.LVL171:
 301:Board/v3/board.cpp ****     MX_TIM4_Init();
 2490              		.loc 4 301 5 is_stmt 1 view .LVU454
 301:Board/v3/board.cpp ****     MX_TIM4_Init();
 2491              		.loc 4 301 17 is_stmt 0 view .LVU455
 2492 001c FFF7FEFF 		bl	MX_TIM3_Init
 2493              	.LVL172:
 302:Board/v3/board.cpp ****     MX_SPI3_Init();
 2494              		.loc 4 302 5 is_stmt 1 view .LVU456
 302:Board/v3/board.cpp ****     MX_SPI3_Init();
 2495              		.loc 4 302 17 is_stmt 0 view .LVU457
 2496 0020 FFF7FEFF 		bl	MX_TIM4_Init
 2497              	.LVL173:
 303:Board/v3/board.cpp ****     MX_ADC3_Init();
 2498              		.loc 4 303 5 is_stmt 1 view .LVU458
 303:Board/v3/board.cpp ****     MX_ADC3_Init();
 2499              		.loc 4 303 17 is_stmt 0 view .LVU459
 2500 0024 FFF7FEFF 		bl	MX_SPI3_Init
 2501              	.LVL174:
 304:Board/v3/board.cpp ****     MX_TIM2_Init();
 2502              		.loc 4 304 5 is_stmt 1 view .LVU460
 304:Board/v3/board.cpp ****     MX_TIM2_Init();
 2503              		.loc 4 304 17 is_stmt 0 view .LVU461
 2504 0028 FFF7FEFF 		bl	MX_ADC3_Init
 2505              	.LVL175:
 305:Board/v3/board.cpp ****     MX_TIM5_Init();
 2506              		.loc 4 305 5 is_stmt 1 view .LVU462
 305:Board/v3/board.cpp ****     MX_TIM5_Init();
 2507              		.loc 4 305 17 is_stmt 0 view .LVU463
 2508 002c FFF7FEFF 		bl	MX_TIM2_Init
 2509              	.LVL176:
 306:Board/v3/board.cpp ****     MX_TIM13_Init();
 2510              		.loc 4 306 5 is_stmt 1 view .LVU464
 306:Board/v3/board.cpp ****     MX_TIM13_Init();
 2511              		.loc 4 306 17 is_stmt 0 view .LVU465
ARM GAS  /tmp/ccysU9ly.s 			page 134


 2512 0030 FFF7FEFF 		bl	MX_TIM5_Init
 2513              	.LVL177:
 307:Board/v3/board.cpp **** 
 2514              		.loc 4 307 5 is_stmt 1 view .LVU466
 307:Board/v3/board.cpp **** 
 2515              		.loc 4 307 18 is_stmt 0 view .LVU467
 2516 0034 FFF7FEFF 		bl	MX_TIM13_Init
 2517              	.LVL178:
 310:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI0_IRQn);
 2518              		.loc 4 310 5 is_stmt 1 view .LVU468
 310:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI0_IRQn);
 2519              		.loc 4 310 25 is_stmt 0 view .LVU469
 2520 0038 0022     		movs	r2, #0
 2521 003a 0121     		movs	r1, #1
 2522 003c 0620     		movs	r0, #6
 2523 003e FFF7FEFF 		bl	HAL_NVIC_SetPriority
 2524              	.LVL179:
 311:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI1_IRQn, 1, 0);
 2525              		.loc 4 311 5 is_stmt 1 view .LVU470
 311:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI1_IRQn, 1, 0);
 2526              		.loc 4 311 23 is_stmt 0 view .LVU471
 2527 0042 0620     		movs	r0, #6
 2528 0044 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 2529              	.LVL180:
 312:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI1_IRQn);
 2530              		.loc 4 312 5 is_stmt 1 view .LVU472
 312:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI1_IRQn);
 2531              		.loc 4 312 25 is_stmt 0 view .LVU473
 2532 0048 0022     		movs	r2, #0
 2533 004a 0121     		movs	r1, #1
 2534 004c 0720     		movs	r0, #7
 2535 004e FFF7FEFF 		bl	HAL_NVIC_SetPriority
 2536              	.LVL181:
 313:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI2_IRQn, 1, 0);
 2537              		.loc 4 313 5 is_stmt 1 view .LVU474
 313:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI2_IRQn, 1, 0);
 2538              		.loc 4 313 23 is_stmt 0 view .LVU475
 2539 0052 0720     		movs	r0, #7
 2540 0054 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 2541              	.LVL182:
 314:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI2_IRQn);
 2542              		.loc 4 314 5 is_stmt 1 view .LVU476
 314:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI2_IRQn);
 2543              		.loc 4 314 25 is_stmt 0 view .LVU477
 2544 0058 0022     		movs	r2, #0
 2545 005a 0121     		movs	r1, #1
 2546 005c 0820     		movs	r0, #8
 2547 005e FFF7FEFF 		bl	HAL_NVIC_SetPriority
 2548              	.LVL183:
 315:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI3_IRQn, 1, 0);
 2549              		.loc 4 315 5 is_stmt 1 view .LVU478
 315:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI3_IRQn, 1, 0);
 2550              		.loc 4 315 23 is_stmt 0 view .LVU479
 2551 0062 0820     		movs	r0, #8
 2552 0064 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 2553              	.LVL184:
 316:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI3_IRQn);
ARM GAS  /tmp/ccysU9ly.s 			page 135


 2554              		.loc 4 316 5 is_stmt 1 view .LVU480
 316:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI3_IRQn);
 2555              		.loc 4 316 25 is_stmt 0 view .LVU481
 2556 0068 0022     		movs	r2, #0
 2557 006a 0121     		movs	r1, #1
 2558 006c 0920     		movs	r0, #9
 2559 006e FFF7FEFF 		bl	HAL_NVIC_SetPriority
 2560              	.LVL185:
 317:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI4_IRQn, 1, 0);
 2561              		.loc 4 317 5 is_stmt 1 view .LVU482
 317:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI4_IRQn, 1, 0);
 2562              		.loc 4 317 23 is_stmt 0 view .LVU483
 2563 0072 0920     		movs	r0, #9
 2564 0074 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 2565              	.LVL186:
 318:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI4_IRQn);
 2566              		.loc 4 318 5 is_stmt 1 view .LVU484
 318:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI4_IRQn);
 2567              		.loc 4 318 25 is_stmt 0 view .LVU485
 2568 0078 0022     		movs	r2, #0
 2569 007a 0121     		movs	r1, #1
 2570 007c 0A20     		movs	r0, #10
 2571 007e FFF7FEFF 		bl	HAL_NVIC_SetPriority
 2572              	.LVL187:
 319:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI9_5_IRQn, 1, 0);
 2573              		.loc 4 319 5 is_stmt 1 view .LVU486
 319:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI9_5_IRQn, 1, 0);
 2574              		.loc 4 319 23 is_stmt 0 view .LVU487
 2575 0082 0A20     		movs	r0, #10
 2576 0084 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 2577              	.LVL188:
 320:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 2578              		.loc 4 320 5 is_stmt 1 view .LVU488
 320:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 2579              		.loc 4 320 25 is_stmt 0 view .LVU489
 2580 0088 0022     		movs	r2, #0
 2581 008a 0121     		movs	r1, #1
 2582 008c 1720     		movs	r0, #23
 2583 008e FFF7FEFF 		bl	HAL_NVIC_SetPriority
 2584              	.LVL189:
 321:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI15_10_IRQn, 1, 0);
 2585              		.loc 4 321 5 is_stmt 1 view .LVU490
 321:Board/v3/board.cpp ****     HAL_NVIC_SetPriority(EXTI15_10_IRQn, 1, 0);
 2586              		.loc 4 321 23 is_stmt 0 view .LVU491
 2587 0092 1720     		movs	r0, #23
 2588 0094 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 2589              	.LVL190:
 322:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 2590              		.loc 4 322 5 is_stmt 1 view .LVU492
 322:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 2591              		.loc 4 322 25 is_stmt 0 view .LVU493
 2592 0098 0022     		movs	r2, #0
 2593 009a 0121     		movs	r1, #1
 2594 009c 2820     		movs	r0, #40
 2595 009e FFF7FEFF 		bl	HAL_NVIC_SetPriority
 2596              	.LVL191:
 323:Board/v3/board.cpp **** 
ARM GAS  /tmp/ccysU9ly.s 			page 136


 2597              		.loc 4 323 5 is_stmt 1 view .LVU494
 323:Board/v3/board.cpp **** 
 2598              		.loc 4 323 23 is_stmt 0 view .LVU495
 2599 00a2 2820     		movs	r0, #40
 2600 00a4 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 2601              	.LVL192:
 325:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(ControlLoop_IRQn);
 2602              		.loc 4 325 5 is_stmt 1 view .LVU496
 325:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(ControlLoop_IRQn);
 2603              		.loc 4 325 25 is_stmt 0 view .LVU497
 2604 00a8 0022     		movs	r2, #0
 2605 00aa 0521     		movs	r1, #5
 2606 00ac 4D20     		movs	r0, #77
 2607 00ae FFF7FEFF 		bl	HAL_NVIC_SetPriority
 2608              	.LVL193:
 326:Board/v3/board.cpp **** 
 2609              		.loc 4 326 5 is_stmt 1 view .LVU498
 326:Board/v3/board.cpp **** 
 2610              		.loc 4 326 23 is_stmt 0 view .LVU499
 2611 00b2 4D20     		movs	r0, #77
 2612 00b4 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 2613              	.LVL194:
 328:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);
 2614              		.loc 4 328 5 is_stmt 1 view .LVU500
 328:Board/v3/board.cpp ****     HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);
 2615              		.loc 4 328 25 is_stmt 0 view .LVU501
 2616 00b8 0022     		movs	r2, #0
 2617 00ba 1146     		mov	r1, r2
 2618 00bc 2C20     		movs	r0, #44
 2619 00be FFF7FEFF 		bl	HAL_NVIC_SetPriority
 2620              	.LVL195:
 329:Board/v3/board.cpp **** 
 2621              		.loc 4 329 5 is_stmt 1 view .LVU502
 329:Board/v3/board.cpp **** 
 2622              		.loc 4 329 23 is_stmt 0 view .LVU503
 2623 00c2 2C20     		movs	r0, #44
 2624 00c4 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 2625              	.LVL196:
 331:Board/v3/board.cpp ****         uart_a->Init.BaudRate = odrv.config_.uart_a_baudrate;
 2626              		.loc 4 331 5 is_stmt 1 view .LVU504
 331:Board/v3/board.cpp ****         uart_a->Init.BaudRate = odrv.config_.uart_a_baudrate;
 2627              		.loc 4 331 22 is_stmt 0 view .LVU505
 2628 00c8 5F4B     		ldr	r3, .L116
 2629 00ca 93F88931 		ldrb	r3, [r3, #393]	@ zero_extendqisi2
 331:Board/v3/board.cpp ****         uart_a->Init.BaudRate = odrv.config_.uart_a_baudrate;
 2630              		.loc 4 331 5 view .LVU506
 2631 00ce 002B     		cmp	r3, #0
 2632 00d0 3FD1     		bne	.L112
 2633              	.L95:
 336:Board/v3/board.cpp ****         uart_b->Init.BaudRate = odrv.config_.uart_b_baudrate;
 2634              		.loc 4 336 5 is_stmt 1 view .LVU507
 336:Board/v3/board.cpp ****         uart_b->Init.BaudRate = odrv.config_.uart_b_baudrate;
 2635              		.loc 4 336 22 is_stmt 0 view .LVU508
 2636 00d2 5D4B     		ldr	r3, .L116
 2637 00d4 93F88A31 		ldrb	r3, [r3, #394]	@ zero_extendqisi2
 336:Board/v3/board.cpp ****         uart_b->Init.BaudRate = odrv.config_.uart_b_baudrate;
 2638              		.loc 4 336 5 view .LVU509
ARM GAS  /tmp/ccysU9ly.s 			page 137


 2639 00d8 002B     		cmp	r3, #0
 2640 00da 43D1     		bne	.L113
 2641              	.L96:
 341:Board/v3/board.cpp ****         // Set up the direction GPIO as input
 2642              		.loc 4 341 5 is_stmt 1 view .LVU510
 341:Board/v3/board.cpp ****         // Set up the direction GPIO as input
 2643              		.loc 4 341 22 is_stmt 0 view .LVU511
 2644 00dc 5A4B     		ldr	r3, .L116
 2645 00de 93F89931 		ldrb	r3, [r3, #409]	@ zero_extendqisi2
 341:Board/v3/board.cpp ****         // Set up the direction GPIO as input
 2646              		.loc 4 341 5 view .LVU512
 2647 00e2 002B     		cmp	r3, #0
 2648 00e4 47D1     		bne	.L114
 2649              	.L97:
 355:Board/v3/board.cpp ****         // The CAN initialization will (and must) init its own GPIOs before the
 2650              		.loc 4 355 5 is_stmt 1 view .LVU513
 355:Board/v3/board.cpp ****         // The CAN initialization will (and must) init its own GPIOs before the
 2651              		.loc 4 355 22 is_stmt 0 view .LVU514
 2652 00e6 584B     		ldr	r3, .L116
 2653 00e8 93F89831 		ldrb	r3, [r3, #408]	@ zero_extendqisi2
 355:Board/v3/board.cpp ****         // The CAN initialization will (and must) init its own GPIOs before the
 2654              		.loc 4 355 5 view .LVU515
 2655 00ec 4BB1     		cbz	r3, .L101
 359:Board/v3/board.cpp ****             odrv.misconfigured_ = true;
 2656              		.loc 4 359 9 is_stmt 1 view .LVU516
 359:Board/v3/board.cpp ****             odrv.misconfigured_ = true;
 2657              		.loc 4 359 39 is_stmt 0 view .LVU517
 2658 00ee 564B     		ldr	r3, .L116
 2659 00f0 93F88731 		ldrb	r3, [r3, #391]	@ zero_extendqisi2
 359:Board/v3/board.cpp ****             odrv.misconfigured_ = true;
 2660              		.loc 4 359 9 view .LVU518
 2661 00f4 072B     		cmp	r3, #7
 2662 00f6 00F09F80 		beq	.L115
 2663              	.L102:
 360:Board/v3/board.cpp ****         }
 2664              		.loc 4 360 13 is_stmt 1 view .LVU519
 360:Board/v3/board.cpp ****         }
 2665              		.loc 4 360 33 is_stmt 0 view .LVU520
 2666 00fa 534B     		ldr	r3, .L116
 2667 00fc 0122     		movs	r2, #1
 2668 00fe 83F8CC22 		strb	r2, [r3, #716]
 2669              	.L101:
 365:Board/v3/board.cpp ****     __HAL_DBGMCU_FREEZE_TIM8();
 2670              		.loc 4 365 5 is_stmt 1 view .LVU521
 2671 0102 524B     		ldr	r3, .L116+4
 2672 0104 DA68     		ldr	r2, [r3, #12]
 2673 0106 42F00102 		orr	r2, r2, #1
 2674 010a DA60     		str	r2, [r3, #12]
 366:Board/v3/board.cpp ****     __HAL_DBGMCU_FREEZE_TIM13();
 2675              		.loc 4 366 5 view .LVU522
 2676 010c DA68     		ldr	r2, [r3, #12]
 2677 010e 42F00202 		orr	r2, r2, #2
 2678 0112 DA60     		str	r2, [r3, #12]
 367:Board/v3/board.cpp **** 
 2679              		.loc 4 367 5 view .LVU523
 2680 0114 9A68     		ldr	r2, [r3, #8]
 2681 0116 42F08002 		orr	r2, r2, #128
ARM GAS  /tmp/ccysU9ly.s 			page 138


 2682 011a 9A60     		str	r2, [r3, #8]
 369:Board/v3/board.cpp **** 
 2683              		.loc 4 369 5 view .LVU524
 2684              	.LVL197:
 2685              	.LBB1014:
 2686              	.LBI1014:
 2687              		.loc 6 11 5 view .LVU525
 2688              	.LBB1015:
 2689              	.LBB1016:
 2690              		.loc 6 11 77 is_stmt 0 view .LVU526
 2691 011c 4C48     		ldr	r0, .L116+8
 2692 011e 0090     		str	r0, [sp]
 2693 0120 4FF48053 		mov	r3, #4096
 2694 0124 ADF80430 		strh	r3, [sp, #4]	@ movhi
 2695              	.LVL198:
 2696              		.loc 6 11 77 view .LVU527
 2697              	.LBE1016:
 2698              	.LBE1015:
 2699              	.LBE1014:
 373:Board/v3/board.cpp ****     delay_us(40); // mimumum pull-down time for full reset: 20us
 2700              		.loc 4 373 5 is_stmt 1 view .LVU528
 2701              	.LBB1017:
 2702              	.LBI1017:
  12:./Drivers/STM32/stm32_gpio.hpp **** 
  13:./Drivers/STM32/stm32_gpio.hpp ****     operator bool() const { return port_ && pin_mask_; }
  14:./Drivers/STM32/stm32_gpio.hpp **** 
  15:./Drivers/STM32/stm32_gpio.hpp ****     /**
  16:./Drivers/STM32/stm32_gpio.hpp ****      * @brief Configures the GPIO with the specified parameters.
  17:./Drivers/STM32/stm32_gpio.hpp ****      * 
  18:./Drivers/STM32/stm32_gpio.hpp ****      * This can be done regardless of the current state of the GPIO.
  19:./Drivers/STM32/stm32_gpio.hpp ****      * 
  20:./Drivers/STM32/stm32_gpio.hpp ****      * If any subscription is in place, it is not disabled by this function.
  21:./Drivers/STM32/stm32_gpio.hpp ****      */
  22:./Drivers/STM32/stm32_gpio.hpp ****     bool config(uint32_t mode, uint32_t pull, uint32_t speed = GPIO_SPEED_FREQ_LOW);
  23:./Drivers/STM32/stm32_gpio.hpp **** 
  24:./Drivers/STM32/stm32_gpio.hpp ****     void write(bool state) {
 2703              		.loc 6 24 10 view .LVU529
 2704              	.LBB1018:
  25:./Drivers/STM32/stm32_gpio.hpp ****         if (port_) {
 2705              		.loc 6 25 9 view .LVU530
  26:./Drivers/STM32/stm32_gpio.hpp ****             HAL_GPIO_WritePin(port_, pin_mask_, state ? GPIO_PIN_SET : GPIO_PIN_RESET);
 2706              		.loc 6 26 13 view .LVU531
 2707              		.loc 6 26 30 is_stmt 0 view .LVU532
 2708 0128 0022     		movs	r2, #0
 2709 012a 99B2     		uxth	r1, r3
 2710 012c FFF7FEFF 		bl	HAL_GPIO_WritePin
 2711              	.LVL199:
 2712              		.loc 6 26 30 view .LVU533
 2713              	.LBE1018:
 2714              	.LBE1017:
 374:Board/v3/board.cpp ****     drv_enable_gpio.write(true);
 2715              		.loc 4 374 5 is_stmt 1 view .LVU534
 374:Board/v3/board.cpp ****     drv_enable_gpio.write(true);
 2716              		.loc 4 374 13 is_stmt 0 view .LVU535
 2717 0130 2820     		movs	r0, #40
 2718 0132 FFF7FEFF 		bl	_Z8delay_usm
 2719              	.LVL200:
ARM GAS  /tmp/ccysU9ly.s 			page 139


 375:Board/v3/board.cpp ****     delay_us(20000); // mimumum pull-down time for full reset: 20us
 2720              		.loc 4 375 5 is_stmt 1 view .LVU536
 2721              	.LBB1019:
 2722              	.LBI1019:
  24:./Drivers/STM32/stm32_gpio.hpp ****         if (port_) {
 2723              		.loc 6 24 10 view .LVU537
 2724              	.LBB1020:
  25:./Drivers/STM32/stm32_gpio.hpp ****             HAL_GPIO_WritePin(port_, pin_mask_, state ? GPIO_PIN_SET : GPIO_PIN_RESET);
 2725              		.loc 6 25 9 view .LVU538
  25:./Drivers/STM32/stm32_gpio.hpp ****             HAL_GPIO_WritePin(port_, pin_mask_, state ? GPIO_PIN_SET : GPIO_PIN_RESET);
 2726              		.loc 6 25 13 is_stmt 0 view .LVU539
 2727 0136 0098     		ldr	r0, [sp]
  25:./Drivers/STM32/stm32_gpio.hpp ****             HAL_GPIO_WritePin(port_, pin_mask_, state ? GPIO_PIN_SET : GPIO_PIN_RESET);
 2728              		.loc 6 25 9 view .LVU540
 2729 0138 20B1     		cbz	r0, .L104
 2730              		.loc 6 26 13 is_stmt 1 view .LVU541
 2731              		.loc 6 26 30 is_stmt 0 view .LVU542
 2732 013a 0122     		movs	r2, #1
 2733 013c BDF80410 		ldrh	r1, [sp, #4]
 2734 0140 FFF7FEFF 		bl	HAL_GPIO_WritePin
 2735              	.LVL201:
 2736              	.L104:
 2737              		.loc 6 26 30 view .LVU543
 2738              	.LBE1020:
 2739              	.LBE1019:
 376:Board/v3/board.cpp **** 
 2740              		.loc 4 376 5 is_stmt 1 view .LVU544
 376:Board/v3/board.cpp **** 
 2741              		.loc 4 376 13 is_stmt 0 view .LVU545
 2742 0144 44F62060 		movw	r0, #20000
 2743 0148 FFF7FEFF 		bl	_Z8delay_usm
 2744              	.LVL202:
 378:Board/v3/board.cpp **** }
 2745              		.loc 4 378 5 is_stmt 1 view .LVU546
 379:Board/v3/board.cpp **** 
 2746              		.loc 4 379 1 is_stmt 0 view .LVU547
 2747 014c 0120     		movs	r0, #1
 2748 014e 0EB0     		add	sp, sp, #56
 2749              	.LCFI16:
 2750              		.cfi_remember_state
 2751              		.cfi_def_cfa_offset 8
 2752              		@ sp needed
 2753 0150 10BD     		pop	{r4, pc}
 2754              	.L112:
 2755              	.LCFI17:
 2756              		.cfi_restore_state
 332:Board/v3/board.cpp ****         MX_UART4_Init();
 2757              		.loc 4 332 9 is_stmt 1 view .LVU548
 332:Board/v3/board.cpp ****         MX_UART4_Init();
 2758              		.loc 4 332 22 is_stmt 0 view .LVU549
 2759 0152 404B     		ldr	r3, .L116+12
 2760 0154 1B68     		ldr	r3, [r3]
 332:Board/v3/board.cpp ****         MX_UART4_Init();
 2761              		.loc 4 332 46 view .LVU550
 2762 0156 3C4A     		ldr	r2, .L116
 2763 0158 D2F88C21 		ldr	r2, [r2, #396]
 332:Board/v3/board.cpp ****         MX_UART4_Init();
ARM GAS  /tmp/ccysU9ly.s 			page 140


 2764              		.loc 4 332 31 view .LVU551
 2765 015c 5A60     		str	r2, [r3, #4]
 333:Board/v3/board.cpp ****     }
 2766              		.loc 4 333 9 is_stmt 1 view .LVU552
 333:Board/v3/board.cpp ****     }
 2767              		.loc 4 333 22 is_stmt 0 view .LVU553
 2768 015e FFF7FEFF 		bl	MX_UART4_Init
 2769              	.LVL203:
 2770 0162 B6E7     		b	.L95
 2771              	.L113:
 337:Board/v3/board.cpp ****         MX_USART2_UART_Init();
 2772              		.loc 4 337 9 is_stmt 1 view .LVU554
 337:Board/v3/board.cpp ****         MX_USART2_UART_Init();
 2773              		.loc 4 337 22 is_stmt 0 view .LVU555
 2774 0164 3C4B     		ldr	r3, .L116+16
 2775 0166 1B68     		ldr	r3, [r3]
 337:Board/v3/board.cpp ****         MX_USART2_UART_Init();
 2776              		.loc 4 337 46 view .LVU556
 2777 0168 374A     		ldr	r2, .L116
 2778 016a D2F89021 		ldr	r2, [r2, #400]
 337:Board/v3/board.cpp ****         MX_USART2_UART_Init();
 2779              		.loc 4 337 31 view .LVU557
 2780 016e 5A60     		str	r2, [r3, #4]
 338:Board/v3/board.cpp ****     }
 2781              		.loc 4 338 9 is_stmt 1 view .LVU558
 338:Board/v3/board.cpp ****     }
 2782              		.loc 4 338 28 is_stmt 0 view .LVU559
 2783 0170 FFF7FEFF 		bl	MX_USART2_UART_Init
 2784              	.LVL204:
 2785 0174 B2E7     		b	.L96
 2786              	.L114:
 343:Board/v3/board.cpp ****         get_gpio(4).config(GPIO_MODE_INPUT, GPIO_PULLUP);
 2787              		.loc 4 343 9 is_stmt 1 view .LVU560
 343:Board/v3/board.cpp ****         get_gpio(4).config(GPIO_MODE_INPUT, GPIO_PULLUP);
 2788              		.loc 4 343 19 is_stmt 0 view .LVU561
 2789 0176 0321     		movs	r1, #3
 2790 0178 02A8     		add	r0, sp, #8
 2791 017a FFF7FEFF 		bl	_ZL8get_gpioj
 2792              	.LVL205:
 343:Board/v3/board.cpp ****         get_gpio(4).config(GPIO_MODE_INPUT, GPIO_PULLUP);
 2793              		.loc 4 343 27 view .LVU562
 2794 017e 0023     		movs	r3, #0
 2795 0180 0122     		movs	r2, #1
 2796 0182 1946     		mov	r1, r3
 2797 0184 02A8     		add	r0, sp, #8
 2798 0186 FFF7FEFF 		bl	_ZN9Stm32Gpio6configEmmm
 2799              	.LVL206:
 344:Board/v3/board.cpp ****         get_gpio(5).config(GPIO_MODE_INPUT, GPIO_PULLUP);
 2800              		.loc 4 344 9 is_stmt 1 view .LVU563
 344:Board/v3/board.cpp ****         get_gpio(5).config(GPIO_MODE_INPUT, GPIO_PULLUP);
 2801              		.loc 4 344 19 is_stmt 0 view .LVU564
 2802 018a 0421     		movs	r1, #4
 2803 018c 04A8     		add	r0, sp, #16
 2804 018e FFF7FEFF 		bl	_ZL8get_gpioj
 2805              	.LVL207:
 344:Board/v3/board.cpp ****         get_gpio(5).config(GPIO_MODE_INPUT, GPIO_PULLUP);
 2806              		.loc 4 344 27 view .LVU565
ARM GAS  /tmp/ccysU9ly.s 			page 141


 2807 0192 0023     		movs	r3, #0
 2808 0194 0122     		movs	r2, #1
 2809 0196 1946     		mov	r1, r3
 2810 0198 04A8     		add	r0, sp, #16
 2811 019a FFF7FEFF 		bl	_ZN9Stm32Gpio6configEmmm
 2812              	.LVL208:
 345:Board/v3/board.cpp **** 
 2813              		.loc 4 345 9 is_stmt 1 view .LVU566
 345:Board/v3/board.cpp **** 
 2814              		.loc 4 345 19 is_stmt 0 view .LVU567
 2815 019e 0521     		movs	r1, #5
 2816 01a0 06A8     		add	r0, sp, #24
 2817 01a2 FFF7FEFF 		bl	_ZL8get_gpioj
 2818              	.LVL209:
 345:Board/v3/board.cpp **** 
 2819              		.loc 4 345 27 view .LVU568
 2820 01a6 0023     		movs	r3, #0
 2821 01a8 0122     		movs	r2, #1
 2822 01aa 1946     		mov	r1, r3
 2823 01ac 06A8     		add	r0, sp, #24
 2824 01ae FFF7FEFF 		bl	_ZN9Stm32Gpio6configEmmm
 2825              	.LVL210:
 347:Board/v3/board.cpp ****         i2c_stats_.addr = (0xD << 3);
 2826              		.loc 4 347 9 is_stmt 1 view .LVU569
 347:Board/v3/board.cpp ****         i2c_stats_.addr = (0xD << 3);
 2827              		.loc 4 347 16 is_stmt 0 view .LVU570
 2828 01b2 0120     		movs	r0, #1
 2829 01b4 FFF7FEFF 		bl	osDelay
 2830              	.LVL211:
 348:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(3).read() ? 0x1 : 0;
 2831              		.loc 4 348 9 is_stmt 1 view .LVU571
 348:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(3).read() ? 0x1 : 0;
 2832              		.loc 4 348 25 is_stmt 0 view .LVU572
 2833 01b8 284B     		ldr	r3, .L116+20
 2834 01ba 6822     		movs	r2, #104
 2835 01bc 1A70     		strb	r2, [r3]
 349:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(4).read() ? 0x2 : 0;
 2836              		.loc 4 349 9 is_stmt 1 view .LVU573
 349:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(4).read() ? 0x2 : 0;
 2837              		.loc 4 349 38 is_stmt 0 view .LVU574
 2838 01be 0321     		movs	r1, #3
 2839 01c0 08A8     		add	r0, sp, #32
 2840 01c2 FFF7FEFF 		bl	_ZL8get_gpioj
 2841              	.LVL212:
 2842              	.LBB1021:
 2843              	.LBI1021:
  27:./Drivers/STM32/stm32_gpio.hpp ****         }
  28:./Drivers/STM32/stm32_gpio.hpp ****     }
  29:./Drivers/STM32/stm32_gpio.hpp **** 
  30:./Drivers/STM32/stm32_gpio.hpp ****     bool read() {
 2844              		.loc 6 30 10 is_stmt 1 view .LVU575
 2845              	.LBB1022:
  31:./Drivers/STM32/stm32_gpio.hpp ****         return port_ && (port_->IDR & pin_mask_);
 2846              		.loc 6 31 9 view .LVU576
 2847              		.loc 6 31 16 is_stmt 0 view .LVU577
 2848 01c6 089B     		ldr	r3, [sp, #32]
 2849              		.loc 6 31 22 view .LVU578
ARM GAS  /tmp/ccysU9ly.s 			page 142


 2850 01c8 53B3     		cbz	r3, .L105
 2851              		.loc 6 31 33 view .LVU579
 2852 01ca 1A69     		ldr	r2, [r3, #16]
 2853              		.loc 6 31 39 view .LVU580
 2854 01cc BDF82430 		ldrh	r3, [sp, #36]
 2855              		.loc 6 31 22 view .LVU581
 2856 01d0 1A42     		tst	r2, r3
 2857 01d2 27D1     		bne	.L106
 2858              	.LBE1022:
 2859              	.LBE1021:
 349:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(4).read() ? 0x2 : 0;
 2860              		.loc 4 349 47 view .LVU582
 2861 01d4 0024     		movs	r4, #0
 2862              	.L98:
 2863              	.LVL213:
 349:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(4).read() ? 0x2 : 0;
 2864              		.loc 4 349 25 discriminator 4 view .LVU583
 2865 01d6 44F06804 		orr	r4, r4, #104
 2866 01da 204B     		ldr	r3, .L116+20
 2867 01dc 1C70     		strb	r4, [r3]
 350:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(5).read() ? 0x4 : 0;
 2868              		.loc 4 350 9 is_stmt 1 discriminator 4 view .LVU584
 350:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(5).read() ? 0x4 : 0;
 2869              		.loc 4 350 38 is_stmt 0 discriminator 4 view .LVU585
 2870 01de 0421     		movs	r1, #4
 2871 01e0 0AA8     		add	r0, sp, #40
 2872 01e2 FFF7FEFF 		bl	_ZL8get_gpioj
 2873              	.LVL214:
 2874              	.LBB1023:
 2875              	.LBI1023:
  30:./Drivers/STM32/stm32_gpio.hpp ****         return port_ && (port_->IDR & pin_mask_);
 2876              		.loc 6 30 10 is_stmt 1 discriminator 4 view .LVU586
 2877              	.LBB1024:
 2878              		.loc 6 31 9 discriminator 4 view .LVU587
 2879              		.loc 6 31 16 is_stmt 0 discriminator 4 view .LVU588
 2880 01e6 0A9B     		ldr	r3, [sp, #40]
 2881              		.loc 6 31 22 discriminator 4 view .LVU589
 2882 01e8 F3B1     		cbz	r3, .L107
 2883              		.loc 6 31 33 view .LVU590
 2884 01ea 1A69     		ldr	r2, [r3, #16]
 2885              		.loc 6 31 39 view .LVU591
 2886 01ec BDF82C30 		ldrh	r3, [sp, #44]
 2887              		.loc 6 31 22 view .LVU592
 2888 01f0 1A42     		tst	r2, r3
 2889 01f2 1BD1     		bne	.L108
 2890              	.LBE1024:
 2891              	.LBE1023:
 350:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(5).read() ? 0x4 : 0;
 2892              		.loc 4 350 47 view .LVU593
 2893 01f4 0020     		movs	r0, #0
 2894              	.L99:
 2895              	.LVL215:
 350:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(5).read() ? 0x4 : 0;
 2896              		.loc 4 350 25 discriminator 4 view .LVU594
 2897 01f6 0443     		orrs	r4, r4, r0
 2898 01f8 184B     		ldr	r3, .L116+20
 2899 01fa 1C70     		strb	r4, [r3]
ARM GAS  /tmp/ccysU9ly.s 			page 143


 351:Board/v3/board.cpp ****         MX_I2C1_Init(i2c_stats_.addr);
 2900              		.loc 4 351 9 is_stmt 1 discriminator 4 view .LVU595
 351:Board/v3/board.cpp ****         MX_I2C1_Init(i2c_stats_.addr);
 2901              		.loc 4 351 38 is_stmt 0 discriminator 4 view .LVU596
 2902 01fc 0521     		movs	r1, #5
 2903 01fe 0CA8     		add	r0, sp, #48
 2904 0200 FFF7FEFF 		bl	_ZL8get_gpioj
 2905              	.LVL216:
 2906              	.LBB1025:
 2907              	.LBI1025:
  30:./Drivers/STM32/stm32_gpio.hpp ****         return port_ && (port_->IDR & pin_mask_);
 2908              		.loc 6 30 10 is_stmt 1 discriminator 4 view .LVU597
 2909              	.LBB1026:
 2910              		.loc 6 31 9 discriminator 4 view .LVU598
 2911              		.loc 6 31 16 is_stmt 0 discriminator 4 view .LVU599
 2912 0204 0C9B     		ldr	r3, [sp, #48]
 2913              		.loc 6 31 22 discriminator 4 view .LVU600
 2914 0206 9BB1     		cbz	r3, .L109
 2915              		.loc 6 31 33 view .LVU601
 2916 0208 1A69     		ldr	r2, [r3, #16]
 2917              		.loc 6 31 39 view .LVU602
 2918 020a BDF83430 		ldrh	r3, [sp, #52]
 2919              		.loc 6 31 22 view .LVU603
 2920 020e 1A42     		tst	r2, r3
 2921 0210 10D1     		bne	.L110
 2922              	.LBE1026:
 2923              	.LBE1025:
 351:Board/v3/board.cpp ****         MX_I2C1_Init(i2c_stats_.addr);
 2924              		.loc 4 351 47 view .LVU604
 2925 0212 0020     		movs	r0, #0
 2926              	.L100:
 2927              	.LVL217:
 351:Board/v3/board.cpp ****         MX_I2C1_Init(i2c_stats_.addr);
 2928              		.loc 4 351 25 discriminator 4 view .LVU605
 2929 0214 2043     		orrs	r0, r0, r4
 2930 0216 114B     		ldr	r3, .L116+20
 2931 0218 1870     		strb	r0, [r3]
 352:Board/v3/board.cpp ****     }
 2932              		.loc 4 352 9 is_stmt 1 discriminator 4 view .LVU606
 352:Board/v3/board.cpp ****     }
 2933              		.loc 4 352 21 is_stmt 0 discriminator 4 view .LVU607
 2934 021a FFF7FEFF 		bl	MX_I2C1_Init
 2935              	.LVL218:
 2936 021e 62E7     		b	.L97
 2937              	.LVL219:
 2938              	.L105:
 349:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(4).read() ? 0x2 : 0;
 2939              		.loc 4 349 47 view .LVU608
 2940 0220 0024     		movs	r4, #0
 2941 0222 D8E7     		b	.L98
 2942              	.L106:
 2943 0224 0124     		movs	r4, #1
 2944 0226 D6E7     		b	.L98
 2945              	.LVL220:
 2946              	.L107:
 350:Board/v3/board.cpp ****         i2c_stats_.addr |= get_gpio(5).read() ? 0x4 : 0;
 2947              		.loc 4 350 47 view .LVU609
ARM GAS  /tmp/ccysU9ly.s 			page 144


 2948 0228 0020     		movs	r0, #0
 2949 022a E4E7     		b	.L99
 2950              	.L108:
 2951 022c 0220     		movs	r0, #2
 2952 022e E2E7     		b	.L99
 2953              	.LVL221:
 2954              	.L109:
 351:Board/v3/board.cpp ****         MX_I2C1_Init(i2c_stats_.addr);
 2955              		.loc 4 351 47 view .LVU610
 2956 0230 0020     		movs	r0, #0
 2957 0232 EFE7     		b	.L100
 2958              	.L110:
 2959 0234 0420     		movs	r0, #4
 2960 0236 EDE7     		b	.L100
 2961              	.LVL222:
 2962              	.L115:
 359:Board/v3/board.cpp ****             odrv.misconfigured_ = true;
 2963              		.loc 4 359 101 discriminator 1 view .LVU611
 2964 0238 034B     		ldr	r3, .L116
 2965 023a 93F88831 		ldrb	r3, [r3, #392]	@ zero_extendqisi2
 359:Board/v3/board.cpp ****             odrv.misconfigured_ = true;
 2966              		.loc 4 359 72 discriminator 1 view .LVU612
 2967 023e 072B     		cmp	r3, #7
 2968 0240 7FF45BAF 		bne	.L102
 2969 0244 5DE7     		b	.L101
 2970              	.L117:
 2971 0246 00BF     		.align	2
 2972              	.L116:
 2973 0248 00400000 		.word	odrv+16384
 2974 024c 002004E0 		.word	-536600576
 2975 0250 00040240 		.word	1073873920
 2976 0254 00000000 		.word	.LANCHOR17
 2977 0258 00000000 		.word	.LANCHOR18
 2978 025c 00000000 		.word	i2c_stats_
 2979              		.cfi_endproc
 2980              	.LFE5222:
 2981              		.fnend
 2983              		.section	.text.HAL_SPI_TxRxCpltCallback,"ax",%progbits
 2984              		.align	1
 2985              		.p2align 2,,3
 2986              		.global	HAL_SPI_TxRxCpltCallback
 2987              		.syntax unified
 2988              		.thumb
 2989              		.thumb_func
 2991              	HAL_SPI_TxRxCpltCallback:
 2992              		.fnstart
 2993              	.LVL223:
 2994              	.LFB5233:
 464:Board/v3/board.cpp ****     if (hspi == &hspi3) {
 2995              		.loc 4 464 56 is_stmt 1 view -0
 2996              		.cfi_startproc
 2997              		@ args = 0, pretend = 0, frame = 0
 2998              		@ frame_needed = 0, uses_anonymous_args = 0
 464:Board/v3/board.cpp ****     if (hspi == &hspi3) {
 2999              		.loc 4 464 56 is_stmt 0 view .LVU614
 3000 0000 08B5     		push	{r3, lr}
 3001              		.save {r3, lr}
ARM GAS  /tmp/ccysU9ly.s 			page 145


 3002              	.LCFI18:
 3003              		.cfi_def_cfa_offset 8
 3004              		.cfi_offset 3, -8
 3005              		.cfi_offset 14, -4
 465:Board/v3/board.cpp ****         spi3_arbiter.on_complete();
 3006              		.loc 4 465 5 is_stmt 1 view .LVU615
 3007 0002 044B     		ldr	r3, .L122
 3008 0004 8342     		cmp	r3, r0
 3009 0006 00D0     		beq	.L121
 3010              	.LVL224:
 3011              	.L118:
 468:Board/v3/board.cpp **** 
 3012              		.loc 4 468 1 is_stmt 0 view .LVU616
 3013 0008 08BD     		pop	{r3, pc}
 3014              	.LVL225:
 3015              	.L121:
 466:Board/v3/board.cpp ****     }
 3016              		.loc 4 466 9 is_stmt 1 view .LVU617
 466:Board/v3/board.cpp ****     }
 3017              		.loc 4 466 33 is_stmt 0 view .LVU618
 3018 000a 0348     		ldr	r0, .L122+4
 3019              	.LVL226:
 466:Board/v3/board.cpp ****     }
 3020              		.loc 4 466 33 view .LVU619
 3021 000c FFF7FEFF 		bl	_ZN15Stm32SpiArbiter11on_completeEv
 3022              	.LVL227:
 468:Board/v3/board.cpp **** 
 3023              		.loc 4 468 1 view .LVU620
 3024 0010 FAE7     		b	.L118
 3025              	.L123:
 3026 0012 00BF     		.align	2
 3027              	.L122:
 3028 0014 00000000 		.word	hspi3
 3029 0018 00000000 		.word	.LANCHOR6
 3030              		.cfi_endproc
 3031              	.LFE5233:
 3032              		.fnend
 3034              		.section	.text.HAL_SPI_TxCpltCallback,"ax",%progbits
 3035              		.align	1
 3036              		.p2align 2,,3
 3037              		.global	HAL_SPI_TxCpltCallback
 3038              		.syntax unified
 3039              		.thumb
 3040              		.thumb_func
 3042              	HAL_SPI_TxCpltCallback:
 3043              		.fnstart
 3044              	.LVL228:
 3045              	.LFB5231:
 456:Board/v3/board.cpp ****     HAL_SPI_TxRxCpltCallback(hspi);
 3046              		.loc 4 456 54 is_stmt 1 view -0
 3047              		.cfi_startproc
 3048              		@ args = 0, pretend = 0, frame = 0
 3049              		@ frame_needed = 0, uses_anonymous_args = 0
 456:Board/v3/board.cpp ****     HAL_SPI_TxRxCpltCallback(hspi);
 3050              		.loc 4 456 54 is_stmt 0 view .LVU622
 3051 0000 08B5     		push	{r3, lr}
 3052              		.save {r3, lr}
ARM GAS  /tmp/ccysU9ly.s 			page 146


 3053              	.LCFI19:
 3054              		.cfi_def_cfa_offset 8
 3055              		.cfi_offset 3, -8
 3056              		.cfi_offset 14, -4
 457:Board/v3/board.cpp **** }
 3057              		.loc 4 457 5 is_stmt 1 view .LVU623
 457:Board/v3/board.cpp **** }
 3058              		.loc 4 457 29 is_stmt 0 view .LVU624
 3059 0002 FFF7FEFF 		bl	HAL_SPI_TxRxCpltCallback
 3060              	.LVL229:
 458:Board/v3/board.cpp **** 
 3061              		.loc 4 458 1 view .LVU625
 3062 0006 08BD     		pop	{r3, pc}
 3063              		.cfi_endproc
 3064              	.LFE5231:
 3065              		.fnend
 3067              		.section	.text.HAL_SPI_RxCpltCallback,"ax",%progbits
 3068              		.align	1
 3069              		.p2align 2,,3
 3070              		.global	HAL_SPI_RxCpltCallback
 3071              		.syntax unified
 3072              		.thumb
 3073              		.thumb_func
 3075              	HAL_SPI_RxCpltCallback:
 3076              		.fnstart
 3077              	.LVL230:
 3078              	.LFB5232:
 460:Board/v3/board.cpp ****     HAL_SPI_TxRxCpltCallback(hspi);
 3079              		.loc 4 460 54 is_stmt 1 view -0
 3080              		.cfi_startproc
 3081              		@ args = 0, pretend = 0, frame = 0
 3082              		@ frame_needed = 0, uses_anonymous_args = 0
 460:Board/v3/board.cpp ****     HAL_SPI_TxRxCpltCallback(hspi);
 3083              		.loc 4 460 54 is_stmt 0 view .LVU627
 3084 0000 08B5     		push	{r3, lr}
 3085              		.save {r3, lr}
 3086              	.LCFI20:
 3087              		.cfi_def_cfa_offset 8
 3088              		.cfi_offset 3, -8
 3089              		.cfi_offset 14, -4
 461:Board/v3/board.cpp **** }
 3090              		.loc 4 461 5 is_stmt 1 view .LVU628
 461:Board/v3/board.cpp **** }
 3091              		.loc 4 461 29 is_stmt 0 view .LVU629
 3092 0002 FFF7FEFF 		bl	HAL_SPI_TxRxCpltCallback
 3093              	.LVL231:
 462:Board/v3/board.cpp **** 
 3094              		.loc 4 462 1 view .LVU630
 3095 0006 08BD     		pop	{r3, pc}
 3096              		.cfi_endproc
 3097              	.LFE5232:
 3098              		.fnend
 3100              		.section	.text.TIM5_IRQHandler,"ax",%progbits
 3101              		.align	1
 3102              		.p2align 2,,3
 3103              		.global	TIM5_IRQHandler
 3104              		.syntax unified
ARM GAS  /tmp/ccysU9ly.s 			page 147


 3105              		.thumb
 3106              		.thumb_func
 3108              	TIM5_IRQHandler:
 3109              		.fnstart
 3110              	.LFB5234:
 470:Board/v3/board.cpp ****     COUNT_IRQ(TIM5_IRQn);
 3111              		.loc 4 470 28 is_stmt 1 view -0
 3112              		.cfi_startproc
 3113              		@ args = 0, pretend = 0, frame = 0
 3114              		@ frame_needed = 0, uses_anonymous_args = 0
 3115 0000 08B5     		push	{r3, lr}
 3116              		.save {r3, lr}
 3117              	.LCFI21:
 3118              		.cfi_def_cfa_offset 8
 3119              		.cfi_offset 3, -8
 3120              		.cfi_offset 14, -4
 471:Board/v3/board.cpp ****     pwm0_input.on_capture();
 3121              		.loc 4 471 5 view .LVU632
 472:Board/v3/board.cpp **** }
 3122              		.loc 4 472 5 view .LVU633
 472:Board/v3/board.cpp **** }
 3123              		.loc 4 472 26 is_stmt 0 view .LVU634
 3124 0002 0248     		ldr	r0, .L130
 3125 0004 FFF7FEFF 		bl	_ZN8PwmInput10on_captureEv
 3126              	.LVL232:
 473:Board/v3/board.cpp **** 
 3127              		.loc 4 473 1 view .LVU635
 3128 0008 08BD     		pop	{r3, pc}
 3129              	.L131:
 3130 000a 00BF     		.align	2
 3131              	.L130:
 3132 000c 00000000 		.word	.LANCHOR15
 3133              		.cfi_endproc
 3134              	.LFE5234:
 3135              		.fnend
 3137              		.section	.text.TIM8_UP_TIM13_IRQHandler,"ax",%progbits
 3138              		.align	1
 3139              		.p2align 2,,3
 3140              		.global	TIM8_UP_TIM13_IRQHandler
 3141              		.syntax unified
 3142              		.thumb
 3143              		.thumb_func
 3145              	TIM8_UP_TIM13_IRQHandler:
 3146              		.fnstart
 3147              	.LFB5235:
 478:Board/v3/board.cpp ****     COUNT_IRQ(TIM8_UP_TIM13_IRQn);
 3148              		.loc 4 478 37 is_stmt 1 view -0
 3149              		.cfi_startproc
 3150              		@ args = 0, pretend = 0, frame = 0
 3151              		@ frame_needed = 0, uses_anonymous_args = 0
 3152 0000 10B5     		push	{r4, lr}
 3153              		.save {r4, lr}
 3154              	.LCFI22:
 3155              		.cfi_def_cfa_offset 8
 3156              		.cfi_offset 4, -8
 3157              		.cfi_offset 14, -4
 479:Board/v3/board.cpp ****     
ARM GAS  /tmp/ccysU9ly.s 			page 148


 3158              		.loc 4 479 5 view .LVU637
 483:Board/v3/board.cpp **** 
 3159              		.loc 4 483 5 view .LVU638
 3160 0002 214B     		ldr	r3, .L139
 3161 0004 1B68     		ldr	r3, [r3]
 3162 0006 6FF00102 		mvn	r2, #1
 3163 000a 1A61     		str	r2, [r3, #16]
 487:Board/v3/board.cpp **** 
 3164              		.loc 4 487 5 view .LVU639
 487:Board/v3/board.cpp **** 
 3165              		.loc 4 487 32 is_stmt 0 view .LVU640
 3166 000c 1F4B     		ldr	r3, .L139+4
 3167 000e 1B68     		ldr	r3, [r3]
 487:Board/v3/board.cpp **** 
 3168              		.loc 4 487 38 view .LVU641
 3169 0010 03F01001 		and	r1, r3, #16
 3170 0014 C3F30013 		ubfx	r3, r3, #4, #1
 3171              	.LVL233:
 489:Board/v3/board.cpp ****     if (timer_update_missed) {
 3172              		.loc 4 489 5 is_stmt 1 view .LVU642
 489:Board/v3/board.cpp ****     if (timer_update_missed) {
 3173              		.loc 4 489 48 is_stmt 0 view .LVU643
 3174 0018 1D4A     		ldr	r2, .L139+8
 3175 001a 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 3176 001c D2B2     		uxtb	r2, r2
 3177              	.LVL234:
 490:Board/v3/board.cpp ****         motors[0].disarm_with_error(Motor::ERROR_TIMER_UPDATE_MISSED);
 3178              		.loc 4 490 5 is_stmt 1 view .LVU644
 3179 001e 9A42     		cmp	r2, r3
 3180 0020 14D0     		beq	.L137
 495:Board/v3/board.cpp **** 
 3181              		.loc 4 495 5 view .LVU645
 495:Board/v3/board.cpp **** 
 3182              		.loc 4 495 20 is_stmt 0 view .LVU646
 3183 0022 1B4A     		ldr	r2, .L139+8
 3184              	.LVL235:
 495:Board/v3/board.cpp **** 
 3185              		.loc 4 495 20 view .LVU647
 3186 0024 1370     		strb	r3, [r2]
 497:Board/v3/board.cpp **** 
 3187              		.loc 4 497 5 is_stmt 1 view .LVU648
 497:Board/v3/board.cpp **** 
 3188              		.loc 4 497 16 is_stmt 0 view .LVU649
 3189 0026 1B4A     		ldr	r2, .L139+12
 3190 0028 1368     		ldr	r3, [r2]
 3191              	.LVL236:
 497:Board/v3/board.cpp **** 
 3192              		.loc 4 497 16 view .LVU650
 3193 002a 03F52453 		add	r3, r3, #10496
 3194 002e 0433     		adds	r3, r3, #4
 3195 0030 1360     		str	r3, [r2]
 3196              	.LVL237:
 499:Board/v3/board.cpp ****         TaskTimer::enabled = odrv.task_timers_armed_;
 3197              		.loc 4 499 5 is_stmt 1 view .LVU651
 3198 0032 D1B1     		cbz	r1, .L138
 509:Board/v3/board.cpp ****         TIM1->CCR2 =
 3199              		.loc 4 509 9 view .LVU652
ARM GAS  /tmp/ccysU9ly.s 			page 149


 514:Board/v3/board.cpp ****             TIM_1_8_PERIOD_CLOCKS / 2;
 3200              		.loc 4 514 20 is_stmt 0 view .LVU653
 3201 0034 154A     		ldr	r2, .L139+4
 3202 0036 40F2D663 		movw	r3, #1750
 3203 003a D363     		str	r3, [r2, #60]
 513:Board/v3/board.cpp ****         TIM8->CCR3 =
 3204              		.loc 4 513 20 view .LVU654
 3205 003c 9363     		str	r3, [r2, #56]
 512:Board/v3/board.cpp ****         TIM8->CCR2 =
 3206              		.loc 4 512 20 view .LVU655
 3207 003e 5363     		str	r3, [r2, #52]
 511:Board/v3/board.cpp ****         TIM8->CCR1 =
 3208              		.loc 4 511 20 view .LVU656
 3209 0040 A2F58062 		sub	r2, r2, #1024
 3210 0044 D363     		str	r3, [r2, #60]
 510:Board/v3/board.cpp ****         TIM1->CCR3 =
 3211              		.loc 4 510 20 view .LVU657
 3212 0046 9363     		str	r3, [r2, #56]
 509:Board/v3/board.cpp ****         TIM1->CCR2 =
 3213              		.loc 4 509 20 view .LVU658
 3214 0048 5363     		str	r3, [r2, #52]
 3215              	.L132:
 517:Board/v3/board.cpp **** 
 3216              		.loc 4 517 1 view .LVU659
 3217 004a 10BD     		pop	{r4, pc}
 3218              	.LVL238:
 3219              	.L137:
 491:Board/v3/board.cpp ****         motors[1].disarm_with_error(Motor::ERROR_TIMER_UPDATE_MISSED);
 3220              		.loc 4 491 9 is_stmt 1 view .LVU660
 491:Board/v3/board.cpp ****         motors[1].disarm_with_error(Motor::ERROR_TIMER_UPDATE_MISSED);
 3221              		.loc 4 491 36 is_stmt 0 view .LVU661
 3222 004c 124C     		ldr	r4, .L139+16
 3223 004e 4FF40022 		mov	r2, #524288
 3224              	.LVL239:
 491:Board/v3/board.cpp ****         motors[1].disarm_with_error(Motor::ERROR_TIMER_UPDATE_MISSED);
 3225              		.loc 4 491 36 view .LVU662
 3226 0052 0023     		movs	r3, #0
 3227              	.LVL240:
 491:Board/v3/board.cpp ****         motors[1].disarm_with_error(Motor::ERROR_TIMER_UPDATE_MISSED);
 3228              		.loc 4 491 36 view .LVU663
 3229 0054 2046     		mov	r0, r4
 3230 0056 FFF7FEFF 		bl	_ZN5Motor17disarm_with_errorEN10ODriveIntf9MotorIntf5ErrorE
 3231              	.LVL241:
 492:Board/v3/board.cpp ****         return;
 3232              		.loc 4 492 9 is_stmt 1 view .LVU664
 492:Board/v3/board.cpp ****         return;
 3233              		.loc 4 492 36 is_stmt 0 view .LVU665
 3234 005a 4FF40022 		mov	r2, #524288
 3235 005e 0023     		movs	r3, #0
 3236 0060 04F5D870 		add	r0, r4, #432
 3237 0064 FFF7FEFF 		bl	_ZN5Motor17disarm_with_errorEN10ODriveIntf9MotorIntf5ErrorE
 3238              	.LVL242:
 493:Board/v3/board.cpp ****     }
 3239              		.loc 4 493 9 is_stmt 1 view .LVU666
 3240 0068 EFE7     		b	.L132
 3241              	.L138:
 500:Board/v3/board.cpp ****         // Run sampling handlers and kick off control tasks when TIM8 is
ARM GAS  /tmp/ccysU9ly.s 			page 150


 3242              		.loc 4 500 9 view .LVU667
 500:Board/v3/board.cpp ****         // Run sampling handlers and kick off control tasks when TIM8 is
 3243              		.loc 4 500 35 is_stmt 0 view .LVU668
 3244 006a 0C48     		ldr	r0, .L139+20
 3245 006c 00F58043 		add	r3, r0, #16384
 3246 0070 93F8E022 		ldrb	r2, [r3, #736]	@ zero_extendqisi2
 500:Board/v3/board.cpp ****         // Run sampling handlers and kick off control tasks when TIM8 is
 3247              		.loc 4 500 28 view .LVU669
 3248 0074 0A4B     		ldr	r3, .L139+24
 3249 0076 1A70     		strb	r2, [r3]
 503:Board/v3/board.cpp ****         NVIC->STIR = ControlLoop_IRQn;
 3250              		.loc 4 503 9 is_stmt 1 view .LVU670
 503:Board/v3/board.cpp ****         NVIC->STIR = ControlLoop_IRQn;
 3251              		.loc 4 503 25 is_stmt 0 view .LVU671
 3252 0078 FFF7FEFF 		bl	_ZN6ODrive11sampling_cbEv
 3253              	.LVL243:
 504:Board/v3/board.cpp ****     } else {
 3254              		.loc 4 504 9 is_stmt 1 view .LVU672
 504:Board/v3/board.cpp ****     } else {
 3255              		.loc 4 504 20 is_stmt 0 view .LVU673
 3256 007c 094B     		ldr	r3, .L139+28
 3257 007e 4D22     		movs	r2, #77
 3258 0080 C3F8002E 		str	r2, [r3, #3584]
 3259 0084 E1E7     		b	.L132
 3260              	.L140:
 3261 0086 00BF     		.align	2
 3262              	.L139:
 3263 0088 00000000 		.word	htim8
 3264 008c 00040140 		.word	1073808384
 3265 0090 00000000 		.word	.LANCHOR19
 3266 0094 00000000 		.word	.LANCHOR20
 3267 0098 00000000 		.word	.LANCHOR10
 3268 009c 00000000 		.word	odrv
 3269 00a0 00000000 		.word	.LANCHOR21
 3270 00a4 00E100E0 		.word	-536813312
 3271              		.cfi_endproc
 3272              	.LFE5235:
 3273              		.fnend
 3275              		.section	.text.OTG_HS_IRQHandler,"ax",%progbits
 3276              		.align	1
 3277              		.p2align 2,,3
 3278              		.global	OTG_HS_IRQHandler
 3279              		.syntax unified
 3280              		.thumb
 3281              		.thumb_func
 3283              	OTG_HS_IRQHandler:
 3284              		.fnstart
 3285              	.LFB5236:
 519:Board/v3/board.cpp ****     COUNT_IRQ(ControlLoop_IRQn);
 3286              		.loc 4 519 35 is_stmt 1 view -0
 3287              		.cfi_startproc
 3288              		@ args = 0, pretend = 0, frame = 72
 3289              		@ frame_needed = 0, uses_anonymous_args = 0
 3290 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 3291              		.save {r4, r5, r6, r7, lr}
 3292              	.LCFI23:
 3293              		.cfi_def_cfa_offset 20
ARM GAS  /tmp/ccysU9ly.s 			page 151


 3294              		.cfi_offset 4, -20
 3295              		.cfi_offset 5, -16
 3296              		.cfi_offset 6, -12
 3297              		.cfi_offset 7, -8
 3298              		.cfi_offset 14, -4
 3299              		.pad #84
 3300 0002 95B0     		sub	sp, sp, #84
 3301              	.LCFI24:
 3302              		.cfi_def_cfa_offset 104
 520:Board/v3/board.cpp ****     uint32_t timestamp = timestamp_;
 3303              		.loc 4 520 5 view .LVU675
 521:Board/v3/board.cpp **** 
 3304              		.loc 4 521 5 view .LVU676
 521:Board/v3/board.cpp **** 
 3305              		.loc 4 521 26 is_stmt 0 view .LVU677
 3306 0004 814B     		ldr	r3, .L165
 3307 0006 1C68     		ldr	r4, [r3]
 3308              	.LVL244:
 524:Board/v3/board.cpp ****     std::optional<Iph_ABC_t> current1;
 3309              		.loc 4 524 5 is_stmt 1 view .LVU678
 524:Board/v3/board.cpp ****     std::optional<Iph_ABC_t> current1;
 3310              		.loc 4 524 30 is_stmt 0 view .LVU679
 3311 0008 0023     		movs	r3, #0
 3312 000a 0A93     		str	r3, [sp, #40]
 3313 000c 0B93     		str	r3, [sp, #44]
 3314 000e 0C93     		str	r3, [sp, #48]
 3315 0010 0D93     		str	r3, [sp, #52]
 525:Board/v3/board.cpp **** 
 3316              		.loc 4 525 5 is_stmt 1 view .LVU680
 525:Board/v3/board.cpp **** 
 3317              		.loc 4 525 30 is_stmt 0 view .LVU681
 3318 0012 0693     		str	r3, [sp, #24]
 3319 0014 0793     		str	r3, [sp, #28]
 3320 0016 0893     		str	r3, [sp, #32]
 3321 0018 0993     		str	r3, [sp, #36]
 527:Board/v3/board.cpp ****         motors[0].disarm_with_error(Motor::ERROR_BAD_TIMING);
 3322              		.loc 4 527 5 is_stmt 1 view .LVU682
 527:Board/v3/board.cpp ****         motors[0].disarm_with_error(Motor::ERROR_BAD_TIMING);
 3323              		.loc 4 527 30 is_stmt 0 view .LVU683
 3324 001a 06A9     		add	r1, sp, #24
 3325 001c 0AA8     		add	r0, sp, #40
 3326 001e FFF7FEFF 		bl	_ZL20fetch_and_reset_adcsPSt8optionalI9Iph_ABC_tES2_
 3327              	.LVL245:
 527:Board/v3/board.cpp ****         motors[0].disarm_with_error(Motor::ERROR_BAD_TIMING);
 3328              		.loc 4 527 5 view .LVU684
 3329 0022 0028     		cmp	r0, #0
 3330 0024 3DD0     		beq	.L160
 3331              	.L142:
 537:Board/v3/board.cpp ****         current0 = {0.0f, 0.0f};
 3332              		.loc 4 537 5 is_stmt 1 view .LVU685
 537:Board/v3/board.cpp ****         current0 = {0.0f, 0.0f};
 3333              		.loc 4 537 17 is_stmt 0 view .LVU686
 3334 0026 7A4B     		ldr	r3, .L165+4
 3335 0028 5B6C     		ldr	r3, [r3, #68]
 537:Board/v3/board.cpp ****         current0 = {0.0f, 0.0f};
 3336              		.loc 4 537 5 view .LVU687
 3337 002a 13F4004F 		tst	r3, #32768
ARM GAS  /tmp/ccysU9ly.s 			page 152


 3338 002e 47D0     		beq	.L161
 3339              	.L143:
 540:Board/v3/board.cpp ****         current1 = {0.0f, 0.0f};
 3340              		.loc 4 540 5 is_stmt 1 view .LVU688
 540:Board/v3/board.cpp ****         current1 = {0.0f, 0.0f};
 3341              		.loc 4 540 17 is_stmt 0 view .LVU689
 3342 0030 784B     		ldr	r3, .L165+8
 3343 0032 5B6C     		ldr	r3, [r3, #68]
 540:Board/v3/board.cpp ****         current1 = {0.0f, 0.0f};
 3344              		.loc 4 540 5 view .LVU690
 3345 0034 13F4004F 		tst	r3, #32768
 3346 0038 56D0     		beq	.L162
 3347              	.L146:
 544:Board/v3/board.cpp ****     motors[1].current_meas_cb(timestamp, current1);
 3348              		.loc 4 544 5 is_stmt 1 view .LVU691
 544:Board/v3/board.cpp ****     motors[1].current_meas_cb(timestamp, current1);
 3349              		.loc 4 544 30 is_stmt 0 view .LVU692
 3350 003a 774D     		ldr	r5, .L165+12
 3351 003c 0CAB     		add	r3, sp, #48
 3352 003e 93E80300 		ldm	r3, {r0, r1}
 3353 0042 8DE80300 		stm	sp, {r0, r1}
 3354 0046 0AAB     		add	r3, sp, #40
 3355 0048 0CCB     		ldm	r3, {r2, r3}
 3356 004a A4F25661 		subw	r1, r4, #1622
 3357 004e 2846     		mov	r0, r5
 3358 0050 FFF7FEFF 		bl	_ZN5Motor15current_meas_cbEmSt8optionalI9Iph_ABC_tE
 3359              	.LVL246:
 545:Board/v3/board.cpp **** 
 3360              		.loc 4 545 5 is_stmt 1 view .LVU693
 545:Board/v3/board.cpp **** 
 3361              		.loc 4 545 30 is_stmt 0 view .LVU694
 3362 0054 08AB     		add	r3, sp, #32
 3363 0056 93E80300 		ldm	r3, {r0, r1}
 3364 005a 8DE80300 		stm	sp, {r0, r1}
 3365 005e 06AB     		add	r3, sp, #24
 3366 0060 0CCB     		ldm	r3, {r2, r3}
 3367 0062 2146     		mov	r1, r4
 3368 0064 05F5D870 		add	r0, r5, #432
 3369 0068 FFF7FEFF 		bl	_ZN5Motor15current_meas_cbEmSt8optionalI9Iph_ABC_tE
 3370              	.LVL247:
 547:Board/v3/board.cpp **** 
 3371              		.loc 4 547 5 is_stmt 1 view .LVU695
 547:Board/v3/board.cpp **** 
 3372              		.loc 4 547 25 is_stmt 0 view .LVU696
 3373 006c 2146     		mov	r1, r4
 3374 006e 6B48     		ldr	r0, .L165+16
 3375 0070 FFF7FEFF 		bl	_ZN6ODrive15control_loop_cbEm
 3376              	.LVL248:
 551:Board/v3/board.cpp ****         while (!(ADC2->SR & ADC_SR_EOC));
 3377              		.loc 4 551 5 is_stmt 1 view .LVU697
 3378              	.LBB1055:
 3379              	.LBB1056:
 3380              	.LBI1056:
 3381              		.file 19 "MotorControl/task_timer.hpp"
   1:MotorControl/task_timer.hpp **** #ifndef __TASK_TIMER_HPP
   2:MotorControl/task_timer.hpp **** #define __TASK_TIMER_HPP
   3:MotorControl/task_timer.hpp **** 
ARM GAS  /tmp/ccysU9ly.s 			page 153


   4:MotorControl/task_timer.hpp **** #include <stdint.h>
   5:MotorControl/task_timer.hpp **** #include <board.h>
   6:MotorControl/task_timer.hpp **** 
   7:MotorControl/task_timer.hpp **** #define MEASURE_START_TIME
   8:MotorControl/task_timer.hpp **** #define MEASURE_END_TIME
   9:MotorControl/task_timer.hpp **** #define MEASURE_LENGTH
  10:MotorControl/task_timer.hpp **** #define MEASURE_MAX_LENGTH
  11:MotorControl/task_timer.hpp **** 
  12:MotorControl/task_timer.hpp **** inline uint16_t sample_TIM13() {
  13:MotorControl/task_timer.hpp ****     constexpr uint16_t clocks_per_cnt = (uint16_t)((float)TIM_1_8_CLOCK_HZ / (float)TIM_APB1_CLOCK_
  14:MotorControl/task_timer.hpp ****     return clocks_per_cnt * TIM13->CNT;  // TODO: Use a hw_config
  15:MotorControl/task_timer.hpp **** }
  16:MotorControl/task_timer.hpp **** 
  17:MotorControl/task_timer.hpp **** struct TaskTimer {
  18:MotorControl/task_timer.hpp ****     uint32_t start_time_ = 0;
  19:MotorControl/task_timer.hpp ****     uint32_t end_time_ = 0;
  20:MotorControl/task_timer.hpp ****     uint32_t length_ = 0;
  21:MotorControl/task_timer.hpp ****     uint32_t max_length_ = 0;
  22:MotorControl/task_timer.hpp **** 
  23:MotorControl/task_timer.hpp ****     static bool enabled;
  24:MotorControl/task_timer.hpp **** 
  25:MotorControl/task_timer.hpp ****     uint32_t start() {
  26:MotorControl/task_timer.hpp ****         return sample_TIM13();
  27:MotorControl/task_timer.hpp ****     }
  28:MotorControl/task_timer.hpp **** 
  29:MotorControl/task_timer.hpp ****     void stop(uint32_t start_time) {
  30:MotorControl/task_timer.hpp ****         uint32_t end_time = sample_TIM13();
  31:MotorControl/task_timer.hpp ****         uint32_t length = end_time - start_time;
  32:MotorControl/task_timer.hpp **** 
  33:MotorControl/task_timer.hpp ****         if (enabled) {
  34:MotorControl/task_timer.hpp **** #ifdef MEASURE_START_TIME
  35:MotorControl/task_timer.hpp ****             start_time_ = start_time;
  36:MotorControl/task_timer.hpp **** #endif
  37:MotorControl/task_timer.hpp **** #ifdef MEASURE_END_TIME
  38:MotorControl/task_timer.hpp ****             end_time_ = end_time;
  39:MotorControl/task_timer.hpp **** #endif
  40:MotorControl/task_timer.hpp **** #ifdef MEASURE_LENGTH
  41:MotorControl/task_timer.hpp ****             length_ = length;
  42:MotorControl/task_timer.hpp **** #endif
  43:MotorControl/task_timer.hpp ****         }
  44:MotorControl/task_timer.hpp **** #ifdef MEASURE_MAX_LENGTH
  45:MotorControl/task_timer.hpp ****         max_length_ = std::max(max_length_, length);
  46:MotorControl/task_timer.hpp **** #endif
  47:MotorControl/task_timer.hpp ****     }
  48:MotorControl/task_timer.hpp **** };
  49:MotorControl/task_timer.hpp **** 
  50:MotorControl/task_timer.hpp **** struct TaskTimerContext {
  51:MotorControl/task_timer.hpp ****     TaskTimerContext(const TaskTimerContext&) = delete;
  52:MotorControl/task_timer.hpp ****     TaskTimerContext(const TaskTimerContext&&) = delete;
  53:MotorControl/task_timer.hpp ****     void operator=(const TaskTimerContext&) = delete;
  54:MotorControl/task_timer.hpp ****     void operator=(const TaskTimerContext&&) = delete;
  55:MotorControl/task_timer.hpp ****     TaskTimerContext(TaskTimer& timer) : timer_(timer), start_time(timer.start()) {}
 3382              		.loc 19 55 5 view .LVU698
 3383              	.LBB1057:
 3384              	.LBB1058:
 3385              		.loc 19 55 81 is_stmt 0 view .LVU699
 3386 0074 6A4B     		ldr	r3, .L165+20
ARM GAS  /tmp/ccysU9ly.s 			page 154


 3387              	.LVL249:
 3388              		.loc 19 55 81 view .LVU700
 3389 0076 0393     		str	r3, [sp, #12]
 3390              	.LVL250:
 3391              	.LBB1059:
 3392              	.LBI1059:
  25:MotorControl/task_timer.hpp ****         return sample_TIM13();
 3393              		.loc 19 25 14 is_stmt 1 view .LVU701
 3394              	.LBB1060:
  26:MotorControl/task_timer.hpp ****     }
 3395              		.loc 19 26 9 view .LVU702
 3396              	.LBB1061:
 3397              	.LBI1061:
  12:MotorControl/task_timer.hpp ****     constexpr uint16_t clocks_per_cnt = (uint16_t)((float)TIM_1_8_CLOCK_HZ / (float)TIM_APB1_CLOCK_
 3398              		.loc 19 12 17 view .LVU703
 3399              	.LBB1062:
  13:MotorControl/task_timer.hpp ****     return clocks_per_cnt * TIM13->CNT;  // TODO: Use a hw_config
 3400              		.loc 19 13 5 view .LVU704
  14:MotorControl/task_timer.hpp **** }
 3401              		.loc 19 14 5 view .LVU705
  14:MotorControl/task_timer.hpp **** }
 3402              		.loc 19 14 36 is_stmt 0 view .LVU706
 3403 0078 6A4B     		ldr	r3, .L165+24
 3404              	.LVL251:
  14:MotorControl/task_timer.hpp **** }
 3405              		.loc 19 14 36 view .LVU707
 3406 007a 5A6A     		ldr	r2, [r3, #36]
 3407 007c 5200     		lsls	r2, r2, #1
 3408 007e 92B2     		uxth	r2, r2
 3409              	.LVL252:
  14:MotorControl/task_timer.hpp **** }
 3410              		.loc 19 14 36 view .LVU708
 3411              	.LBE1062:
 3412              	.LBE1061:
 3413              	.LBE1060:
 3414              	.LBE1059:
 3415              		.loc 19 55 81 view .LVU709
 3416 0080 0492     		str	r2, [sp, #16]
 3417 0082 0023     		movs	r3, #0
 3418 0084 8DF81430 		strb	r3, [sp, #20]
 3419              	.LVL253:
 3420              	.L151:
 3421              		.loc 19 55 81 view .LVU710
 3422              	.LBE1058:
 3423              	.LBE1057:
 3424              	.LBE1056:
 551:Board/v3/board.cpp ****         while (!(ADC2->SR & ADC_SR_EOC));
 3425              		.loc 4 551 5 is_stmt 1 discriminator 1 view .LVU711
 3426 0088 9DF81430 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 3427 008c 002B     		cmp	r3, #0
 3428 008e 3FD1     		bne	.L149
 3429              	.L150:
 552:Board/v3/board.cpp ****     }
 3430              		.loc 4 552 9 view .LVU712
 552:Board/v3/board.cpp ****     }
 3431              		.loc 4 552 16 view .LVU713
 552:Board/v3/board.cpp ****     }
ARM GAS  /tmp/ccysU9ly.s 			page 155


 3432              		.loc 4 552 24 is_stmt 0 view .LVU714
 3433 0090 654B     		ldr	r3, .L165+28
 3434 0092 1B68     		ldr	r3, [r3]
 552:Board/v3/board.cpp ****     }
 3435              		.loc 4 552 16 view .LVU715
 3436 0094 13F0020F 		tst	r3, #2
 3437 0098 FAD0     		beq	.L150
 551:Board/v3/board.cpp ****         while (!(ADC2->SR & ADC_SR_EOC));
 3438              		.loc 4 551 5 is_stmt 1 discriminator 3 view .LVU716
 3439 009a 0123     		movs	r3, #1
 3440 009c 8DF81430 		strb	r3, [sp, #20]
 3441 00a0 F2E7     		b	.L151
 3442              	.LVL254:
 3443              	.L160:
 551:Board/v3/board.cpp ****         while (!(ADC2->SR & ADC_SR_EOC));
 3444              		.loc 4 551 5 is_stmt 0 discriminator 3 view .LVU717
 3445              	.LBE1055:
 528:Board/v3/board.cpp ****         motors[1].disarm_with_error(Motor::ERROR_BAD_TIMING);
 3446              		.loc 4 528 9 is_stmt 1 view .LVU718
 528:Board/v3/board.cpp ****         motors[1].disarm_with_error(Motor::ERROR_BAD_TIMING);
 3447              		.loc 4 528 36 is_stmt 0 view .LVU719
 3448 00a2 5D4D     		ldr	r5, .L165+12
 3449 00a4 4FF00072 		mov	r2, #33554432
 3450 00a8 0023     		movs	r3, #0
 3451 00aa 2846     		mov	r0, r5
 3452 00ac FFF7FEFF 		bl	_ZN5Motor17disarm_with_errorEN10ODriveIntf9MotorIntf5ErrorE
 3453              	.LVL255:
 529:Board/v3/board.cpp ****     }
 3454              		.loc 4 529 9 is_stmt 1 view .LVU720
 529:Board/v3/board.cpp ****     }
 3455              		.loc 4 529 36 is_stmt 0 view .LVU721
 3456 00b0 4FF00072 		mov	r2, #33554432
 3457 00b4 0023     		movs	r3, #0
 3458 00b6 05F5D870 		add	r0, r5, #432
 3459 00ba FFF7FEFF 		bl	_ZN5Motor17disarm_with_errorEN10ODriveIntf9MotorIntf5ErrorE
 3460              	.LVL256:
 3461 00be B2E7     		b	.L142
 3462              	.L161:
 538:Board/v3/board.cpp ****     }
 3463              		.loc 4 538 9 is_stmt 1 view .LVU722
 538:Board/v3/board.cpp ****     }
 3464              		.loc 4 538 31 is_stmt 0 view .LVU723
 3465 00c0 0023     		movs	r3, #0
 3466 00c2 0E93     		str	r3, [sp, #56]
 3467 00c4 0F93     		str	r3, [sp, #60]
 3468 00c6 1093     		str	r3, [sp, #64]
 3469              	.LVL257:
 3470              	.LBB1077:
 3471              	.LBI1077:
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 3472              		.loc 17 788 2 is_stmt 1 view .LVU724
 3473              	.LBB1078:
 3474              	.LBB1079:
 3475              	.LBI1079:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 3476              		.loc 17 433 22 view .LVU725
 3477              	.LBB1080:
ARM GAS  /tmp/ccysU9ly.s 			page 156


 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3478              		.loc 17 434 58 is_stmt 0 view .LVU726
 3479 00c8 9DF83430 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 3480              	.LVL258:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3481              		.loc 17 434 58 view .LVU727
 3482              	.LBE1080:
 3483              	.LBE1079:
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_get() = std::forward<_Up>(__u);
 3484              		.loc 17 790 4 view .LVU728
 3485 00cc 23B1     		cbz	r3, .L144
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 3486              		.loc 17 791 6 view .LVU729
 3487 00ce 0023     		movs	r3, #0
 3488 00d0 0A93     		str	r3, [sp, #40]
 3489 00d2 0B93     		str	r3, [sp, #44]
 3490 00d4 0C93     		str	r3, [sp, #48]
 3491 00d6 ABE7     		b	.L143
 3492              	.L144:
 3493              	.LVL259:
 3494              	.LBB1081:
 3495              	.LBI1081:
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 3496              		.loc 17 415 2 is_stmt 1 view .LVU730
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 3497              		.loc 17 415 2 is_stmt 0 view .LVU731
 3498              	.LBE1081:
 3499              	.LBE1078:
 3500              	.LBE1077:
 3501              		.loc 18 175 3 is_stmt 1 view .LVU732
 3502              	.LBB1085:
 3503              	.LBB1084:
 3504              	.LBB1083:
 3505              	.LBB1082:
 3506              		.loc 18 175 3 is_stmt 0 view .LVU733
 3507 00d8 0023     		movs	r3, #0
 3508 00da 0A93     		str	r3, [sp, #40]
 3509 00dc 0B93     		str	r3, [sp, #44]
 3510 00de 0C93     		str	r3, [sp, #48]
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 3511              		.loc 17 421 51 view .LVU734
 3512 00e0 0123     		movs	r3, #1
 3513 00e2 8DF83430 		strb	r3, [sp, #52]
 3514              	.LVL260:
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3515              		.loc 17 422 2 view .LVU735
 3516 00e6 A3E7     		b	.L143
 3517              	.L162:
 3518              	.LBE1082:
 3519              	.LBE1083:
 3520              	.LBE1084:
 3521              	.LBE1085:
 541:Board/v3/board.cpp ****     }
 3522              		.loc 4 541 9 is_stmt 1 view .LVU736
 541:Board/v3/board.cpp ****     }
 3523              		.loc 4 541 31 is_stmt 0 view .LVU737
 3524 00e8 0023     		movs	r3, #0
ARM GAS  /tmp/ccysU9ly.s 			page 157


 3525 00ea 1193     		str	r3, [sp, #68]
 3526 00ec 1293     		str	r3, [sp, #72]
 3527 00ee 1393     		str	r3, [sp, #76]
 3528              	.LVL261:
 3529              	.LBB1086:
 3530              	.LBI1086:
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 3531              		.loc 17 788 2 is_stmt 1 view .LVU738
 3532              	.LBB1087:
 3533              	.LBB1088:
 3534              	.LBI1088:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 3535              		.loc 17 433 22 view .LVU739
 3536              	.LBB1089:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3537              		.loc 17 434 58 is_stmt 0 view .LVU740
 3538 00f0 9DF82430 		ldrb	r3, [sp, #36]	@ zero_extendqisi2
 3539              	.LVL262:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3540              		.loc 17 434 58 view .LVU741
 3541              	.LBE1089:
 3542              	.LBE1088:
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_get() = std::forward<_Up>(__u);
 3543              		.loc 17 790 4 view .LVU742
 3544 00f4 23B1     		cbz	r3, .L147
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 3545              		.loc 17 791 6 view .LVU743
 3546 00f6 0023     		movs	r3, #0
 3547 00f8 0693     		str	r3, [sp, #24]
 3548 00fa 0793     		str	r3, [sp, #28]
 3549 00fc 0893     		str	r3, [sp, #32]
 3550 00fe 9CE7     		b	.L146
 3551              	.L147:
 3552              	.LVL263:
 3553              	.LBB1090:
 3554              	.LBI1090:
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 3555              		.loc 17 415 2 is_stmt 1 view .LVU744
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 3556              		.loc 17 415 2 is_stmt 0 view .LVU745
 3557              	.LBE1090:
 3558              	.LBE1087:
 3559              	.LBE1086:
 3560              		.loc 18 175 3 is_stmt 1 view .LVU746
 3561              	.LBB1094:
 3562              	.LBB1093:
 3563              	.LBB1092:
 3564              	.LBB1091:
 3565              		.loc 18 175 3 is_stmt 0 view .LVU747
 3566 0100 0023     		movs	r3, #0
 3567 0102 0693     		str	r3, [sp, #24]
 3568 0104 0793     		str	r3, [sp, #28]
 3569 0106 0893     		str	r3, [sp, #32]
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 3570              		.loc 17 421 51 view .LVU748
 3571 0108 0123     		movs	r3, #1
 3572 010a 8DF82430 		strb	r3, [sp, #36]
ARM GAS  /tmp/ccysU9ly.s 			page 158


 3573              	.LVL264:
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3574              		.loc 17 422 2 view .LVU749
 3575 010e 94E7     		b	.L146
 3576              	.LVL265:
 3577              	.L149:
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3578              		.loc 17 422 2 view .LVU750
 3579              	.LBE1091:
 3580              	.LBE1092:
 3581              	.LBE1093:
 3582              	.LBE1094:
 3583              	.LBB1095:
 3584              	.LBB1063:
 3585              	.LBI1063:
  56:MotorControl/task_timer.hpp ****     ~TaskTimerContext() { timer_.stop(start_time); }
 3586              		.loc 19 56 5 is_stmt 1 view .LVU751
 3587              	.LBB1064:
 3588              		.loc 19 56 27 view .LVU752
 3589              	.LBB1065:
 3590              	.LBI1065:
  29:MotorControl/task_timer.hpp ****         uint32_t end_time = sample_TIM13();
 3591              		.loc 19 29 10 view .LVU753
 3592              	.LBB1066:
  30:MotorControl/task_timer.hpp ****         uint32_t length = end_time - start_time;
 3593              		.loc 19 30 9 view .LVU754
 3594              	.LBB1067:
 3595              	.LBI1067:
  12:MotorControl/task_timer.hpp ****     constexpr uint16_t clocks_per_cnt = (uint16_t)((float)TIM_1_8_CLOCK_HZ / (float)TIM_APB1_CLOCK_
 3596              		.loc 19 12 17 view .LVU755
 3597              	.LBB1068:
  13:MotorControl/task_timer.hpp ****     return clocks_per_cnt * TIM13->CNT;  // TODO: Use a hw_config
 3598              		.loc 19 13 5 view .LVU756
  14:MotorControl/task_timer.hpp **** }
 3599              		.loc 19 14 5 view .LVU757
  14:MotorControl/task_timer.hpp **** }
 3600              		.loc 19 14 36 is_stmt 0 view .LVU758
 3601 0110 444B     		ldr	r3, .L165+24
 3602 0112 5B6A     		ldr	r3, [r3, #36]
 3603 0114 5B00     		lsls	r3, r3, #1
 3604 0116 9BB2     		uxth	r3, r3
 3605              	.LVL266:
  14:MotorControl/task_timer.hpp **** }
 3606              		.loc 19 14 36 view .LVU759
 3607              	.LBE1068:
 3608              	.LBE1067:
  31:MotorControl/task_timer.hpp **** 
 3609              		.loc 19 31 9 is_stmt 1 view .LVU760
  31:MotorControl/task_timer.hpp **** 
 3610              		.loc 19 31 36 is_stmt 0 view .LVU761
 3611 0118 991A     		subs	r1, r3, r2
  31:MotorControl/task_timer.hpp **** 
 3612              		.loc 19 31 18 view .LVU762
 3613 011a 0291     		str	r1, [sp, #8]
  33:MotorControl/task_timer.hpp **** #ifdef MEASURE_START_TIME
 3614              		.loc 19 33 9 is_stmt 1 view .LVU763
 3615 011c 4349     		ldr	r1, .L165+32
ARM GAS  /tmp/ccysU9ly.s 			page 159


 3616 011e 0978     		ldrb	r1, [r1]	@ zero_extendqisi2
 3617 0120 39B1     		cbz	r1, .L152
  35:MotorControl/task_timer.hpp **** #endif
 3618              		.loc 19 35 13 view .LVU764
  35:MotorControl/task_timer.hpp **** #endif
 3619              		.loc 19 35 25 is_stmt 0 view .LVU765
 3620 0122 4349     		ldr	r1, .L165+36
 3621 0124 C1F81423 		str	r2, [r1, #788]
  38:MotorControl/task_timer.hpp **** #endif
 3622              		.loc 19 38 13 is_stmt 1 view .LVU766
  38:MotorControl/task_timer.hpp **** #endif
 3623              		.loc 19 38 23 is_stmt 0 view .LVU767
 3624 0128 C1F81833 		str	r3, [r1, #792]
  41:MotorControl/task_timer.hpp **** #endif
 3625              		.loc 19 41 13 is_stmt 1 view .LVU768
  41:MotorControl/task_timer.hpp **** #endif
 3626              		.loc 19 41 21 is_stmt 0 view .LVU769
 3627 012c 029B     		ldr	r3, [sp, #8]
 3628              	.LVL267:
  41:MotorControl/task_timer.hpp **** #endif
 3629              		.loc 19 41 21 view .LVU770
 3630 012e C1F81C33 		str	r3, [r1, #796]
 3631              	.LVL268:
 3632              	.L152:
  45:MotorControl/task_timer.hpp **** #endif
 3633              		.loc 19 45 9 is_stmt 1 view .LVU771
 3634              	.LBB1069:
 3635              	.LBI1069:
 3636              		.file 20 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Core algorithmic facilities -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Copyright (C) 2001-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** /*
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Copyright (c) 1994
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Hewlett-Packard Company
ARM GAS  /tmp/ccysU9ly.s 			page 160


  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Permission to use, copy, modify, distribute and sell this software
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * and its documentation for any purpose is hereby granted without fee,
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * provided that the above copyright notice appear in all copies and
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * that both that copyright notice and this permission notice appear
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * in supporting documentation.  Hewlett-Packard Company makes no
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * representations about the suitability of this software for any
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Copyright (c) 1996-1998
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Silicon Graphics Computer Systems, Inc.
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Permission to use, copy, modify, distribute and sell this software
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * and its documentation for any purpose is hereby granted without fee,
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * provided that the above copyright notice appear in all copies and
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * that both that copyright notice and this permission notice appear
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * in supporting documentation.  Silicon Graphics makes no
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * representations about the suitability of this software for any
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  */
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** /** @file bits/stl_algobase.h
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *  This is an internal header file, included by other library headers.
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *  Do not attempt to use it directly. @headername{algorithm}
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  */
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #ifndef _STL_ALGOBASE_H
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #define _STL_ALGOBASE_H 1
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/c++config.h>
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/functexcept.h>
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/cpp_type_traits.h>
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <ext/type_traits.h>
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <ext/numeric_traits.h>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_pair.h>
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator_base_types.h>
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator_base_funcs.h>
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator.h>
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/concept_check.h>
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <debug/debug.h>
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/move.h> // For std::swap
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/predefined_ops.h>
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** # include <type_traits>
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus > 201703L
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** # include <compare>
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** namespace std _GLIBCXX_VISIBILITY(default)
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** {
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /*
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    * A constexpr wrapper for __builtin_memcmp.
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    * @param __num The number of elements of type _Tp (not bytes).
ARM GAS  /tmp/ccysU9ly.s 			page 161


  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    */
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp, typename _Up>
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline int
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #ifdef __cpp_lib_is_constant_evaluated
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (std::is_constant_evaluated())
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  for(; __num > 0; ++__first1, ++__first2, --__num)
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    if (*__first1 != *__first2)
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      return *__first1 < *__first2 ? -1 : 1;
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return 0;
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       else
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus < 201103L
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // nutshell, we are partially implementing the resolution of DR 187,
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // when it's safe, i.e., the value_types are equal.
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _BoolType>
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __iter_swap
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _ForwardIterator1, typename _ForwardIterator2>
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static void
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  typedef typename iterator_traits<_ForwardIterator1>::value_type
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    _ValueType1;
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  _ValueType1 __tmp = *__a;
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  *__a = *__b;
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  *__b = __tmp;
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<>
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __iter_swap<true>
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _ForwardIterator1, typename _ForwardIterator2>
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static void
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  swap(*__a, *__b);
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif // C++03
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Swaps the contents of two iterators.
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  An iterator.
ARM GAS  /tmp/ccysU9ly.s 			page 162


 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another iterator.
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   Nothing.
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This function swaps the values pointed to by two iterators, not the
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  iterators themselves.
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2>
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline void
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator1>)
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator2>)
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus < 201103L
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator1>::value_type
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ValueType1;
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator2>::value_type
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ValueType2;
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ValueType2>)
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ValueType1>)
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator1>::reference
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ReferenceType1;
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator2>::reference
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ReferenceType2;
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	&& __are_same<_ValueType1&, _ReferenceType1>::__value
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	&& __are_same<_ValueType2&, _ReferenceType2>::__value>::
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(__a, __b);
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #else
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // _GLIBCXX_RESOLVE_LIB_DEFECTS
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // 187. iter_swap underspecified
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       swap(*__a, *__b);
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Swap the elements of two sequences.
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first1  A forward iterator.
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __last1   A forward iterator.
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first2  A forward iterator.
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   An iterator equal to @p first2+(last1-first1).
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  Swaps each element in the range @p [first1,last1) with the
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  corresponding element in the range @p [first2,(last1-first1)).
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  The ranges must not overlap.
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2>
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
ARM GAS  /tmp/ccysU9ly.s 			page 163


 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _ForwardIterator2
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		_ForwardIterator2 __first2)
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator1>)
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator2>)
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_requires_valid_range(__first1, __last1);
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       for (; __first1 != __last1; ++__first1, (void)++__first2)
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	std::iter_swap(__first1, __first2);
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __first2;
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief This does what you think it does.
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup sorting_algorithms
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  A thing of arbitrary type.
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another thing of arbitrary type.
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   The lesser of the parameters.
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This is the simple classic generic implementation.  It will work on
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  temporary expressions, since they are only evaluated once, unlike a
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  preprocessor macro.
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp>
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline const _Tp&
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     min(const _Tp& __a, const _Tp& __b)
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       //return __b < __a ? __b : __a;
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (__b < __a)
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief This does what you think it does.
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup sorting_algorithms
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  A thing of arbitrary type.
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another thing of arbitrary type.
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   The greater of the parameters.
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This is the simple classic generic implementation.  It will work on
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  temporary expressions, since they are only evaluated once, unlike a
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  preprocessor macro.
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp>
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline const _Tp&
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     max(const _Tp& __a, const _Tp& __b)
 3637              		.loc 20 254 5 view .LVU772
 3638              	.LBB1070:
ARM GAS  /tmp/ccysU9ly.s 			page 164


 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       //return  __a < __b ? __b : __a;
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (__a < __b)
 3639              		.loc 20 259 15 is_stmt 0 view .LVU773
 3640 0132 3F4B     		ldr	r3, .L165+36
 3641 0134 D3F82023 		ldr	r2, [r3, #800]
 3642              	.LVL269:
 3643              		.loc 20 259 15 view .LVU774
 3644 0138 029B     		ldr	r3, [sp, #8]
 3645              		.loc 20 259 7 view .LVU775
 3646 013a 9A42     		cmp	r2, r3
 3647 013c 41D3     		bcc	.L157
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 3648              		.loc 20 261 14 view .LVU776
 3649 013e 3D4B     		ldr	r3, .L165+40
 3650              	.LVL270:
 3651              	.L153:
 3652              		.loc 20 261 14 view .LVU777
 3653              	.LBE1070:
 3654              	.LBE1069:
  45:MotorControl/task_timer.hpp **** #endif
 3655              		.loc 19 45 31 view .LVU778
 3656 0140 1A68     		ldr	r2, [r3]
  45:MotorControl/task_timer.hpp **** #endif
 3657              		.loc 19 45 21 view .LVU779
 3658 0142 3B4B     		ldr	r3, .L165+36
 3659 0144 C3F82023 		str	r2, [r3, #800]
 3660              	.LVL271:
  45:MotorControl/task_timer.hpp **** #endif
 3661              		.loc 19 45 21 view .LVU780
 3662              	.LBE1066:
 3663              	.LBE1065:
 3664              	.LBE1064:
 3665              	.LBE1063:
 3666              	.LBE1095:
 555:Board/v3/board.cpp ****         motors[0].disarm_with_error(Motor::ERROR_BAD_TIMING);
 3667              		.loc 4 555 5 is_stmt 1 view .LVU781
 555:Board/v3/board.cpp ****         motors[0].disarm_with_error(Motor::ERROR_BAD_TIMING);
 3668              		.loc 4 555 30 is_stmt 0 view .LVU782
 3669 0148 06A9     		add	r1, sp, #24
 3670 014a 0AA8     		add	r0, sp, #40
 3671 014c FFF7FEFF 		bl	_ZL20fetch_and_reset_adcsPSt8optionalI9Iph_ABC_tES2_
 3672              	.LVL272:
 555:Board/v3/board.cpp ****         motors[0].disarm_with_error(Motor::ERROR_BAD_TIMING);
 3673              		.loc 4 555 5 view .LVU783
 3674 0150 0028     		cmp	r0, #0
 3675 0152 38D0     		beq	.L163
 3676              	.L154:
 560:Board/v3/board.cpp ****     motors[1].dc_calib_cb(timestamp + TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1), current1);
 3677              		.loc 4 560 5 is_stmt 1 view .LVU784
 560:Board/v3/board.cpp ****     motors[1].dc_calib_cb(timestamp + TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1), current1);
 3678              		.loc 4 560 26 is_stmt 0 view .LVU785
 3679 0154 304E     		ldr	r6, .L165+12
 3680 0156 0CAB     		add	r3, sp, #48
ARM GAS  /tmp/ccysU9ly.s 			page 165


 3681 0158 93E80300 		ldm	r3, {r0, r1}
 3682 015c 8DE80300 		stm	sp, {r0, r1}
 3683 0160 0AAB     		add	r3, sp, #40
 3684 0162 0CCB     		ldm	r3, {r2, r3}
 3685 0164 04F50A51 		add	r1, r4, #8832
 3686 0168 2E31     		adds	r1, r1, #46
 3687 016a 3046     		mov	r0, r6
 3688 016c FFF7FEFF 		bl	_ZN5Motor11dc_calib_cbEmSt8optionalI9Iph_ABC_tE
 3689              	.LVL273:
 561:Board/v3/board.cpp **** 
 3690              		.loc 4 561 5 is_stmt 1 view .LVU786
 561:Board/v3/board.cpp **** 
 3691              		.loc 4 561 26 is_stmt 0 view .LVU787
 3692 0170 04F52455 		add	r5, r4, #10496
 3693 0174 0435     		adds	r5, r5, #4
 3694 0176 06F5D877 		add	r7, r6, #432
 3695 017a 08AB     		add	r3, sp, #32
 3696 017c 93E80300 		ldm	r3, {r0, r1}
 3697 0180 8DE80300 		stm	sp, {r0, r1}
 3698 0184 06AB     		add	r3, sp, #24
 3699 0186 0CCB     		ldm	r3, {r2, r3}
 3700 0188 2946     		mov	r1, r5
 3701 018a 3846     		mov	r0, r7
 3702 018c FFF7FEFF 		bl	_ZN5Motor11dc_calib_cbEmSt8optionalI9Iph_ABC_tE
 3703              	.LVL274:
 563:Board/v3/board.cpp ****     motors[1].pwm_update_cb(timestamp + 3 * TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1));
 3704              		.loc 4 563 5 is_stmt 1 view .LVU788
 563:Board/v3/board.cpp ****     motors[1].pwm_update_cb(timestamp + 3 * TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1));
 3705              		.loc 4 563 28 is_stmt 0 view .LVU789
 3706 0190 04F5E941 		add	r1, r4, #29824
 3707 0194 3631     		adds	r1, r1, #54
 3708 0196 3046     		mov	r0, r6
 3709 0198 FFF7FEFF 		bl	_ZN5Motor13pwm_update_cbEm
 3710              	.LVL275:
 564:Board/v3/board.cpp **** 
 3711              		.loc 4 564 5 is_stmt 1 view .LVU790
 564:Board/v3/board.cpp **** 
 3712              		.loc 4 564 28 is_stmt 0 view .LVU791
 3713 019c 04F5F641 		add	r1, r4, #31488
 3714 01a0 0C31     		adds	r1, r1, #12
 3715 01a2 3846     		mov	r0, r7
 3716 01a4 FFF7FEFF 		bl	_ZN5Motor13pwm_update_cbEm
 3717              	.LVL276:
 569:Board/v3/board.cpp ****         motors[0].disarm_with_error(Motor::ERROR_CONTROL_DEADLINE_MISSED);
 3718              		.loc 4 569 5 is_stmt 1 view .LVU792
 569:Board/v3/board.cpp ****         motors[0].disarm_with_error(Motor::ERROR_CONTROL_DEADLINE_MISSED);
 3719              		.loc 4 569 9 is_stmt 0 view .LVU793
 3720 01a8 184B     		ldr	r3, .L165
 3721 01aa 1B68     		ldr	r3, [r3]
 569:Board/v3/board.cpp ****         motors[0].disarm_with_error(Motor::ERROR_CONTROL_DEADLINE_MISSED);
 3722              		.loc 4 569 5 view .LVU794
 3723 01ac 9D42     		cmp	r5, r3
 3724 01ae 19D1     		bne	.L164
 3725              	.L155:
 574:Board/v3/board.cpp ****     TaskTimer::enabled = false;
 3726              		.loc 4 574 5 is_stmt 1 view .LVU795
 574:Board/v3/board.cpp ****     TaskTimer::enabled = false;
ARM GAS  /tmp/ccysU9ly.s 			page 166


 3727              		.loc 4 574 36 is_stmt 0 view .LVU796
 3728 01b0 1F4B     		ldr	r3, .L165+36
 3729 01b2 93F8E032 		ldrb	r3, [r3, #736]	@ zero_extendqisi2
 574:Board/v3/board.cpp ****     TaskTimer::enabled = false;
 3730              		.loc 4 574 55 view .LVU797
 3731 01b6 03B3     		cbz	r3, .L158
 574:Board/v3/board.cpp ****     TaskTimer::enabled = false;
 3732              		.loc 4 574 58 discriminator 1 view .LVU798
 3733 01b8 1C4A     		ldr	r2, .L165+32
 3734 01ba 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 574:Board/v3/board.cpp ****     TaskTimer::enabled = false;
 3735              		.loc 4 574 55 discriminator 1 view .LVU799
 3736 01bc F2B1     		cbz	r2, .L156
 574:Board/v3/board.cpp ****     TaskTimer::enabled = false;
 3737              		.loc 4 574 55 view .LVU800
 3738 01be 0023     		movs	r3, #0
 3739 01c0 1CE0     		b	.L156
 3740              	.LVL277:
 3741              	.L157:
 3742              	.LBB1096:
 3743              	.LBB1076:
 3744              	.LBB1075:
 3745              	.LBB1074:
 3746              	.LBB1073:
 3747              	.LBB1072:
 3748              	.LBB1071:
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 3749              		.loc 20 260 9 view .LVU801
 3750 01c2 02AB     		add	r3, sp, #8
 3751              	.LVL278:
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 3752              		.loc 20 260 9 view .LVU802
 3753 01c4 BCE7     		b	.L153
 3754              	.LVL279:
 3755              	.L163:
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __a;
 3756              		.loc 20 260 9 view .LVU803
 3757              	.LBE1071:
 3758              	.LBE1072:
 3759              	.LBE1073:
 3760              	.LBE1074:
 3761              	.LBE1075:
 3762              	.LBE1076:
 3763              	.LBE1096:
 556:Board/v3/board.cpp ****         motors[1].disarm_with_error(Motor::ERROR_BAD_TIMING);
 3764              		.loc 4 556 9 is_stmt 1 view .LVU804
 556:Board/v3/board.cpp ****         motors[1].disarm_with_error(Motor::ERROR_BAD_TIMING);
 3765              		.loc 4 556 36 is_stmt 0 view .LVU805
 3766 01c6 144D     		ldr	r5, .L165+12
 3767 01c8 4FF00072 		mov	r2, #33554432
 3768 01cc 0023     		movs	r3, #0
 3769 01ce 2846     		mov	r0, r5
 3770 01d0 FFF7FEFF 		bl	_ZN5Motor17disarm_with_errorEN10ODriveIntf9MotorIntf5ErrorE
 3771              	.LVL280:
 557:Board/v3/board.cpp ****     }
 3772              		.loc 4 557 9 is_stmt 1 view .LVU806
 557:Board/v3/board.cpp ****     }
ARM GAS  /tmp/ccysU9ly.s 			page 167


 3773              		.loc 4 557 36 is_stmt 0 view .LVU807
 3774 01d4 4FF00072 		mov	r2, #33554432
 3775 01d8 0023     		movs	r3, #0
 3776 01da 05F5D870 		add	r0, r5, #432
 3777 01de FFF7FEFF 		bl	_ZN5Motor17disarm_with_errorEN10ODriveIntf9MotorIntf5ErrorE
 3778              	.LVL281:
 3779 01e2 B7E7     		b	.L154
 3780              	.L164:
 570:Board/v3/board.cpp ****         motors[1].disarm_with_error(Motor::ERROR_CONTROL_DEADLINE_MISSED);
 3781              		.loc 4 570 9 is_stmt 1 view .LVU808
 570:Board/v3/board.cpp ****         motors[1].disarm_with_error(Motor::ERROR_CONTROL_DEADLINE_MISSED);
 3782              		.loc 4 570 36 is_stmt 0 view .LVU809
 3783 01e4 1022     		movs	r2, #16
 3784 01e6 0023     		movs	r3, #0
 3785 01e8 3046     		mov	r0, r6
 3786 01ea FFF7FEFF 		bl	_ZN5Motor17disarm_with_errorEN10ODriveIntf9MotorIntf5ErrorE
 3787              	.LVL282:
 571:Board/v3/board.cpp ****     }
 3788              		.loc 4 571 9 is_stmt 1 view .LVU810
 571:Board/v3/board.cpp ****     }
 3789              		.loc 4 571 36 is_stmt 0 view .LVU811
 3790 01ee 1022     		movs	r2, #16
 3791 01f0 0023     		movs	r3, #0
 3792 01f2 3846     		mov	r0, r7
 3793 01f4 FFF7FEFF 		bl	_ZN5Motor17disarm_with_errorEN10ODriveIntf9MotorIntf5ErrorE
 3794              	.LVL283:
 3795 01f8 DAE7     		b	.L155
 3796              	.L158:
 574:Board/v3/board.cpp ****     TaskTimer::enabled = false;
 3797              		.loc 4 574 55 view .LVU812
 3798 01fa 0023     		movs	r3, #0
 3799              	.L156:
 574:Board/v3/board.cpp ****     TaskTimer::enabled = false;
 3800              		.loc 4 574 29 discriminator 6 view .LVU813
 3801 01fc 0C4A     		ldr	r2, .L165+36
 3802 01fe 82F8E032 		strb	r3, [r2, #736]
 575:Board/v3/board.cpp **** }
 3803              		.loc 4 575 5 is_stmt 1 discriminator 6 view .LVU814
 575:Board/v3/board.cpp **** }
 3804              		.loc 4 575 24 is_stmt 0 discriminator 6 view .LVU815
 3805 0202 0A4B     		ldr	r3, .L165+32
 3806 0204 0022     		movs	r2, #0
 3807 0206 1A70     		strb	r2, [r3]
 576:Board/v3/board.cpp **** 
 3808              		.loc 4 576 1 discriminator 6 view .LVU816
 3809 0208 15B0     		add	sp, sp, #84
 3810              	.LCFI25:
 3811              		.cfi_def_cfa_offset 20
 3812              		@ sp needed
 3813 020a F0BD     		pop	{r4, r5, r6, r7, pc}
 3814              	.LVL284:
 3815              	.L166:
 576:Board/v3/board.cpp **** 
 3816              		.loc 4 576 1 discriminator 6 view .LVU817
 3817              		.align	2
 3818              	.L165:
 3819 020c 00000000 		.word	.LANCHOR20
ARM GAS  /tmp/ccysU9ly.s 			page 168


 3820 0210 00000140 		.word	1073807360
 3821 0214 00040140 		.word	1073808384
 3822 0218 00000000 		.word	.LANCHOR10
 3823 021c 00000000 		.word	odrv
 3824 0220 14430000 		.word	odrv+17172
 3825 0224 001C0040 		.word	1073748992
 3826 0228 00210140 		.word	1073815808
 3827 022c 00000000 		.word	.LANCHOR21
 3828 0230 00400000 		.word	odrv+16384
 3829 0234 20430000 		.word	odrv+17184
 3830              		.cfi_endproc
 3831              	.LFE5236:
 3832              		.fnend
 3834              		.section	.text.I2C1_EV_IRQHandler,"ax",%progbits
 3835              		.align	1
 3836              		.p2align 2,,3
 3837              		.global	I2C1_EV_IRQHandler
 3838              		.syntax unified
 3839              		.thumb
 3840              		.thumb_func
 3842              	I2C1_EV_IRQHandler:
 3843              		.fnstart
 3844              	.LFB5252:
 578:Board/v3/board.cpp ****     COUNT_IRQ(I2C1_EV_IRQn);
 3845              		.loc 4 578 31 is_stmt 1 view -0
 3846              		.cfi_startproc
 3847              		@ args = 0, pretend = 0, frame = 0
 3848              		@ frame_needed = 0, uses_anonymous_args = 0
 3849 0000 08B5     		push	{r3, lr}
 3850              		.save {r3, lr}
 3851              	.LCFI26:
 3852              		.cfi_def_cfa_offset 8
 3853              		.cfi_offset 3, -8
 3854              		.cfi_offset 14, -4
 579:Board/v3/board.cpp ****     HAL_I2C_EV_IRQHandler(&hi2c1);
 3855              		.loc 4 579 5 view .LVU819
 580:Board/v3/board.cpp **** }
 3856              		.loc 4 580 5 view .LVU820
 580:Board/v3/board.cpp **** }
 3857              		.loc 4 580 26 is_stmt 0 view .LVU821
 3858 0002 0248     		ldr	r0, .L169
 3859 0004 FFF7FEFF 		bl	HAL_I2C_EV_IRQHandler
 3860              	.LVL285:
 581:Board/v3/board.cpp **** 
 3861              		.loc 4 581 1 view .LVU822
 3862 0008 08BD     		pop	{r3, pc}
 3863              	.L170:
 3864 000a 00BF     		.align	2
 3865              	.L169:
 3866 000c 00000000 		.word	hi2c1
 3867              		.cfi_endproc
 3868              	.LFE5252:
 3869              		.fnend
 3871              		.section	.text.I2C1_ER_IRQHandler,"ax",%progbits
 3872              		.align	1
 3873              		.p2align 2,,3
 3874              		.global	I2C1_ER_IRQHandler
ARM GAS  /tmp/ccysU9ly.s 			page 169


 3875              		.syntax unified
 3876              		.thumb
 3877              		.thumb_func
 3879              	I2C1_ER_IRQHandler:
 3880              		.fnstart
 3881              	.LFB5253:
 583:Board/v3/board.cpp ****     COUNT_IRQ(I2C1_ER_IRQn);
 3882              		.loc 4 583 31 is_stmt 1 view -0
 3883              		.cfi_startproc
 3884              		@ args = 0, pretend = 0, frame = 0
 3885              		@ frame_needed = 0, uses_anonymous_args = 0
 3886 0000 08B5     		push	{r3, lr}
 3887              		.save {r3, lr}
 3888              	.LCFI27:
 3889              		.cfi_def_cfa_offset 8
 3890              		.cfi_offset 3, -8
 3891              		.cfi_offset 14, -4
 584:Board/v3/board.cpp ****     HAL_I2C_ER_IRQHandler(&hi2c1);
 3892              		.loc 4 584 5 view .LVU824
 585:Board/v3/board.cpp **** }
 3893              		.loc 4 585 5 view .LVU825
 585:Board/v3/board.cpp **** }
 3894              		.loc 4 585 26 is_stmt 0 view .LVU826
 3895 0002 0248     		ldr	r0, .L173
 3896 0004 FFF7FEFF 		bl	HAL_I2C_ER_IRQHandler
 3897              	.LVL286:
 586:Board/v3/board.cpp **** 
 3898              		.loc 4 586 1 view .LVU827
 3899 0008 08BD     		pop	{r3, pc}
 3900              	.L174:
 3901 000a 00BF     		.align	2
 3902              	.L173:
 3903 000c 00000000 		.word	hi2c1
 3904              		.cfi_endproc
 3905              	.LFE5253:
 3906              		.fnend
 3908              		.section	.text.OTG_FS_IRQHandler,"ax",%progbits
 3909              		.align	1
 3910              		.p2align 2,,3
 3911              		.global	OTG_FS_IRQHandler
 3912              		.syntax unified
 3913              		.thumb
 3914              		.thumb_func
 3916              	OTG_FS_IRQHandler:
 3917              		.fnstart
 3918              	.LFB5254:
 589:Board/v3/board.cpp ****     COUNT_IRQ(OTG_FS_IRQn);
 3919              		.loc 4 589 30 is_stmt 1 view -0
 3920              		.cfi_startproc
 3921              		@ args = 0, pretend = 0, frame = 0
 3922              		@ frame_needed = 0, uses_anonymous_args = 0
 3923 0000 08B5     		push	{r3, lr}
 3924              		.save {r3, lr}
 3925              	.LCFI28:
 3926              		.cfi_def_cfa_offset 8
 3927              		.cfi_offset 3, -8
 3928              		.cfi_offset 14, -4
ARM GAS  /tmp/ccysU9ly.s 			page 170


 590:Board/v3/board.cpp ****     HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 3929              		.loc 4 590 5 view .LVU829
 591:Board/v3/board.cpp **** }
 3930              		.loc 4 591 5 view .LVU830
 591:Board/v3/board.cpp **** }
 3931              		.loc 4 591 23 is_stmt 0 view .LVU831
 3932 0002 0248     		ldr	r0, .L177
 3933 0004 FFF7FEFF 		bl	HAL_PCD_IRQHandler
 3934              	.LVL287:
 592:Board/v3/board.cpp **** 
 3935              		.loc 4 592 1 view .LVU832
 3936 0008 08BD     		pop	{r3, pc}
 3937              	.L178:
 3938 000a 00BF     		.align	2
 3939              	.L177:
 3940 000c 00000000 		.word	hpcd_USB_OTG_FS
 3941              		.cfi_endproc
 3942              	.LFE5254:
 3943              		.fnend
 3945              		.section	.text._ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj,"axG",%progbits,_ZNSt5arrayIP17TIM_Handle
 3946              		.align	1
 3947              		.p2align 2,,3
 3948              		.weak	_ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj
 3949              		.syntax unified
 3950              		.thumb
 3951              		.thumb_func
 3953              	_ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj:
 3954              		.fnstart
 3955              	.LVL288:
 3956              	.LFB6074:
 3957              		.file 21 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // <array> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // Copyright (C) 2007-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** /** @file include/array
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****  *  This is a Standard C++ Library header.
ARM GAS  /tmp/ccysU9ly.s 			page 171


  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****  */
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #ifndef _GLIBCXX_ARRAY
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #define _GLIBCXX_ARRAY 1
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #pragma GCC system_header
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #if __cplusplus < 201103L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** # include <bits/c++0x_warning.h>
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #else
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <utility>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <bits/functexcept.h>
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <bits/stl_algobase.h>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <bits/range_access.h>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** namespace std _GLIBCXX_VISIBILITY(default)
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** {
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   template<typename _Tp, std::size_t _Nm>
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     struct __array_traits
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     {
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef _Tp _Type[_Nm];
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef __is_swappable<_Tp> _Is_swappable;
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       static constexpr _Tp&
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _S_ref(const _Type& __t, std::size_t __n) noexcept
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       static constexpr _Tp*
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _S_ptr(const _Type& __t) noexcept
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp*>(__t); }
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     };
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****  template<typename _Tp>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    struct __array_traits<_Tp, 0>
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    {
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      struct _Type { };
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      typedef true_type _Is_swappable;
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      typedef true_type _Is_nothrow_swappable;
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      static constexpr _Tp&
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      _S_ref(const _Type&, std::size_t) noexcept
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      { return *static_cast<_Tp*>(nullptr); }
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      static constexpr _Tp*
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      _S_ptr(const _Type&) noexcept
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      { return nullptr; }
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    };
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   /**
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @brief A standard container for storing a fixed size sequence of elements.
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @ingroup sequences
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
ARM GAS  /tmp/ccysU9ly.s 			page 172


  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  Meets the requirements of a <a href="tables.html#65">container</a>, a
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  <a href="tables.html#66">reversible container</a>, and a
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  <a href="tables.html#67">sequence</a>.
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  Sets support random access iterators.
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @tparam  Tp  Type of element. Required to be a complete type.
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @tparam  Nm  Number of elements.
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   */
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   template<typename _Tp, std::size_t _Nm>
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     struct array
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     {
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef _Tp 	    			      value_type;
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef value_type*			      pointer;
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef const value_type*                       const_pointer;
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef value_type&                   	      reference;
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef const value_type&             	      const_reference;
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef value_type*          		      iterator;
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef const value_type*			      const_iterator;
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::size_t                    	      size_type;
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::ptrdiff_t                   	      difference_type;
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::reverse_iterator<iterator>	      reverse_iterator;
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::reverse_iterator<const_iterator>   const_reverse_iterator;
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Support for zero-sized arrays mandatory.
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef _GLIBCXX_STD_C::__array_traits<_Tp, _Nm> _AT_Type;
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typename _AT_Type::_Type                         _M_elems;
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // No explicit construct/copy/destroy for aggregate type.
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // DR 776.
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX20_CONSTEXPR void
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       fill(const value_type& __u)
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { std::fill_n(begin(), size(), __u); }
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX20_CONSTEXPR void
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       swap(array& __other)
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       noexcept(_AT_Type::_Is_nothrow_swappable::value)
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { std::swap_ranges(begin(), end(), __other.begin()); }
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Iterators.
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR iterator
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       begin() noexcept
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return iterator(data()); }
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       begin() const noexcept
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data()); }
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR iterator
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       end() noexcept
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return iterator(data() + _Nm); }
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       end() const noexcept
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data() + _Nm); }
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
ARM GAS  /tmp/ccysU9ly.s 			page 173


 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reverse_iterator
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rbegin() noexcept
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return reverse_iterator(end()); }
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rbegin() const noexcept
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(end()); }
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reverse_iterator
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rend() noexcept
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return reverse_iterator(begin()); }
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rend() const noexcept
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(begin()); }
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       cbegin() const noexcept
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data()); }
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       cend() const noexcept
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data() + _Nm); }
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       crbegin() const noexcept
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(end()); }
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       crend() const noexcept
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(begin()); }
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Capacity.
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       constexpr size_type
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       size() const noexcept { return _Nm; }
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       constexpr size_type
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       max_size() const noexcept { return _Nm; }
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX_NODISCARD constexpr bool
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       empty() const noexcept { return size() == 0; }
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Element access.
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reference
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       operator[](size_type __n) noexcept
 3958              		.loc 21 185 7 is_stmt 1 view -0
 3959              		.cfi_startproc
 3960              		@ args = 0, pretend = 0, frame = 0
 3961              		@ frame_needed = 0, uses_anonymous_args = 0
 3962              		@ link register save eliminated.
 3963              	.LBB1097:
 3964              	.LBI1097:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3965              		.loc 21 55 7 view .LVU834
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3966              		.loc 21 55 7 is_stmt 0 view .LVU835
 3967              	.LBE1097:
ARM GAS  /tmp/ccysU9ly.s 			page 174


 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 3968              		.loc 21 186 49 view .LVU836
 3969 0000 00EB8100 		add	r0, r0, r1, lsl #2
 3970              	.LVL289:
 3971              		.loc 21 186 49 view .LVU837
 3972 0004 7047     		bx	lr
 3973              		.cfi_endproc
 3974              	.LFE6074:
 3975              		.cantunwind
 3976              		.fnend
 3978 0006 00BF     		.section	.text._ZNSt5arrayIjLj3EEixEj,"axG",%progbits,_ZNSt5arrayIjLj3EEixEj,comdat
 3979              		.align	1
 3980              		.p2align 2,,3
 3981              		.weak	_ZNSt5arrayIjLj3EEixEj
 3982              		.syntax unified
 3983              		.thumb
 3984              		.thumb_func
 3986              	_ZNSt5arrayIjLj3EEixEj:
 3987              		.fnstart
 3988              	.LVL290:
 3989              	.LFB6076:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return _AT_Type::_S_ref(_M_elems, __n); }
 3990              		.loc 21 185 7 is_stmt 1 view -0
 3991              		.cfi_startproc
 3992              		@ args = 0, pretend = 0, frame = 0
 3993              		@ frame_needed = 0, uses_anonymous_args = 0
 3994              		@ link register save eliminated.
 3995              	.LBB1098:
 3996              	.LBI1098:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3997              		.loc 21 55 7 view .LVU839
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3998              		.loc 21 55 7 is_stmt 0 view .LVU840
 3999              	.LBE1098:
 4000              		.loc 21 186 49 view .LVU841
 4001 0000 00EB8100 		add	r0, r0, r1, lsl #2
 4002              	.LVL291:
 4003              		.loc 21 186 49 view .LVU842
 4004 0004 7047     		bx	lr
 4005              		.cfi_endproc
 4006              	.LFE6076:
 4007              		.cantunwind
 4008              		.fnend
 4010 0006 00BF     		.section	.text._ZN10Stm32Timer24start_synchronously_implILj3EJLj0ELj1ELj2EEEEvSt5arrayIP17TIM_Hand
 4011              		.align	1
 4012              		.p2align 2,,3
 4013              		.weak	_ZN10Stm32Timer24start_synchronously_implILj3EJLj0ELj1ELj2EEEEvSt5arrayIP17TIM_HandleTypeDef
 4014              		.syntax unified
 4015              		.thumb
 4016              		.thumb_func
 4018              	_ZN10Stm32Timer24start_synchronously_implILj3EJLj0ELj1ELj2EEEEvSt5arrayIP17TIM_HandleTypeDefXT_EES1
 4019              		.fnstart
 4020              	.LFB5944:
 4021              		.file 22 "./Drivers/STM32/stm32_timer.hpp"
   1:./Drivers/STM32/stm32_timer.hpp **** #ifndef __STM32_TIMER_HPP
   2:./Drivers/STM32/stm32_timer.hpp **** #define __STM32_TIMER_HPP
   3:./Drivers/STM32/stm32_timer.hpp **** 
ARM GAS  /tmp/ccysU9ly.s 			page 175


   4:./Drivers/STM32/stm32_timer.hpp **** #include "stm32_system.h"
   5:./Drivers/STM32/stm32_timer.hpp **** #include <tim.h>
   6:./Drivers/STM32/stm32_timer.hpp **** #include <array>
   7:./Drivers/STM32/stm32_timer.hpp **** 
   8:./Drivers/STM32/stm32_timer.hpp **** class Stm32Timer {
   9:./Drivers/STM32/stm32_timer.hpp **** public:
  10:./Drivers/STM32/stm32_timer.hpp ****     /**
  11:./Drivers/STM32/stm32_timer.hpp ****      * @brief Starts multiple timers deterministically and synchronously from the
  12:./Drivers/STM32/stm32_timer.hpp ****      * specified offset.
  13:./Drivers/STM32/stm32_timer.hpp ****      * 
  14:./Drivers/STM32/stm32_timer.hpp ****      * All timers are atomically (*) put into the following state (regardless of
  15:./Drivers/STM32/stm32_timer.hpp ****      * their previous state/configuration):
  16:./Drivers/STM32/stm32_timer.hpp ****      *  - TIMx_CNT will be initialized according to the corresponding counter[i] parameter.
  17:./Drivers/STM32/stm32_timer.hpp ****      *  - If the timer is in center-aligned mode, it will be set to up-counting direction.
  18:./Drivers/STM32/stm32_timer.hpp ****      *  - The update repetition counter is reset to TIMx_RCR (if applicable).
  19:./Drivers/STM32/stm32_timer.hpp ****      *  - The prescaler counter is reset.
  20:./Drivers/STM32/stm32_timer.hpp ****      *  - Update interrupts are disabled.
  21:./Drivers/STM32/stm32_timer.hpp ****      *  - The counter put into running state.
  22:./Drivers/STM32/stm32_timer.hpp ****      * 
  23:./Drivers/STM32/stm32_timer.hpp ****      * This function is implemented by generating an update event on all selected timers.
  24:./Drivers/STM32/stm32_timer.hpp ****      * That means as a side effect all things that are connected to the update event
  25:./Drivers/STM32/stm32_timer.hpp ****      * except the interrupt routine itself (i.e. ADCs, DMAs, slave timers, etc) will
  26:./Drivers/STM32/stm32_timer.hpp ****      * be triggered.
  27:./Drivers/STM32/stm32_timer.hpp ****      * 
  28:./Drivers/STM32/stm32_timer.hpp ****      * Also you probably want to disable any connected PWM outputs to prevent glitches.
  29:./Drivers/STM32/stm32_timer.hpp ****      * 
  30:./Drivers/STM32/stm32_timer.hpp ****      * (*) Best-effort atomically. There will be skew of a handful of clock cycles
  31:./Drivers/STM32/stm32_timer.hpp ****      *     but it's always the same given the compiler version and configuration.
  32:./Drivers/STM32/stm32_timer.hpp ****      */
  33:./Drivers/STM32/stm32_timer.hpp ****     template<size_t I>
  34:./Drivers/STM32/stm32_timer.hpp ****     static void start_synchronously(std::array<TIM_HandleTypeDef*, I> timers, std::array<size_t, I>
  35:./Drivers/STM32/stm32_timer.hpp ****         start_synchronously_impl(timers, counters, std::make_index_sequence<I>());
  36:./Drivers/STM32/stm32_timer.hpp ****     }
  37:./Drivers/STM32/stm32_timer.hpp **** 
  38:./Drivers/STM32/stm32_timer.hpp **** private:
  39:./Drivers/STM32/stm32_timer.hpp **** 
  40:./Drivers/STM32/stm32_timer.hpp **** #pragma GCC push_options
  41:./Drivers/STM32/stm32_timer.hpp **** #pragma GCC optimize (3)
  42:./Drivers/STM32/stm32_timer.hpp **** 
  43:./Drivers/STM32/stm32_timer.hpp ****     template<size_t I, size_t ... Is>
  44:./Drivers/STM32/stm32_timer.hpp ****     static void start_synchronously_impl(std::array<TIM_HandleTypeDef*, I> timers, std::array<size_
 4022              		.loc 22 44 17 is_stmt 1 view -0
 4023              		.cfi_startproc
 4024              		@ args = 20, pretend = 8, frame = 16
 4025              		@ frame_needed = 0, uses_anonymous_args = 0
 4026              	.LVL292:
 4027              	.LBB1099:
  45:./Drivers/STM32/stm32_timer.hpp ****         for (size_t i = 0; i < I; ++i) {
 4028              		.loc 22 45 30 view .LVU844
 4029              		.loc 22 45 30 is_stmt 0 view .LVU845
 4030              	.LBE1099:
  44:./Drivers/STM32/stm32_timer.hpp ****         for (size_t i = 0; i < I; ++i) {
 4031              		.loc 22 44 17 view .LVU846
 4032 0000 82B0     		sub	sp, sp, #8
 4033              	.LCFI29:
 4034              		.cfi_def_cfa_offset 8
 4035 0002 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
ARM GAS  /tmp/ccysU9ly.s 			page 176


 4036              	.LCFI30:
 4037              		.cfi_def_cfa_offset 36
 4038              		.cfi_offset 4, -36
 4039              		.cfi_offset 5, -32
 4040              		.cfi_offset 6, -28
 4041              		.cfi_offset 7, -24
 4042              		.cfi_offset 8, -20
 4043              		.cfi_offset 9, -16
 4044              		.cfi_offset 14, -12
 4045 0006 85B0     		sub	sp, sp, #20
 4046              	.LCFI31:
 4047              		.cfi_def_cfa_offset 56
  44:./Drivers/STM32/stm32_timer.hpp ****         for (size_t i = 0; i < I; ++i) {
 4048              		.loc 22 44 17 view .LVU847
 4049 0008 01AC     		add	r4, sp, #4
 4050 000a 0CAE     		add	r6, sp, #48
 4051 000c 84E80700 		stm	r4, {r0, r1, r2}
 4052              	.LBB1104:
 4053              	.LBB1100:
  46:./Drivers/STM32/stm32_timer.hpp ****             TIM_HandleTypeDef* htim = timers[i];
 4054              		.loc 22 46 45 view .LVU848
 4055 0010 0021     		movs	r1, #0
 4056 0012 2046     		mov	r0, r4
 4057              	.LBE1100:
 4058              	.LBE1104:
  44:./Drivers/STM32/stm32_timer.hpp ****         for (size_t i = 0; i < I; ++i) {
 4059              		.loc 22 44 17 view .LVU849
 4060 0014 46F8043F 		str	r3, [r6, #4]!
 4061              	.LBB1105:
 4062              	.LBB1101:
 4063              		.loc 22 46 45 view .LVU850
 4064 0018 FFF7FEFF 		bl	_ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj
 4065              	.LVL293:
  47:./Drivers/STM32/stm32_timer.hpp **** 
  48:./Drivers/STM32/stm32_timer.hpp ****             // Stop the timer so we can start all of them later more atomically.
  49:./Drivers/STM32/stm32_timer.hpp ****             htim->Instance->CR1 &= ~TIM_CR1_CEN;
 4066              		.loc 22 49 19 view .LVU851
 4067 001c 0368     		ldr	r3, [r0]
 4068 001e 1D68     		ldr	r5, [r3]
 4069              		.loc 22 49 33 view .LVU852
 4070 0020 2B68     		ldr	r3, [r5]
  50:./Drivers/STM32/stm32_timer.hpp **** 
  51:./Drivers/STM32/stm32_timer.hpp ****             // Generate update event to force all of the timer's registers into
  52:./Drivers/STM32/stm32_timer.hpp ****             // a known state.
  53:./Drivers/STM32/stm32_timer.hpp ****             __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
  54:./Drivers/STM32/stm32_timer.hpp ****             htim->Instance->EGR |= TIM_EGR_UG;
  55:./Drivers/STM32/stm32_timer.hpp ****             __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 4071              		.loc 22 55 13 view .LVU853
 4072 0022 6FF00107 		mvn	r7, #1
  49:./Drivers/STM32/stm32_timer.hpp **** 
 4073              		.loc 22 49 33 view .LVU854
 4074 0026 3B40     		ands	r3, r3, r7
 4075 0028 2B60     		str	r3, [r5]
  53:./Drivers/STM32/stm32_timer.hpp ****             htim->Instance->EGR |= TIM_EGR_UG;
 4076              		.loc 22 53 13 view .LVU855
 4077 002a EB68     		ldr	r3, [r5, #12]
 4078 002c 3B40     		ands	r3, r3, r7
ARM GAS  /tmp/ccysU9ly.s 			page 177


 4079 002e EB60     		str	r3, [r5, #12]
  54:./Drivers/STM32/stm32_timer.hpp ****             __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 4080              		.loc 22 54 33 view .LVU856
 4081 0030 6B69     		ldr	r3, [r5, #20]
 4082 0032 43F00103 		orr	r3, r3, #1
 4083 0036 6B61     		str	r3, [r5, #20]
  56:./Drivers/STM32/stm32_timer.hpp **** 
  57:./Drivers/STM32/stm32_timer.hpp ****             // Load counter with the desired value.
  58:./Drivers/STM32/stm32_timer.hpp ****             htim->Instance->CNT = counters[i];
 4084              		.loc 22 58 43 view .LVU857
 4085 0038 0021     		movs	r1, #0
  55:./Drivers/STM32/stm32_timer.hpp **** 
 4086              		.loc 22 55 13 view .LVU858
 4087 003a 2F61     		str	r7, [r5, #16]
 4088              		.loc 22 58 43 view .LVU859
 4089 003c 3046     		mov	r0, r6
 4090 003e FFF7FEFF 		bl	_ZNSt5arrayIjLj3EEixEj
 4091              	.LVL294:
 4092              		.loc 22 58 33 view .LVU860
 4093 0042 0368     		ldr	r3, [r0]
 4094 0044 6B62     		str	r3, [r5, #36]
 4095              	.LBE1101:
  45:./Drivers/STM32/stm32_timer.hpp ****             TIM_HandleTypeDef* htim = timers[i];
 4096              		.loc 22 45 9 is_stmt 1 view .LVU861
 4097              	.LVL295:
  45:./Drivers/STM32/stm32_timer.hpp ****             TIM_HandleTypeDef* htim = timers[i];
 4098              		.loc 22 45 30 view .LVU862
 4099              	.LBB1102:
  46:./Drivers/STM32/stm32_timer.hpp **** 
 4100              		.loc 22 46 45 is_stmt 0 view .LVU863
 4101 0046 0121     		movs	r1, #1
 4102 0048 2046     		mov	r0, r4
 4103 004a FFF7FEFF 		bl	_ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj
 4104              	.LVL296:
  49:./Drivers/STM32/stm32_timer.hpp **** 
 4105              		.loc 22 49 19 view .LVU864
 4106 004e 0368     		ldr	r3, [r0]
 4107 0050 1D68     		ldr	r5, [r3]
  49:./Drivers/STM32/stm32_timer.hpp **** 
 4108              		.loc 22 49 33 view .LVU865
 4109 0052 2B68     		ldr	r3, [r5]
 4110 0054 3B40     		ands	r3, r3, r7
 4111 0056 2B60     		str	r3, [r5]
  53:./Drivers/STM32/stm32_timer.hpp ****             htim->Instance->EGR |= TIM_EGR_UG;
 4112              		.loc 22 53 13 view .LVU866
 4113 0058 EB68     		ldr	r3, [r5, #12]
 4114 005a 3B40     		ands	r3, r3, r7
 4115 005c EB60     		str	r3, [r5, #12]
  54:./Drivers/STM32/stm32_timer.hpp ****             __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 4116              		.loc 22 54 33 view .LVU867
 4117 005e 6B69     		ldr	r3, [r5, #20]
 4118 0060 43F00103 		orr	r3, r3, #1
 4119 0064 6B61     		str	r3, [r5, #20]
 4120              		.loc 22 58 43 view .LVU868
 4121 0066 0121     		movs	r1, #1
  55:./Drivers/STM32/stm32_timer.hpp **** 
 4122              		.loc 22 55 13 view .LVU869
ARM GAS  /tmp/ccysU9ly.s 			page 178


 4123 0068 2F61     		str	r7, [r5, #16]
 4124              		.loc 22 58 43 view .LVU870
 4125 006a 3046     		mov	r0, r6
 4126 006c FFF7FEFF 		bl	_ZNSt5arrayIjLj3EEixEj
 4127              	.LVL297:
 4128              		.loc 22 58 33 view .LVU871
 4129 0070 0368     		ldr	r3, [r0]
 4130 0072 6B62     		str	r3, [r5, #36]
 4131              	.LBE1102:
  45:./Drivers/STM32/stm32_timer.hpp ****             TIM_HandleTypeDef* htim = timers[i];
 4132              		.loc 22 45 9 is_stmt 1 view .LVU872
 4133              	.LVL298:
  45:./Drivers/STM32/stm32_timer.hpp ****             TIM_HandleTypeDef* htim = timers[i];
 4134              		.loc 22 45 30 view .LVU873
 4135              	.LBB1103:
  46:./Drivers/STM32/stm32_timer.hpp **** 
 4136              		.loc 22 46 45 is_stmt 0 view .LVU874
 4137 0074 0221     		movs	r1, #2
 4138 0076 2046     		mov	r0, r4
 4139 0078 FFF7FEFF 		bl	_ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj
 4140              	.LVL299:
 4141 007c 0346     		mov	r3, r0
 4142              	.LVL300:
 4143              		.loc 22 58 43 view .LVU875
 4144 007e 0221     		movs	r1, #2
  49:./Drivers/STM32/stm32_timer.hpp **** 
 4145              		.loc 22 49 19 view .LVU876
 4146 0080 1B68     		ldr	r3, [r3]
 4147 0082 1D68     		ldr	r5, [r3]
  49:./Drivers/STM32/stm32_timer.hpp **** 
 4148              		.loc 22 49 33 view .LVU877
 4149 0084 2B68     		ldr	r3, [r5]
 4150 0086 3B40     		ands	r3, r3, r7
 4151 0088 2B60     		str	r3, [r5]
  53:./Drivers/STM32/stm32_timer.hpp ****             htim->Instance->EGR |= TIM_EGR_UG;
 4152              		.loc 22 53 13 view .LVU878
 4153 008a EB68     		ldr	r3, [r5, #12]
 4154 008c 3B40     		ands	r3, r3, r7
 4155 008e EB60     		str	r3, [r5, #12]
  54:./Drivers/STM32/stm32_timer.hpp ****             __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 4156              		.loc 22 54 33 view .LVU879
 4157 0090 6B69     		ldr	r3, [r5, #20]
 4158 0092 43F00103 		orr	r3, r3, #1
 4159 0096 6B61     		str	r3, [r5, #20]
 4160              		.loc 22 58 43 view .LVU880
 4161 0098 3046     		mov	r0, r6
  55:./Drivers/STM32/stm32_timer.hpp **** 
 4162              		.loc 22 55 13 view .LVU881
 4163 009a 2F61     		str	r7, [r5, #16]
 4164              		.loc 22 58 43 view .LVU882
 4165 009c FFF7FEFF 		bl	_ZNSt5arrayIjLj3EEixEj
 4166              	.LVL301:
 4167              		.loc 22 58 33 view .LVU883
 4168 00a0 0368     		ldr	r3, [r0]
 4169 00a2 6B62     		str	r3, [r5, #36]
 4170              	.LBE1103:
  45:./Drivers/STM32/stm32_timer.hpp ****             TIM_HandleTypeDef* htim = timers[i];
ARM GAS  /tmp/ccysU9ly.s 			page 179


 4171              		.loc 22 45 9 is_stmt 1 view .LVU884
 4172              	.LVL302:
  45:./Drivers/STM32/stm32_timer.hpp ****             TIM_HandleTypeDef* htim = timers[i];
 4173              		.loc 22 45 30 view .LVU885
  45:./Drivers/STM32/stm32_timer.hpp ****             TIM_HandleTypeDef* htim = timers[i];
 4174              		.loc 22 45 30 is_stmt 0 view .LVU886
 4175              	.LBE1105:
 4176              	.LBB1106:
  59:./Drivers/STM32/stm32_timer.hpp ****         }
  60:./Drivers/STM32/stm32_timer.hpp **** 
  61:./Drivers/STM32/stm32_timer.hpp ****         register volatile uint32_t* cr_addr[I];
  62:./Drivers/STM32/stm32_timer.hpp ****         register uint32_t cr_val[I];
  63:./Drivers/STM32/stm32_timer.hpp ****         for (size_t i = 0; i < I; ++i) {
  64:./Drivers/STM32/stm32_timer.hpp ****             cr_addr[i] = &timers[i]->Instance->CR1;
 4177              		.loc 22 64 33 view .LVU887
 4178 00a4 0021     		movs	r1, #0
 4179 00a6 2046     		mov	r0, r4
 4180 00a8 FFF7FEFF 		bl	_ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj
 4181              	.LVL303:
 4182              		.loc 22 64 38 view .LVU888
 4183 00ac 0368     		ldr	r3, [r0]
  65:./Drivers/STM32/stm32_timer.hpp ****             cr_val[i] = timers[i]->Instance->CR1 | TIM_CR1_CEN;
 4184              		.loc 22 65 31 view .LVU889
 4185 00ae 0021     		movs	r1, #0
 4186 00b0 2046     		mov	r0, r4
  64:./Drivers/STM32/stm32_timer.hpp ****             cr_val[i] = timers[i]->Instance->CR1 | TIM_CR1_CEN;
 4187              		.loc 22 64 38 view .LVU890
 4188 00b2 D3F80090 		ldr	r9, [r3]
 4189              		.loc 22 65 31 view .LVU891
 4190 00b6 FFF7FEFF 		bl	_ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj
 4191              	.LVL304:
 4192              		.loc 22 65 36 view .LVU892
 4193 00ba 0368     		ldr	r3, [r0]
 4194 00bc 1B68     		ldr	r3, [r3]
 4195              		.loc 22 65 46 view .LVU893
 4196 00be 1E68     		ldr	r6, [r3]
  64:./Drivers/STM32/stm32_timer.hpp ****             cr_val[i] = timers[i]->Instance->CR1 | TIM_CR1_CEN;
 4197              		.loc 22 64 33 view .LVU894
 4198 00c0 0121     		movs	r1, #1
 4199 00c2 2046     		mov	r0, r4
 4200              		.loc 22 65 50 view .LVU895
 4201 00c4 0E43     		orrs	r6, r6, r1
  63:./Drivers/STM32/stm32_timer.hpp ****             cr_addr[i] = &timers[i]->Instance->CR1;
 4202              		.loc 22 63 9 is_stmt 1 view .LVU896
 4203              	.LVL305:
  63:./Drivers/STM32/stm32_timer.hpp ****             cr_addr[i] = &timers[i]->Instance->CR1;
 4204              		.loc 22 63 30 view .LVU897
  64:./Drivers/STM32/stm32_timer.hpp ****             cr_val[i] = timers[i]->Instance->CR1 | TIM_CR1_CEN;
 4205              		.loc 22 64 33 is_stmt 0 view .LVU898
 4206 00c6 FFF7FEFF 		bl	_ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj
 4207              	.LVL306:
  64:./Drivers/STM32/stm32_timer.hpp ****             cr_val[i] = timers[i]->Instance->CR1 | TIM_CR1_CEN;
 4208              		.loc 22 64 38 view .LVU899
 4209 00ca 0368     		ldr	r3, [r0]
 4210              		.loc 22 65 31 view .LVU900
 4211 00cc 0121     		movs	r1, #1
 4212 00ce 2046     		mov	r0, r4
ARM GAS  /tmp/ccysU9ly.s 			page 180


  64:./Drivers/STM32/stm32_timer.hpp ****             cr_val[i] = timers[i]->Instance->CR1 | TIM_CR1_CEN;
 4213              		.loc 22 64 38 view .LVU901
 4214 00d0 D3F80080 		ldr	r8, [r3]
 4215              		.loc 22 65 31 view .LVU902
 4216 00d4 FFF7FEFF 		bl	_ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj
 4217              	.LVL307:
 4218              		.loc 22 65 36 view .LVU903
 4219 00d8 0368     		ldr	r3, [r0]
 4220 00da 1B68     		ldr	r3, [r3]
  64:./Drivers/STM32/stm32_timer.hpp ****             cr_val[i] = timers[i]->Instance->CR1 | TIM_CR1_CEN;
 4221              		.loc 22 64 33 view .LVU904
 4222 00dc 0221     		movs	r1, #2
 4223 00de 2046     		mov	r0, r4
 4224              		.loc 22 65 46 view .LVU905
 4225 00e0 1D68     		ldr	r5, [r3]
  64:./Drivers/STM32/stm32_timer.hpp ****             cr_val[i] = timers[i]->Instance->CR1 | TIM_CR1_CEN;
 4226              		.loc 22 64 33 view .LVU906
 4227 00e2 FFF7FEFF 		bl	_ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj
 4228              	.LVL308:
 4229 00e6 0346     		mov	r3, r0
 4230              		.loc 22 65 31 view .LVU907
 4231 00e8 0221     		movs	r1, #2
  64:./Drivers/STM32/stm32_timer.hpp ****             cr_val[i] = timers[i]->Instance->CR1 | TIM_CR1_CEN;
 4232              		.loc 22 64 38 view .LVU908
 4233 00ea 1B68     		ldr	r3, [r3]
 4234              		.loc 22 65 31 view .LVU909
 4235 00ec 2046     		mov	r0, r4
  64:./Drivers/STM32/stm32_timer.hpp ****             cr_val[i] = timers[i]->Instance->CR1 | TIM_CR1_CEN;
 4236              		.loc 22 64 38 view .LVU910
 4237 00ee 1F68     		ldr	r7, [r3]
 4238              		.loc 22 65 31 view .LVU911
 4239 00f0 FFF7FEFF 		bl	_ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj
 4240              	.LVL309:
 4241              		.loc 22 65 36 view .LVU912
 4242 00f4 0368     		ldr	r3, [r0]
 4243 00f6 1B68     		ldr	r3, [r3]
 4244              		.loc 22 65 46 view .LVU913
 4245 00f8 1C68     		ldr	r4, [r3]
 4246              		.loc 22 65 50 view .LVU914
 4247 00fa 45F00105 		orr	r5, r5, #1
  63:./Drivers/STM32/stm32_timer.hpp ****             cr_addr[i] = &timers[i]->Instance->CR1;
 4248              		.loc 22 63 9 is_stmt 1 view .LVU915
 4249              	.LVL310:
  63:./Drivers/STM32/stm32_timer.hpp ****             cr_addr[i] = &timers[i]->Instance->CR1;
 4250              		.loc 22 63 30 view .LVU916
 4251              		.loc 22 65 50 is_stmt 0 view .LVU917
 4252 00fe 44F00104 		orr	r4, r4, #1
  63:./Drivers/STM32/stm32_timer.hpp ****             cr_addr[i] = &timers[i]->Instance->CR1;
 4253              		.loc 22 63 9 is_stmt 1 view .LVU918
 4254              	.LVL311:
  63:./Drivers/STM32/stm32_timer.hpp ****             cr_addr[i] = &timers[i]->Instance->CR1;
 4255              		.loc 22 63 30 view .LVU919
 4256              	.LBE1106:
  66:./Drivers/STM32/stm32_timer.hpp ****         }
  67:./Drivers/STM32/stm32_timer.hpp **** 
  68:./Drivers/STM32/stm32_timer.hpp ****         // Restart all timers as atomically as possible.
  69:./Drivers/STM32/stm32_timer.hpp ****         // By inspection we find that this is compiled to the following code:
ARM GAS  /tmp/ccysU9ly.s 			page 181


  70:./Drivers/STM32/stm32_timer.hpp ****         //    f7ff faa0 	bl	800bdd0 <cpu_enter_critical()>
  71:./Drivers/STM32/stm32_timer.hpp ****         //    f8c9 6000 	str.w	r6, [r9]
  72:./Drivers/STM32/stm32_timer.hpp ****         //    f8c8 5000 	str.w	r5, [r8]
  73:./Drivers/STM32/stm32_timer.hpp ****         //    603c      	str	r4, [r7, #0]
  74:./Drivers/STM32/stm32_timer.hpp ****         //    f7ff fa9d 	bl	800bdd8 <cpu_exit_critical(unsigned long)>
  75:./Drivers/STM32/stm32_timer.hpp ****         uint32_t mask = cpu_enter_critical();
 4257              		.loc 22 75 43 is_stmt 0 view .LVU920
 4258 0102 FFF7FEFF 		bl	cpu_enter_critical
 4259              	.LVL312:
  76:./Drivers/STM32/stm32_timer.hpp ****         int dummy[I] = {(*cr_addr[Is] = cr_val[Is], 0)...};
 4260              		.loc 22 76 39 view .LVU921
 4261 0106 C9F80060 		str	r6, [r9]
 4262              	.LVL313:
 4263              		.loc 22 76 39 view .LVU922
 4264 010a C8F80050 		str	r5, [r8]
 4265              	.LVL314:
 4266              		.loc 22 76 39 view .LVU923
 4267 010e 3C60     		str	r4, [r7]
 4268              	.LVL315:
  77:./Drivers/STM32/stm32_timer.hpp ****         (void)dummy;
  78:./Drivers/STM32/stm32_timer.hpp ****         cpu_exit_critical(mask);
 4269              		.loc 22 78 26 view .LVU924
 4270 0110 FFF7FEFF 		bl	cpu_exit_critical
 4271              	.LVL316:
  79:./Drivers/STM32/stm32_timer.hpp ****     }
 4272              		.loc 22 79 5 view .LVU925
 4273 0114 05B0     		add	sp, sp, #20
 4274              	.LCFI32:
 4275              		.cfi_def_cfa_offset 36
 4276              		@ sp needed
 4277 0116 BDE8F043 		pop	{r4, r5, r6, r7, r8, r9, lr}
 4278              	.LCFI33:
 4279              		.cfi_restore 14
 4280              		.cfi_restore 9
 4281              		.cfi_restore 8
 4282              		.cfi_restore 7
 4283              		.cfi_restore 6
 4284              		.cfi_restore 5
 4285              		.cfi_restore 4
 4286              		.cfi_def_cfa_offset 8
 4287 011a 02B0     		add	sp, sp, #8
 4288              	.LCFI34:
 4289              		.cfi_def_cfa_offset 0
 4290 011c 7047     		bx	lr
 4291              		.cfi_endproc
 4292              	.LFE5944:
 4293              		.cantunwind
 4294              		.fnend
 4296 011e 00BF     		.section	.text._Z12start_timersv,"ax",%progbits
 4297              		.align	1
 4298              		.p2align 2,,3
 4299              		.global	_Z12start_timersv
 4300              		.syntax unified
 4301              		.thumb
 4302              		.thumb_func
 4304              	_Z12start_timersv:
 4305              		.fnstart
ARM GAS  /tmp/ccysU9ly.s 			page 182


 4306              	.LFB5223:
 381:Board/v3/board.cpp ****     CRITICAL_SECTION() {
 4307              		.loc 4 381 21 is_stmt 1 view -0
 4308              		.cfi_startproc
 4309              		@ args = 0, pretend = 0, frame = 56
 4310              		@ frame_needed = 0, uses_anonymous_args = 0
 4311 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 4312              	.LCFI35:
 4313              		.cfi_def_cfa_offset 20
 4314              		.cfi_offset 4, -20
 4315              		.cfi_offset 5, -16
 4316              		.cfi_offset 6, -12
 4317              		.cfi_offset 7, -8
 4318              		.cfi_offset 14, -4
 4319 0002 93B0     		sub	sp, sp, #76
 4320              	.LCFI36:
 4321              		.cfi_def_cfa_offset 96
 382:Board/v3/board.cpp ****         // Temporarily disable ADC triggers so they don't trigger as a side
 4322              		.loc 4 382 5 view .LVU927
 4323              	.LVL317:
 4324              	.LBB1107:
 4325              	.LBB1108:
 4326              	.LBI1108:
  40:./Drivers/STM32/stm32_system.h **** 
  41:./Drivers/STM32/stm32_system.h **** #ifdef __cplusplus
  42:./Drivers/STM32/stm32_system.h **** }
  43:./Drivers/STM32/stm32_system.h **** #endif
  44:./Drivers/STM32/stm32_system.h **** 
  45:./Drivers/STM32/stm32_system.h **** 
  46:./Drivers/STM32/stm32_system.h **** // C++ only definitions
  47:./Drivers/STM32/stm32_system.h **** 
  48:./Drivers/STM32/stm32_system.h **** #ifdef __cplusplus
  49:./Drivers/STM32/stm32_system.h **** 
  50:./Drivers/STM32/stm32_system.h **** struct CriticalSectionContext {
  51:./Drivers/STM32/stm32_system.h ****     CriticalSectionContext(const CriticalSectionContext&) = delete;
  52:./Drivers/STM32/stm32_system.h ****     CriticalSectionContext(const CriticalSectionContext&&) = delete;
  53:./Drivers/STM32/stm32_system.h ****     void operator=(const CriticalSectionContext&) = delete;
  54:./Drivers/STM32/stm32_system.h ****     void operator=(const CriticalSectionContext&&) = delete;
  55:./Drivers/STM32/stm32_system.h ****     operator bool() { return true; };
  56:./Drivers/STM32/stm32_system.h ****     CriticalSectionContext() : mask_(cpu_enter_critical()) {}
 4327              		.loc 1 56 5 view .LVU928
 4328              	.LBB1109:
 4329              	.LBB1110:
 4330              	.LBB1111:
 4331              	.LBI1111:
  31:./Drivers/STM32/stm32_system.h ****     uint32_t primask = __get_PRIMASK();
 4332              		.loc 1 31 24 view .LVU929
 4333              	.LBB1112:
  32:./Drivers/STM32/stm32_system.h ****     __disable_irq();
 4334              		.loc 1 32 5 view .LVU930
 4335              	.LBB1113:
 4336              	.LBI1113:
 382:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 4337              		.loc 2 382 31 view .LVU931
 4338              	.LBB1114:
 384:ThirdParty/CMSIS/Include/cmsis_gcc.h **** 
 4339              		.loc 2 384 3 view .LVU932
ARM GAS  /tmp/ccysU9ly.s 			page 183


 386:ThirdParty/CMSIS/Include/cmsis_gcc.h ****   return(result);
 4340              		.loc 2 386 3 view .LVU933
 4341              		.syntax unified
 4342              	@ 386 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 4343 0004 EFF31087 		MRS r7, primask
 4344              	@ 0 "" 2
 4345              	.LVL318:
 387:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 4346              		.loc 2 387 3 view .LVU934
 387:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 4347              		.loc 2 387 3 is_stmt 0 view .LVU935
 4348              		.thumb
 4349              		.syntax unified
 4350              	.LBE1114:
 4351              	.LBE1113:
  33:./Drivers/STM32/stm32_system.h ****     return primask;
 4352              		.loc 1 33 5 is_stmt 1 view .LVU936
 4353              	.LBB1115:
 4354              	.LBI1115:
 140:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 4355              		.loc 2 140 27 view .LVU937
 4356              	.LBB1116:
 142:ThirdParty/CMSIS/Include/cmsis_gcc.h **** }
 4357              		.loc 2 142 3 view .LVU938
 4358              		.syntax unified
 4359              	@ 142 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 4360 0008 72B6     		cpsid i
 4361              	@ 0 "" 2
 4362              		.thumb
 4363              		.syntax unified
 4364              	.LBE1116:
 4365              	.LBE1115:
  34:./Drivers/STM32/stm32_system.h **** }
 4366              		.loc 1 34 5 view .LVU939
 4367              	.LBE1112:
 4368              	.LBE1111:
 4369              		.loc 1 56 58 is_stmt 0 view .LVU940
 4370 000a 0497     		str	r7, [sp, #16]
 4371 000c 0023     		movs	r3, #0
 4372 000e 8DF81430 		strb	r3, [sp, #20]
 4373              	.LVL319:
 4374              		.loc 1 56 58 view .LVU941
 4375              	.LBE1110:
 4376              	.LBE1109:
 4377              	.LBE1108:
 4378              	.LBE1107:
  55:./Drivers/STM32/stm32_system.h ****     CriticalSectionContext() : mask_(cpu_enter_critical()) {}
 4379              		.loc 1 55 23 is_stmt 1 view .LVU942
 4380              	.LBB1127:
 385:Board/v3/board.cpp ****         hadc2.Instance->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_JEXTEN);
 4381              		.loc 4 385 9 view .LVU943
 385:Board/v3/board.cpp ****         hadc2.Instance->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_JEXTEN);
 4382              		.loc 4 385 15 is_stmt 0 view .LVU944
 4383 0012 3B4E     		ldr	r6, .L186
 4384 0014 3268     		ldr	r2, [r6]
 385:Board/v3/board.cpp ****         hadc2.Instance->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_JEXTEN);
 4385              		.loc 4 385 29 view .LVU945
ARM GAS  /tmp/ccysU9ly.s 			page 184


 4386 0016 9368     		ldr	r3, [r2, #8]
 4387 0018 23F44013 		bic	r3, r3, #3145728
 4388 001c 9360     		str	r3, [r2, #8]
 386:Board/v3/board.cpp ****         hadc3.Instance->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_JEXTEN);
 4389              		.loc 4 386 9 is_stmt 1 view .LVU946
 386:Board/v3/board.cpp ****         hadc3.Instance->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_JEXTEN);
 4390              		.loc 4 386 15 is_stmt 0 view .LVU947
 4391 001e 394D     		ldr	r5, .L186+4
 4392 0020 2A68     		ldr	r2, [r5]
 386:Board/v3/board.cpp ****         hadc3.Instance->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_JEXTEN);
 4393              		.loc 4 386 29 view .LVU948
 4394 0022 9368     		ldr	r3, [r2, #8]
 4395 0024 23F04053 		bic	r3, r3, #805306368
 4396 0028 23F44013 		bic	r3, r3, #3145728
 4397 002c 9360     		str	r3, [r2, #8]
 387:Board/v3/board.cpp **** 
 4398              		.loc 4 387 9 is_stmt 1 view .LVU949
 387:Board/v3/board.cpp **** 
 4399              		.loc 4 387 15 is_stmt 0 view .LVU950
 4400 002e 364C     		ldr	r4, .L186+8
 4401 0030 2268     		ldr	r2, [r4]
 387:Board/v3/board.cpp **** 
 4402              		.loc 4 387 29 view .LVU951
 4403 0032 9368     		ldr	r3, [r2, #8]
 4404 0034 23F04053 		bic	r3, r3, #805306368
 4405 0038 23F44013 		bic	r3, r3, #3145728
 4406 003c 9360     		str	r3, [r2, #8]
 395:Board/v3/board.cpp ****             {&htim1, &htim8, &htim13},
 4407              		.loc 4 395 9 is_stmt 1 view .LVU952
 395:Board/v3/board.cpp ****             {&htim1, &htim8, &htim13},
 4408              		.loc 4 395 43 is_stmt 0 view .LVU953
 4409 003e DFF8D0C0 		ldr	ip, .L186+16
 4410 0042 0DF1300E 		add	lr, sp, #48
 4411 0046 0CF10803 		add	r3, ip, #8
 4412 004a 93E80700 		ldm	r3, {r0, r1, r2}
 4413 004e 8EE80700 		stm	lr, {r0, r1, r2}
 4414 0052 0FAB     		add	r3, sp, #60
 4415 0054 0CF11402 		add	r2, ip, #20
 4416 0058 07CA     		ldm	r2, {r0, r1, r2}
 4417 005a 83E80700 		stm	r3, {r0, r1, r2}
 4418 005e 0DF1180C 		add	ip, sp, #24
 4419 0062 9EE80700 		ldm	lr, {r0, r1, r2}
 4420 0066 8CE80700 		stm	ip, {r0, r1, r2}
 4421 006a 0DF1240E 		add	lr, sp, #36
 4422 006e 93E80700 		ldm	r3, {r0, r1, r2}
 4423 0072 8EE80700 		stm	lr, {r0, r1, r2}
 4424              	.LBB1117:
 4425              	.LBI1117:
  34:./Drivers/STM32/stm32_timer.hpp ****         start_synchronously_impl(timers, counters, std::make_index_sequence<I>());
 4426              		.loc 22 34 17 is_stmt 1 view .LVU954
 4427              	.LBB1118:
  35:./Drivers/STM32/stm32_timer.hpp ****     }
 4428              		.loc 22 35 33 is_stmt 0 view .LVU955
 4429 0076 4FF00003 		mov	r3, #0
 4430 007a 8DF80830 		strb	r3, [sp, #8]
 4431 007e 0AAB     		add	r3, sp, #40
 4432 0080 93E80300 		ldm	r3, {r0, r1}
ARM GAS  /tmp/ccysU9ly.s 			page 185


 4433 0084 8DE80300 		stm	sp, {r0, r1}
 4434 0088 099B     		ldr	r3, [sp, #36]
 4435 008a 9CE80700 		ldm	ip, {r0, r1, r2}
 4436 008e FFF7FEFF 		bl	_ZN10Stm32Timer24start_synchronously_implILj3EJLj0ELj1ELj2EEEEvSt5arrayIP17TIM_HandleTypeDefXT_
 4437              	.LVL320:
 4438              	.LBE1118:
 4439              	.LBE1117:
 400:Board/v3/board.cpp ****         hadc2.Instance->CR2 |= (ADC_EXTERNALTRIGCONVEDGE_RISING | ADC_EXTERNALTRIGINJECCONVEDGE_RIS
 4440              		.loc 4 400 9 is_stmt 1 view .LVU956
 400:Board/v3/board.cpp ****         hadc2.Instance->CR2 |= (ADC_EXTERNALTRIGCONVEDGE_RISING | ADC_EXTERNALTRIGINJECCONVEDGE_RIS
 4441              		.loc 4 400 15 is_stmt 0 view .LVU957
 4442 0092 3268     		ldr	r2, [r6]
 400:Board/v3/board.cpp ****         hadc2.Instance->CR2 |= (ADC_EXTERNALTRIGCONVEDGE_RISING | ADC_EXTERNALTRIGINJECCONVEDGE_RIS
 4443              		.loc 4 400 29 view .LVU958
 4444 0094 9368     		ldr	r3, [r2, #8]
 4445 0096 43F48013 		orr	r3, r3, #1048576
 4446 009a 9360     		str	r3, [r2, #8]
 401:Board/v3/board.cpp ****         hadc3.Instance->CR2 |= (ADC_EXTERNALTRIGCONVEDGE_RISING | ADC_EXTERNALTRIGINJECCONVEDGE_RIS
 4447              		.loc 4 401 9 is_stmt 1 view .LVU959
 401:Board/v3/board.cpp ****         hadc3.Instance->CR2 |= (ADC_EXTERNALTRIGCONVEDGE_RISING | ADC_EXTERNALTRIGINJECCONVEDGE_RIS
 4448              		.loc 4 401 15 is_stmt 0 view .LVU960
 4449 009c 2968     		ldr	r1, [r5]
 401:Board/v3/board.cpp ****         hadc3.Instance->CR2 |= (ADC_EXTERNALTRIGCONVEDGE_RISING | ADC_EXTERNALTRIGINJECCONVEDGE_RIS
 4450              		.loc 4 401 29 view .LVU961
 4451 009e 8B68     		ldr	r3, [r1, #8]
 4452 00a0 43F08053 		orr	r3, r3, #268435456
 4453 00a4 43F48013 		orr	r3, r3, #1048576
 4454 00a8 8B60     		str	r3, [r1, #8]
 402:Board/v3/board.cpp **** 
 4455              		.loc 4 402 9 is_stmt 1 view .LVU962
 402:Board/v3/board.cpp **** 
 4456              		.loc 4 402 15 is_stmt 0 view .LVU963
 4457 00aa 2168     		ldr	r1, [r4]
 402:Board/v3/board.cpp **** 
 4458              		.loc 4 402 29 view .LVU964
 4459 00ac 8B68     		ldr	r3, [r1, #8]
 4460 00ae 43F08053 		orr	r3, r3, #268435456
 4461 00b2 43F48013 		orr	r3, r3, #1048576
 4462 00b6 8B60     		str	r3, [r1, #8]
 404:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_JEOC);
 4463              		.loc 4 404 9 is_stmt 1 view .LVU965
 4464 00b8 6FF00403 		mvn	r3, #4
 4465 00bc 1360     		str	r3, [r2]
 405:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_JEOC);
 4466              		.loc 4 405 9 view .LVU966
 4467 00be 2A68     		ldr	r2, [r5]
 4468 00c0 1360     		str	r3, [r2]
 406:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc1, ADC_FLAG_EOC);
 4469              		.loc 4 406 9 view .LVU967
 4470 00c2 2268     		ldr	r2, [r4]
 4471 00c4 1360     		str	r3, [r2]
 407:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_EOC);
 4472              		.loc 4 407 9 view .LVU968
 4473 00c6 3268     		ldr	r2, [r6]
 4474 00c8 6FF00203 		mvn	r3, #2
 4475 00cc 1360     		str	r3, [r2]
 408:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_EOC);
ARM GAS  /tmp/ccysU9ly.s 			page 186


 4476              		.loc 4 408 9 view .LVU969
 4477 00ce 2A68     		ldr	r2, [r5]
 4478 00d0 1360     		str	r3, [r2]
 409:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc1, ADC_FLAG_OVR);
 4479              		.loc 4 409 9 view .LVU970
 4480 00d2 2268     		ldr	r2, [r4]
 4481 00d4 1360     		str	r3, [r2]
 410:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_OVR);
 4482              		.loc 4 410 9 view .LVU971
 4483 00d6 3268     		ldr	r2, [r6]
 4484 00d8 6FF02003 		mvn	r3, #32
 4485 00dc 1360     		str	r3, [r2]
 411:Board/v3/board.cpp ****         __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_OVR);
 4486              		.loc 4 411 9 view .LVU972
 4487 00de 2A68     		ldr	r2, [r5]
 4488 00e0 1360     		str	r3, [r2]
 412:Board/v3/board.cpp ****         
 4489              		.loc 4 412 9 view .LVU973
 4490 00e2 2268     		ldr	r2, [r4]
 4491 00e4 1360     		str	r3, [r2]
 414:Board/v3/board.cpp ****         __HAL_TIM_ENABLE_IT(&htim8, TIM_IT_UPDATE);
 4492              		.loc 4 414 9 view .LVU974
 4493 00e6 094B     		ldr	r3, .L186+12
 4494 00e8 1B68     		ldr	r3, [r3]
 4495 00ea 6FF00102 		mvn	r2, #1
 4496 00ee 1A61     		str	r2, [r3, #16]
 415:Board/v3/board.cpp ****     }
 4497              		.loc 4 415 9 view .LVU975
 4498 00f0 DA68     		ldr	r2, [r3, #12]
 4499 00f2 42F00102 		orr	r2, r2, #1
 4500 00f6 DA60     		str	r2, [r3, #12]
 4501              	.LVL321:
 4502              	.LBB1119:
 4503              	.LBI1119:
  57:./Drivers/STM32/stm32_system.h ****     ~CriticalSectionContext() { cpu_exit_critical(mask_); }
 4504              		.loc 1 57 5 view .LVU976
 4505              	.LBB1120:
 4506              		.loc 1 57 33 view .LVU977
 4507              	.LBB1121:
 4508              	.LBI1121:
  37:./Drivers/STM32/stm32_system.h ****     __set_PRIMASK(priority_mask);
 4509              		.loc 1 37 20 view .LVU978
 4510              	.LBE1121:
 4511              	.LBE1120:
 4512              	.LBE1119:
 4513              	.LBE1127:
  38:./Drivers/STM32/stm32_system.h **** }
 4514              		.loc 1 38 5 view .LVU979
 4515              	.LBB1128:
 4516              	.LBB1126:
 4517              	.LBB1125:
 4518              	.LBB1124:
 4519              	.LBB1122:
 4520              	.LBI1122:
 412:ThirdParty/CMSIS/Include/cmsis_gcc.h **** {
 4521              		.loc 2 412 27 view .LVU980
 4522              	.LBB1123:
ARM GAS  /tmp/ccysU9ly.s 			page 187


 4523              		.loc 2 414 3 view .LVU981
 4524              		.syntax unified
 4525              	@ 414 "ThirdParty/CMSIS/Include/cmsis_gcc.h" 1
 4526 00f8 87F31088 		MSR primask, r7
 4527              	@ 0 "" 2
 4528              	.LVL322:
 4529              		.loc 2 414 3 is_stmt 0 view .LVU982
 4530              		.thumb
 4531              		.syntax unified
 4532              	.LBE1123:
 4533              	.LBE1122:
 4534              	.LBE1124:
 4535              	.LBE1125:
 4536              	.LBE1126:
 4537              	.LBE1128:
 417:Board/v3/board.cpp **** 
 4538              		.loc 4 417 1 view .LVU983
 4539 00fc 13B0     		add	sp, sp, #76
 4540              	.LCFI37:
 4541              		.cfi_def_cfa_offset 20
 4542              		@ sp needed
 4543 00fe F0BD     		pop	{r4, r5, r6, r7, pc}
 4544              	.LVL323:
 4545              	.L187:
 417:Board/v3/board.cpp **** 
 4546              		.loc 4 417 1 view .LVU984
 4547              		.align	2
 4548              	.L186:
 4549 0100 00000000 		.word	hadc1
 4550 0104 00000000 		.word	hadc2
 4551 0108 00000000 		.word	hadc3
 4552 010c 00000000 		.word	htim8
 4553 0110 00000000 		.word	.LANCHOR14
 4554              		.cfi_endproc
 4555              	.LFE5223:
 4556              		.cantunwind
 4557              		.fnend
 4559              		.section	.text._GLOBAL__sub_I__ZN9TaskTimer7enabledE,"ax",%progbits
 4560              		.align	1
 4561              		.p2align 2,,3
 4562              		.syntax unified
 4563              		.thumb
 4564              		.thumb_func
 4566              	_GLOBAL__sub_I__ZN9TaskTimer7enabledE:
 4567              		.fnstart
 4568              	.LFB6285:
 4569              		.loc 4 594 1 is_stmt 1 view -0
 4570              		.cfi_startproc
 4571              		@ args = 0, pretend = 0, frame = 0
 4572              		@ frame_needed = 0, uses_anonymous_args = 0
 4573 0000 08B5     		push	{r3, lr}
 4574              	.LCFI38:
 4575              		.cfi_def_cfa_offset 8
 4576              		.cfi_offset 3, -8
 4577              		.cfi_offset 14, -4
 4578              		.loc 4 594 1 is_stmt 0 view .LVU986
 4579 0002 4FF6FF71 		movw	r1, #65535
ARM GAS  /tmp/ccysU9ly.s 			page 188


 4580 0006 0120     		movs	r0, #1
 4581 0008 FFF7FEFF 		bl	_Z41__static_initialization_and_destruction_0ii
 4582              	.LVL324:
 4583 000c 08BD     		pop	{r3, pc}
 4584              		.cfi_endproc
 4585              	.LFE6285:
 4586              		.cantunwind
 4587              		.fnend
 4589 000e 00BF     		.section	.init_array,"aw",%init_array
 4590              		.align	2
 4591 0000 00000000 		.word	_GLOBAL__sub_I__ZN9TaskTimer7enabledE(target1)
 4592              		.weak	_ZTS14GateDriverBase
 4593              		.section	.rodata._ZTS14GateDriverBase,"aG",%progbits,_ZTS14GateDriverBase,comdat
 4594              		.align	2
 4597              	_ZTS14GateDriverBase:
 4598 0000 31344761 		.ascii	"14GateDriverBase\000"
 4598      74654472 
 4598      69766572 
 4598      42617365 
 4598      00
 4599              		.weak	_ZTI14GateDriverBase
 4600              		.section	.rodata._ZTI14GateDriverBase,"aG",%progbits,_ZTI14GateDriverBase,comdat
 4601              		.align	2
 4604              	_ZTI14GateDriverBase:
 4605 0000 08000000 		.word	_ZTVN10__cxxabiv117__class_type_infoE+8
 4606 0004 00000000 		.word	_ZTS14GateDriverBase
 4607              		.weak	_ZTS9OpAmpBase
 4608              		.section	.rodata._ZTS9OpAmpBase,"aG",%progbits,_ZTS9OpAmpBase,comdat
 4609              		.align	2
 4612              	_ZTS9OpAmpBase:
 4613 0000 394F7041 		.ascii	"9OpAmpBase\000"
 4613      6D704261 
 4613      736500
 4614              		.weak	_ZTI9OpAmpBase
 4615              		.section	.rodata._ZTI9OpAmpBase,"aG",%progbits,_ZTI9OpAmpBase,comdat
 4616              		.align	2
 4619              	_ZTI9OpAmpBase:
 4620 0000 08000000 		.word	_ZTVN10__cxxabiv117__class_type_infoE+8
 4621 0004 00000000 		.word	_ZTS9OpAmpBase
 4622              		.weak	_ZTSN10ODriveIntf14ControllerIntfE
 4623              		.section	.rodata._ZTSN10ODriveIntf14ControllerIntfE,"aG",%progbits,_ZTSN10ODriveIntf14ControllerIn
 4624              		.align	2
 4627              	_ZTSN10ODriveIntf14ControllerIntfE:
 4628 0000 4E31304F 		.ascii	"N10ODriveIntf14ControllerIntfE\000"
 4628      44726976 
 4628      65496E74 
 4628      66313443 
 4628      6F6E7472 
 4629              		.weak	_ZTIN10ODriveIntf14ControllerIntfE
 4630              		.section	.rodata._ZTIN10ODriveIntf14ControllerIntfE,"aG",%progbits,_ZTIN10ODriveIntf14ControllerIn
 4631              		.align	2
 4634              	_ZTIN10ODriveIntf14ControllerIntfE:
 4635 0000 08000000 		.word	_ZTVN10__cxxabiv117__class_type_infoE+8
 4636 0004 00000000 		.word	_ZTSN10ODriveIntf14ControllerIntfE
 4637              		.weak	_ZTSN10ODriveIntf19MechanicalBrakeIntfE
 4638              		.section	.rodata._ZTSN10ODriveIntf19MechanicalBrakeIntfE,"aG",%progbits,_ZTSN10ODriveIntf19Mechani
 4639              		.align	2
ARM GAS  /tmp/ccysU9ly.s 			page 189


 4642              	_ZTSN10ODriveIntf19MechanicalBrakeIntfE:
 4643 0000 4E31304F 		.ascii	"N10ODriveIntf19MechanicalBrakeIntfE\000"
 4643      44726976 
 4643      65496E74 
 4643      6631394D 
 4643      65636861 
 4644              		.weak	_ZTIN10ODriveIntf19MechanicalBrakeIntfE
 4645              		.section	.rodata._ZTIN10ODriveIntf19MechanicalBrakeIntfE,"aG",%progbits,_ZTIN10ODriveIntf19Mechani
 4646              		.align	2
 4649              	_ZTIN10ODriveIntf19MechanicalBrakeIntfE:
 4650 0000 08000000 		.word	_ZTVN10__cxxabiv117__class_type_infoE+8
 4651 0004 00000000 		.word	_ZTSN10ODriveIntf19MechanicalBrakeIntfE
 4652              		.weak	_ZTV14GateDriverBase
 4653              		.section	.rodata._ZTV14GateDriverBase,"aG",%progbits,_ZTV14GateDriverBase,comdat
 4654              		.align	2
 4657              	_ZTV14GateDriverBase:
 4658 0000 00000000 		.word	0
 4659 0004 00000000 		.word	_ZTI14GateDriverBase
 4660 0008 00000000 		.word	__cxa_pure_virtual
 4661 000c 00000000 		.word	__cxa_pure_virtual
 4662              		.weak	_ZTV9OpAmpBase
 4663              		.section	.rodata._ZTV9OpAmpBase,"aG",%progbits,_ZTV9OpAmpBase,comdat
 4664              		.align	2
 4667              	_ZTV9OpAmpBase:
 4668 0000 00000000 		.word	0
 4669 0004 00000000 		.word	_ZTI9OpAmpBase
 4670 0008 00000000 		.word	__cxa_pure_virtual
 4671 000c 00000000 		.word	__cxa_pure_virtual
 4672 0010 00000000 		.word	__cxa_pure_virtual
 4673              		.weak	_ZTVN10ODriveIntf14ControllerIntfE
 4674              		.section	.rodata._ZTVN10ODriveIntf14ControllerIntfE,"aG",%progbits,_ZTVN10ODriveIntf14ControllerIn
 4675              		.align	2
 4678              	_ZTVN10ODriveIntf14ControllerIntfE:
 4679 0000 00000000 		.word	0
 4680 0004 00000000 		.word	_ZTIN10ODriveIntf14ControllerIntfE
 4681 0008 00000000 		.word	__cxa_pure_virtual
 4682 000c 00000000 		.word	__cxa_pure_virtual
 4683 0010 00000000 		.word	__cxa_pure_virtual
 4684 0014 00000000 		.word	__cxa_pure_virtual
 4685              		.weak	_ZTVN10ODriveIntf19MechanicalBrakeIntfE
 4686              		.section	.rodata._ZTVN10ODriveIntf19MechanicalBrakeIntfE,"aG",%progbits,_ZTVN10ODriveIntf19Mechani
 4687              		.align	2
 4690              	_ZTVN10ODriveIntf19MechanicalBrakeIntfE:
 4691 0000 00000000 		.word	0
 4692 0004 00000000 		.word	_ZTIN10ODriveIntf19MechanicalBrakeIntfE
 4693 0008 00000000 		.word	__cxa_pure_virtual
 4694 000c 00000000 		.word	__cxa_pure_virtual
 4695              		.global	counting_down_
 4696              		.global	timestamp_
 4697              		.global	usb_dev_handle
 4698              		.global	pwm0_input
 4699              		.global	alternate_functions
 4700              		.global	gpios
 4701              		.global	axes
 4702              		.global	trap
 4703              		.global	controllers
 4704              		.global	sensorless_estimators
ARM GAS  /tmp/ccysU9ly.s 			page 190


 4705              		.global	mechanical_brakes
 4706              		.global	endstops
 4707              		.global	encoders
 4708              		.global	motors
 4709              		.global	motor_thermistors
 4710              		.global	fet_thermistors
 4711              		.global	m1_gate_driver
 4712              		.global	m0_gate_driver
 4713              		.global	uart_c
 4714              		.global	uart_b
 4715              		.global	uart_a
 4716              		.global	ext_spi_arbiter
 4717              		.global	spi3_arbiter
 4718              		.global	fake_otp
 4719              		.global	_ZN9TaskTimer7enabledE
 4720              		.section	.rodata
 4721              		.align	2
 4722              		.set	.LANCHOR14,. + 0
 4723              	.LC2:
 4724 0000 0100     		.short	1
 4725 0002 0200     		.short	2
 4726 0004 0300     		.short	3
 4727 0006 0400     		.short	4
 4728              	.LC0:
 4729 0008 00000000 		.word	htim1
 4730 000c 00000000 		.word	htim8
 4731 0010 00000000 		.word	htim13
 4732              	.LC1:
 4733 0014 56060000 		.word	1622
 4734 0018 00000000 		.word	0
 4735 001c 2B030000 		.word	811
 4736              		.section	.bss._ZN9TaskTimer7enabledE,"aw",%nobits
 4737              		.set	.LANCHOR21,. + 0
 4740              	_ZN9TaskTimer7enabledE:
 4741 0000 00       		.space	1
 4742              		.section	.bss.axes,"aw",%nobits
 4743              		.align	3
 4744              		.set	.LANCHOR12,. + 0
 4747              	axes:
 4748 0000 00000000 		.space	1376
 4748      00000000 
 4748      00000000 
 4748      00000000 
 4748      00000000 
 4749              		.section	.bss.controllers,"aw",%nobits
 4750              		.align	2
 4753              	controllers:
 4754 0000 00000000 		.space	29344
 4754      00000000 
 4754      00000000 
 4754      00000000 
 4754      00000000 
 4755              		.section	.bss.counting_down_,"aw",%nobits
 4756              		.set	.LANCHOR19,. + 0
 4759              	counting_down_:
 4760 0000 00       		.space	1
 4761              		.section	.bss.encoders,"aw",%nobits
ARM GAS  /tmp/ccysU9ly.s 			page 191


 4762              		.align	2
 4763              		.set	.LANCHOR11,. + 0
 4766              	encoders:
 4767 0000 00000000 		.space	832
 4767      00000000 
 4767      00000000 
 4767      00000000 
 4767      00000000 
 4768              		.section	.bss.fet_thermistors,"aw",%nobits
 4769              		.align	2
 4770              		.set	.LANCHOR1,. + 0
 4773              	fet_thermistors:
 4774 0000 00000000 		.space	112
 4774      00000000 
 4774      00000000 
 4774      00000000 
 4774      00000000 
 4775              		.section	.bss.gpios,"aw",%nobits
 4776              		.align	2
 4777              		.set	.LANCHOR0,. + 0
 4780              	gpios:
 4781 0000 00000000 		.space	136
 4781      00000000 
 4781      00000000 
 4781      00000000 
 4781      00000000 
 4782              		.section	.bss.m0_gate_driver,"aw",%nobits
 4783              		.align	2
 4784              		.set	.LANCHOR7,. + 0
 4787              	m0_gate_driver:
 4788 0000 00000000 		.space	48
 4788      00000000 
 4788      00000000 
 4788      00000000 
 4788      00000000 
 4789              		.section	.bss.m1_gate_driver,"aw",%nobits
 4790              		.align	2
 4791              		.set	.LANCHOR8,. + 0
 4794              	m1_gate_driver:
 4795 0000 00000000 		.space	48
 4795      00000000 
 4795      00000000 
 4795      00000000 
 4795      00000000 
 4796              		.section	.bss.mechanical_brakes,"aw",%nobits
 4797              		.align	2
 4798              		.set	.LANCHOR3,. + 0
 4801              	mechanical_brakes:
 4802 0000 00000000 		.space	32
 4802      00000000 
 4802      00000000 
 4802      00000000 
 4802      00000000 
 4803              		.section	.bss.motor_thermistors,"aw",%nobits
 4804              		.align	2
 4805              		.set	.LANCHOR2,. + 0
 4808              	motor_thermistors:
ARM GAS  /tmp/ccysU9ly.s 			page 192


 4809 0000 00000000 		.space	160
 4809      00000000 
 4809      00000000 
 4809      00000000 
 4809      00000000 
 4810              		.section	.bss.motors,"aw",%nobits
 4811              		.align	3
 4812              		.set	.LANCHOR10,. + 0
 4815              	motors:
 4816 0000 00000000 		.space	864
 4816      00000000 
 4816      00000000 
 4816      00000000 
 4816      00000000 
 4817              		.section	.bss.pwm0_input,"aw",%nobits
 4818              		.align	2
 4819              		.set	.LANCHOR15,. + 0
 4822              	pwm0_input:
 4823 0000 00000000 		.space	12
 4823      00000000 
 4823      00000000 
 4824              		.section	.bss.sensorless_estimators,"aw",%nobits
 4825              		.align	2
 4826              		.set	.LANCHOR4,. + 0
 4829              	sensorless_estimators:
 4830 0000 00000000 		.space	128
 4830      00000000 
 4830      00000000 
 4830      00000000 
 4830      00000000 
 4831              		.section	.bss.spi3_arbiter,"aw",%nobits
 4832              		.align	2
 4833              		.set	.LANCHOR6,. + 0
 4836              	spi3_arbiter:
 4837 0000 00000000 		.space	8
 4837      00000000 
 4838              		.section	.bss.timestamp_,"aw",%nobits
 4839              		.align	2
 4840              		.set	.LANCHOR20,. + 0
 4843              	timestamp_:
 4844 0000 00000000 		.space	4
 4845              		.section	.bss.trap,"aw",%nobits
 4846              		.align	2
 4847              		.set	.LANCHOR5,. + 0
 4850              	trap:
 4851 0000 00000000 		.space	128
 4851      00000000 
 4851      00000000 
 4851      00000000 
 4851      00000000 
 4852              		.section	.bss.uart_c,"aw",%nobits
 4853              		.align	2
 4856              	uart_c:
 4857 0000 00000000 		.space	4
 4858              		.section	.data.alternate_functions,"aw"
 4859              		.align	2
 4862              	alternate_functions:
ARM GAS  /tmp/ccysU9ly.s 			page 193


 4863 0000 00000000 		.word	0
 4864 0004 FF       		.byte	-1
 4865 0005 000000   		.space	3
 4866 0008 00000000 		.word	0
 4867 000c FF       		.byte	-1
 4868 000d 000000   		.space	3
 4869 0010 00000000 		.word	0
 4870 0014 FF       		.byte	-1
 4871 0015 000000   		.space	3
 4872 0018 04000000 		.word	4
 4873 001c 08       		.byte	8
 4874 001d 000000   		.space	3
 4875 0020 0A000000 		.word	10
 4876 0024 02       		.byte	2
 4877 0025 000000   		.space	3
 4878 0028 00000000 		.word	0
 4879 002c FF       		.byte	-1
 4880 002d 000000   		.space	3
 4881 0030 04000000 		.word	4
 4882 0034 08       		.byte	8
 4883 0035 000000   		.space	3
 4884 0038 0A000000 		.word	10
 4885 003c 02       		.byte	2
 4886 003d 000000   		.space	3
 4887 0040 00000000 		.word	0
 4888 0044 FF       		.byte	-1
 4889 0045 000000   		.space	3
 4890 0048 05000000 		.word	5
 4891 004c 07       		.byte	7
 4892 004d 000000   		.space	3
 4893 0050 0A000000 		.word	10
 4894 0054 02       		.byte	2
 4895 0055 000000   		.space	3
 4896 0058 00000000 		.word	0
 4897 005c FF       		.byte	-1
 4898 005d 000000   		.space	3
 4899 0060 05000000 		.word	5
 4900 0064 07       		.byte	7
 4901 0065 000000   		.space	3
 4902 0068 0A000000 		.word	10
 4903 006c 02       		.byte	2
 4904 006d 000000   		.space	3
 4905 0070 00000000 		.word	0
 4906 0074 FF       		.byte	-1
 4907 0075 000000   		.space	3
 4908 0078 00000000 		.word	0
 4909 007c FF       		.byte	-1
 4910 007d 000000   		.space	3
 4911 0080 00000000 		.word	0
 4912 0084 FF       		.byte	-1
 4913 0085 000000   		.space	3
 4914 0088 00000000 		.word	0
 4915 008c FF       		.byte	-1
 4916 008d 000000   		.space	3
 4917 0090 00000000 		.word	0
 4918 0094 FF       		.byte	-1
 4919 0095 000000   		.space	3
ARM GAS  /tmp/ccysU9ly.s 			page 194


 4920 0098 00000000 		.word	0
 4921 009c FF       		.byte	-1
 4922 009d 000000   		.space	3
 4923 00a0 00000000 		.word	0
 4924 00a4 FF       		.byte	-1
 4925 00a5 000000   		.space	3
 4926 00a8 00000000 		.word	0
 4927 00ac FF       		.byte	-1
 4928 00ad 000000   		.space	3
 4929 00b0 00000000 		.word	0
 4930 00b4 FF       		.byte	-1
 4931 00b5 000000   		.space	3
 4932 00b8 00000000 		.word	0
 4933 00bc FF       		.byte	-1
 4934 00bd 000000   		.space	3
 4935 00c0 00000000 		.word	0
 4936 00c4 FF       		.byte	-1
 4937 00c5 000000   		.space	3
 4938 00c8 00000000 		.word	0
 4939 00cc FF       		.byte	-1
 4940 00cd 000000   		.space	3
 4941 00d0 00000000 		.word	0
 4942 00d4 FF       		.byte	-1
 4943 00d5 000000   		.space	3
 4944 00d8 0B000000 		.word	11
 4945 00dc 02       		.byte	2
 4946 00dd 000000   		.space	3
 4947 00e0 00000000 		.word	0
 4948 00e4 FF       		.byte	-1
 4949 00e5 000000   		.space	3
 4950 00e8 00000000 		.word	0
 4951 00ec FF       		.byte	-1
 4952 00ed 000000   		.space	3
 4953 00f0 0B000000 		.word	11
 4954 00f4 02       		.byte	2
 4955 00f5 000000   		.space	3
 4956 00f8 00000000 		.word	0
 4957 00fc FF       		.byte	-1
 4958 00fd 000000   		.space	3
 4959 0100 00000000 		.word	0
 4960 0104 FF       		.byte	-1
 4961 0105 000000   		.space	3
 4962 0108 00000000 		.word	0
 4963 010c FF       		.byte	-1
 4964 010d 000000   		.space	3
 4965 0110 00000000 		.word	0
 4966 0114 FF       		.byte	-1
 4967 0115 000000   		.space	3
 4968 0118 00000000 		.word	0
 4969 011c FF       		.byte	-1
 4970 011d 000000   		.space	3
 4971 0120 08000000 		.word	8
 4972 0124 04       		.byte	4
 4973 0125 000000   		.space	3
 4974 0128 0C000000 		.word	12
 4975 012c 02       		.byte	2
 4976 012d 000000   		.space	3
ARM GAS  /tmp/ccysU9ly.s 			page 195


 4977 0130 00000000 		.word	0
 4978 0134 FF       		.byte	-1
 4979 0135 000000   		.space	3
 4980 0138 08000000 		.word	8
 4981 013c 04       		.byte	4
 4982 013d 000000   		.space	3
 4983 0140 0C000000 		.word	12
 4984 0144 02       		.byte	2
 4985 0145 000000   		.space	3
 4986 0148 00000000 		.word	0
 4987 014c FF       		.byte	-1
 4988 014d 000000   		.space	3
 4989 0150 00000000 		.word	0
 4990 0154 FF       		.byte	-1
 4991 0155 000000   		.space	3
 4992 0158 00000000 		.word	0
 4993 015c FF       		.byte	-1
 4994 015d 000000   		.space	3
 4995 0160 00000000 		.word	0
 4996 0164 FF       		.byte	-1
 4997 0165 000000   		.space	3
 4998 0168 07000000 		.word	7
 4999 016c 09       		.byte	9
 5000 016d 000000   		.space	3
 5001 0170 08000000 		.word	8
 5002 0174 04       		.byte	4
 5003 0175 000000   		.space	3
 5004 0178 00000000 		.word	0
 5005 017c FF       		.byte	-1
 5006 017d 000000   		.space	3
 5007 0180 07000000 		.word	7
 5008 0184 09       		.byte	9
 5009 0185 000000   		.space	3
 5010 0188 08000000 		.word	8
 5011 018c 04       		.byte	4
 5012 018d 000000   		.space	3
 5013 0190 00000000 		.word	0
 5014 0194 FF       		.byte	-1
 5015 0195 000000   		.space	3
 5016              		.section	.data.endstops,"aw"
 5017              		.align	2
 5018              		.set	.LANCHOR13,. + 0
 5021              	endstops:
 5022 0000 00000000 		.word	0
 5023 0004 32000000 		.word	50
 5024 0008 0000     		.short	0
 5025 000a 00       		.byte	0
 5026 000b 00       		.byte	0
 5027 000c 00000000 		.word	0
 5028 0010 00000000 		.word	0
 5029 0014 00       		.byte	0
 5030 0015 00       		.byte	0
 5031 0016 00       		.byte	0
 5032 0017 00       		.space	1
 5033 0018 00000000 		.word	0
 5034 001c 00000000 		.word	0
 5035 0020 00000000 		.word	0
ARM GAS  /tmp/ccysU9ly.s 			page 196


 5036 0024 00000000 		.word	0
 5037 0028 00       		.byte	0
 5038 0029 000000   		.space	3
 5039 002c 00000000 		.word	0
 5040 0030 32000000 		.word	50
 5041 0034 0000     		.short	0
 5042 0036 00       		.byte	0
 5043 0037 00       		.byte	0
 5044 0038 00000000 		.word	0
 5045 003c 00000000 		.word	0
 5046 0040 00       		.byte	0
 5047 0041 00       		.byte	0
 5048 0042 00       		.byte	0
 5049 0043 00       		.space	1
 5050 0044 00000000 		.word	0
 5051 0048 00000000 		.word	0
 5052 004c 00000000 		.word	0
 5053 0050 00000000 		.word	0
 5054 0054 00       		.byte	0
 5055 0055 000000   		.space	3
 5056 0058 00000000 		.word	0
 5057 005c 32000000 		.word	50
 5058 0060 0000     		.short	0
 5059 0062 00       		.byte	0
 5060 0063 00       		.byte	0
 5061 0064 00000000 		.word	0
 5062 0068 00000000 		.word	0
 5063 006c 00       		.byte	0
 5064 006d 00       		.byte	0
 5065 006e 00       		.byte	0
 5066 006f 00       		.space	1
 5067 0070 00000000 		.word	0
 5068 0074 00000000 		.word	0
 5069 0078 00000000 		.word	0
 5070 007c 00000000 		.word	0
 5071 0080 00       		.byte	0
 5072 0081 000000   		.space	3
 5073 0084 00000000 		.word	0
 5074 0088 32000000 		.word	50
 5075 008c 0000     		.short	0
 5076 008e 00       		.byte	0
 5077 008f 00       		.byte	0
 5078 0090 00000000 		.word	0
 5079 0094 00000000 		.word	0
 5080 0098 00       		.byte	0
 5081 0099 00       		.byte	0
 5082 009a 00       		.byte	0
 5083 009b 00       		.space	1
 5084 009c 00000000 		.word	0
 5085 00a0 00000000 		.word	0
 5086 00a4 00000000 		.word	0
 5087 00a8 00000000 		.word	0
 5088 00ac 00       		.byte	0
 5089 00ad 000000   		.space	3
 5090              		.section	.data.uart_a,"aw"
 5091              		.align	2
 5092              		.set	.LANCHOR17,. + 0
ARM GAS  /tmp/ccysU9ly.s 			page 197


 5095              	uart_a:
 5096 0000 00000000 		.word	huart4
 5097              		.section	.data.uart_b,"aw"
 5098              		.align	2
 5099              		.set	.LANCHOR18,. + 0
 5102              	uart_b:
 5103 0000 00000000 		.word	huart2
 5104              		.section	.rodata._ZL26fet_thermistor_poly_coeffs,"a"
 5105              		.align	2
 5106              		.set	.LANCHOR9,. + 0
 5109              	_ZL26fet_thermistor_poly_coeffs:
 5110 0000 34F8B543 		.word	1135999028
 5111 0004 AC13E7C3 		.word	-1008266324
 5112 0008 91C69943 		.word	1134151313
 5113 000c 39CEDDC1 		.word	-1042428359
 5114              		.section	.rodata.ext_spi_arbiter,"a"
 5115              		.align	2
 5118              	ext_spi_arbiter:
 5119 0000 00000000 		.word	spi3_arbiter
 5120              		.section	.rodata.usb_dev_handle,"a"
 5121              		.align	2
 5124              	usb_dev_handle:
 5125 0000 00000000 		.word	hUsbDeviceFS
 5126              		.section	.testdata,"aw"
 5127              		.align	2
 5128              		.set	.LANCHOR16,. + 0
 5131              	fake_otp:
 5132 0000 00000003 		.ascii	"\000\000\000\003\0068\000"
 5132      063800
 5133 0007 00000000 		.space	521
 5133      00000000 
 5133      00000000 
 5133      00000000 
 5133      00000000 
 5134              		.text
 5135              	.Letext0:
 5136              		.file 23 "ThirdParty/CMSIS/Device/ST/STM32F4xx/Include/stm32f405xx.h"
 5137              		.file 24 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/machine/_default_types.h"
 5138              		.file 25 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/_stdint.h"
 5139              		.file 26 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdint.h"
 5140              		.file 27 "ThirdParty/CMSIS/Include/core_cm4.h"
 5141              		.file 28 "/opt/gcc-arm-none-eabi/lib/gcc/arm-none-eabi/10.3.1/include/stddef.h"
 5142              		.file 29 "/opt/gcc-arm-none-eabi/lib/gcc/arm-none-eabi/10.3.1/include/stdarg.h"
 5143              		.file 30 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/_types.h"
 5144              		.file 31 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/reent.h"
 5145              		.file 32 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/lock.h"
 5146              		.file 33 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdio.h"
 5147              		.file 34 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_def.h"
 5148              		.file 35 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_gpio.h"
 5149              		.file 36 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_dma.h"
 5150              		.file 37 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_adc.h"
 5151              		.file 38 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_i2c.h"
 5152              		.file 39 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_spi.h"
 5153              		.file 40 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_tim.h"
 5154              		.file 41 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_uart.h"
 5155              		.file 42 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_ll_usb.h"
 5156              		.file 43 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_pcd.h"
ARM GAS  /tmp/ccysU9ly.s 			page 198


 5157              		.file 44 "Board/v3/Inc/spi.h"
 5158              		.file 45 "Board/v3/Inc/tim.h"
 5159              		.file 46 "Board/v3/Inc/i2c.h"
 5160              		.file 47 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdlib"
 5161              		.file 48 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h"
 5162              		.file 49 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath"
 5163              		.file 50 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/type_traits"
 5164              		.file 51 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/arm-none-eabi/thumb/v7e-m+fp/har
 5165              		.file 52 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/debug/debug.h"
 5166              		.file 53 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h"
 5167              		.file 54 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception_ptr.h"
 5168              		.file 55 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_iterator.h"
 5169              		.file 56 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/enable_special_members.h"
 5170              		.file 57 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/algorithmfwd.h"
 5171              		.file 58 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional"
 5172              		.file 59 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstring"
 5173              		.file 60 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/utility"
 5174              		.file 61 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/parse_numbers.h"
 5175              		.file 62 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cwchar"
 5176              		.file 63 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/clocale"
 5177              		.file 64 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdint"
 5178              		.file 65 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/string_view"
 5179              		.file 66 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/basic_string.h"
 5180              		.file 67 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdio"
 5181              		.file 68 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h"
 5182              		.file 69 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/predefined_ops.h"
 5183              		.file 70 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdlib.h"
 5184              		.file 71 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/stdlib.h"
 5185              		.file 72 "ThirdParty/STM32_USB_Device_Library/Core/Inc/usbd_def.h"
 5186              		.file 73 "Board/v3/Inc/usb_device.h"
 5187              		.file 74 "ThirdParty/FreeRTOS/Source/CMSIS_RTOS/cmsis_os.h"
 5188              		.file 75 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/math.h"
 5189              		.file 76 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/math.h"
 5190              		.file 77 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/string.h"
 5191              		.file 78 "fibre-cpp/include/fibre/cpp_utils.hpp"
 5192              		.file 79 "fibre-cpp/include/fibre/callback.hpp"
 5193              		.file 80 "./MotorControl/thermistor.hpp"
 5194              		.file 81 "Board/v3/Inc/board.h"
 5195              		.file 82 "./MotorControl/motor.hpp"
 5196              		.file 83 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/pstl/execution_defs.h"
 5197              		.file 84 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h"
 5198              		.file 85 "./MotorControl/utils.hpp"
 5199              		.file 86 "./communication/interface_i2c.h"
 5200              		.file 87 "Board/v3/Inc/usart.h"
 5201              		.file 88 "Board/v3/Inc/adc.h"
 5202              		.file 89 "MotorControl/endstop.hpp"
 5203              		.file 90 "MotorControl/timer.hpp"
 5204              		.file 91 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/wchar.h"
 5205              		.file 92 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/locale.h"
 5206              		.file 93 "./MotorControl/current_limiter.hpp"
 5207              		.file 94 "MotorControl/low_level.h"
 5208              		.file 95 "Board/v3/Inc/gpio.h"
 5209              		.file 96 "Board/v3/Inc/dma.h"
 5210              		.file 97 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_cortex.h"
 5211              		.file 98 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal.h"
 5212              		.file 99 "<built-in>"
ARM GAS  /tmp/ccysU9ly.s 			page 199


DEFINED SYMBOLS
                            *ABS*:0000000000000000 board.cpp
     /tmp/ccysU9ly.s:20     .text.cpu_enter_critical:0000000000000000 $t
     /tmp/ccysU9ly.s:26     .text.cpu_enter_critical:0000000000000000 cpu_enter_critical
.ARM.exidx.text.cpu_enter_critical:0000000000000000 $d
     /tmp/ccysU9ly.s:77     .text.cpu_exit_critical:0000000000000000 $t
     /tmp/ccysU9ly.s:83     .text.cpu_exit_critical:0000000000000000 cpu_exit_critical
.ARM.exidx.text.cpu_exit_critical:0000000000000000 $d
     /tmp/ccysU9ly.s:116    .text._ZL8get_gpioj:0000000000000000 $t
     /tmp/ccysU9ly.s:122    .text._ZL8get_gpioj:0000000000000000 _ZL8get_gpioj
     /tmp/ccysU9ly.s:161    .text._ZL8get_gpioj:000000000000001c $d
    .ARM.exidx.text._ZL8get_gpioj:0000000000000000 $d
     /tmp/ccysU9ly.s:168    .text.__tcf_0:0000000000000000 $t
     /tmp/ccysU9ly.s:174    .text.__tcf_0:0000000000000000 __tcf_0
     /tmp/ccysU9ly.s:207    .text.__tcf_0:0000000000000018 $d
          .ARM.exidx.text.__tcf_0:0000000000000000 $d
     /tmp/ccysU9ly.s:215    .text.__tcf_1:0000000000000000 $t
     /tmp/ccysU9ly.s:221    .text.__tcf_1:0000000000000000 __tcf_1
     /tmp/ccysU9ly.s:253    .text.__tcf_1:0000000000000018 $d
          .ARM.exidx.text.__tcf_1:0000000000000000 $d
     /tmp/ccysU9ly.s:261    .text._Z41__static_initialization_and_destruction_0ii:0000000000000000 $t
     /tmp/ccysU9ly.s:267    .text._Z41__static_initialization_and_destruction_0ii:0000000000000000 _Z41__static_initialization_and_destruction_0ii
     /tmp/ccysU9ly.s:906    .text._Z41__static_initialization_and_destruction_0ii:00000000000002a0 $d
     /tmp/ccysU9ly.s:4657   .rodata._ZTV14GateDriverBase:0000000000000000 _ZTV14GateDriverBase
     /tmp/ccysU9ly.s:4667   .rodata._ZTV9OpAmpBase:0000000000000000 _ZTV9OpAmpBase
     /tmp/ccysU9ly.s:4690   .rodata._ZTVN10ODriveIntf19MechanicalBrakeIntfE:0000000000000000 _ZTVN10ODriveIntf19MechanicalBrakeIntfE
     /tmp/ccysU9ly.s:938    .text._Z41__static_initialization_and_destruction_0ii:0000000000000318 $t
     /tmp/ccysU9ly.s:1805   .text._Z41__static_initialization_and_destruction_0ii:0000000000000610 $d
     /tmp/ccysU9ly.s:4753   .bss.controllers:0000000000000000 controllers
     /tmp/ccysU9ly.s:4678   .rodata._ZTVN10ODriveIntf14ControllerIntfE:0000000000000000 _ZTVN10ODriveIntf14ControllerIntfE
     /tmp/ccysU9ly.s:1834   .text._Z41__static_initialization_and_destruction_0ii:0000000000000678 $t
     /tmp/ccysU9ly.s:1855   .text._Z41__static_initialization_and_destruction_0ii:000000000000069c $d
.ARM.extab.text._Z41__static_initialization_and_destruction_0ii:0000000000000000 $d
.ARM.exidx.text._Z41__static_initialization_and_destruction_0ii:0000000000000000 $d
     /tmp/ccysU9ly.s:1888   .text._ZL20fetch_and_reset_adcsPSt8optionalI9Iph_ABC_tES2_:0000000000000000 $t
     /tmp/ccysU9ly.s:1894   .text._ZL20fetch_and_reset_adcsPSt8optionalI9Iph_ABC_tES2_:0000000000000000 _ZL20fetch_and_reset_adcsPSt8optionalI9Iph_ABC_tES2_
     /tmp/ccysU9ly.s:2298   .text._ZL20fetch_and_reset_adcsPSt8optionalI9Iph_ABC_tES2_:000000000000013c $d
.ARM.exidx.text._ZL20fetch_and_reset_adcsPSt8optionalI9Iph_ABC_tES2_:0000000000000000 $d
     /tmp/ccysU9ly.s:2310   .text._Z19check_board_versionPKh:0000000000000000 $t
     /tmp/ccysU9ly.s:2317   .text._Z19check_board_versionPKh:0000000000000000 _Z19check_board_versionPKh
.ARM.exidx.text._Z19check_board_versionPKh:0000000000000000 $d
     /tmp/ccysU9ly.s:2373   .text._Z11system_initv:0000000000000000 $t
     /tmp/ccysU9ly.s:2380   .text._Z11system_initv:0000000000000000 _Z11system_initv
     /tmp/ccysU9ly.s:2435   .text._Z11system_initv:0000000000000024 $d
 .ARM.extab.text._Z11system_initv:0000000000000000 $d
 .ARM.exidx.text._Z11system_initv:0000000000000000 $d
     /tmp/ccysU9ly.s:2442   .text._Z10board_initv:0000000000000000 $t
     /tmp/ccysU9ly.s:2449   .text._Z10board_initv:0000000000000000 _Z10board_initv
     /tmp/ccysU9ly.s:2973   .text._Z10board_initv:0000000000000248 $d
  .ARM.exidx.text._Z10board_initv:0000000000000000 $d
     /tmp/ccysU9ly.s:2984   .text.HAL_SPI_TxRxCpltCallback:0000000000000000 $t
     /tmp/ccysU9ly.s:2991   .text.HAL_SPI_TxRxCpltCallback:0000000000000000 HAL_SPI_TxRxCpltCallback
     /tmp/ccysU9ly.s:3028   .text.HAL_SPI_TxRxCpltCallback:0000000000000014 $d
.ARM.extab.text.HAL_SPI_TxRxCpltCallback:0000000000000000 $d
.ARM.exidx.text.HAL_SPI_TxRxCpltCallback:0000000000000000 $d
     /tmp/ccysU9ly.s:3035   .text.HAL_SPI_TxCpltCallback:0000000000000000 $t
     /tmp/ccysU9ly.s:3042   .text.HAL_SPI_TxCpltCallback:0000000000000000 HAL_SPI_TxCpltCallback
ARM GAS  /tmp/ccysU9ly.s 			page 200


.ARM.extab.text.HAL_SPI_TxCpltCallback:0000000000000000 $d
.ARM.exidx.text.HAL_SPI_TxCpltCallback:0000000000000000 $d
     /tmp/ccysU9ly.s:3068   .text.HAL_SPI_RxCpltCallback:0000000000000000 $t
     /tmp/ccysU9ly.s:3075   .text.HAL_SPI_RxCpltCallback:0000000000000000 HAL_SPI_RxCpltCallback
.ARM.extab.text.HAL_SPI_RxCpltCallback:0000000000000000 $d
.ARM.exidx.text.HAL_SPI_RxCpltCallback:0000000000000000 $d
     /tmp/ccysU9ly.s:3101   .text.TIM5_IRQHandler:0000000000000000 $t
     /tmp/ccysU9ly.s:3108   .text.TIM5_IRQHandler:0000000000000000 TIM5_IRQHandler
     /tmp/ccysU9ly.s:3132   .text.TIM5_IRQHandler:000000000000000c $d
  .ARM.extab.text.TIM5_IRQHandler:0000000000000000 $d
  .ARM.exidx.text.TIM5_IRQHandler:0000000000000000 $d
     /tmp/ccysU9ly.s:3138   .text.TIM8_UP_TIM13_IRQHandler:0000000000000000 $t
     /tmp/ccysU9ly.s:3145   .text.TIM8_UP_TIM13_IRQHandler:0000000000000000 TIM8_UP_TIM13_IRQHandler
     /tmp/ccysU9ly.s:3263   .text.TIM8_UP_TIM13_IRQHandler:0000000000000088 $d
.ARM.exidx.text.TIM8_UP_TIM13_IRQHandler:0000000000000000 $d
     /tmp/ccysU9ly.s:3276   .text.OTG_HS_IRQHandler:0000000000000000 $t
     /tmp/ccysU9ly.s:3283   .text.OTG_HS_IRQHandler:0000000000000000 OTG_HS_IRQHandler
     /tmp/ccysU9ly.s:3819   .text.OTG_HS_IRQHandler:000000000000020c $d
.ARM.exidx.text.OTG_HS_IRQHandler:0000000000000000 $d
     /tmp/ccysU9ly.s:3835   .text.I2C1_EV_IRQHandler:0000000000000000 $t
     /tmp/ccysU9ly.s:3842   .text.I2C1_EV_IRQHandler:0000000000000000 I2C1_EV_IRQHandler
     /tmp/ccysU9ly.s:3866   .text.I2C1_EV_IRQHandler:000000000000000c $d
.ARM.extab.text.I2C1_EV_IRQHandler:0000000000000000 $d
.ARM.exidx.text.I2C1_EV_IRQHandler:0000000000000000 $d
     /tmp/ccysU9ly.s:3872   .text.I2C1_ER_IRQHandler:0000000000000000 $t
     /tmp/ccysU9ly.s:3879   .text.I2C1_ER_IRQHandler:0000000000000000 I2C1_ER_IRQHandler
     /tmp/ccysU9ly.s:3903   .text.I2C1_ER_IRQHandler:000000000000000c $d
.ARM.extab.text.I2C1_ER_IRQHandler:0000000000000000 $d
.ARM.exidx.text.I2C1_ER_IRQHandler:0000000000000000 $d
     /tmp/ccysU9ly.s:3909   .text.OTG_FS_IRQHandler:0000000000000000 $t
     /tmp/ccysU9ly.s:3916   .text.OTG_FS_IRQHandler:0000000000000000 OTG_FS_IRQHandler
     /tmp/ccysU9ly.s:3940   .text.OTG_FS_IRQHandler:000000000000000c $d
.ARM.extab.text.OTG_FS_IRQHandler:0000000000000000 $d
.ARM.exidx.text.OTG_FS_IRQHandler:0000000000000000 $d
     /tmp/ccysU9ly.s:3946   .text._ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj:0000000000000000 $t
     /tmp/ccysU9ly.s:3953   .text._ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj:0000000000000000 _ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj
.ARM.exidx.text._ZNSt5arrayIP17TIM_HandleTypeDefLj3EEixEj:0000000000000000 $d
     /tmp/ccysU9ly.s:3979   .text._ZNSt5arrayIjLj3EEixEj:0000000000000000 $t
     /tmp/ccysU9ly.s:3986   .text._ZNSt5arrayIjLj3EEixEj:0000000000000000 _ZNSt5arrayIjLj3EEixEj
.ARM.exidx.text._ZNSt5arrayIjLj3EEixEj:0000000000000000 $d
     /tmp/ccysU9ly.s:4011   .text._ZN10Stm32Timer24start_synchronously_implILj3EJLj0ELj1ELj2EEEEvSt5arrayIP17TIM_HandleTypeDefXT_EES1_IjXT_EESt16integer_sequenceIjJXspT0_EEE:0000000000000000 $t
     /tmp/ccysU9ly.s:4018   .text._ZN10Stm32Timer24start_synchronously_implILj3EJLj0ELj1ELj2EEEEvSt5arrayIP17TIM_HandleTypeDefXT_EES1_IjXT_EESt16integer_sequenceIjJXspT0_EEE:0000000000000000 _ZN10Stm32Timer24start_synchronously_implILj3EJLj0ELj1ELj2EEEEvSt5arrayIP17TIM_HandleTypeDefXT_EES1_IjXT_EESt16integer_sequenceIjJXspT0_EEE
.ARM.exidx.text._ZN10Stm32Timer24start_synchronously_implILj3EJLj0ELj1ELj2EEEEvSt5arrayIP17TIM_HandleTypeDefXT_EES1_IjXT_EESt16integer_sequenceIjJXspT0_EEE:0000000000000000 $d
     /tmp/ccysU9ly.s:4297   .text._Z12start_timersv:0000000000000000 $t
     /tmp/ccysU9ly.s:4304   .text._Z12start_timersv:0000000000000000 _Z12start_timersv
     /tmp/ccysU9ly.s:4549   .text._Z12start_timersv:0000000000000100 $d
.ARM.exidx.text._Z12start_timersv:0000000000000000 $d
     /tmp/ccysU9ly.s:4560   .text._GLOBAL__sub_I__ZN9TaskTimer7enabledE:0000000000000000 $t
     /tmp/ccysU9ly.s:4566   .text._GLOBAL__sub_I__ZN9TaskTimer7enabledE:0000000000000000 _GLOBAL__sub_I__ZN9TaskTimer7enabledE
.ARM.exidx.text._GLOBAL__sub_I__ZN9TaskTimer7enabledE:0000000000000000 $d
     /tmp/ccysU9ly.s:4590   .init_array:0000000000000000 $d
     /tmp/ccysU9ly.s:4597   .rodata._ZTS14GateDriverBase:0000000000000000 _ZTS14GateDriverBase
     /tmp/ccysU9ly.s:4594   .rodata._ZTS14GateDriverBase:0000000000000000 $d
     /tmp/ccysU9ly.s:4604   .rodata._ZTI14GateDriverBase:0000000000000000 _ZTI14GateDriverBase
     /tmp/ccysU9ly.s:4601   .rodata._ZTI14GateDriverBase:0000000000000000 $d
     /tmp/ccysU9ly.s:4612   .rodata._ZTS9OpAmpBase:0000000000000000 _ZTS9OpAmpBase
     /tmp/ccysU9ly.s:4609   .rodata._ZTS9OpAmpBase:0000000000000000 $d
ARM GAS  /tmp/ccysU9ly.s 			page 201


     /tmp/ccysU9ly.s:4619   .rodata._ZTI9OpAmpBase:0000000000000000 _ZTI9OpAmpBase
     /tmp/ccysU9ly.s:4616   .rodata._ZTI9OpAmpBase:0000000000000000 $d
     /tmp/ccysU9ly.s:4627   .rodata._ZTSN10ODriveIntf14ControllerIntfE:0000000000000000 _ZTSN10ODriveIntf14ControllerIntfE
     /tmp/ccysU9ly.s:4624   .rodata._ZTSN10ODriveIntf14ControllerIntfE:0000000000000000 $d
     /tmp/ccysU9ly.s:4634   .rodata._ZTIN10ODriveIntf14ControllerIntfE:0000000000000000 _ZTIN10ODriveIntf14ControllerIntfE
     /tmp/ccysU9ly.s:4631   .rodata._ZTIN10ODriveIntf14ControllerIntfE:0000000000000000 $d
     /tmp/ccysU9ly.s:4642   .rodata._ZTSN10ODriveIntf19MechanicalBrakeIntfE:0000000000000000 _ZTSN10ODriveIntf19MechanicalBrakeIntfE
     /tmp/ccysU9ly.s:4639   .rodata._ZTSN10ODriveIntf19MechanicalBrakeIntfE:0000000000000000 $d
     /tmp/ccysU9ly.s:4649   .rodata._ZTIN10ODriveIntf19MechanicalBrakeIntfE:0000000000000000 _ZTIN10ODriveIntf19MechanicalBrakeIntfE
     /tmp/ccysU9ly.s:4646   .rodata._ZTIN10ODriveIntf19MechanicalBrakeIntfE:0000000000000000 $d
     /tmp/ccysU9ly.s:4654   .rodata._ZTV14GateDriverBase:0000000000000000 $d
     /tmp/ccysU9ly.s:4664   .rodata._ZTV9OpAmpBase:0000000000000000 $d
     /tmp/ccysU9ly.s:4675   .rodata._ZTVN10ODriveIntf14ControllerIntfE:0000000000000000 $d
     /tmp/ccysU9ly.s:4687   .rodata._ZTVN10ODriveIntf19MechanicalBrakeIntfE:0000000000000000 $d
     /tmp/ccysU9ly.s:4759   .bss.counting_down_:0000000000000000 counting_down_
     /tmp/ccysU9ly.s:4843   .bss.timestamp_:0000000000000000 timestamp_
     /tmp/ccysU9ly.s:5124   .rodata.usb_dev_handle:0000000000000000 usb_dev_handle
     /tmp/ccysU9ly.s:4822   .bss.pwm0_input:0000000000000000 pwm0_input
     /tmp/ccysU9ly.s:4862   .data.alternate_functions:0000000000000000 alternate_functions
     /tmp/ccysU9ly.s:4780   .bss.gpios:0000000000000000 gpios
     /tmp/ccysU9ly.s:4747   .bss.axes:0000000000000000 axes
     /tmp/ccysU9ly.s:4850   .bss.trap:0000000000000000 trap
     /tmp/ccysU9ly.s:4829   .bss.sensorless_estimators:0000000000000000 sensorless_estimators
     /tmp/ccysU9ly.s:4801   .bss.mechanical_brakes:0000000000000000 mechanical_brakes
     /tmp/ccysU9ly.s:5021   .data.endstops:0000000000000000 endstops
     /tmp/ccysU9ly.s:4766   .bss.encoders:0000000000000000 encoders
     /tmp/ccysU9ly.s:4815   .bss.motors:0000000000000000 motors
     /tmp/ccysU9ly.s:4808   .bss.motor_thermistors:0000000000000000 motor_thermistors
     /tmp/ccysU9ly.s:4773   .bss.fet_thermistors:0000000000000000 fet_thermistors
     /tmp/ccysU9ly.s:4794   .bss.m1_gate_driver:0000000000000000 m1_gate_driver
     /tmp/ccysU9ly.s:4787   .bss.m0_gate_driver:0000000000000000 m0_gate_driver
     /tmp/ccysU9ly.s:4856   .bss.uart_c:0000000000000000 uart_c
     /tmp/ccysU9ly.s:5102   .data.uart_b:0000000000000000 uart_b
     /tmp/ccysU9ly.s:5095   .data.uart_a:0000000000000000 uart_a
     /tmp/ccysU9ly.s:5118   .rodata.ext_spi_arbiter:0000000000000000 ext_spi_arbiter
     /tmp/ccysU9ly.s:4836   .bss.spi3_arbiter:0000000000000000 spi3_arbiter
     /tmp/ccysU9ly.s:5131   .testdata:0000000000000000 fake_otp
     /tmp/ccysU9ly.s:4740   .bss._ZN9TaskTimer7enabledE:0000000000000000 _ZN9TaskTimer7enabledE
     /tmp/ccysU9ly.s:4721   .rodata:0000000000000000 $d
     /tmp/ccysU9ly.s:4741   .bss._ZN9TaskTimer7enabledE:0000000000000000 $d
     /tmp/ccysU9ly.s:4743   .bss.axes:0000000000000000 $d
     /tmp/ccysU9ly.s:4750   .bss.controllers:0000000000000000 $d
     /tmp/ccysU9ly.s:4760   .bss.counting_down_:0000000000000000 $d
     /tmp/ccysU9ly.s:4762   .bss.encoders:0000000000000000 $d
     /tmp/ccysU9ly.s:4769   .bss.fet_thermistors:0000000000000000 $d
     /tmp/ccysU9ly.s:4776   .bss.gpios:0000000000000000 $d
     /tmp/ccysU9ly.s:4783   .bss.m0_gate_driver:0000000000000000 $d
     /tmp/ccysU9ly.s:4790   .bss.m1_gate_driver:0000000000000000 $d
     /tmp/ccysU9ly.s:4797   .bss.mechanical_brakes:0000000000000000 $d
     /tmp/ccysU9ly.s:4804   .bss.motor_thermistors:0000000000000000 $d
     /tmp/ccysU9ly.s:4811   .bss.motors:0000000000000000 $d
     /tmp/ccysU9ly.s:4818   .bss.pwm0_input:0000000000000000 $d
     /tmp/ccysU9ly.s:4825   .bss.sensorless_estimators:0000000000000000 $d
     /tmp/ccysU9ly.s:4832   .bss.spi3_arbiter:0000000000000000 $d
     /tmp/ccysU9ly.s:4839   .bss.timestamp_:0000000000000000 $d
     /tmp/ccysU9ly.s:4846   .bss.trap:0000000000000000 $d
     /tmp/ccysU9ly.s:4853   .bss.uart_c:0000000000000000 $d
ARM GAS  /tmp/ccysU9ly.s 			page 202


     /tmp/ccysU9ly.s:4859   .data.alternate_functions:0000000000000000 $d
     /tmp/ccysU9ly.s:5017   .data.endstops:0000000000000000 $d
     /tmp/ccysU9ly.s:5091   .data.uart_a:0000000000000000 $d
     /tmp/ccysU9ly.s:5098   .data.uart_b:0000000000000000 $d
     /tmp/ccysU9ly.s:5105   .rodata._ZL26fet_thermistor_poly_coeffs:0000000000000000 $d
     /tmp/ccysU9ly.s:5109   .rodata._ZL26fet_thermistor_poly_coeffs:0000000000000000 _ZL26fet_thermistor_poly_coeffs
     /tmp/ccysU9ly.s:5115   .rodata.ext_spi_arbiter:0000000000000000 $d
     /tmp/ccysU9ly.s:5121   .rodata.usb_dev_handle:0000000000000000 $d
     /tmp/ccysU9ly.s:5127   .testdata:0000000000000000 $d

UNDEFINED SYMBOLS
_ZN31OnboardThermistorCurrentLimiterC1EtPKfj
__aeabi_atexit
_ZN32OffboardThermistorCurrentLimiterC1Ev
_ZN5MotorC1EP17TIM_HandleTypeDefhfR7Drv8301S3_R31OnboardThermistorCurrentLimiterR32OffboardThermistorCurrentLimiter
_ZN7EncoderC1EP17TIM_HandleTypeDef9Stm32GpioS2_S2_S2_P15Stm32SpiArbiter
memset
hspi3
__dso_handle
htim1
htim8
htim3
htim4
_ZTV15MechanicalBrake
_ZTV7Drv8301
_ZN4AxisC1Eitt10osPriorityR7EncoderR19SensorlessEstimatorR10ControllerR5MotorR21TrapezoidalTrajectoryR7EndstopSC_R15MechanicalBrake
__cxa_end_cleanup
_ZTV10Controller
htim5
__gxx_personality_v0
vbus_sense_adc_cb
_ZN7Drv83018is_readyEv
_ZN5Motor25phase_current_from_adcvalEm
__aeabi_unwind_cpp_pr0
HAL_Init
SystemClock_Config
__aeabi_unwind_cpp_pr1
MX_GPIO_Init
MX_DMA_Init
MX_ADC1_Init
MX_ADC2_Init
MX_TIM1_Init
MX_TIM8_Init
MX_TIM3_Init
MX_TIM4_Init
MX_SPI3_Init
MX_ADC3_Init
MX_TIM2_Init
MX_TIM5_Init
MX_TIM13_Init
HAL_NVIC_SetPriority
HAL_NVIC_EnableIRQ
HAL_GPIO_WritePin
_Z8delay_usm
MX_UART4_Init
MX_USART2_UART_Init
_ZN9Stm32Gpio6configEmmm
ARM GAS  /tmp/ccysU9ly.s 			page 203


osDelay
MX_I2C1_Init
odrv
i2c_stats_
_ZN15Stm32SpiArbiter11on_completeEv
_ZN8PwmInput10on_captureEv
_ZN5Motor17disarm_with_errorEN10ODriveIntf9MotorIntf5ErrorE
_ZN6ODrive11sampling_cbEv
_ZN5Motor15current_meas_cbEmSt8optionalI9Iph_ABC_tE
_ZN6ODrive15control_loop_cbEm
_ZN5Motor11dc_calib_cbEmSt8optionalI9Iph_ABC_tE
_ZN5Motor13pwm_update_cbEm
HAL_I2C_EV_IRQHandler
hi2c1
HAL_I2C_ER_IRQHandler
HAL_PCD_IRQHandler
hpcd_USB_OTG_FS
hadc1
hadc2
hadc3
_ZTVN10__cxxabiv117__class_type_infoE
__cxa_pure_virtual
htim13
huart4
huart2
hUsbDeviceFS
