ARM GAS  /tmp/ccawPiBL.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"controller.cpp"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text._ZNKSt18bad_variant_access4whatEv,"axG",%progbits,_ZNKSt18bad_variant_access4whatEv
  20              		.align	1
  21              		.weak	_ZNKSt18bad_variant_access4whatEv
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	_ZNKSt18bad_variant_access4whatEv:
  27              		.fnstart
  28              	.LVL0:
  29              	.LFB3066:
  30              		.file 1 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // <variant> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // Copyright (C) 2016-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** /** @file variant
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****  *  This is the `<variant>` C++ Library header.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****  */
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/ccawPiBL.s 			page 2


  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #ifndef _GLIBCXX_VARIANT
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define _GLIBCXX_VARIANT 1
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #pragma GCC system_header
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #if __cplusplus >= 201703L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <type_traits>
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <utility>
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/enable_special_members.h>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/functexcept.h>
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/move.h>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/functional_hash.h>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/invoke.h>
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <ext/aligned_buffer.h>
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/parse_numbers.h>
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/stl_iterator_base_types.h>
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/stl_iterator_base_funcs.h>
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #include <bits/stl_construct.h>
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #if __cplusplus > 201703L
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** # include <compare>
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #endif
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace std _GLIBCXX_VISIBILITY(default)
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __detail
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __variant
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Nth_type;
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _First, typename... _Rest>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Nth_type<_Np, _First, _Rest...>
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _Nth_type<_Np-1, _Rest...> { };
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _First, typename... _Rest>
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Nth_type<0, _First, _Rest...>
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = _First; };
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __variant
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __detail
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define __cpp_lib_variant 201606L
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types> class tuple;
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types> class variant;
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename> struct hash;
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size;
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<const _Variant> : variant_size<_Variant> {};
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/ccawPiBL.s 			page 3


  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<volatile _Variant> : variant_size<_Variant> {};
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<const volatile _Variant> : variant_size<_Variant> {};
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_size<variant<_Types...>>
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : std::integral_constant<size_t, sizeof...(_Types)> {};
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr size_t variant_size_v = variant_size<_Variant>::value;
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative;
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _First, typename... _Rest>
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, variant<_First, _Rest...>>
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : variant_alternative<_Np-1, variant<_Rest...>> {};
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _First, typename... _Rest>
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<0, variant<_First, _Rest...>>
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = _First; };
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using variant_alternative_t =
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       typename variant_alternative<_Np, _Variant>::type;
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, const _Variant>
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = add_const_t<variant_alternative_t<_Np, _Variant>>; };
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, volatile _Variant>
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = add_volatile_t<variant_alternative_t<_Np, _Variant>>; };
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct variant_alternative<_Np, const volatile _Variant>
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { using type = add_cv_t<variant_alternative_t<_Np, _Variant>>; };
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   inline constexpr size_t variant_npos = -1;
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>>&
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(variant<_Types...>&);
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>>&&
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(variant<_Types...>&&);
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>> const&
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(const variant<_Types...>&);
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>> const&&
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(const variant<_Types...>&&);
ARM GAS  /tmp/ccawPiBL.s 			page 4


 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, typename... _Variants>
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __do_visit(_Visitor&& __visitor, _Variants&&... __variants);
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename... _Types, typename _Tp>
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     decltype(auto)
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __variant_cast(_Tp&& __rhs)
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if constexpr (is_lvalue_reference_v<_Tp>)
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (is_const_v<remove_reference_t<_Tp>>)
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return static_cast<const variant<_Types...>&>(__rhs);
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return static_cast<variant<_Types...>&>(__rhs);
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       else
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         return static_cast<variant<_Types...>&&>(__rhs);
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __detail
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** namespace __variant
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** {
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns the first appearence of _Tp in _Types.
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns sizeof...(_Types) if _Tp is not in _Types.
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __index_of : std::integral_constant<size_t, 0> {};
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr size_t __index_of_v = __index_of<_Tp, _Types...>::value;
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _First, typename... _Rest>
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __index_of<_Tp, _First, _Rest...> :
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       std::integral_constant<size_t, is_same_v<_Tp, _First>
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	? 0 : __index_of_v<_Tp, _Rest...> + 1> {};
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // used for raw visitation
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   struct __variant_cookie {};
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // used for raw visitation with indices passed in
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   struct __variant_idx_cookie { using type = __variant_idx_cookie; };
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Used to enable deduction (and same-type checking) for std::visit:
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename> struct __deduce_visit_result { };
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Visit variants that might be valueless.
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr void
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __raw_visit(_Visitor&& __visitor, _Variants&&... __variants)
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       std::__do_visit<__variant_cookie>(std::forward<_Visitor>(__visitor),
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				        std::forward<_Variants>(__variants)...);
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Visit variants that might be valueless, passing indices to the visitor.
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr void
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __raw_idx_visit(_Visitor&& __visitor, _Variants&&... __variants)
ARM GAS  /tmp/ccawPiBL.s 			page 5


 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       std::__do_visit<__variant_idx_cookie>(std::forward<_Visitor>(__visitor),
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  std::forward<_Variants>(__variants)...);
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // _Uninitialized<T> is guaranteed to be a trivially destructible type,
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // even if T is not.
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Type, bool = std::is_trivially_destructible_v<_Type>>
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Uninitialized;
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Type>
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Uninitialized<_Type, true>
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Uninitialized(in_place_index_t<0>, _Args&&... __args)
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_storage(std::forward<_Args>(__args)...)
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr const _Type& _M_get() const & noexcept
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr _Type& _M_get() & noexcept
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr const _Type&& _M_get() const && noexcept
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(_M_storage); }
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr _Type&& _M_get() && noexcept
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(_M_storage); }
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Type _M_storage;
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Type>
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Uninitialized<_Type, false>
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Uninitialized(in_place_index_t<0>, _Args&&... __args)
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  ::new ((void*)std::addressof(_M_storage))
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    _Type(std::forward<_Args>(__args)...);
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       const _Type& _M_get() const & noexcept
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return *_M_storage._M_ptr(); }
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Type& _M_get() & noexcept
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return *_M_storage._M_ptr(); }
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       const _Type&& _M_get() const && noexcept
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(*_M_storage._M_ptr()); }
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Type&& _M_get() && noexcept
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return std::move(*_M_storage._M_ptr()); }
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/ccawPiBL.s 			page 6


 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __gnu_cxx::__aligned_membuf<_Type> _M_storage;
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Union>
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __get(in_place_index_t<0>, _Union&& __u) noexcept
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Union>
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __get(in_place_index_t<_Np>, _Union&& __u) noexcept
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __variant::__get(in_place_index<_Np-1>,
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			      std::forward<_Union>(__u)._M_rest);
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns the typed storage for __v.
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr decltype(auto)
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     __get(_Variant&& __v) noexcept
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __variant::__get(std::in_place_index<_Np>,
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			      std::forward<_Variant>(__v)._M_u);
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Traits
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_default_ctor =
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  is_default_constructible_v<typename _Nth_type<0, _Types...>::type>;
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_copy_ctor =
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_copy_constructible_v<_Types> && ...);
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_move_ctor =
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_move_constructible_v<_Types> && ...);
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_copy_assign =
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_copy_ctor
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_copy_assignable_v<_Types> && ...);
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_move_assign =
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_move_ctor
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_move_assignable_v<_Types> && ...);
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_dtor =
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_trivially_destructible_v<_Types> && ...);
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_copy_ctor =
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_trivially_copy_constructible_v<_Types> && ...);
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_move_ctor =
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_trivially_move_constructible_v<_Types> && ...);
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_copy_assign =
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_trivial_dtor && _S_trivial_copy_ctor
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_trivially_copy_assignable_v<_Types> && ...);
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_trivial_move_assign =
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_trivial_dtor && _S_trivial_move_ctor
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_trivially_move_assignable_v<_Types> && ...);
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // The following nothrow traits are for non-trivial SMFs. Trivial SMFs
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // are always nothrow.
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_default_ctor =
ARM GAS  /tmp/ccawPiBL.s 			page 7


 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  is_nothrow_default_constructible_v<
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      typename _Nth_type<0, _Types...>::type>;
 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_copy_ctor = false;
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_move_ctor =
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (is_nothrow_move_constructible_v<_Types> && ...);
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_copy_assign = false;
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool _S_nothrow_move_assign =
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _S_nothrow_move_ctor
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  && (is_nothrow_move_assignable_v<_Types> && ...);
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Defines members and ctors.
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     union _Variadic_union { };
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _First, typename... _Rest>
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     union _Variadic_union<_First, _Rest...>
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr _Variadic_union() : _M_rest() { }
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr _Variadic_union(in_place_index_t<0>, _Args&&... __args)
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_first(in_place_index<0>, std::forward<_Args>(__args)...)
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr _Variadic_union(in_place_index_t<_Np>, _Args&&... __args)
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_rest(in_place_index<_Np-1>, std::forward<_Args>(__args)...)
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Uninitialized<_First> _M_first;
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variadic_union<_Rest...> _M_rest;
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // _Never_valueless_alt is true for variant alternatives that can
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // always be placed in a variant without it becoming valueless.
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // For suitably-small, trivially copyable types we can create temporaries
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // on the stack and then memcpy them into place.
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp>
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Never_valueless_alt
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : __and_<bool_constant<sizeof(_Tp) <= 256>, is_trivially_copyable<_Tp>>
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { };
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Specialize _Never_valueless_alt for other types which have a
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // non-throwing and cheap move construction and move assignment operator,
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // so that emplacing the type will provide the strong exception-safety
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // guarantee, by creating and moving a temporary.
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Whether _Never_valueless_alt<T> is true or not affects the ABI of a
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // variant using that alternative, so we can't change the value later!
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // True if every alternative in _Types... can be emplaced in a variant
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // without it becoming valueless. If this is true, variant<_Types...>
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // can never be valueless, which enables some minor optimizations.
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename... _Types>
 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr bool __never_valueless()
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
ARM GAS  /tmp/ccawPiBL.s 			page 8


 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return _Traits<_Types...>::_S_move_assign
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	&& (_Never_valueless_alt<_Types>::value && ...);
 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Defines index and the dtor, possibly trivial.
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool __trivially_destructible, typename... _Types>
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_storage;
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename... _Types>
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using __select_index =
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       typename __select_int::_Select_int_base<sizeof...(_Types),
 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					      unsigned char,
 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					      unsigned short>::type::value_type;
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_storage<false, _Types...>
 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_storage()
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       : _M_index(static_cast<__index_type>(variant_npos))
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { }
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
 397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_index{_Np}
 398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void _M_reset()
 401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if (!_M_valid()) [[unlikely]]
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return;
 404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::__do_visit<void>([](auto&& __this_mem) mutable
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::_Destroy(std::__addressof(__this_mem));
 408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __variant_cast<_Types...>(*this));
 409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_index = static_cast<__index_type>(variant_npos);
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       ~_Variant_storage()
 414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_reset(); }
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void*
 417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_storage() const noexcept
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return const_cast<void*>(static_cast<const void*>(
 420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::addressof(_M_u)));
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr bool
 424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_valid() const noexcept
 425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (__variant::__never_valueless<_Types...>())
 427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return true;
ARM GAS  /tmp/ccawPiBL.s 			page 9


 428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return this->_M_index != __index_type(variant_npos);
 429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variadic_union<_Types...> _M_u;
 432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using __index_type = __select_index<_Types...>;
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __index_type _M_index;
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_storage<true, _Types...>
 438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr
 440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_storage()
 441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       : _M_index(static_cast<__index_type>(variant_npos))
 442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { }
 443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
 447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_index{_Np}
 449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void _M_reset() noexcept
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { _M_index = static_cast<__index_type>(variant_npos); }
 453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void*
 455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_storage() const noexcept
 456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return const_cast<void*>(static_cast<const void*>(
 458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::addressof(_M_u)));
 459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr bool
 462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_valid() const noexcept
 463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (__variant::__never_valueless<_Types...>())
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return true;
 466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return this->_M_index != static_cast<__index_type>(variant_npos);
 467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variadic_union<_Types...> _M_u;
 470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using __index_type = __select_index<_Types...>;
 471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __index_type _M_index;
 472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Variant_storage_alias =
 476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_storage<_Traits<_Types...>::_S_trivial_dtor, _Types...>;
 477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Up>
 479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void __variant_construct_single(_Tp&& __lhs, _Up&& __rhs_mem)
 480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void* __storage = std::addressof(__lhs._M_u);
 482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Type = remove_reference_t<decltype(__rhs_mem)>;
 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if constexpr (!is_same_v<_Type, __variant_cookie>)
 484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         ::new (__storage)
ARM GAS  /tmp/ccawPiBL.s 			page 10


 485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Type(std::forward<decltype(__rhs_mem)>(__rhs_mem));
 486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types, typename _Tp, typename _Up>
 489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void __variant_construct(_Tp&& __lhs, _Up&& __rhs)
 490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __lhs._M_index = __rhs._M_index;
 492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __variant::__raw_visit([&__lhs](auto&& __rhs_mem) mutable
 493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(std::forward<_Tp>(__lhs),
 495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      std::forward<decltype(__rhs_mem)>(__rhs_mem));
 496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}, __variant_cast<_Types...>(std::forward<_Up>(__rhs)));
 497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
 498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The following are (Copy|Move) (ctor|assign) layers for forwarding
 500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // triviality and handling non-trivial SMF behaviors.
 501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_ctor_base : _Variant_storage_alias<_Types...>
 504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Variant_storage_alias<_Types...>;
 506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base(const _Copy_ctor_base& __rhs)
 509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_copy_ctor)
 510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant_construct<_Types...>(*this, __rhs);
 512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base(_Copy_ctor_base&&) = default;
 515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base& operator=(const _Copy_ctor_base&) = default;
 516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_ctor_base& operator=(_Copy_ctor_base&&) = default;
 517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_ctor_base<true, _Types...> : _Variant_storage_alias<_Types...>
 521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Variant_storage_alias<_Types...>;
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Copy_ctor_alias =
 528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Copy_ctor_base<_Traits<_Types...>::_S_trivial_copy_ctor, _Types...>;
 529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_ctor_base : _Copy_ctor_alias<_Types...>
 532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_ctor_alias<_Types...>;
 534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base(_Move_ctor_base&& __rhs)
 537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_move_ctor)
 538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant_construct<_Types...>(*this, std::move(__rhs));
 540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/ccawPiBL.s 			page 11


 542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)
 544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, std::forward<_Up>(__rhs));
 547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)
 552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, __rhs);
 555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base(const _Move_ctor_base&) = default;
 559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base& operator=(const _Move_ctor_base&) = default;
 560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_ctor_base& operator=(_Move_ctor_base&&) = default;
 561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_ctor_base<true, _Types...> : _Copy_ctor_alias<_Types...>
 565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_ctor_alias<_Types...>;
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)
 571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, std::forward<_Up>(__rhs));
 574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Up>
 578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)
 579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_reset();
 581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __variant_construct_single(*this, __rhs);
 582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  this->_M_index = __rhs_index;
 583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Move_ctor_alias =
 588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Move_ctor_base<_Traits<_Types...>::_S_trivial_move_ctor, _Types...>;
 589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_assign_base : _Move_ctor_alias<_Types...>
 592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Move_ctor_alias<_Types...>;
 594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base&
 597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       operator=(const _Copy_assign_base& __rhs)
 598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_copy_assign)
ARM GAS  /tmp/ccawPiBL.s 			page 12


 599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant::__raw_idx_visit(
 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  [this](auto&& __rhs_mem, auto __rhs_index) mutable
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
 603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    if constexpr (__rhs_index != variant_npos)
 604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      {
 605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		if (this->_M_index == __rhs_index)
 606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant::__get<__rhs_index>(*this) = __rhs_mem;
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		else
 608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  {
 609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    using __rhs_type = __remove_cvref_t<decltype(__rhs_mem)>;
 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    if constexpr (is_nothrow_copy_constructible_v<__rhs_type>
 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			|| !is_nothrow_move_constructible_v<__rhs_type>)
 612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // The standard says this->emplace<__rhs_type>(__rhs_mem)
 613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // should be used here, but _M_destructive_copy is
 614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // equivalent in this case. Either copy construction
 615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // doesn't throw, so _M_destructive_copy gives strong
 616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // exception safety guarantee, or both copy construction
 617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // and move construction can throw, so emplace only gives
 618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      // basic exception safety anyway.
 619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      this->_M_destructive_copy(__rhs_index, __rhs_mem);
 620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    else
 621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      __variant_cast<_Types...>(*this)
 622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			= variant<_Types...>(std::in_place_index<__rhs_index>,
 623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					     __rhs_mem);
 624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  }
 625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      }
 626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    else
 627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
 628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __variant_cast<_Types...>(__rhs));
 629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return *this;
 630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base(const _Copy_assign_base&) = default;
 633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base(_Copy_assign_base&&) = default;
 634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base& operator=(_Copy_assign_base&&) = default;
 635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Copy_assign_base<true, _Types...> : _Move_ctor_alias<_Types...>
 639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Move_ctor_alias<_Types...>;
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Copy_assign_alias =
 646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Copy_assign_base<_Traits<_Types...>::_S_trivial_copy_assign, _Types...>;
 647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<bool, typename... _Types>
 649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_assign_base : _Copy_assign_alias<_Types...>
 650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_assign_alias<_Types...>;
 652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base&
 655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       operator=(_Move_assign_base&& __rhs)
ARM GAS  /tmp/ccawPiBL.s 			page 13


 656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_move_assign)
 657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__variant::__raw_idx_visit(
 659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  [this](auto&& __rhs_mem, auto __rhs_index) mutable
 660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
 661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    if constexpr (__rhs_index != variant_npos)
 662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      {
 663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		if (this->_M_index == __rhs_index)
 664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant::__get<__rhs_index>(*this) = std::move(__rhs_mem);
 665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		else
 666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant_cast<_Types...>(*this)
 667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    .template emplace<__rhs_index>(std::move(__rhs_mem));
 668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      }
 669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    else
 670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
 671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __variant_cast<_Types...>(__rhs));
 672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return *this;
 673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base(const _Move_assign_base&) = default;
 676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base(_Move_assign_base&&) = default;
 677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base& operator=(const _Move_assign_base&) = default;
 678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Move_assign_base<true, _Types...> : _Copy_assign_alias<_Types...>
 682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Copy_assign_alias<_Types...>;
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_Base;
 685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _Move_assign_alias =
 689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Move_assign_base<_Traits<_Types...>::_S_trivial_move_assign, _Types...>;
 690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_base : _Move_assign_alias<_Types...>
 693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = _Move_assign_alias<_Types...>;
 695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base()
 698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  noexcept(_Traits<_Types...>::_S_nothrow_default_ctor)
 699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       : _Variant_base(in_place_index<0>) { }
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
 702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Variant_base(in_place_index_t<_Np> __i, _Args&&... __args)
 704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _Base(__i, std::forward<_Args>(__args)...)
 705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
 706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base(const _Variant_base&) = default;
 708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base(_Variant_base&&) = default;
 709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base& operator=(const _Variant_base&) = default;
 710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Variant_base& operator=(_Variant_base&&) = default;
 711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/ccawPiBL.s 			page 14


 713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // For how many times does _Tp appear in _Tuple?
 714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Tuple>
 715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __tuple_count;
 716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Tuple>
 718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr size_t __tuple_count_v =
 719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __tuple_count<_Tp, _Tuple>::value;
 720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __tuple_count<_Tp, tuple<_Types...>>
 723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : integral_constant<size_t, 0> { };
 724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _First, typename... _Rest>
 726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __tuple_count<_Tp, tuple<_First, _Rest...>>
 727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : integral_constant<
 728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	size_t,
 729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__tuple_count_v<_Tp, tuple<_Rest...>> + is_same_v<_Tp, _First>> { };
 730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // TODO: Reuse this in <tuple> ?
 732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
 733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline constexpr bool __exactly_once =
 734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __tuple_count_v<_Tp, tuple<_Types...>> == 1;
 735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Helper used to check for valid conversions that don't involve narrowing.
 737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Ti> struct _Arr { _Ti _M_x[1]; };
 738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Build an imaginary function FUN(Ti) for each alternative type Ti
 740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Ind, typename _Tp, typename _Ti,
 741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   bool _Ti_is_cv_bool = is_same_v<remove_cv_t<_Ti>, bool>,
 742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename = void>
 743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUN
 744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // This function means 'using _Build_FUN<I, T, Ti>::_S_fun;' is valid,
 746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // but only static functions will be considered in the call below.
 747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void _S_fun();
 748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // ... for which Ti x[] = {std::forward<T>(t)}; is well-formed,
 751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Ind, typename _Tp, typename _Ti>
 752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUN<_Ind, _Tp, _Ti, false,
 753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      void_t<decltype(_Arr<_Ti>{{std::declval<_Tp>()}})>>
 754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // This is the FUN function for type _Ti, with index _Ind
 756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static integral_constant<size_t, _Ind> _S_fun(_Ti);
 757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // ... and if Ti is cv bool, remove_cvref_t<T> is bool.
 760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Ind, typename _Tp, typename _Ti>
 761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUN<_Ind, _Tp, _Ti, true,
 762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      enable_if_t<is_same_v<__remove_cvref_t<_Tp>, bool>>>
 763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       // This is the FUN function for when _Ti is cv bool, with index _Ind
 765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static integral_constant<size_t, _Ind> _S_fun(_Ti);
 766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant,
 769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename = make_index_sequence<variant_size_v<_Variant>>>
ARM GAS  /tmp/ccawPiBL.s 			page 15


 770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUNs;
 771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Ti, size_t... _Ind>
 773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Build_FUNs<_Tp, variant<_Ti...>, index_sequence<_Ind...>>
 774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _Build_FUN<_Ind, _Tp, _Ti>...
 775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Build_FUN<_Ind, _Tp, _Ti>::_S_fun...;
 777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The index j of the overload FUN(Tj) selected by overload resolution
 780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // for FUN(std::forward<_Tp>(t))
 781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant>
 782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using _FUN_type
 783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       = decltype(_Build_FUNs<_Tp, _Variant>::_S_fun(std::declval<_Tp>()));
 784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The index selected for FUN(std::forward<T>(t)), or variant_npos if none.
 786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant, typename = void>
 787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __accepted_index
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : integral_constant<size_t, variant_npos>
 789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { };
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename _Variant>
 792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __accepted_index<_Tp, _Variant, void_t<_FUN_type<_Tp, _Variant>>>
 793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _FUN_type<_Tp, _Variant>
 794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { };
 795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Returns the raw storage for __v.
 797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant>
 798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void* __get_storage(_Variant&& __v) noexcept
 799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return __v._M_storage(); }
 800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template <typename _Maybe_variant_cookie, typename _Variant>
 802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Extra_visit_slot_needed
 803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename> struct _Variant_never_valueless;
 805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Types>
 807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct _Variant_never_valueless<variant<_Types...>>
 808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: bool_constant<__variant::__never_valueless<_Types...>()> {};
 809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr bool value =
 811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	(is_same_v<_Maybe_variant_cookie, __variant_cookie>
 812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	 || is_same_v<_Maybe_variant_cookie, __variant_idx_cookie>)
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	&& !_Variant_never_valueless<__remove_cvref_t<_Variant>>::value;
 814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Used for storing a multi-dimensional vtable.
 817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, size_t... _Dimensions>
 818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Multi_array;
 819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Partial specialization with rank zero, stores a single _Tp element.
 821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp>
 822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Multi_array<_Tp>
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename>
 825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result
 826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
ARM GAS  /tmp/ccawPiBL.s 			page 16


 827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = _Tp; };
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Args>
 830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<const void(*)(_Args...)>
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
 832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = void(*)(_Args...); };
 833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Args>
 835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<__variant_cookie(*)(_Args...)>
 836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
 837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = void(*)(_Args...); };
 838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _Args>
 840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<__variant_idx_cookie(*)(_Args...)>
 841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: false_type
 842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = void(*)(_Args...); };
 843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename _Res, typename... _Args>
 845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __untag_result<__deduce_visit_result<_Res>(*)(_Args...)>
 846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: true_type
 847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ using element_type = _Res(*)(_Args...); };
 848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using __result_is_deduced = __untag_result<_Tp>;
 850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr const typename __untag_result<_Tp>::element_type&
 852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _M_access() const
 853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_data; }
 854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       typename __untag_result<_Tp>::element_type _M_data;
 856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Partial specialization with rank >= 1.
 859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Ret,
 860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename _Visitor,
 861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename... _Variants,
 862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   size_t __first, size_t... __rest>
 863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Multi_array<_Ret(*)(_Visitor, _Variants...), __first, __rest...>
 864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr size_t __index =
 866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	sizeof...(_Variants) - sizeof...(__rest) - 1;
 867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Variant = typename _Nth_type<__index, _Variants...>::type;
 869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr int __do_cookie =
 871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Extra_visit_slot_needed<_Ret, _Variant>::value ? 1 : 0;
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Tp = _Ret(*)(_Visitor, _Variants...);
 874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Args>
 876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr decltype(auto)
 877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_M_access(size_t __first_index, _Args... __rest_indices) const
 878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return _M_arr[__first_index + __do_cookie]
 880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    ._M_access(__rest_indices...);
 881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Multi_array<_Tp, __rest...> _M_arr[__first + __do_cookie];
ARM GAS  /tmp/ccawPiBL.s 			page 17


 884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Creates a multi-dimensional vtable recursively.
 887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //
 888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // For example,
 889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // visit([](auto, auto){},
 890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //       variant<int, char>(),  // typedef'ed as V1
 891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //       variant<float, double, long double>())  // typedef'ed as V2
 892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // will trigger instantiations of:
 893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 2, 3>,
 894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                   tuple<V1&&, V2&&>, std::index_sequence<>>
 895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //   __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 3>,
 896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                     tuple<V1&&, V2&&>, std::index_sequence<0>>
 897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 0>>
 899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 1>>
 901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 2>>
 903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //   __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 3>,
 904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                     tuple<V1&&, V2&&>, std::index_sequence<1>>
 905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 0>>
 907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 1>>
 909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,
 910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 2>>
 911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The returned multi-dimensional vtable can be fast accessed by the visitor
 912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // using index calculation.
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Array_type, typename _Index_seq>
 914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable_impl;
 915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Defines the _S_apply() member that returns a _Multi_array populated
 917:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // with function pointers that perform the visitation expressions e(m)
 918:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // for each valid pack of indexes into the variant types _Variants.
 919:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   //
 920:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // This partial specialization builds up the index sequences by recursively
 921:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // calling _S_apply() on the next specialization of __gen_vtable_impl.
 922:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // The base case of the recursion defines the actual function pointers.
 923:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, size_t... __dimensions,
 924:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   typename... _Variants, size_t... __indices>
 925:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable_impl<
 926:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Multi_array<_Result_type (*)(_Visitor, _Variants...), __dimensions...>,
 927:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::index_sequence<__indices...>>
 928:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 929:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Next =
 930:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  remove_reference_t<typename _Nth_type<sizeof...(__indices),
 931:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			     _Variants...>::type>;
 932:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Array_type =
 933:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Multi_array<_Result_type (*)(_Visitor, _Variants...),
 934:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		       __dimensions...>;
 935:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 936:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr _Array_type
 937:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _S_apply()
 938:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 939:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Array_type __vtable{};
 940:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_S_apply_all_alts(
ARM GAS  /tmp/ccawPiBL.s 			page 18


 941:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __vtable, make_index_sequence<variant_size_v<_Next>>());
 942:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return __vtable;
 943:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
 944:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 945:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t... __var_indices>
 946:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr void
 947:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_S_apply_all_alts(_Array_type& __vtable,
 948:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			  std::index_sequence<__var_indices...>)
 949:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 950:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (_Extra_visit_slot_needed<_Result_type, _Next>::value)
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    (_S_apply_single_alt<true, __var_indices>(
 952:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __vtable._M_arr[__var_indices + 1],
 953:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      &(__vtable._M_arr[0])), ...);
 954:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 955:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    (_S_apply_single_alt<false, __var_indices>(
 956:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __vtable._M_arr[__var_indices]), ...);
 957:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 958:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 959:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<bool __do_cookie, size_t __index, typename _Tp>
 960:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr void
 961:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_S_apply_single_alt(_Tp& __element, _Tp* __cookie_element = nullptr)
 962:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
 963:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__do_cookie)
 964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
 965:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element = __gen_vtable_impl<
 966:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		_Tp,
 967:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::index_sequence<__indices..., __index>>::_S_apply();
 968:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      *__cookie_element = __gen_vtable_impl<
 969:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		_Tp,
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::index_sequence<__indices..., variant_npos>>::_S_apply();
 971:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
 972:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
 973:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
 974:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element = __gen_vtable_impl<
 975:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		remove_reference_t<decltype(__element)>,
 976:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::index_sequence<__indices..., __index>>::_S_apply();
 977:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
 978:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
 979:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
 980:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 981:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // This partial specialization is the base case for the recursion.
 982:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // It populates a _Multi_array element with the address of a function
 983:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // that invokes the visitor with the alternatives specified by __indices.
 984:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, typename... _Variants,
 985:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	   size_t... __indices>
 986:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable_impl<
 987:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _Multi_array<_Result_type (*)(_Visitor, _Variants...)>,
 988:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		   std::index_sequence<__indices...>>
 989:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 990:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Array_type =
 991:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Multi_array<_Result_type (*)(_Visitor, _Variants...)>;
 992:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 993:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t __index, typename _Variant>
 994:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr decltype(auto)
 995:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__element_by_index_or_cookie(_Variant&& __var) noexcept
 996:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         {
 997:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__index != variant_npos)
ARM GAS  /tmp/ccawPiBL.s 			page 19


 998:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return __variant::__get<__index>(std::forward<_Variant>(__var));
 999:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
1000:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    return __variant_cookie{};
1001:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1002:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1003:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr decltype(auto)
1004:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __visit_invoke(_Visitor&& __visitor, _Variants... __vars)
1005:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
1006:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (is_same_v<_Result_type, __variant_idx_cookie>)
1007:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // For raw visitation using indices, pass the indices to the visitor
1008:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // and discard the return value:
1009:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  std::__invoke(std::forward<_Visitor>(__visitor),
1010:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element_by_index_or_cookie<__indices>(
1011:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::forward<_Variants>(__vars))...,
1012:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      integral_constant<size_t, __indices>()...);
1013:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (is_same_v<_Result_type, __variant_cookie>)
1014:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // For raw visitation without indices, and discard the return value:
1015:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  std::__invoke(std::forward<_Visitor>(__visitor),
1016:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element_by_index_or_cookie<__indices>(
1017:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::forward<_Variants>(__vars))...);
1018:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (_Array_type::__result_is_deduced::value)
1019:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // For the usual std::visit case deduce the return value:
1020:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return std::__invoke(std::forward<_Visitor>(__visitor),
1021:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __element_by_index_or_cookie<__indices>(
1022:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		std::forward<_Variants>(__vars))...);
1023:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else // for std::visit<R> use INVOKE<R>
1024:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return std::__invoke_r<_Result_type>(
1025:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      std::forward<_Visitor>(__visitor),
1026:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __variant::__get<__indices>(std::forward<_Variants>(__vars))...);
1027:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
1028:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1029:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr auto
1030:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _S_apply()
1031:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _Array_type{&__visit_invoke}; }
1032:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
1033:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1034:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Result_type, typename _Visitor, typename... _Variants>
1035:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct __gen_vtable
1036:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1037:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Array_type =
1038:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  _Multi_array<_Result_type (*)(_Visitor, _Variants...),
1039:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		       variant_size_v<remove_reference_t<_Variants>>...>;
1040:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1041:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static constexpr _Array_type _S_vtable
1042:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	= __gen_vtable_impl<_Array_type, std::index_sequence<>>::_S_apply();
1043:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
1044:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1045:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Tp>
1046:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Base_dedup : public _Tp { };
1047:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1048:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Variant, typename __indices>
1049:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_hash_base;
1050:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1051:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types, size_t... __indices>
1052:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     struct _Variant_hash_base<variant<_Types...>,
1053:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			      std::index_sequence<__indices...>>
1054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : _Base_dedup<__indices, __poison_hash<remove_const_t<_Types>>>... { };
ARM GAS  /tmp/ccawPiBL.s 			page 20


1055:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1056:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant>
1057:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using __get_t = decltype(std::get<_Np>(std::declval<_Variant>()));
1058:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1059:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Return type of std::visit.
1060:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
1061:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     using __visit_result_t
1062:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       = invoke_result_t<_Visitor, __get_t<0, _Variants>...>;
1063:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1064:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __variant
1065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** } // namespace __detail
1066:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1067:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename _Variant, typename... _Args>
1068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     void __variant_construct_by_index(_Variant& __v, _Args&&... __args)
1069:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __v._M_index = _Np;
1071:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       auto&& __storage = __detail::__variant::__get<_Np>(__v);
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       ::new ((void*)std::addressof(__storage))
1073:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         remove_reference_t<decltype(__storage)>
1074:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  (std::forward<_Args>(__args)...);
1075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1076:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1077:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1078:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr bool
1079:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     holds_alternative(const variant<_Types...>& __v) noexcept
1080:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1081:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1082:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1083:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __v.index() == __detail::__variant::__index_of_v<_Tp, _Types...>;
1084:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1085:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1086:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1087:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr _Tp& get(variant<_Types...>& __v)
1088:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1089:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1090:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1091:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1092:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
1093:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1094:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1095:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1096:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr _Tp&& get(variant<_Types...>&& __v)
1097:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1098:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1099:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::move(__v));
1103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr const _Tp& get(const variant<_Types...>& __v)
1107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
ARM GAS  /tmp/ccawPiBL.s 			page 21


1112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr const _Tp&& get(const variant<_Types...>&& __v)
1116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	std::move(__v));
1122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
1125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr add_pointer_t<variant_alternative_t<_Np, variant<_Types...>>>
1126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(variant<_Types...>* __ptr) noexcept
1127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
1129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(_Np < sizeof...(_Types),
1130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "The index must be in [0, number of alternatives)");
1131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Alternative_type>, "_Tp must not be void");
1132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if (__ptr && __ptr->index() == _Np)
1133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return std::addressof(__detail::__variant::__get<_Np>(*__ptr));
1134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return nullptr;
1135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
1138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr
1139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     add_pointer_t<const variant_alternative_t<_Np, variant<_Types...>>>
1140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(const variant<_Types...>* __ptr) noexcept
1141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
1143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(_Np < sizeof...(_Types),
1144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "The index must be in [0, number of alternatives)");
1145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Alternative_type>, "_Tp must not be void");
1146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if (__ptr && __ptr->index() == _Np)
1147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	return std::addressof(__detail::__variant::__get<_Np>(*__ptr));
1148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return nullptr;
1149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr add_pointer_t<_Tp>
1153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(variant<_Types...>* __ptr) noexcept
1154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
1158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __ptr);
1160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Tp, typename... _Types>
1163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr add_pointer_t<const _Tp>
1164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get_if(const variant<_Types...>* __ptr) noexcept
1165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
1167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "T must occur exactly once in alternatives");
1168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!is_void_v<_Tp>, "_Tp must not be void");
ARM GAS  /tmp/ccawPiBL.s 			page 22


1169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
1170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __ptr);
1171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   struct monostate { };
1174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP, __NAME) \
1176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types> \
1177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr bool operator __OP(const variant<_Types...>& __lhs, \
1178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				 const variant<_Types...>& __rhs) \
1179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { \
1180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       bool __ret = true; \
1181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __detail::__variant::__raw_idx_visit( \
1182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         [&__ret, &__lhs] (auto&& __rhs_mem, auto __rhs_index) mutable \
1183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****         { \
1184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__rhs_index != variant_npos) \
1185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    { \
1186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      if (__lhs.index() == __rhs_index) \
1187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	        { \
1188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  auto& __this_mem = std::get<__rhs_index>(__lhs);	\
1189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****                   __ret = __this_mem __OP __rhs_mem; \
1190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****                 } \
1191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      else \
1192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		__ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \
1193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****             } \
1194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****           else \
1195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****             __ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \
1196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}, __rhs); \
1197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __ret; \
1198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(<, less)
1201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(<=, less_equal)
1202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(==, equal)
1203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(!=, not_equal)
1204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(>=, greater_equal)
1205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   _VARIANT_RELATION_FUNCTION_TEMPLATE(>, greater)
1206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #undef _VARIANT_RELATION_FUNCTION_TEMPLATE
1208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator==(monostate, monostate) noexcept { return true; }
1210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #ifdef __cpp_lib_three_way_comparison
1212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     requires (three_way_comparable<_Types> && ...)
1214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr
1215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     common_comparison_category_t<compare_three_way_result_t<_Types>...>
1216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     operator<=>(const variant<_Types...>& __v, const variant<_Types...>& __w)
1217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       common_comparison_category_t<compare_three_way_result_t<_Types>...> __ret
1219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	= strong_ordering::equal;
1220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __detail::__variant::__raw_idx_visit(
1222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	[&__ret, &__v] (auto&& __w_mem, auto __w_index) mutable
1223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (__w_index != variant_npos)
1225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
ARM GAS  /tmp/ccawPiBL.s 			page 23


1226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      if (__v.index() == __w_index)
1227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  auto& __this_mem = std::get<__w_index>(__v);
1229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __ret = __this_mem <=> __w_mem;
1230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  return;
1231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __ret = (__v.index() + 1) <=> (__w_index + 1);
1234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}, __w);
1235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       return __ret;
1236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     }
1237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr strong_ordering
1239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   operator<=>(monostate, monostate) noexcept { return strong_ordering::equal; }
1240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #else
1241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator!=(monostate, monostate) noexcept { return false; }
1242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator<(monostate, monostate) noexcept { return false; }
1243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator>(monostate, monostate) noexcept { return false; }
1244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator<=(monostate, monostate) noexcept { return true; }
1245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   constexpr bool operator>=(monostate, monostate) noexcept { return true; }
1246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #endif
1247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename _Visitor, typename... _Variants>
1249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
1250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     visit(_Visitor&&, _Variants&&...);
1251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     inline enable_if_t<(is_move_constructible_v<_Types> && ...)
1254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			&& (is_swappable_v<_Types> && ...)>
1255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     swap(variant<_Types...>& __lhs, variant<_Types...>& __rhs)
1256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     noexcept(noexcept(__lhs.swap(__rhs)))
1257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { __lhs.swap(__rhs); }
1258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     enable_if_t<!((is_move_constructible_v<_Types> && ...)
1261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		   && (is_swappable_v<_Types> && ...))>
1262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     swap(variant<_Types...>&, variant<_Types...>&) = delete;
1263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   class bad_variant_access : public exception
1265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
1266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   public:
1267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     bad_variant_access() noexcept { }
1268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     const char* what() const noexcept override
  31              		.loc 1 1269 17 view -0
  32              		.cfi_startproc
  33              		@ args = 0, pretend = 0, frame = 0
  34              		@ frame_needed = 0, uses_anonymous_args = 0
  35              		@ link register save eliminated.
1270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return _M_reason; }
  36              		.loc 1 1270 7 view .LVU1
  37              		.loc 1 1270 25 is_stmt 0 view .LVU2
  38 0000 4068     		ldr	r0, [r0, #4]
  39              	.LVL1:
  40              		.loc 1 1270 25 view .LVU3
  41 0002 7047     		bx	lr
  42              		.cfi_endproc
ARM GAS  /tmp/ccawPiBL.s 			page 24


  43              	.LFE3066:
  44              		.cantunwind
  45              		.fnend
  47              		.section	.text._ZN10Controller21get_anticogging_valueEm,"axG",%progbits,_ZN10Controller21get_antic
  48              		.align	1
  49              		.weak	_ZN10Controller21get_anticogging_valueEm
  50              		.syntax unified
  51              		.thumb
  52              		.thumb_func
  54              	_ZN10Controller21get_anticogging_valueEm:
  55              		.fnstart
  56              	.LVL2:
  57              	.LFB4306:
  58              		.file 2 "MotorControl/controller.hpp"
   1:MotorControl/controller.hpp **** #ifndef __CONTROLLER_HPP
   2:MotorControl/controller.hpp **** #define __CONTROLLER_HPP
   3:MotorControl/controller.hpp **** 
   4:MotorControl/controller.hpp **** class Controller : public ODriveIntf::ControllerIntf {
   5:MotorControl/controller.hpp **** public:
   6:MotorControl/controller.hpp ****     struct Anticogging_t {
   7:MotorControl/controller.hpp ****         uint32_t index = 0;
   8:MotorControl/controller.hpp ****         float cogging_map[3600];
   9:MotorControl/controller.hpp ****         bool pre_calibrated = false;
  10:MotorControl/controller.hpp ****         bool calib_anticogging = false;
  11:MotorControl/controller.hpp ****         float calib_pos_threshold = 1.0f;
  12:MotorControl/controller.hpp ****         float calib_vel_threshold = 1.0f;
  13:MotorControl/controller.hpp ****         float cogging_ratio = 1.0f;
  14:MotorControl/controller.hpp ****         bool anticogging_enabled = true;
  15:MotorControl/controller.hpp ****     };
  16:MotorControl/controller.hpp **** 
  17:MotorControl/controller.hpp ****     struct Autotuning_t {
  18:MotorControl/controller.hpp ****         float frequency = 0.0f;
  19:MotorControl/controller.hpp ****         float pos_amplitude = 0.0f;
  20:MotorControl/controller.hpp ****         float vel_amplitude = 0.0f;
  21:MotorControl/controller.hpp ****         float torque_amplitude = 0.0f;
  22:MotorControl/controller.hpp ****     };
  23:MotorControl/controller.hpp **** 
  24:MotorControl/controller.hpp ****     struct Config_t {
  25:MotorControl/controller.hpp ****         ControlMode control_mode = CONTROL_MODE_POSITION_CONTROL;  //see: ControlMode_t
  26:MotorControl/controller.hpp ****         InputMode input_mode = INPUT_MODE_PASSTHROUGH;             //see: InputMode_t
  27:MotorControl/controller.hpp ****         float pos_gain = 20.0f;                  // [(turn/s) / turn]
  28:MotorControl/controller.hpp ****         float vel_gain = 1.0f / 6.0f;            // [Nm/(turn/s)]
  29:MotorControl/controller.hpp ****         // float vel_gain = 0.2f / 200.0f,       // [Nm/(rad/s)] <sensorless example>
  30:MotorControl/controller.hpp ****         float vel_integrator_gain = 2.0f / 6.0f; // [Nm/(turn/s * s)]
  31:MotorControl/controller.hpp ****         float vel_limit = 2.0f;                  // [turn/s] Infinity to disable.
  32:MotorControl/controller.hpp ****         float vel_limit_tolerance = 1.2f;        // ratio to vel_lim. Infinity to disable.
  33:MotorControl/controller.hpp ****         float vel_integrator_limit = INFINITY;   // Vel. integrator clamping value. Infinity to dis
  34:MotorControl/controller.hpp ****         float vel_ramp_rate = 1.0f;              // [(turn/s) / s]
  35:MotorControl/controller.hpp ****         float torque_ramp_rate = 0.01f;          // Nm / sec
  36:MotorControl/controller.hpp ****         bool circular_setpoints = false;
  37:MotorControl/controller.hpp ****         float circular_setpoint_range = 1.0f;    // Circular range when circular_setpoints is true.
  38:MotorControl/controller.hpp ****         uint32_t steps_per_circular_range = 1024;
  39:MotorControl/controller.hpp ****         float inertia = 0.0f;                    // [Nm/(turn/s^2)]
  40:MotorControl/controller.hpp ****         float input_filter_bandwidth = 2.0f;     // [1/s]
  41:MotorControl/controller.hpp ****         float homing_speed = 0.25f;              // [turn/s]
  42:MotorControl/controller.hpp ****         Anticogging_t anticogging;
  43:MotorControl/controller.hpp ****         float gain_scheduling_width = 10.0f;
ARM GAS  /tmp/ccawPiBL.s 			page 25


  44:MotorControl/controller.hpp ****         bool enable_gain_scheduling = false;
  45:MotorControl/controller.hpp ****         bool enable_vel_limit = true;
  46:MotorControl/controller.hpp ****         bool enable_overspeed_error = true;
  47:MotorControl/controller.hpp ****         bool enable_torque_mode_vel_limit = true;  // enable velocity limit in current control mode
  48:MotorControl/controller.hpp ****         uint8_t axis_to_mirror = -1;
  49:MotorControl/controller.hpp ****         float mirror_ratio = 1.0f;
  50:MotorControl/controller.hpp ****         float torque_mirror_ratio = 0.0f;
  51:MotorControl/controller.hpp ****         uint8_t load_encoder_axis = -1;  // default depends on Axis number and is set in load_confi
  52:MotorControl/controller.hpp ****         float mechanical_power_bandwidth = 20.0f; // [rad/s] filter cutoff for mechanical power for
  53:MotorControl/controller.hpp ****         float electrical_power_bandwidth = 20.0f; // [rad/s] filter cutoff for electrical power for
  54:MotorControl/controller.hpp ****         float spinout_electrical_power_threshold = 10.0f; // [W] electrical power threshold for spi
  55:MotorControl/controller.hpp ****         float spinout_mechanical_power_threshold = -10.0f; // [W] mechanical power threshold for sp
  56:MotorControl/controller.hpp **** 
  57:MotorControl/controller.hpp ****         // custom setters
  58:MotorControl/controller.hpp ****         Controller* parent;
  59:MotorControl/controller.hpp ****         void set_input_filter_bandwidth(float value) { input_filter_bandwidth = value; parent->upda
  60:MotorControl/controller.hpp ****         void set_steps_per_circular_range(uint32_t value) { steps_per_circular_range = value > 0 ? 
  61:MotorControl/controller.hpp ****         void set_control_mode(ControlMode value) { control_mode = value; parent->control_mode_updat
  62:MotorControl/controller.hpp ****     };
  63:MotorControl/controller.hpp **** 
  64:MotorControl/controller.hpp ****     
  65:MotorControl/controller.hpp ****     bool apply_config();
  66:MotorControl/controller.hpp **** 
  67:MotorControl/controller.hpp ****     void reset();
  68:MotorControl/controller.hpp ****     void set_error(Error error);
  69:MotorControl/controller.hpp **** 
  70:MotorControl/controller.hpp ****     constexpr void input_pos_updated() {
  71:MotorControl/controller.hpp ****         input_pos_updated_ = true;
  72:MotorControl/controller.hpp ****     }
  73:MotorControl/controller.hpp ****     bool control_mode_updated();
  74:MotorControl/controller.hpp ****     void set_input_pos_and_steps(float pos);
  75:MotorControl/controller.hpp **** 
  76:MotorControl/controller.hpp ****     bool select_encoder(size_t encoder_num);
  77:MotorControl/controller.hpp **** 
  78:MotorControl/controller.hpp ****     // Trajectory-Planned control
  79:MotorControl/controller.hpp ****     void move_to_pos(float goal_point);
  80:MotorControl/controller.hpp ****     void move_incremental(float displacement, bool from_goal_point);
  81:MotorControl/controller.hpp ****     
  82:MotorControl/controller.hpp ****     // TODO: make this more similar to other calibration loops
  83:MotorControl/controller.hpp ****     void start_anticogging_calibration();
  84:MotorControl/controller.hpp ****     float remove_anticogging_bias();
  85:MotorControl/controller.hpp ****     bool anticogging_calibration(float pos_estimate, float vel_estimate);
  86:MotorControl/controller.hpp ****     
  87:MotorControl/controller.hpp ****     float get_anticogging_value(uint32_t index) {
  59              		.loc 2 87 11 is_stmt 1 view -0
  60              		.cfi_startproc
  61              		@ args = 0, pretend = 0, frame = 0
  62              		@ frame_needed = 0, uses_anonymous_args = 0
  63              		@ link register save eliminated.
  88:MotorControl/controller.hpp ****         return (index < 3600) ? config_.anticogging.cogging_map[index] : 0.0f;
  64              		.loc 2 88 9 view .LVU5
  65              		.loc 2 88 31 is_stmt 0 view .LVU6
  66 0000 B1F5616F 		cmp	r1, #3600
  67 0004 05D2     		bcs	.L4
  68              		.loc 2 88 31 discriminator 1 view .LVU7
  69 0006 1431     		adds	r1, r1, #20
  70              	.LVL3:
ARM GAS  /tmp/ccawPiBL.s 			page 26


  71              		.loc 2 88 31 discriminator 1 view .LVU8
  72 0008 00EB8100 		add	r0, r0, r1, lsl #2
  73              	.LVL4:
  74              		.loc 2 88 31 discriminator 1 view .LVU9
  75 000c 90ED020A 		vldr.32	s0, [r0, #8]
  76 0010 7047     		bx	lr
  77              	.LVL5:
  78              	.L4:
  79              		.loc 2 88 31 view .LVU10
  80 0012 9FED010A 		vldr.32	s0, .L5
  89:MotorControl/controller.hpp ****     }
  81              		.loc 2 89 5 view .LVU11
  82 0016 7047     		bx	lr
  83              	.L6:
  84              		.align	2
  85              	.L5:
  86 0018 00000000 		.word	0
  87              		.cfi_endproc
  88              	.LFE4306:
  89              		.cantunwind
  90              		.fnend
  92              		.section	.text._ZN10Controller16move_incrementalEfb,"ax",%progbits
  93              		.align	1
  94              		.global	_ZN10Controller16move_incrementalEfb
  95              		.syntax unified
  96              		.thumb
  97              		.thumb_func
  99              	_ZN10Controller16move_incrementalEfb:
 100              		.fnstart
 101              	.LVL6:
 102              	.LFB5190:
 103              		.file 3 "MotorControl/controller.cpp"
   1:MotorControl/controller.cpp **** 
   2:MotorControl/controller.cpp **** #include "odrive_main.h"
   3:MotorControl/controller.cpp **** #include <algorithm>
   4:MotorControl/controller.cpp **** #include <numeric>
   5:MotorControl/controller.cpp **** 
   6:MotorControl/controller.cpp **** bool Controller::apply_config() {
   7:MotorControl/controller.cpp ****     config_.parent = this;
   8:MotorControl/controller.cpp ****     update_filter_gains();
   9:MotorControl/controller.cpp ****     return true;
  10:MotorControl/controller.cpp **** }
  11:MotorControl/controller.cpp **** 
  12:MotorControl/controller.cpp **** void Controller::reset() {
  13:MotorControl/controller.cpp ****     // pos_setpoint is initialized in start_closed_loop_control
  14:MotorControl/controller.cpp ****     vel_setpoint_ = 0.0f;
  15:MotorControl/controller.cpp ****     vel_integrator_torque_ = 0.0f;
  16:MotorControl/controller.cpp ****     torque_setpoint_ = 0.0f;
  17:MotorControl/controller.cpp ****     mechanical_power_ = 0.0f;
  18:MotorControl/controller.cpp ****     electrical_power_ = 0.0f;
  19:MotorControl/controller.cpp **** }
  20:MotorControl/controller.cpp **** 
  21:MotorControl/controller.cpp **** void Controller::set_error(Error error) {
  22:MotorControl/controller.cpp ****     error_ |= error;
  23:MotorControl/controller.cpp ****     last_error_time_ = odrv.n_evt_control_loop_ * current_meas_period;
  24:MotorControl/controller.cpp **** }
  25:MotorControl/controller.cpp **** 
ARM GAS  /tmp/ccawPiBL.s 			page 27


  26:MotorControl/controller.cpp **** //--------------------------------
  27:MotorControl/controller.cpp **** // Command Handling
  28:MotorControl/controller.cpp **** //--------------------------------
  29:MotorControl/controller.cpp **** 
  30:MotorControl/controller.cpp **** 
  31:MotorControl/controller.cpp **** void Controller::move_to_pos(float goal_point) {
  32:MotorControl/controller.cpp ****     axis_->trap_traj_.planTrapezoidal(goal_point, pos_setpoint_, vel_setpoint_,
  33:MotorControl/controller.cpp ****                                  axis_->trap_traj_.config_.vel_limit,
  34:MotorControl/controller.cpp ****                                  axis_->trap_traj_.config_.accel_limit,
  35:MotorControl/controller.cpp ****                                  axis_->trap_traj_.config_.decel_limit);
  36:MotorControl/controller.cpp ****     axis_->trap_traj_.t_ = 0.0f;
  37:MotorControl/controller.cpp ****     trajectory_done_ = false;
  38:MotorControl/controller.cpp **** }
  39:MotorControl/controller.cpp **** 
  40:MotorControl/controller.cpp **** void Controller::move_incremental(float displacement, bool from_input_pos = true){
 104              		.loc 3 40 82 is_stmt 1 view -0
 105              		.cfi_startproc
 106              		@ args = 0, pretend = 0, frame = 0
 107              		@ frame_needed = 0, uses_anonymous_args = 0
 108              		@ link register save eliminated.
  41:MotorControl/controller.cpp ****     if(from_input_pos){
 109              		.loc 3 41 5 view .LVU13
 110 0000 69B1     		cbz	r1, .L8
  42:MotorControl/controller.cpp ****         input_pos_ += displacement;
 111              		.loc 3 42 9 view .LVU14
 112              		.loc 3 42 20 is_stmt 0 view .LVU15
 113 0002 00F56453 		add	r3, r0, #14592
 114 0006 D3ED057A 		vldr.32	s15, [r3, #20]
 115 000a 37EE800A 		vadd.f32	s0, s15, s0
 116              	.LVL7:
 117              		.loc 3 42 20 view .LVU16
 118 000e 83ED050A 		vstr.32	s0, [r3, #20]
 119              	.L9:
  43:MotorControl/controller.cpp ****     } else{
  44:MotorControl/controller.cpp ****         input_pos_ = pos_setpoint_ + displacement;
  45:MotorControl/controller.cpp ****     }
  46:MotorControl/controller.cpp **** 
  47:MotorControl/controller.cpp ****     input_pos_updated();
 120              		.loc 3 47 5 is_stmt 1 view .LVU17
 121              	.LVL8:
 122              	.LBB547:
 123              	.LBI547:
  70:MotorControl/controller.hpp ****         input_pos_updated_ = true;
 124              		.loc 2 70 20 view .LVU18
 125              	.LBB548:
  71:MotorControl/controller.hpp ****     }
 126              		.loc 2 71 9 view .LVU19
  71:MotorControl/controller.hpp ****     }
 127              		.loc 2 71 28 is_stmt 0 view .LVU20
 128 0012 00F54050 		add	r0, r0, #12288
 129              	.LVL9:
  71:MotorControl/controller.hpp ****     }
 130              		.loc 2 71 28 view .LVU21
 131 0016 0123     		movs	r3, #1
 132 0018 80F83C39 		strb	r3, [r0, #2364]
 133              	.LVL10:
  71:MotorControl/controller.hpp ****     }
ARM GAS  /tmp/ccawPiBL.s 			page 28


 134              		.loc 2 71 28 view .LVU22
 135              	.LBE548:
 136              	.LBE547:
  48:MotorControl/controller.cpp **** }
 137              		.loc 3 48 1 view .LVU23
 138 001c 7047     		bx	lr
 139              	.LVL11:
 140              	.L8:
  44:MotorControl/controller.cpp ****     }
 141              		.loc 3 44 9 is_stmt 1 view .LVU24
  44:MotorControl/controller.cpp ****     }
 142              		.loc 3 44 22 is_stmt 0 view .LVU25
 143 001e 00F54053 		add	r3, r0, #12288
 144 0022 03F60412 		addw	r2, r3, #2308
 145 0026 D2ED007A 		vldr.32	s15, [r2]
  44:MotorControl/controller.cpp ****     }
 146              		.loc 3 44 36 view .LVU26
 147 002a 37EE800A 		vadd.f32	s0, s15, s0
 148              	.LVL12:
  44:MotorControl/controller.cpp ****     }
 149              		.loc 3 44 20 view .LVU27
 150 002e 03F61413 		addw	r3, r3, #2324
 151 0032 83ED000A 		vstr.32	s0, [r3]
 152 0036 ECE7     		b	.L9
 153              		.cfi_endproc
 154              	.LFE5190:
 155              		.cantunwind
 156              		.fnend
 158              		.section	.text._ZN10Controller29start_anticogging_calibrationEv,"ax",%progbits
 159              		.align	1
 160              		.global	_ZN10Controller29start_anticogging_calibrationEv
 161              		.syntax unified
 162              		.thumb
 163              		.thumb_func
 165              	_ZN10Controller29start_anticogging_calibrationEv:
 166              		.fnstart
 167              	.LVL13:
 168              	.LFB5191:
  49:MotorControl/controller.cpp **** 
  50:MotorControl/controller.cpp **** void Controller::start_anticogging_calibration() {
 169              		.loc 3 50 50 is_stmt 1 view -0
 170              		.cfi_startproc
 171              		@ args = 0, pretend = 0, frame = 0
 172              		@ frame_needed = 0, uses_anonymous_args = 0
 173              		@ link register save eliminated.
  51:MotorControl/controller.cpp ****     // Ensure the cogging map was correctly allocated earlier and that the motor is capable of cali
  52:MotorControl/controller.cpp ****     if (axis_->error_ == Axis::ERROR_NONE) {
 174              		.loc 3 52 5 view .LVU29
 175              		.loc 3 52 9 is_stmt 0 view .LVU30
 176 0000 00F54053 		add	r3, r0, #12288
 177 0004 D3F8D838 		ldr	r3, [r3, #2264]
 178              		.loc 3 52 16 view .LVU31
 179 0008 D3F84832 		ldr	r3, [r3, #584]
 180              		.loc 3 52 5 view .LVU32
 181 000c 23B9     		cbnz	r3, .L10
  53:MotorControl/controller.cpp ****         config_.anticogging.calib_anticogging = true;
 182              		.loc 3 53 9 is_stmt 1 view .LVU33
ARM GAS  /tmp/ccawPiBL.s 			page 29


 183              		.loc 3 53 47 is_stmt 0 view .LVU34
 184 000e 00F54050 		add	r0, r0, #12288
 185              	.LVL14:
 186              		.loc 3 53 47 view .LVU35
 187 0012 0123     		movs	r3, #1
 188 0014 80F89938 		strb	r3, [r0, #2201]
 189              	.LVL15:
 190              	.L10:
  54:MotorControl/controller.cpp ****     }
  55:MotorControl/controller.cpp **** }
 191              		.loc 3 55 1 view .LVU36
 192 0018 7047     		bx	lr
 193              		.cfi_endproc
 194              	.LFE5191:
 195              		.cantunwind
 196              		.fnend
 198              		.section	.text._ZN10Controller23remove_anticogging_biasEv,"ax",%progbits
 199              		.align	1
 200              		.global	_ZN10Controller23remove_anticogging_biasEv
 201              		.syntax unified
 202              		.thumb
 203              		.thumb_func
 205              	_ZN10Controller23remove_anticogging_biasEv:
 206              		.fnstart
 207              	.LVL16:
 208              	.LFB5192:
  56:MotorControl/controller.cpp **** 
  57:MotorControl/controller.cpp **** float Controller::remove_anticogging_bias()
  58:MotorControl/controller.cpp **** {
 209              		.loc 3 58 1 is_stmt 1 view -0
 210              		.cfi_startproc
 211              		@ args = 0, pretend = 0, frame = 0
 212              		@ frame_needed = 0, uses_anonymous_args = 0
 213              		@ link register save eliminated.
  59:MotorControl/controller.cpp ****     auto& cogmap = config_.anticogging.cogging_map;
 214              		.loc 3 59 5 view .LVU38
 215              		.loc 3 59 11 is_stmt 0 view .LVU39
 216 0000 00F15803 		add	r3, r0, #88
 217              	.LVL17:
  60:MotorControl/controller.cpp ****     
  61:MotorControl/controller.cpp ****     auto sum = std::accumulate(std::begin(cogmap), std::end(cogmap), 0.0f);
 218              		.loc 3 61 5 is_stmt 1 view .LVU40
 219              	.LBB549:
 220              	.LBI549:
 221              		.file 4 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // <range_access.h> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // Copyright (C) 2010-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
ARM GAS  /tmp/ccawPiBL.s 			page 30


  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** /** @file bits/range_access.h
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****  *  This is an internal header file, included by other library headers.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****  *  Do not attempt to use it directly. @headername{iterator}
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****  */
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** #ifndef _GLIBCXX_RANGE_ACCESS_H
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** #define _GLIBCXX_RANGE_ACCESS_H 1
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** #pragma GCC system_header
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** #if __cplusplus >= 201103L
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** #include <initializer_list>
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** #include <bits/iterator_concepts.h>
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** #include <ext/numeric_traits.h>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** namespace std _GLIBCXX_VISIBILITY(default)
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** {
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   /**
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @brief  Return an iterator pointing to the first element of
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *          the container.
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @param  __cont  Container.
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    */
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   template<typename _Container>
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     inline _GLIBCXX17_CONSTEXPR auto
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     begin(_Container& __cont) -> decltype(__cont.begin())
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     { return __cont.begin(); }
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   /**
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @brief  Return an iterator pointing to the first element of
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *          the const container.
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @param  __cont  Container.
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    */
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   template<typename _Container>
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     inline _GLIBCXX17_CONSTEXPR auto
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     begin(const _Container& __cont) -> decltype(__cont.begin())
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     { return __cont.begin(); }
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   /**
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @brief  Return an iterator pointing to one past the last element of
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *          the container.
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @param  __cont  Container.
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    */
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   template<typename _Container>
ARM GAS  /tmp/ccawPiBL.s 			page 31


  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     inline _GLIBCXX17_CONSTEXPR auto
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     end(_Container& __cont) -> decltype(__cont.end())
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     { return __cont.end(); }
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   /**
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @brief  Return an iterator pointing to one past the last element of
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *          the const container.
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @param  __cont  Container.
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    */
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   template<typename _Container>
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     inline _GLIBCXX17_CONSTEXPR auto
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     end(const _Container& __cont) -> decltype(__cont.end())
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     { return __cont.end(); }
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   /**
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @brief  Return an iterator pointing to the first element of the array.
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @param  __arr  Array.
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    */
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   template<typename _Tp, size_t _Nm>
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     inline _GLIBCXX14_CONSTEXPR _Tp*
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     begin(_Tp (&__arr)[_Nm]) noexcept
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     { return __arr; }
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h **** 
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   /**
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @brief  Return an iterator pointing to one past the last element
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *          of the array.
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    *  @param  __arr  Array.
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****    */
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****   template<typename _Tp, size_t _Nm>
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     inline _GLIBCXX14_CONSTEXPR _Tp*
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     end(_Tp (&__arr)[_Nm]) noexcept
 222              		.loc 4 100 5 view .LVU41
 223              	.LBB550:
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/range_access.h ****     { return __arr + _Nm; }
 224              		.loc 4 101 22 is_stmt 0 view .LVU42
 225 0004 00F56252 		add	r2, r0, #14464
 226 0008 1832     		adds	r2, r2, #24
 227              	.LVL18:
 228              		.loc 4 101 22 view .LVU43
 229              	.LBE550:
 230              	.LBE549:
 231              	.LBB552:
 232              	.LBI552:
 233              		.file 5 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // Numeric functions implementation -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // Copyright (C) 2001-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
ARM GAS  /tmp/ccawPiBL.s 			page 32


  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** /*
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  *
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * Copyright (c) 1994
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * Hewlett-Packard Company
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  *
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * Permission to use, copy, modify, distribute and sell this software
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * and its documentation for any purpose is hereby granted without fee,
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * provided that the above copyright notice appear in all copies and
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * that both that copyright notice and this permission notice appear
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * in supporting documentation.  Hewlett-Packard Company makes no
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * representations about the suitability of this software for any
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  *
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  *
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * Copyright (c) 1996,1997
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * Silicon Graphics Computer Systems, Inc.
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  *
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * Permission to use, copy, modify, distribute and sell this software
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * and its documentation for any purpose is hereby granted without fee,
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * provided that the above copyright notice appear in all copies and
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * that both that copyright notice and this permission notice appear
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * in supporting documentation.  Silicon Graphics makes no
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * representations about the suitability of this software for any
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  */
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** /** @file bits/stl_numeric.h
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  *  This is an internal header file, included by other library headers.
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  *  Do not attempt to use it directly. @headername{numeric}
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****  */
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** #ifndef _STL_NUMERIC_H
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** #define _STL_NUMERIC_H 1
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** #include <bits/concept_check.h>
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** #include <debug/debug.h>
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** #include <bits/move.h> // For _GLIBCXX_MOVE
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** namespace std _GLIBCXX_VISIBILITY(default)
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** {
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****   /** @defgroup numeric_ops Generalized Numeric operations
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  @ingroup algorithms
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    */
ARM GAS  /tmp/ccawPiBL.s 			page 33


  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** #if __cplusplus >= 201103L
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****   /**
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  @brief  Create a range of sequentially increasing values.
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  For each element in the range @p [first,last) assigns @p value and
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  increments @p value as if by @p ++value.
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  @param  __first  Start of range.
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  @param  __last  End of range.
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  @param  __value  Starting value.
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  @return  Nothing.
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  @ingroup numeric_ops
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    */
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****   template<typename _ForwardIterator, typename _Tp>
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****     _GLIBCXX20_CONSTEXPR
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****     void
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****     iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value)
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****     {
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****       // concept requirements
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 				  _ForwardIterator>)
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****       __glibcxx_function_requires(_ConvertibleConcept<_Tp,
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 	    typename iterator_traits<_ForwardIterator>::value_type>)
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****       __glibcxx_requires_valid_range(__first, __last);
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****       for (; __first != __last; ++__first)
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 	{
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 	  *__first = __value;
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 	  ++__value;
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 	}
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****     }
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** #endif
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** _GLIBCXX_END_NAMESPACE_VERSION
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** _GLIBCXX_BEGIN_NAMESPACE_ALGO
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** #if __cplusplus > 201703L
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // _GLIBCXX_RESOLVE_LIB_DEFECTS
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** // DR 2055. std::move in std::accumulate and other algorithms
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** # define _GLIBCXX_MOVE_IF_20(_E) std::move(_E)
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** #else
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** # define _GLIBCXX_MOVE_IF_20(_E) _E
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** #endif
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****   /// @addtogroup numeric_ops
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****   /// @{
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****   /**
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  @brief  Accumulate values in a range.
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  Accumulates the values in the range [first,last) using operator+().  The
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  initial value is @a init.  The values are processed in order.
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  @param  __first  Start of range.
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  @param  __last  End of range.
ARM GAS  /tmp/ccawPiBL.s 			page 34


 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  @param  __init  Starting value to add other values to.
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    *  @return  The final sum.
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****    */
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****   template<typename _InputIterator, typename _Tp>
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****     _GLIBCXX20_CONSTEXPR
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****     inline _Tp
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****     accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
 234              		.loc 5 134 5 is_stmt 1 view .LVU44
 235              	.LBE552:
 236              	.LBB554:
 237              	.LBB551:
 238              		.loc 4 101 22 is_stmt 0 view .LVU45
 239 000a 1946     		mov	r1, r3
 240 000c DFED0B7A 		vldr.32	s15, .L18
 241              	.LVL19:
 242              	.L14:
 243              		.loc 4 101 22 view .LVU46
 244              	.LBE551:
 245              	.LBE554:
 246              	.LBB555:
 247              	.LBB553:
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****     {
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****       // concept requirements
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****       __glibcxx_requires_valid_range(__first, __last);
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h ****       for (; __first != __last; ++__first)
 248              		.loc 5 140 22 is_stmt 1 view .LVU47
 249 0010 9142     		cmp	r1, r2
 250 0012 04D0     		beq	.L13
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 	__init = _GLIBCXX_MOVE_IF_20(__init) + *__first;
 251              		.loc 5 141 39 is_stmt 0 view .LVU48
 252 0014 B1EC017A 		vldmia.32	r1!, {s14}
 253              	.LVL20:
 254              		.loc 5 141 9 view .LVU49
 255 0018 77EE877A 		vadd.f32	s15, s15, s14
 256              	.LVL21:
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 	__init = _GLIBCXX_MOVE_IF_20(__init) + *__first;
 257              		.loc 5 140 7 is_stmt 1 view .LVU50
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 	__init = _GLIBCXX_MOVE_IF_20(__init) + *__first;
 258              		.loc 5 140 7 is_stmt 0 view .LVU51
 259 001c F8E7     		b	.L14
 260              	.L13:
 261              	.LVL22:
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_numeric.h **** 	__init = _GLIBCXX_MOVE_IF_20(__init) + *__first;
 262              		.loc 5 140 7 view .LVU52
 263              	.LBE553:
 264              	.LBE555:
  62:MotorControl/controller.cpp ****     auto average = sum / std::size(cogmap);
 265              		.loc 3 62 5 is_stmt 1 view .LVU53
 266              		.loc 3 62 42 is_stmt 0 view .LVU54
 267 001e 9FED087A 		vldr.32	s14, .L18+4
 268 0022 87EE870A 		vdiv.f32	s0, s15, s14
 269              	.LVL23:
  63:MotorControl/controller.cpp **** 
  64:MotorControl/controller.cpp ****     for(auto& val : cogmap) {
 270              		.loc 3 64 5 is_stmt 1 view .LVU55
ARM GAS  /tmp/ccawPiBL.s 			page 35


 271              		.loc 3 64 5 is_stmt 0 view .LVU56
 272 0026 05E0     		b	.L16
 273              	.LVL24:
 274              	.L17:
 275              	.LBB556:
  65:MotorControl/controller.cpp ****         val -= average;
 276              		.loc 3 65 9 is_stmt 1 discriminator 2 view .LVU57
 277              		.loc 3 65 13 is_stmt 0 discriminator 2 view .LVU58
 278 0028 D3ED007A 		vldr.32	s15, [r3]
 279 002c 77EEC07A 		vsub.f32	s15, s15, s0
 280 0030 E3EC017A 		vstmia.32	r3!, {s15}
 281              	.LVL25:
  64:MotorControl/controller.cpp ****         val -= average;
 282              		.loc 3 64 5 is_stmt 1 discriminator 2 view .LVU59
 283              	.L16:
  64:MotorControl/controller.cpp ****         val -= average;
 284              		.loc 3 64 21 discriminator 3 view .LVU60
 285 0034 9342     		cmp	r3, r2
 286 0036 F7D1     		bne	.L17
  64:MotorControl/controller.cpp ****         val -= average;
 287              		.loc 3 64 21 is_stmt 0 discriminator 3 view .LVU61
 288              	.LBE556:
  66:MotorControl/controller.cpp ****     }
  67:MotorControl/controller.cpp **** 
  68:MotorControl/controller.cpp ****     return average;
  69:MotorControl/controller.cpp **** }
 289              		.loc 3 69 1 view .LVU62
 290 0038 7047     		bx	lr
 291              	.L19:
 292 003a 00BF     		.align	2
 293              	.L18:
 294 003c 00000000 		.word	0
 295 0040 00006145 		.word	1163984896
 296              		.cfi_endproc
 297              	.LFE5192:
 298              		.cantunwind
 299              		.fnend
 301              		.section	.text._ZL8limitVelffff,"ax",%progbits
 302              		.align	1
 303              		.syntax unified
 304              		.thumb
 305              		.thumb_func
 307              	_ZL8limitVelffff:
 308              		.fnstart
 309              	.LVL26:
 310              	.LFB5202:
  70:MotorControl/controller.cpp **** 
  71:MotorControl/controller.cpp **** 
  72:MotorControl/controller.cpp **** /*
  73:MotorControl/controller.cpp ****  * This anti-cogging implementation iterates through each encoder position,
  74:MotorControl/controller.cpp ****  * waits for zero velocity & position error,
  75:MotorControl/controller.cpp ****  * then samples the current required to maintain that position.
  76:MotorControl/controller.cpp ****  * 
  77:MotorControl/controller.cpp ****  * This holding current is added as a feedforward term in the control loop.
  78:MotorControl/controller.cpp ****  */
  79:MotorControl/controller.cpp **** bool Controller::anticogging_calibration(float pos_estimate, float vel_estimate) {
  80:MotorControl/controller.cpp ****     float pos_err = input_pos_ - pos_estimate;
ARM GAS  /tmp/ccawPiBL.s 			page 36


  81:MotorControl/controller.cpp ****     if (std::abs(pos_err) <= config_.anticogging.calib_pos_threshold / (float)axis_->encoder_.confi
  82:MotorControl/controller.cpp ****         std::abs(vel_estimate) < config_.anticogging.calib_vel_threshold / (float)axis_->encoder_.c
  83:MotorControl/controller.cpp ****         config_.anticogging.cogging_map[std::clamp<uint32_t>(config_.anticogging.index++, 0, 3600)]
  84:MotorControl/controller.cpp ****     }
  85:MotorControl/controller.cpp ****     if (config_.anticogging.index < 3600) {
  86:MotorControl/controller.cpp ****         config_.control_mode = CONTROL_MODE_POSITION_CONTROL;
  87:MotorControl/controller.cpp ****         input_pos_ = config_.anticogging.index * axis_->encoder_.getCoggingRatio();
  88:MotorControl/controller.cpp ****         input_vel_ = 0.0f;
  89:MotorControl/controller.cpp ****         input_torque_ = 0.0f;
  90:MotorControl/controller.cpp ****         input_pos_updated();
  91:MotorControl/controller.cpp ****         return false;
  92:MotorControl/controller.cpp ****     } else {
  93:MotorControl/controller.cpp ****         config_.anticogging.index = 0;
  94:MotorControl/controller.cpp ****         config_.control_mode = CONTROL_MODE_POSITION_CONTROL;
  95:MotorControl/controller.cpp ****         input_pos_ = 0.0f;  // Send the motor home
  96:MotorControl/controller.cpp ****         input_vel_ = 0.0f;
  97:MotorControl/controller.cpp ****         input_torque_ = 0.0f;
  98:MotorControl/controller.cpp ****         input_pos_updated();
  99:MotorControl/controller.cpp ****         anticogging_valid_ = true;
 100:MotorControl/controller.cpp ****         config_.anticogging.calib_anticogging = false;
 101:MotorControl/controller.cpp ****         return true;
 102:MotorControl/controller.cpp ****     }
 103:MotorControl/controller.cpp **** }
 104:MotorControl/controller.cpp **** 
 105:MotorControl/controller.cpp **** void Controller::set_input_pos_and_steps(float const pos) {
 106:MotorControl/controller.cpp ****     input_pos_ = pos;
 107:MotorControl/controller.cpp ****     if (config_.circular_setpoints) {
 108:MotorControl/controller.cpp ****         float const range = config_.circular_setpoint_range;
 109:MotorControl/controller.cpp ****         axis_->steps_ = (int64_t)(fmodf_pos(pos, range) / range * config_.steps_per_circular_range)
 110:MotorControl/controller.cpp ****     } else {
 111:MotorControl/controller.cpp ****         axis_->steps_ = (int64_t)(pos * config_.steps_per_circular_range);
 112:MotorControl/controller.cpp ****     }
 113:MotorControl/controller.cpp **** }
 114:MotorControl/controller.cpp **** 
 115:MotorControl/controller.cpp **** bool Controller::control_mode_updated() {
 116:MotorControl/controller.cpp ****     if (config_.control_mode >= CONTROL_MODE_POSITION_CONTROL) {
 117:MotorControl/controller.cpp ****         std::optional<float> estimate = (config_.circular_setpoints ?
 118:MotorControl/controller.cpp ****                                 pos_estimate_circular_src_ :
 119:MotorControl/controller.cpp ****                                 pos_estimate_linear_src_).any();
 120:MotorControl/controller.cpp ****         if (!estimate.has_value()) {
 121:MotorControl/controller.cpp ****             return false;
 122:MotorControl/controller.cpp ****         }
 123:MotorControl/controller.cpp **** 
 124:MotorControl/controller.cpp ****         pos_setpoint_ = *estimate;
 125:MotorControl/controller.cpp ****         set_input_pos_and_steps(*estimate);
 126:MotorControl/controller.cpp ****     }
 127:MotorControl/controller.cpp ****     return true;
 128:MotorControl/controller.cpp **** }
 129:MotorControl/controller.cpp **** 
 130:MotorControl/controller.cpp **** 
 131:MotorControl/controller.cpp **** void Controller::update_filter_gains() {
 132:MotorControl/controller.cpp ****     float bandwidth = std::min(config_.input_filter_bandwidth, 0.25f * current_meas_hz);
 133:MotorControl/controller.cpp ****     input_filter_ki_ = 2.0f * bandwidth;  // basic conversion to discrete time
 134:MotorControl/controller.cpp ****     input_filter_kp_ = 0.25f * (input_filter_ki_ * input_filter_ki_); // Critically damped
 135:MotorControl/controller.cpp **** }
 136:MotorControl/controller.cpp **** 
 137:MotorControl/controller.cpp **** static float limitVel(const float vel_limit, const float vel_estimate, const float vel_gain, const 
ARM GAS  /tmp/ccawPiBL.s 			page 37


 311              		.loc 3 137 114 is_stmt 1 view -0
 312              		.cfi_startproc
 313              		@ args = 0, pretend = 0, frame = 16
 314              		@ frame_needed = 0, uses_anonymous_args = 0
 315              		@ link register save eliminated.
 316              		.loc 3 137 114 is_stmt 0 view .LVU64
 317 0000 84B0     		sub	sp, sp, #16
 318              	.LCFI0:
 319              		.cfi_def_cfa_offset 16
 320 0002 CDED011A 		vstr.32	s3, [sp, #4]
 138:MotorControl/controller.cpp ****     float Tmax = (vel_limit - vel_estimate) * vel_gain;
 321              		.loc 3 138 5 is_stmt 1 view .LVU65
 322              		.loc 3 138 29 is_stmt 0 view .LVU66
 323 0006 70EE607A 		vsub.f32	s15, s0, s1
 324              		.loc 3 138 45 view .LVU67
 325 000a 67EE817A 		vmul.f32	s15, s15, s2
 326              		.loc 3 138 11 view .LVU68
 327 000e CDED037A 		vstr.32	s15, [sp, #12]
 139:MotorControl/controller.cpp ****     float Tmin = (-vel_limit - vel_estimate) * vel_gain;
 328              		.loc 3 139 5 is_stmt 1 view .LVU69
 329              		.loc 3 139 19 is_stmt 0 view .LVU70
 330 0012 B1EE400A 		vneg.f32	s0, s0
 331              	.LVL27:
 332              		.loc 3 139 30 view .LVU71
 333 0016 30EE600A 		vsub.f32	s0, s0, s1
 334              		.loc 3 139 46 view .LVU72
 335 001a 20EE010A 		vmul.f32	s0, s0, s2
 336              		.loc 3 139 11 view .LVU73
 337 001e 8DED020A 		vstr.32	s0, [sp, #8]
 140:MotorControl/controller.cpp ****     return std::clamp(torque, Tmin, Tmax);
 338              		.loc 3 140 5 is_stmt 1 view .LVU74
 339              	.LVL28:
 340              	.LBB557:
 341              	.LBI557:
 342              		.file 6 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // Algorithm implementation -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // Copyright (C) 2001-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
ARM GAS  /tmp/ccawPiBL.s 			page 38


  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** /*
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  *
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * Copyright (c) 1994
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * Hewlett-Packard Company
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  *
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * Permission to use, copy, modify, distribute and sell this software
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * and its documentation for any purpose is hereby granted without fee,
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * provided that the above copyright notice appear in all copies and
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * that both that copyright notice and this permission notice appear
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * in supporting documentation.  Hewlett-Packard Company makes no
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * representations about the suitability of this software for any
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  *
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  *
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * Copyright (c) 1996
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * Silicon Graphics Computer Systems, Inc.
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  *
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * Permission to use, copy, modify, distribute and sell this software
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * and its documentation for any purpose is hereby granted without fee,
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * provided that the above copyright notice appear in all copies and
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * that both that copyright notice and this permission notice appear
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * in supporting documentation.  Silicon Graphics makes no
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * representations about the suitability of this software for any
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  */
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** /** @file bits/stl_algo.h
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  *  This is an internal header file, included by other library headers.
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  *  Do not attempt to use it directly. @headername{algorithm}
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  */
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #ifndef _STL_ALGO_H
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #define _STL_ALGO_H 1
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #include <cstdlib>	     // for rand
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #include <bits/algorithmfwd.h>
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #include <bits/stl_heap.h>
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #include <bits/stl_tempbuf.h>  // for _Temporary_buffer
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #include <bits/predefined_ops.h>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #if __cplusplus >= 201103L
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #include <bits/uniform_int_dist.h>
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #endif
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** // See concept_check.h for the __glibcxx_*_requires macros.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** namespace std _GLIBCXX_VISIBILITY(default)
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** {
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// Swaps the median value of *__a, *__b and *__c under __comp to *__result
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _Iterator, typename _Compare>
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
ARM GAS  /tmp/ccawPiBL.s 			page 39


  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   _Iterator __c, _Compare __comp)
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__comp(__a, __b))
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__comp(__b, __c))
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::iter_swap(__result, __b);
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else if (__comp(__a, __c))
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::iter_swap(__result, __c);
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::iter_swap(__result, __a);
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else if (__comp(__a, __c))
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::iter_swap(__result, __a);
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else if (__comp(__b, __c))
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::iter_swap(__result, __c);
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::iter_swap(__result, __b);
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// Provided for stable_partition to use.
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Predicate>
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _InputIterator
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __find_if_not(_InputIterator __first, _InputIterator __last,
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _Predicate __pred)
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__find_if(__first, __last,
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			    __gnu_cxx::__ops::__negate(__pred),
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			    std::__iterator_category(__first));
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// Like find_if_not(), but uses and updates a count of the
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// remaining range length instead of comparing against an end
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// iterator.
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Predicate, typename _Distance>
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _InputIterator
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (; __len; --__len,  (void) ++__first)
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__pred(__first))
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  break;
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __first;
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // set_difference
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // set_intersection
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // set_symmetric_difference
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // set_union
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // for_each
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // find
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // find_if
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // find_first_of
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // adjacent_find
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // count
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // count_if
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // search
ARM GAS  /tmp/ccawPiBL.s 			page 40


 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2,
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator1
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _BinaryPredicate  __predicate)
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // Test for empty ranges
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first1 == __last1 || __first2 == __last2)
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __first1;
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // Test for a pattern of length 1.
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator2 __p1(__first2);
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (++__p1 == __last2)
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return std::__find_if(__first1, __last1,
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // General case.
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator1 __current = __first1;
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (;;)
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __first1 =
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::__find_if(__first1, __last1,
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__first1 == __last1)
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __last1;
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _ForwardIterator2 __p = __p1;
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __current = __first1;
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (++__current == __last1)
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __last1;
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  while (__predicate(__current, __p))
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (++__p == __last2)
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		return __first1;
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (++__current == __last1)
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		return __last1;
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first1;
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __first1;
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // search_n
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is an helper function for search_n overloaded for forward iterators.
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Integer,
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _UnaryPredicate>
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
ARM GAS  /tmp/ccawPiBL.s 			page 41


 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _Integer __count, _UnaryPredicate __unary_pred,
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   std::forward_iterator_tag)
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __first = std::__find_if(__first, __last, __unary_pred);
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__first != __last)
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  typename iterator_traits<_ForwardIterator>::difference_type
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __n = __count;
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _ForwardIterator __i = __first;
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__i;
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  while (__i != __last && __n != 1 && __unary_pred(__i))
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__i;
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      --__n;
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__n == 1)
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __first;
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__i == __last)
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __last;
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __first = std::__find_if(++__i, __last, __unary_pred);
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __last;
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is an helper function for search_n overloaded for random access
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  iterators.
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIter, typename _Integer,
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _UnaryPredicate>
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _RandomAccessIter
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _Integer __count, _UnaryPredicate __unary_pred,
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   std::random_access_iterator_tag)
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_DistanceType;
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _DistanceType __tailSize = __last - __first;
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _DistanceType __remainder = __count;
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__remainder <= __tailSize) // the main loop...
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __first += __remainder;
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __tailSize -= __remainder;
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  // __first here is always pointing to one past the last element of
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  // next possible match.
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _RandomAccessIter __backTrack = __first; 
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  while (__unary_pred(--__backTrack))
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (--__remainder == 0)
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		return (__first - __count); // Success
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __remainder = __count + 1 - (__first - __backTrack);
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
ARM GAS  /tmp/ccawPiBL.s 			page 42


 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __last; // Failure
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Integer,
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _UnaryPredicate>
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __search_n(_ForwardIterator __first, _ForwardIterator __last,
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _Integer __count,
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _UnaryPredicate __unary_pred)
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__count <= 0)
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __first;
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__count == 1)
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return std::__find_if(__first, __last, __unary_pred);
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__search_n_aux(__first, __last, __count, __unary_pred,
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				 std::__iterator_category(__first));
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // find_end for forward iterators.
 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2,
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator1
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       forward_iterator_tag, forward_iterator_tag,
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _BinaryPredicate __comp)
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first2 == __last2)
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __last1;
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator1 __result = __last1;
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (1)
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _ForwardIterator1 __new_result
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    = std::__search(__first1, __last1, __first2, __last2, __comp);
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__new_result == __last1)
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __result;
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __result = __new_result;
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __first1 = __new_result;
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__first1;
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // find_end for bidirectional iterators (much faster).
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _BidirectionalIterator1
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __find_end(_BidirectionalIterator1 __first1,
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _BidirectionalIterator1 __last1,
ARM GAS  /tmp/ccawPiBL.s 			page 43


 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _BidirectionalIterator2 __first2,
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _BidirectionalIterator2 __last2,
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       bidirectional_iterator_tag, bidirectional_iterator_tag,
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _BinaryPredicate __comp)
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BidirectionalIteratorConcept<
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _BidirectionalIterator1>)
 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BidirectionalIteratorConcept<
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _BidirectionalIterator2>)
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _RevIterator1 __rlast1(__first1);
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _RevIterator2 __rlast2(__first2);
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					      _RevIterator2(__last2), __rlast2,
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					      __comp);
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__rresult == __rlast1)
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __last1;
 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _BidirectionalIterator1 __result = __rresult.base();
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::advance(__result, -std::distance(__first2, __last2));
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  return __result;
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Find last matching subsequence in a sequence.
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first1  Start of range to search.
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last1   End of range to search.
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first2  Start of sequence to match.
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last2   End of sequence to match.
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   The last iterator @c i in the range
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__first1,__last1-(__last2-__first2)) such that @c *(i+N) ==
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p *(__first2+N) for each @c N in the range @p
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Searches the range @p [__first1,__last1) for a sub-sequence that
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  compares equal value-by-value with the sequence given by @p
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first2,__last2) and returns an iterator to the __first
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  element of the sub-sequence, or @p __last1 if the sub-sequence
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  is not found.  The sub-sequence will be the last such
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  subsequence contained in [__first1,__last1).
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Because the sub-sequence must lie completely within the range @p
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first1,__last1) it must start at a position less than @p
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  __last1-(__last2-__first2) where @p __last2-__first2 is the
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  length of the sub-sequence.  This means that the returned
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  iterator @c i will be in the range @p
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first1,__last1-(__last2-__first2))
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2>
ARM GAS  /tmp/ccawPiBL.s 			page 44


 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator1
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_EqualOpConcept<
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator1>::value_type,
 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator2>::value_type>)
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first1, __last1);
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first2, __last2);
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__find_end(__first1, __last1, __first2, __last2,
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     std::__iterator_category(__first1),
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     std::__iterator_category(__first2),
 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     __gnu_cxx::__ops::__iter_equal_to_iter());
 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Find last matching subsequence in a sequence using a predicate.
 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first1  Start of range to search.
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last1   End of range to search.
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first2  Start of sequence to match.
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last2   End of sequence to match.
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp    The predicate to use.
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return The last iterator @c i in the range @p
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first1,__last1-(__last2-__first2)) such that @c
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  predicate(*(i+N), @p (__first2+N)) is true for each @c N in the
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  range @p [0,__last2-__first2), or @p __last1 if no such iterator
 397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  exists.
 398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Searches the range @p [__first1,__last1) for a sub-sequence that
 400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  compares equal value-by-value with the sequence given by @p
 401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first2,__last2) using comp as a predicate and returns an
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  iterator to the first element of the sub-sequence, or @p __last1
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  if the sub-sequence is not found.  The sub-sequence will be the
 404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  last such subsequence contained in [__first,__last1).
 405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Because the sub-sequence must lie completely within the range @p
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first1,__last1) it must start at a position less than @p
 408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  __last1-(__last2-__first2) where @p __last2-__first2 is the
 409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  length of the sub-sequence.  This means that the returned
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  iterator @c i will be in the range @p
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first1,__last1-(__last2-__first2))
 412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2,
 414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator1
 417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
 419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _BinaryPredicate __comp)
 420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
ARM GAS  /tmp/ccawPiBL.s 			page 45


 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
 423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
 424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
 425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator1>::value_type,
 426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator2>::value_type>)
 427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first1, __last1);
 428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first2, __last2);
 429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__find_end(__first1, __last1, __first2, __last2,
 431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     std::__iterator_category(__first1),
 432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     std::__iterator_category(__first2),
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     __gnu_cxx::__ops::__iter_comp_iter(__comp));
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #if __cplusplus >= 201103L
 437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Checks that a predicate is true for all the elements
 439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          of a sequence.
 440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
 441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
 442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    An input iterator.
 443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate.
 444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  True if the check is true, false otherwise.
 445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Returns true if @p __pred is true for each element in the range
 447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__first,__last), and false otherwise.
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Predicate>
 450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
 453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     { return __last == std::find_if_not(__first, __last, __pred); }
 454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Checks that a predicate is false for all the elements
 457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          of a sequence.
 458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
 459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
 460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    An input iterator.
 461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate.
 462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  True if the check is true, false otherwise.
 463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Returns true if @p __pred is false for each element in the range
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__first,__last), and false otherwise.
 466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Predicate>
 468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
 470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
 471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     { return __last == _GLIBCXX_STD_A::find_if(__first, __last, __pred); }
 472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Checks that a predicate is true for at least one element
 475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          of a sequence.
 476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
 477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
 478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    An input iterator.
ARM GAS  /tmp/ccawPiBL.s 			page 46


 479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate.
 480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  True if the check is true, false otherwise.
 481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Returns true if an element exists in the range @p
 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first,__last) such that @p __pred is true, and false
 484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  otherwise.
 485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Predicate>
 487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
 489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
 490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     { return !std::none_of(__first, __last, __pred); }
 491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Find the first element in a sequence for which a
 494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          predicate is false.
 495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
 496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  An input iterator.
 497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   An input iterator.
 498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred   A predicate.
 499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   The first iterator @c i in the range @p [__first,__last)
 500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  such that @p __pred(*i) is false, or @p __last if no such iterator exists.
 501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Predicate>
 503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _InputIterator
 505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     find_if_not(_InputIterator __first, _InputIterator __last,
 506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		_Predicate __pred)
 507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
 510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
 511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      typename iterator_traits<_InputIterator>::value_type>)
 512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__find_if_not(__first, __last,
 514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__gnu_cxx::__ops::__pred_iter(__pred));
 515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Checks whether the sequence is partitioned.
 519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  An input iterator.
 521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   An input iterator.
 522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred   A predicate.
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  True if the range @p [__first,__last) is partioned by @p __pred,
 524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  i.e. if all elements that satisfy @p __pred appear before those that
 525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  do not.
 526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Predicate>
 528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
 530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     is_partitioned(_InputIterator __first, _InputIterator __last,
 531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _Predicate __pred)
 532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __first = std::find_if_not(__first, __last, __pred);
 534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
 535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return true;
ARM GAS  /tmp/ccawPiBL.s 			page 47


 536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       ++__first;
 537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::none_of(__first, __last, __pred);
 538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Find the partition point of a partitioned range.
 542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
 544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
 545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate.
 546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  An iterator @p mid such that @p all_of(__first, mid, __pred)
 547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *           and @p none_of(mid, __last, __pred) are both true.
 548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Predicate>
 550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
 552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     partition_point(_ForwardIterator __first, _ForwardIterator __last,
 553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		    _Predicate __pred)
 554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
 557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
 558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      typename iterator_traits<_ForwardIterator>::value_type>)
 559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // A specific debug-mode test will be necessary...
 561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_ForwardIterator>::difference_type
 564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_DistanceType;
 565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _DistanceType __len = std::distance(__first, __last);
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__len > 0)
 569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _DistanceType __half = __len >> 1;
 571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _ForwardIterator __middle = __first;
 572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::advance(__middle, __half);
 573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__pred(*__middle))
 574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
 575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __first = __middle;
 576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__first;
 577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __len = __len - __half - 1;
 578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
 579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
 580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __len = __half;
 581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __first;
 583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #endif
 585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator,
 587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Predicate>
 588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
 590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __remove_copy_if(_InputIterator __first, _InputIterator __last,
 591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _OutputIterator __result, _Predicate __pred)
 592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
ARM GAS  /tmp/ccawPiBL.s 			page 48


 593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (; __first != __last; ++__first)
 594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__pred(__first))
 595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
 596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    *__result = *__first;
 597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__result;
 598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
 599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __result;
 600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copy a sequence, removing elements of a given value.
 604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
 606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    An input iterator.
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result  An output iterator.
 608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __value   The value to be removed.
 609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   An iterator designating the end of the resulting sequence.
 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Copies each element in the range @p [__first,__last) not equal
 612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  to @p __value to the range beginning at @p __result.
 613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  remove_copy() is stable, so the relative order of elements that
 614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  are copied is unchanged.
 615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator, typename _Tp>
 617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _OutputIterator
 619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     remove_copy(_InputIterator __first, _InputIterator __last,
 620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		_OutputIterator __result, const _Tp& __value)
 621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
 624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
 625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_EqualOpConcept<
 627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
 628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__remove_copy_if(__first, __last, __result,
 631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	__gnu_cxx::__ops::__iter_equals_val(__value));
 632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copy a sequence, removing elements for which a predicate is true.
 636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
 638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    An input iterator.
 639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result  An output iterator.
 640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate.
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   An iterator designating the end of the resulting sequence.
 642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Copies each element in the range @p [__first,__last) for which
 644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p __pred returns false to the range beginning at @p __result.
 645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  remove_copy_if() is stable, so the relative order of elements that are
 647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  copied is unchanged.
 648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator,
ARM GAS  /tmp/ccawPiBL.s 			page 49


 650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Predicate>
 651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _OutputIterator
 653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     remove_copy_if(_InputIterator __first, _InputIterator __last,
 654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _OutputIterator __result, _Predicate __pred)
 655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
 658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
 659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
 661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__remove_copy_if(__first, __last, __result,
 665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				   __gnu_cxx::__ops::__pred_iter(__pred));
 666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #if __cplusplus >= 201103L
 669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copy the elements of a sequence for which a predicate is true.
 671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
 673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    An input iterator.
 674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result  An output iterator.
 675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate.
 676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   An iterator designating the end of the resulting sequence.
 677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Copies each element in the range @p [__first,__last) for which
 679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p __pred returns true to the range beginning at @p __result.
 680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  copy_if() is stable, so the relative order of elements that are
 682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  copied is unchanged.
 683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator,
 685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Predicate>
 686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
 688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     copy_if(_InputIterator __first, _InputIterator __last,
 689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    _OutputIterator __result, _Predicate __pred)
 690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
 693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
 694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
 696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (; __first != __last; ++__first)
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (__pred(*__first))
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
 702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    *__result = *__first;
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__result;
 704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
 705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __result;
 706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
ARM GAS  /tmp/ccawPiBL.s 			page 50


 707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Size, typename _OutputIterator>
 709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
 711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result)
 712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__n > 0)
 714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  while (true)
 716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
 717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      *__result = *__first;
 718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__result;
 719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (--__n > 0)
 720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		++__first;
 721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      else
 722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		break;
 723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
 724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __result;
 726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****  
 728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _CharT, typename _Size>
 729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __enable_if_t<__is_char<_CharT>::__value, _CharT*>
 730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>,
 731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _Size, _CharT*);
 732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Size, typename _OutputIterator>
 734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
 736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __copy_n(_InputIterator __first, _Size __n,
 737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _OutputIterator __result, input_iterator_tag)
 738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__niter_wrap(__result,
 740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			       __copy_n_a(__first, __n,
 741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					  std::__niter_base(__result)));
 742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Size,
 745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _OutputIterator>
 746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _OutputIterator
 748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __copy_n(_RandomAccessIterator __first, _Size __n,
 749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _OutputIterator __result, random_access_iterator_tag)
 750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     { return std::copy(__first, __first + __n, __result); }
 751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copies the range [first,first+n) into [result,result+n).
 754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  An input iterator.
 756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __n      The number of elements to copy.
 757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result An output iterator.
 758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  result+n.
 759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This inline function will boil down to a call to @c memmove whenever
 761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  possible.  Failing that, if random access iterators are passed, then the
 762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  loop count will be known (and therefore a candidate for compiler
 763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  optimizations such as unrolling).
ARM GAS  /tmp/ccawPiBL.s 			page 51


 764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _Size, typename _OutputIterator>
 766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _OutputIterator
 768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
 769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
 772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
 773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       const auto __n2 = std::__size_to_integer(__n);
 776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__n2 <= 0)
 777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __result;
 778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_can_increment(__first, __n2);
 780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_can_increment(__result, __n2);
 781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__copy_n(__first, __n2, __result,
 783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   std::__iterator_category(__first));
 784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copy the elements of a sequence to separate output sequences
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *         depending on the truth value of a predicate.
 789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    An input iterator.
 792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __out_true   An output iterator.
 793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __out_false  An output iterator.
 794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate.
 795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   A pair designating the ends of the resulting sequences.
 796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Copies each element in the range @p [__first,__last) for which
 798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p __pred returns true to the range beginning at @p out_true
 799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  and each element for which @p __pred returns false to @p __out_false.
 800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator1,
 802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _OutputIterator2, typename _Predicate>
 803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     pair<_OutputIterator1, _OutputIterator2>
 805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     partition_copy(_InputIterator __first, _InputIterator __last,
 806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _OutputIterator1 __out_true, _OutputIterator2 __out_false,
 807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _Predicate __pred)
 808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
 811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator1,
 812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator2,
 814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
 817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       
 819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (; __first != __last; ++__first)
 820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (__pred(*__first))
ARM GAS  /tmp/ccawPiBL.s 			page 52


 821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
 822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    *__out_true = *__first;
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__out_true;
 824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
 825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	else
 826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
 827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    *__out_false = *__first;
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__out_false;
 829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
 830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
 832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #endif // C++11
 834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Predicate>
 836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
 838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __remove_if(_ForwardIterator __first, _ForwardIterator __last,
 839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		_Predicate __pred)
 840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __first = std::__find_if(__first, __last, __pred);
 842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
 843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __first;
 844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __result = __first;
 845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       ++__first;
 846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (; __first != __last; ++__first)
 847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__pred(__first))
 848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
 849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    *__result = _GLIBCXX_MOVE(*__first);
 850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__result;
 851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
 852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __result;
 853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Remove elements from a sequence.
 857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  An input iterator.
 859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   An input iterator.
 860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __value  The value to be removed.
 861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   An iterator designating the end of the resulting sequence.
 862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  All elements equal to @p __value are removed from the range
 864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__first,__last).
 865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  remove() is stable, so the relative order of elements that are
 867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  not removed is unchanged.
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Elements between the end of the resulting sequence and @p __last
 870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  are still present, but their value is unspecified.
 871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Tp>
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
 875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     remove(_ForwardIterator __first, _ForwardIterator __last,
 876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   const _Tp& __value)
 877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
ARM GAS  /tmp/ccawPiBL.s 			page 53


 878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _ForwardIterator>)
 881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_EqualOpConcept<
 882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
 883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__remove_if(__first, __last,
 886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		__gnu_cxx::__ops::__iter_equals_val(__value));
 887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Remove elements from a sequence using a predicate.
 891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  A forward iterator.
 893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   A forward iterator.
 894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred   A predicate.
 895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   An iterator designating the end of the resulting sequence.
 896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  All elements for which @p __pred returns true are removed from the range
 898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__first,__last).
 899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  remove_if() is stable, so the relative order of elements that are
 901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  not removed is unchanged.
 902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Elements between the end of the resulting sequence and @p __last
 904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  are still present, but their value is unspecified.
 905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Predicate>
 907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
 909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     remove_if(_ForwardIterator __first, _ForwardIterator __last,
 910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      _Predicate __pred)
 911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _ForwardIterator>)
 915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator>::value_type>)
 917:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 918:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 919:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__remove_if(__first, __last,
 920:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			      __gnu_cxx::__ops::__pred_iter(__pred));
 921:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 922:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 923:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _BinaryPredicate>
 924:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 925:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
 926:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
 927:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		    _BinaryPredicate __binary_pred)
 928:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 929:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
 930:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __last;
 931:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __next = __first;
 932:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (++__next != __last)
 933:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
 934:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__binary_pred(__first, __next))
ARM GAS  /tmp/ccawPiBL.s 			page 54


 935:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __first;
 936:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __first = __next;
 937:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
 938:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __last;
 939:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 940:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 941:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _BinaryPredicate>
 942:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 943:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
 944:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __unique(_ForwardIterator __first, _ForwardIterator __last,
 945:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _BinaryPredicate __binary_pred)
 946:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 947:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // Skip the beginning, if already unique.
 948:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __first = std::__adjacent_find(__first, __last, __binary_pred);
 949:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
 950:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __last;
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 952:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // Do the real copy work.
 953:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __dest = __first;
 954:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       ++__first;
 955:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (++__first != __last)
 956:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__binary_pred(__dest, __first))
 957:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  *++__dest = _GLIBCXX_MOVE(*__first);
 958:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return ++__dest;
 959:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 960:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 961:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
 962:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Remove consecutive duplicate values from a sequence.
 963:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  A forward iterator.
 965:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   A forward iterator.
 966:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  An iterator designating the end of the resulting sequence.
 967:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 968:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Removes all but the first element from each group of consecutive
 969:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  values that compare equal.
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  unique() is stable, so the relative order of elements that are
 971:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  not removed is unchanged.
 972:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Elements between the end of the resulting sequence and @p __last
 973:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  are still present, but their value is unspecified.
 974:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
 975:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator>
 976:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
 977:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
 978:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     unique(_ForwardIterator __first, _ForwardIterator __last)
 979:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 980:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
 981:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 982:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _ForwardIterator>)
 983:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_EqualityComparableConcept<
 984:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     typename iterator_traits<_ForwardIterator>::value_type>)
 985:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
 986:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 987:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__unique(__first, __last,
 988:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   __gnu_cxx::__ops::__iter_equal_to_iter());
 989:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
 990:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
 991:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
ARM GAS  /tmp/ccawPiBL.s 			page 55


 992:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Remove consecutive values from a sequence using a predicate.
 993:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
 994:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first        A forward iterator.
 995:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last         A forward iterator.
 996:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __binary_pred  A binary predicate.
 997:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  An iterator designating the end of the resulting sequence.
 998:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
 999:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Removes all but the first element from each group of consecutive
1000:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  values for which @p __binary_pred returns true.
1001:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  unique() is stable, so the relative order of elements that are
1002:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  not removed is unchanged.
1003:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Elements between the end of the resulting sequence and @p __last
1004:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  are still present, but their value is unspecified.
1005:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1006:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _BinaryPredicate>
1007:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1008:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
1009:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     unique(_ForwardIterator __first, _ForwardIterator __last,
1010:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   _BinaryPredicate __binary_pred)
1011:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1012:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
1013:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
1014:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _ForwardIterator>)
1015:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
1016:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		typename iterator_traits<_ForwardIterator>::value_type,
1017:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		typename iterator_traits<_ForwardIterator>::value_type>)
1018:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
1019:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1020:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__unique(__first, __last,
1021:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
1022:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1023:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1024:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1025:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is an uglified
1026:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
1027:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *              _BinaryPredicate)
1028:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  overloaded for forward iterators and output iterator as result.
1029:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1030:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _OutputIterator,
1031:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
1032:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1033:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
1034:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
1035:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _OutputIterator __result, _BinaryPredicate __binary_pred,
1036:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  forward_iterator_tag, output_iterator_tag)
1037:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1038:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements -- iterators already checked
1039:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
1040:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  typename iterator_traits<_ForwardIterator>::value_type,
1041:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  typename iterator_traits<_ForwardIterator>::value_type>)
1042:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1043:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __next = __first;
1044:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       *__result = *__first;
1045:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (++__next != __last)
1046:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__binary_pred(__first, __next))
1047:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
1048:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __first = __next;
ARM GAS  /tmp/ccawPiBL.s 			page 56


1049:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    *++__result = *__first;
1050:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
1051:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return ++__result;
1052:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1053:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1055:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is an uglified
1056:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
1057:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *              _BinaryPredicate)
1058:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  overloaded for input iterators and output iterator as result.
1059:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1060:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator,
1061:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
1062:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1063:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
1064:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __unique_copy(_InputIterator __first, _InputIterator __last,
1065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _OutputIterator __result, _BinaryPredicate __binary_pred,
1066:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  input_iterator_tag, output_iterator_tag)
1067:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements -- iterators already checked
1069:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
1070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  typename iterator_traits<_InputIterator>::value_type,
1071:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  typename iterator_traits<_InputIterator>::value_type>)
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1073:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typename iterator_traits<_InputIterator>::value_type __value = *__first;
1074:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
1075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	__rebound_pred
1076:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	= __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
1077:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       *__result = __value;
1078:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (++__first != __last)
1079:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__rebound_pred(__first, __value))
1080:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
1081:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __value = *__first;
1082:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    *++__result = __value;
1083:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
1084:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return ++__result;
1085:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1086:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1087:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1088:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is an uglified
1089:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
1090:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *              _BinaryPredicate)
1091:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  overloaded for input iterators and forward iterator as result.
1092:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1093:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _ForwardIterator,
1094:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
1095:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1096:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
1097:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __unique_copy(_InputIterator __first, _InputIterator __last,
1098:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _ForwardIterator __result, _BinaryPredicate __binary_pred,
1099:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  input_iterator_tag, forward_iterator_tag)
1100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements -- iterators already checked
1102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
1103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  typename iterator_traits<_ForwardIterator>::value_type,
1104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  typename iterator_traits<_InputIterator>::value_type>)
1105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       *__result = *__first;
ARM GAS  /tmp/ccawPiBL.s 			page 57


1106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (++__first != __last)
1107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__binary_pred(__result, __first))
1108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  *++__result = *__first;
1109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return ++__result;
1110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is an uglified reverse(_BidirectionalIterator,
1114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *                              _BidirectionalIterator)
1115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  overloaded for bidirectional iterators.
1116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator>
1118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
1120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
1121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      bidirectional_iterator_tag)
1122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (true)
1124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (__first == __last || __first == --__last)
1125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  return;
1126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	else
1127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
1128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::iter_swap(__first, __last);
1129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__first;
1130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
1131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is an uglified reverse(_BidirectionalIterator,
1135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *                              _BidirectionalIterator)
1136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  overloaded for random access iterators.
1137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator>
1139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
1141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
1142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      random_access_iterator_tag)
1143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
1145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return;
1146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       --__last;
1147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__first < __last)
1148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::iter_swap(__first, __last);
1150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first;
1151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  --__last;
1152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Reverse a sequence.
1157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
1158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  A bidirectional iterator.
1159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   A bidirectional iterator.
1160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   reverse() returns no value.
1161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
1162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Reverses the order of the elements in the range @p [__first,__last),
ARM GAS  /tmp/ccawPiBL.s 			page 58


1163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  so that the first element becomes the last etc.
1164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  For every @c i such that @p 0<=i<=(__last-__first)/2), @p reverse()
1165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  swaps @p *(__first+i) and @p *(__last-(i+1))
1166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator>
1168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline void
1170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
1171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
1173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
1174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _BidirectionalIterator>)
1175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
1176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__reverse(__first, __last, std::__iterator_category(__first));
1177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copy a sequence, reversing its elements.
1181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
1182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   A bidirectional iterator.
1183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    A bidirectional iterator.
1184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result  An output iterator.
1185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  An iterator designating the end of the resulting sequence.
1186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
1187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Copies the elements in the range @p [__first,__last) to the
1188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  range @p [__result,__result+(__last-__first)) such that the
1189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  order of the elements is reversed.  For every @c i such that @p
1190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  0<=i<=(__last-__first), @p reverse_copy() performs the
1191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  assignment @p *(__result+(__last-__first)-1-i) = *(__first+i).
1192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  The ranges @p [__first,__last) and @p
1193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__result,__result+(__last-__first)) must not overlap.
1194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator, typename _OutputIterator>
1196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
1198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
1199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		 _OutputIterator __result)
1200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
1202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BidirectionalIteratorConcept<
1203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _BidirectionalIterator>)
1204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
1205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		typename iterator_traits<_BidirectionalIterator>::value_type>)
1206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
1207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__first != __last)
1209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  --__last;
1211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  *__result = *__last;
1212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__result;
1213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __result;
1215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is a helper function for the rotate algorithm specialized on RAIs.
1219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  It returns the greatest common divisor of two integer values.
ARM GAS  /tmp/ccawPiBL.s 			page 59


1220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _EuclideanRingElement>
1222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _EuclideanRingElement
1224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
1225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__n != 0)
1227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _EuclideanRingElement __t = __m % __n;
1229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __m = __n;
1230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __n = __t;
1231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __m;
1233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   inline namespace _V2
1236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   {
1237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the rotate algorithm.
1239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator>
1240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
1242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __rotate(_ForwardIterator __first,
1243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _ForwardIterator __middle,
1244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _ForwardIterator __last,
1245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     forward_iterator_tag)
1246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __middle)
1248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __last;
1249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else if (__last == __middle)
1250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __first;
1251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __first2 = __middle;
1253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       do
1254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::iter_swap(__first, __first2);
1256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first;
1257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first2;
1258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__first == __middle)
1259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __middle = __first2;
1260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__first2 != __last);
1262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __ret = __first;
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __first2 = __middle;
1266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__first2 != __last)
1268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::iter_swap(__first, __first2);
1270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first;
1271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first2;
1272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__first == __middle)
1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __middle = __first2;
1274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else if (__first2 == __last)
1275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __first2 = __middle;
1276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
ARM GAS  /tmp/ccawPiBL.s 			page 60


1277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __ret;
1278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    /// This is a helper function for the rotate algorithm.
1281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator>
1282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _BidirectionalIterator
1284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __rotate(_BidirectionalIterator __first,
1285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _BidirectionalIterator __middle,
1286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _BidirectionalIterator __last,
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      bidirectional_iterator_tag)
1288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
1290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
1291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _BidirectionalIterator>)
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __middle)
1294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __last;
1295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else if (__last == __middle)
1296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __first;
1297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__reverse(__first,  __middle, bidirectional_iterator_tag());
1299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__reverse(__middle, __last,   bidirectional_iterator_tag());
1300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__first != __middle && __middle != __last)
1302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::iter_swap(__first, --__last);
1304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first;
1305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __middle)
1308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__reverse(__middle, __last,   bidirectional_iterator_tag());
1310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  return __last;
1311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else
1313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__reverse(__first,  __middle, bidirectional_iterator_tag());
1315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  return __first;
1316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the rotate algorithm.
1320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator>
1321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _RandomAccessIterator
1323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __rotate(_RandomAccessIterator __first,
1324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _RandomAccessIterator __middle,
1325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _RandomAccessIterator __last,
1326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     random_access_iterator_tag)
1327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
1329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
1330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _RandomAccessIterator>)
1331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __middle)
1333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __last;
ARM GAS  /tmp/ccawPiBL.s 			page 61


1334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else if (__last == __middle)
1335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __first;
1336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_RandomAccessIterator>::difference_type
1338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_Distance;
1339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_RandomAccessIterator>::value_type
1340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_ValueType;
1341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _Distance __n = __last   - __first;
1343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _Distance __k = __middle - __first;
1344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__k == __n - __k)
1346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::swap_ranges(__first, __middle, __middle);
1348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  return __middle;
1349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _RandomAccessIterator __p = __first;
1352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _RandomAccessIterator __ret = __first + (__last - __middle);
1353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (;;)
1355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__k < __n - __k)
1357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
1358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (__is_pod(_ValueType) && __k == 1)
1359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		{
1360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _ValueType __t = _GLIBCXX_MOVE(*__p);
1361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _GLIBCXX_MOVE3(__p + 1, __p + __n, __p);
1362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  *(__p + __n - 1) = _GLIBCXX_MOVE(__t);
1363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  return __ret;
1364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		}
1365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      _RandomAccessIterator __q = __p + __k;
1366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      for (_Distance __i = 0; __i < __n - __k; ++ __i)
1367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		{
1368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  std::iter_swap(__p, __q);
1369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  ++__p;
1370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  ++__q;
1371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		}
1372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __n %= __k;
1373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (__n == 0)
1374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		return __ret;
1375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      std::swap(__n, __k);
1376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __k = __n - __k;
1377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
1378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
1379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
1380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __k = __n - __k;
1381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (__is_pod(_ValueType) && __k == 1)
1382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		{
1383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _ValueType __t = _GLIBCXX_MOVE(*(__p + __n - 1));
1384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _GLIBCXX_MOVE_BACKWARD3(__p, __p + __n - 1, __p + __n);
1385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  *__p = _GLIBCXX_MOVE(__t);
1386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  return __ret;
1387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		}
1388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      _RandomAccessIterator __q = __p + __n;
1389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __p = __q - __k;
1390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      for (_Distance __i = 0; __i < __n - __k; ++ __i)
ARM GAS  /tmp/ccawPiBL.s 			page 62


1391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		{
1392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  --__p;
1393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  --__q;
1394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  std::iter_swap(__p, __q);
1395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		}
1396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __n %= __k;
1397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (__n == 0)
1398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		return __ret;
1399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      std::swap(__n, __k);
1400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
1401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    // _GLIBCXX_RESOLVE_LIB_DEFECTS
1405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    // DR 488. rotate throws away useful information
1406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Rotate the elements of a sequence.
1408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
1409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   A forward iterator.
1410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __middle  A forward iterator.
1411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    A forward iterator.
1412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  first + (last - middle).
1413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
1414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Rotates the elements of the range @p [__first,__last) by 
1415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p (__middle - __first) positions so that the element at @p __middle
1416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  is moved to @p __first, the element at @p __middle+1 is moved to
1417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p __first+1 and so on for each element in the range
1418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__first,__last).
1419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
1420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This effectively swaps the ranges @p [__first,__middle) and
1421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__middle,__last).
1422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
1423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Performs
1424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *   @p *(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n)
1425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  for each @p n in the range @p [0,__last-__first).
1426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator>
1428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
1430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     rotate(_ForwardIterator __first, _ForwardIterator __middle,
1431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   _ForwardIterator __last)
1432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
1434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
1435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _ForwardIterator>)
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __middle);
1437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__middle, __last);
1438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__rotate(__first, __middle, __last,
1440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   std::__iterator_category(__first));
1441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   } // namespace _V2
1444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copy a sequence, rotating its elements.
1447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
ARM GAS  /tmp/ccawPiBL.s 			page 63


1448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   A forward iterator.
1449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __middle  A forward iterator.
1450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    A forward iterator.
1451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result  An output iterator.
1452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   An iterator designating the end of the resulting sequence.
1453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
1454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Copies the elements of the range @p [__first,__last) to the
1455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  range beginning at @result, rotating the copied elements by 
1456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p (__middle-__first) positions so that the element at @p __middle
1457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  is moved to @p __result, the element at @p __middle+1 is moved
1458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  to @p __result+1 and so on for each element in the range @p
1459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first,__last).
1460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
1461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Performs 
1462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p *(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n)
1463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  for each @p n in the range @p [0,__last-__first).
1464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _OutputIterator>
1466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _OutputIterator
1468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
1469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		_ForwardIterator __last, _OutputIterator __result)
1470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
1472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
1473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
1474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		typename iterator_traits<_ForwardIterator>::value_type>)
1475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __middle);
1476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__middle, __last);
1477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::copy(__first, __middle,
1479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		       std::copy(__middle, __last, __result));
1480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function...
1483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Predicate>
1484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
1486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __partition(_ForwardIterator __first, _ForwardIterator __last,
1487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		_Predicate __pred, forward_iterator_tag)
1488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
1490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __first;
1491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__pred(*__first))
1493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (++__first == __last)
1494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  return __first;
1495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __next = __first;
1497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (++__next != __last)
1499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (__pred(*__next))
1500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
1501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::iter_swap(__first, __next);
1502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__first;
1503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
1504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
ARM GAS  /tmp/ccawPiBL.s 			page 64


1505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __first;
1506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function...
1509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator, typename _Predicate>
1510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _BidirectionalIterator
1512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
1513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		_Predicate __pred, bidirectional_iterator_tag)
1514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (true)
1516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  while (true)
1518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    if (__first == __last)
1519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      return __first;
1520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    else if (__pred(*__first))
1521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__first;
1522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    else
1523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      break;
1524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  --__last;
1525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  while (true)
1526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    if (__first == __last)
1527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      return __first;
1528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    else if (!bool(__pred(*__last)))
1529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      --__last;
1530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    else
1531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      break;
1532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::iter_swap(__first, __last);
1533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first;
1534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // partition
1538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function...
1540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// Requires __first != __last and !__pred(__first)
1541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// and __len == distance(__first, __last).
1542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   ///
1543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// !__pred(__first) allows us to guarantee that we don't
1544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// move-assign an element onto itself.
1545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
1546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Distance>
1547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
1548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __stable_partition_adaptive(_ForwardIterator __first,
1549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				_ForwardIterator __last,
1550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				_Predicate __pred, _Distance __len,
1551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				_Pointer __buffer,
1552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				_Distance __buffer_size)
1553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__len == 1)
1555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __first;
1556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__len <= __buffer_size)
1558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _ForwardIterator __result1 = __first;
1560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _Pointer __result2 = __buffer;
1561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
ARM GAS  /tmp/ccawPiBL.s 			page 65


1562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  // The precondition guarantees that !__pred(__first), so
1563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  // move that element to the buffer before starting the loop.
1564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  // This ensures that we only call __pred once per element.
1565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  *__result2 = _GLIBCXX_MOVE(*__first);
1566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__result2;
1567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first;
1568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  for (; __first != __last; ++__first)
1569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    if (__pred(__first))
1570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      {
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		*__result1 = _GLIBCXX_MOVE(*__first);
1572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		++__result1;
1573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      }
1574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    else
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      {
1576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		*__result2 = _GLIBCXX_MOVE(*__first);
1577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		++__result2;
1578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      }
1579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _GLIBCXX_MOVE3(__buffer, __result2, __result1);
1581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  return __result1;
1582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __middle = __first;
1585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::advance(__middle, __len / 2);
1586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __left_split =
1587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::__stable_partition_adaptive(__first, __middle, __pred,
1588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					 __len / 2, __buffer,
1589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					 __buffer_size);
1590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // Advance past true-predicate values to satisfy this
1592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // function's preconditions.
1593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _Distance __right_len = __len - __len / 2;
1594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __right_split =
1595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::__find_if_not_n(__middle, __right_len, __pred);
1596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__right_len)
1598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	__right_split =
1599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__stable_partition_adaptive(__right_split, __last, __pred,
1600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					   __right_len,
1601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					   __buffer, __buffer_size);
1602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::rotate(__left_split, __middle, __right_split);
1604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Predicate>
1607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
1608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
1609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		       _Predicate __pred)
1610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __first = std::__find_if_not(__first, __last, __pred);
1612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
1614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __first;
1615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_ForwardIterator>::value_type
1617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_ValueType;
1618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_ForwardIterator>::difference_type
ARM GAS  /tmp/ccawPiBL.s 			page 66


1619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_DistanceType;
1620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _Temporary_buffer<_ForwardIterator, _ValueType>
1622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	__buf(__first, std::distance(__first, __last));
1623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return
1624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::__stable_partition_adaptive(__first, __last, __pred,
1625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					 _DistanceType(__buf.requested_size()),
1626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					 __buf.begin(),
1627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					 _DistanceType(__buf.size()));
1628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Move elements for which a predicate is true to the beginning
1632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *         of a sequence, preserving relative ordering.
1633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
1634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   A forward iterator.
1635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    A forward iterator.
1636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A predicate functor.
1637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  An iterator @p middle such that @p __pred(i) is true for each
1638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  iterator @p i in the range @p [first,middle) and false for each @p i
1639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  in the range @p [middle,last).
1640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
1641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Performs the same function as @p partition() with the additional
1642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  guarantee that the relative ordering of elements in each group is
1643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  preserved, so any two elements @p x and @p y in the range
1644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__first,__last) such that @p __pred(x)==__pred(y) will have the same
1645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  relative ordering after calling @p stable_partition().
1646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Predicate>
1648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
1649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     stable_partition(_ForwardIterator __first, _ForwardIterator __last,
1650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _Predicate __pred)
1651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
1653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
1654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _ForwardIterator>)
1655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
1656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator>::value_type>)
1657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
1658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__stable_partition(__first, __last,
1660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				     __gnu_cxx::__ops::__pred_iter(__pred));
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the sort routines.
1664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Compare>
1665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
1667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __heap_select(_RandomAccessIterator __first,
1668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _RandomAccessIterator __middle,
1669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _RandomAccessIterator __last, _Compare __comp)
1670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__make_heap(__first, __middle, __comp);
1672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
1673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (__comp(__i, __first))
1674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__pop_heap(__first, __middle, __i, __comp);
1675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
ARM GAS  /tmp/ccawPiBL.s 			page 67


1676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // partial_sort
1678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _RandomAccessIterator,
1680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Compare>
1681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _RandomAccessIterator
1683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __partial_sort_copy(_InputIterator __first, _InputIterator __last,
1684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			_RandomAccessIterator __result_first,
1685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			_RandomAccessIterator __result_last,
1686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			_Compare __comp)
1687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_InputIterator>::value_type
1689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_InputValueType;
1690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef iterator_traits<_RandomAccessIterator> _RItTraits;
1691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename _RItTraits::difference_type _DistanceType;
1692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__result_first == __result_last)
1694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __result_last;
1695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _RandomAccessIterator __result_real_last = __result_first;
1696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__first != __last && __result_real_last != __result_last)
1697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  *__result_real_last = *__first;
1699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__result_real_last;
1700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first;
1701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       
1703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__make_heap(__result_first, __result_real_last, __comp);
1704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__first != __last)
1705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__comp(__first, __result_first))
1707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::__adjust_heap(__result_first, _DistanceType(0),
1708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			       _DistanceType(__result_real_last
1709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					     - __result_first),
1710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			       _InputValueType(*__first), __comp);
1711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first;
1712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__sort_heap(__result_first, __result_real_last, __comp);
1714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __result_real_last;
1715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copy the smallest elements of a sequence.
1719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
1720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
1721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
1722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result_first   A random-access iterator.
1723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result_last    Another random-access iterator.
1724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   An iterator indicating the end of the resulting sequence.
1725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
1726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Copies and sorts the smallest N values from the range @p [__first,__last)
1727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  to the range beginning at @p __result_first, where the number of
1728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
1729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p (__result_last-__result_first).
1730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  After the sort if @e i and @e j are iterators in the range
1731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__result_first,__result_first+N) such that i precedes j then
1732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  *j<*i is false.
ARM GAS  /tmp/ccawPiBL.s 			page 68


1733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  The value returned is @p __result_first+N.
1734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _RandomAccessIterator>
1736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _RandomAccessIterator
1738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     partial_sort_copy(_InputIterator __first, _InputIterator __last,
1739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _RandomAccessIterator __result_first,
1740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _RandomAccessIterator __result_last)
1741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #ifdef _GLIBCXX_CONCEPT_CHECKS
1743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_InputIterator>::value_type
1744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_InputValueType;
1745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_RandomAccessIterator>::value_type
1746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_OutputValueType;
1747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #endif
1748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
1750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
1751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ConvertibleConcept<_InputValueType,
1752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _OutputValueType>)
1753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_LessThanOpConcept<_InputValueType,
1754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 						     _OutputValueType>)
1755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_LessThanComparableConcept<_OutputValueType>)
1756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
1757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive(__first, __last);
1758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__result_first, __result_last);
1759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__partial_sort_copy(__first, __last,
1761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				      __result_first, __result_last,
1762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				      __gnu_cxx::__ops::__iter_less_iter());
1763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copy the smallest elements of a sequence using a predicate for
1767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *         comparison.
1768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
1769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An input iterator.
1770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another input iterator.
1771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result_first   A random-access iterator.
1772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result_last    Another random-access iterator.
1773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp    A comparison functor.
1774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   An iterator indicating the end of the resulting sequence.
1775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
1776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Copies and sorts the smallest N values from the range @p [__first,__last)
1777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  to the range beginning at @p result_first, where the number of
1778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
1779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p (__result_last-__result_first).
1780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  After the sort if @e i and @e j are iterators in the range
1781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__result_first,__result_first+N) such that i precedes j then
1782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p __comp(*j,*i) is false.
1783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  The value returned is @p __result_first+N.
1784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _RandomAccessIterator,
1786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Compare>
1787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _RandomAccessIterator
1789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     partial_sort_copy(_InputIterator __first, _InputIterator __last,
ARM GAS  /tmp/ccawPiBL.s 			page 69


1790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _RandomAccessIterator __result_first,
1791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _RandomAccessIterator __result_last,
1792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _Compare __comp)
1793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #ifdef _GLIBCXX_CONCEPT_CHECKS
1795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_InputIterator>::value_type
1796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_InputValueType;
1797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_RandomAccessIterator>::value_type
1798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_OutputValueType;
1799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #endif
1800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
1802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
1803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
1804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _RandomAccessIterator>)
1805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ConvertibleConcept<_InputValueType,
1806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _OutputValueType>)
1807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
1808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _InputValueType, _OutputValueType>)
1809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
1810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _OutputValueType, _OutputValueType>)
1811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
1812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
1813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__result_first, __result_last);
1814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__partial_sort_copy(__first, __last,
1816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				      __result_first, __result_last,
1817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__gnu_cxx::__ops::__iter_comp_iter(__comp));
1818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the sort routine.
1821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Compare>
1822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
1824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __unguarded_linear_insert(_RandomAccessIterator __last,
1825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			      _Compare __comp)
1826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typename iterator_traits<_RandomAccessIterator>::value_type
1828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	__val = _GLIBCXX_MOVE(*__last);
1829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _RandomAccessIterator __next = __last;
1830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       --__next;
1831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__comp(__val, __next))
1832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  *__last = _GLIBCXX_MOVE(*__next);
1834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __last = __next;
1835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  --__next;
1836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       *__last = _GLIBCXX_MOVE(__val);
1838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the sort routine.
1841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Compare>
1842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
1844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __insertion_sort(_RandomAccessIterator __first,
1845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _RandomAccessIterator __last, _Compare __comp)
1846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
ARM GAS  /tmp/ccawPiBL.s 			page 70


1847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last) return;
1848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
1850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__comp(__i, __first))
1852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
1853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      typename iterator_traits<_RandomAccessIterator>::value_type
1854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		__val = _GLIBCXX_MOVE(*__i);
1855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      _GLIBCXX_MOVE_BACKWARD3(__first, __i, __i + 1);
1856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      *__first = _GLIBCXX_MOVE(__val);
1857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
1858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
1859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::__unguarded_linear_insert(__i,
1860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__gnu_cxx::__ops::__val_comp_iter(__comp));
1861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the sort routine.
1865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Compare>
1866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline void
1868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __unguarded_insertion_sort(_RandomAccessIterator __first,
1869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			       _RandomAccessIterator __last, _Compare __comp)
1870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
1872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::__unguarded_linear_insert(__i,
1873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__gnu_cxx::__ops::__val_comp_iter(__comp));
1874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
1877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @doctodo
1878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This controls some aspect of the sort routines.
1879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
1880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   enum { _S_threshold = 16 };
1881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the sort routine.
1883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Compare>
1884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
1886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __final_insertion_sort(_RandomAccessIterator __first,
1887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   _RandomAccessIterator __last, _Compare __comp)
1888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__last - __first > int(_S_threshold))
1890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
1892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
1893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					  __comp);
1894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else
1896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::__insertion_sort(__first, __last, __comp);
1897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function...
1900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Compare>
1901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _RandomAccessIterator
1903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __unguarded_partition(_RandomAccessIterator __first,
ARM GAS  /tmp/ccawPiBL.s 			page 71


1904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			  _RandomAccessIterator __last,
1905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			  _RandomAccessIterator __pivot, _Compare __comp)
1906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (true)
1908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  while (__comp(__first, __pivot))
1910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__first;
1911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  --__last;
1912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  while (__comp(__pivot, __last))
1913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    --__last;
1914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (!(__first < __last))
1915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __first;
1916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::iter_swap(__first, __last);
1917:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first;
1918:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1919:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1920:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1921:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function...
1922:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Compare>
1923:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1924:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _RandomAccessIterator
1925:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __unguarded_partition_pivot(_RandomAccessIterator __first,
1926:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				_RandomAccessIterator __last, _Compare __comp)
1927:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1928:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _RandomAccessIterator __mid = __first + (__last - __first) / 2;
1929:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
1930:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  __comp);
1931:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__unguarded_partition(__first + 1, __last, __first, __comp);
1932:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1933:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1934:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Compare>
1935:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1936:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline void
1937:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __partial_sort(_RandomAccessIterator __first,
1938:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _RandomAccessIterator __middle,
1939:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _RandomAccessIterator __last,
1940:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _Compare __comp)
1941:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1942:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__heap_select(__first, __middle, __last, __comp);
1943:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__sort_heap(__first, __middle, __comp);
1944:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1945:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1946:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the sort routine.
1947:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Size, typename _Compare>
1948:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1949:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
1950:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __introsort_loop(_RandomAccessIterator __first,
1951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _RandomAccessIterator __last,
1952:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _Size __depth_limit, _Compare __comp)
1953:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1954:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__last - __first > int(_S_threshold))
1955:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1956:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__depth_limit == 0)
1957:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
1958:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      std::__partial_sort(__first, __last, __last, __comp);
1959:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      return;
1960:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
ARM GAS  /tmp/ccawPiBL.s 			page 72


1961:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  --__depth_limit;
1962:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _RandomAccessIterator __cut =
1963:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::__unguarded_partition_pivot(__first, __last, __comp);
1964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__introsort_loop(__cut, __last, __depth_limit, __comp);
1965:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __last = __cut;
1966:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1967:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1968:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1969:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // sort
1970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1971:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Compare>
1972:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1973:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline void
1974:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
1975:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   _Compare __comp)
1976:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1977:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first != __last)
1978:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1979:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__introsort_loop(__first, __last,
1980:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				std::__lg(__last - __first) * 2,
1981:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__comp);
1982:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__final_insertion_sort(__first, __last, __comp);
1983:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
1984:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
1985:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
1986:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Size, typename _Compare>
1987:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
1988:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
1989:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
1990:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _RandomAccessIterator __last, _Size __depth_limit,
1991:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _Compare __comp)
1992:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
1993:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__last - __first > 3)
1994:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
1995:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__depth_limit == 0)
1996:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
1997:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      std::__heap_select(__first, __nth + 1, __last, __comp);
1998:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      // Place the nth largest element in its final position.
1999:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      std::iter_swap(__first, __nth);
2000:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      return;
2001:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2002:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  --__depth_limit;
2003:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _RandomAccessIterator __cut =
2004:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::__unguarded_partition_pivot(__first, __last, __comp);
2005:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__cut <= __nth)
2006:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __first = __cut;
2007:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
2008:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __last = __cut;
2009:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2010:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__insertion_sort(__first, __last, __comp);
2011:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2012:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2013:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // nth_element
2014:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2015:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // lower_bound moved to stl_algobase.h
2016:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2017:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
ARM GAS  /tmp/ccawPiBL.s 			page 73


2018:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Finds the first position in which @p __val could be inserted
2019:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *         without changing the ordering.
2020:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup binary_search_algorithms
2021:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
2022:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
2023:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __val     The search term.
2024:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp    A functor to use for comparisons.
2025:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return An iterator pointing to the first element <em>not less
2026:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *           than</em> @p __val, or end() if every element is less
2027:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *           than @p __val.
2028:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup binary_search_algorithms
2029:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2030:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  The comparison function should have the same effects on ordering as
2031:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  the function used for the initial sort.
2032:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
2033:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Tp, typename _Compare>
2034:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2035:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
2036:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     lower_bound(_ForwardIterator __first, _ForwardIterator __last,
2037:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		const _Tp& __val, _Compare __comp)
2038:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2039:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
2040:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
2041:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
2042:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
2043:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_partitioned_lower_pred(__first, __last,
2044:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 						__val, __comp);
2045:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2046:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__lower_bound(__first, __last, __val,
2047:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__gnu_cxx::__ops::__iter_comp_val(__comp));
2048:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2049:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2050:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Tp, typename _Compare>
2051:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2052:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
2053:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
2054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  const _Tp& __val, _Compare __comp)
2055:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2056:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_ForwardIterator>::difference_type
2057:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_DistanceType;
2058:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2059:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _DistanceType __len = std::distance(__first, __last);
2060:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2061:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__len > 0)
2062:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2063:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _DistanceType __half = __len >> 1;
2064:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _ForwardIterator __middle = __first;
2065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::advance(__middle, __half);
2066:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__comp(__val, __middle))
2067:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __len = __half;
2068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
2069:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
2070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __first = __middle;
2071:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__first;
2072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __len = __len - __half - 1;
2073:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2074:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
ARM GAS  /tmp/ccawPiBL.s 			page 74


2075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __first;
2076:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2077:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2078:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
2079:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Finds the last position in which @p __val could be inserted
2080:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *         without changing the ordering.
2081:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup binary_search_algorithms
2082:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
2083:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
2084:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __val     The search term.
2085:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  An iterator pointing to the first element greater than @p __val,
2086:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *           or end() if no elements are greater than @p __val.
2087:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup binary_search_algorithms
2088:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
2089:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Tp>
2090:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2091:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
2092:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     upper_bound(_ForwardIterator __first, _ForwardIterator __last,
2093:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		const _Tp& __val)
2094:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2095:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
2096:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
2097:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_LessThanOpConcept<
2098:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
2099:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_partitioned_upper(__first, __last, __val);
2100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__upper_bound(__first, __last, __val,
2102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__gnu_cxx::__ops::__val_less_iter());
2103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
2106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Finds the last position in which @p __val could be inserted
2107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *         without changing the ordering.
2108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup binary_search_algorithms
2109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
2110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
2111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __val     The search term.
2112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp    A functor to use for comparisons.
2113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  An iterator pointing to the first element greater than @p __val,
2114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *           or end() if no elements are greater than @p __val.
2115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup binary_search_algorithms
2116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  The comparison function should have the same effects on ordering as
2118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  the function used for the initial sort.
2119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
2120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Tp, typename _Compare>
2121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
2123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     upper_bound(_ForwardIterator __first, _ForwardIterator __last,
2124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		const _Tp& __val, _Compare __comp)
2125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
2127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
2128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
2129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
2130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_partitioned_upper_pred(__first, __last,
2131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 						__val, __comp);
ARM GAS  /tmp/ccawPiBL.s 			page 75


2132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__upper_bound(__first, __last, __val,
2134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__gnu_cxx::__ops::__val_comp_iter(__comp));
2135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Tp,
2138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _CompareItTp, typename _CompareTpIt>
2139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     pair<_ForwardIterator, _ForwardIterator>
2141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __equal_range(_ForwardIterator __first, _ForwardIterator __last,
2142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  const _Tp& __val,
2143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
2144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_ForwardIterator>::difference_type
2146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_DistanceType;
2147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _DistanceType __len = std::distance(__first, __last);
2149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__len > 0)
2151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _DistanceType __half = __len >> 1;
2153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _ForwardIterator __middle = __first;
2154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::advance(__middle, __half);
2155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__comp_it_val(__middle, __val))
2156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
2157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __first = __middle;
2158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__first;
2159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __len = __len - __half - 1;
2160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else if (__comp_val_it(__val, __middle))
2162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    __len = __half;
2163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
2164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
2165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      _ForwardIterator __left
2166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		= std::__lower_bound(__first, __middle, __val, __comp_it_val);
2167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      std::advance(__first, __len);
2168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      _ForwardIterator __right
2169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		= std::__upper_bound(++__middle, __first, __val, __comp_val_it);
2170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
2171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
2174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
2177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Finds the largest subrange in which @p __val could be inserted
2178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *         at any place in it without changing the ordering.
2179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup binary_search_algorithms
2180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
2181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
2182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __val     The search term.
2183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  An pair of iterators defining the subrange.
2184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup binary_search_algorithms
2185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is equivalent to
2187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @code
2188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *    std::make_pair(lower_bound(__first, __last, __val),
ARM GAS  /tmp/ccawPiBL.s 			page 76


2189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *                   upper_bound(__first, __last, __val))
2190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @endcode
2191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  but does not actually call those functions.
2192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
2193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Tp>
2194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline pair<_ForwardIterator, _ForwardIterator>
2196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     equal_range(_ForwardIterator __first, _ForwardIterator __last,
2197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		const _Tp& __val)
2198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
2200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
2201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_LessThanOpConcept<
2202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
2203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_LessThanOpConcept<
2204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
2205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_partitioned_lower(__first, __last, __val);
2206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_partitioned_upper(__first, __last, __val);
2207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__equal_range(__first, __last, __val,
2209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__gnu_cxx::__ops::__iter_less_val(),
2210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__gnu_cxx::__ops::__val_less_iter());
2211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
2214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Finds the largest subrange in which @p __val could be inserted
2215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *         at any place in it without changing the ordering.
2216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
2217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
2218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __val     The search term.
2219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp    A functor to use for comparisons.
2220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  An pair of iterators defining the subrange.
2221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup binary_search_algorithms
2222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This is equivalent to
2224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @code
2225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *    std::make_pair(lower_bound(__first, __last, __val, __comp),
2226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *                   upper_bound(__first, __last, __val, __comp))
2227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @endcode
2228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  but does not actually call those functions.
2229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
2230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Tp, typename _Compare>
2231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline pair<_ForwardIterator, _ForwardIterator>
2233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     equal_range(_ForwardIterator __first, _ForwardIterator __last,
2234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		const _Tp& __val, _Compare __comp)
2235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
2237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
2238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
2239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
2240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
2241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
2242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_partitioned_lower_pred(__first, __last,
2243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 						__val, __comp);
2244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_partitioned_upper_pred(__first, __last,
2245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 						__val, __comp);
ARM GAS  /tmp/ccawPiBL.s 			page 77


2246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__equal_range(__first, __last, __val,
2248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__gnu_cxx::__ops::__iter_comp_val(__comp),
2249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__gnu_cxx::__ops::__val_comp_iter(__comp));
2250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
2253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Determines whether an element exists in a range.
2254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup binary_search_algorithms
2255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
2256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
2257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __val     The search term.
2258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return True if @p __val (or its equivalent) is in [@p
2259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  __first,@p __last ].
2260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Note that this does not actually return an iterator to @p __val.  For
2262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  that, use std::find or a container's specialized find member functions.
2263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
2264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Tp>
2265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     bool
2267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     binary_search(_ForwardIterator __first, _ForwardIterator __last,
2268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  const _Tp& __val)
2269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
2271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
2272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_LessThanOpConcept<
2273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
2274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_partitioned_lower(__first, __last, __val);
2275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_partitioned_upper(__first, __last, __val);
2276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __i
2278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	= std::__lower_bound(__first, __last, __val,
2279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     __gnu_cxx::__ops::__iter_less_val());
2280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __i != __last && !(__val < *__i);
2281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
2284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Determines whether an element exists in a range.
2285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup binary_search_algorithms
2286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
2287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
2288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __val     The search term.
2289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp    A functor to use for comparisons.
2290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  True if @p __val (or its equivalent) is in @p [__first,__last].
2291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Note that this does not actually return an iterator to @p __val.  For
2293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  that, use std::find or a container's specialized find member functions.
2294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  The comparison function should have the same effects on ordering as
2296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  the function used for the initial sort.
2297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
2298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Tp, typename _Compare>
2299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     bool
2301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     binary_search(_ForwardIterator __first, _ForwardIterator __last,
2302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  const _Tp& __val, _Compare __comp)
ARM GAS  /tmp/ccawPiBL.s 			page 78


2303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
2305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
2306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
2307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
2308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_partitioned_lower_pred(__first, __last,
2309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 						__val, __comp);
2310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_partitioned_upper_pred(__first, __last,
2311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 						__val, __comp);
2312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __i
2314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	= std::__lower_bound(__first, __last, __val,
2315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     __gnu_cxx::__ops::__iter_comp_val(__comp));
2316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __i != __last && !bool(__comp(__val, *__i));
2317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // merge
2320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the __merge_adaptive routines.
2322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator1, typename _InputIterator2,
2323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _OutputIterator, typename _Compare>
2324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
2325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
2326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			  _InputIterator2 __first2, _InputIterator2 __last2,
2327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			  _OutputIterator __result, _Compare __comp)
2328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__first1 != __last1 && __first2 != __last2)
2330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__comp(__first2, __first1))
2332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
2333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      *__result = _GLIBCXX_MOVE(*__first2);
2334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__first2;
2335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
2337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
2338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      *__result = _GLIBCXX_MOVE(*__first1);
2339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__first1;
2340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__result;
2342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first1 != __last1)
2344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_GLIBCXX_MOVE3(__first1, __last1, __result);
2345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the __merge_adaptive routines.
2348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
2349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BidirectionalIterator3, typename _Compare>
2350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
2351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
2352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				   _BidirectionalIterator1 __last1,
2353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				   _BidirectionalIterator2 __first2,
2354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				   _BidirectionalIterator2 __last2,
2355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				   _BidirectionalIterator3 __result,
2356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				   _Compare __comp)
2357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first1 == __last1)
2359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
ARM GAS  /tmp/ccawPiBL.s 			page 79


2360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _GLIBCXX_MOVE_BACKWARD3(__first2, __last2, __result);
2361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  return;
2362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else if (__first2 == __last2)
2364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return;
2365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       --__last1;
2367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       --__last2;
2368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (true)
2369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__comp(__last2, __last1))
2371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
2372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      *--__result = _GLIBCXX_MOVE(*__last1);
2373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (__first1 == __last1)
2374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		{
2375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _GLIBCXX_MOVE_BACKWARD3(__first2, ++__last2, __result);
2376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  return;
2377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		}
2378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      --__last1;
2379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
2381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
2382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      *--__result = _GLIBCXX_MOVE(*__last2);
2383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (__first2 == __last2)
2384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		return;
2385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      --__last2;
2386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the merge routines.
2391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
2392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Distance>
2393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _BidirectionalIterator1
2394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __rotate_adaptive(_BidirectionalIterator1 __first,
2395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _BidirectionalIterator1 __middle,
2396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _BidirectionalIterator1 __last,
2397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _Distance __len1, _Distance __len2,
2398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _BidirectionalIterator2 __buffer,
2399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _Distance __buffer_size)
2400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _BidirectionalIterator2 __buffer_end;
2402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__len1 > __len2 && __len2 <= __buffer_size)
2403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__len2)
2405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
2406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
2407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      _GLIBCXX_MOVE_BACKWARD3(__first, __middle, __last);
2408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      return _GLIBCXX_MOVE3(__buffer, __buffer_end, __first);
2409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
2411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __first;
2412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else if (__len1 <= __buffer_size)
2414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__len1)
2416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
ARM GAS  /tmp/ccawPiBL.s 			page 80


2417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
2418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      _GLIBCXX_MOVE3(__middle, __last, __first);
2419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      return _GLIBCXX_MOVE_BACKWARD3(__buffer, __buffer_end, __last);
2420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
2422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return __last;
2423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else
2425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return std::rotate(__first, __middle, __last);
2426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the merge routines.
2429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator, typename _Distance, 
2430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Pointer, typename _Compare>
2431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
2432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __merge_adaptive(_BidirectionalIterator __first,
2433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _BidirectionalIterator __middle,
2434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _BidirectionalIterator __last,
2435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _Distance __len1, _Distance __len2,
2436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _Pointer __buffer, _Distance __buffer_size,
2437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _Compare __comp)
2438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__len1 <= __len2 && __len1 <= __buffer_size)
2440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
2442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
2443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				     __first, __comp);
2444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else if (__len2 <= __buffer_size)
2446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
2448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__move_merge_adaptive_backward(__first, __middle, __buffer,
2449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					      __buffer_end, __last, __comp);
2450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else
2452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _BidirectionalIterator __first_cut = __first;
2454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _BidirectionalIterator __second_cut = __middle;
2455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _Distance __len11 = 0;
2456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _Distance __len22 = 0;
2457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__len1 > __len2)
2458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
2459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __len11 = __len1 / 2;
2460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      std::advance(__first_cut, __len11);
2461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __second_cut
2462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		= std::__lower_bound(__middle, __last, *__first_cut,
2463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				     __gnu_cxx::__ops::__iter_comp_val(__comp));
2464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __len22 = std::distance(__middle, __second_cut);
2465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
2467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
2468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __len22 = __len2 / 2;
2469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      std::advance(__second_cut, __len22);
2470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __first_cut
2471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		= std::__upper_bound(__first, __middle, *__second_cut,
2472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				     __gnu_cxx::__ops::__val_comp_iter(__comp));
2473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      __len11 = std::distance(__first, __first_cut);
ARM GAS  /tmp/ccawPiBL.s 			page 81


2474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _BidirectionalIterator __new_middle
2477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
2478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				     __len1 - __len11, __len22, __buffer,
2479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				     __buffer_size);
2480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
2481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__len22, __buffer, __buffer_size, __comp);
2482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__merge_adaptive(__new_middle, __second_cut, __last,
2483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__len1 - __len11,
2484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__len2 - __len22, __buffer,
2485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__buffer_size, __comp);
2486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the merge routines.
2490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator, typename _Distance,
2491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Compare>
2492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
2493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __merge_without_buffer(_BidirectionalIterator __first,
2494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   _BidirectionalIterator __middle,
2495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   _BidirectionalIterator __last,
2496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   _Distance __len1, _Distance __len2,
2497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   _Compare __comp)
2498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__len1 == 0 || __len2 == 0)
2500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return;
2501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__len1 + __len2 == 2)
2503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__comp(__middle, __first))
2505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    std::iter_swap(__first, __middle);
2506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  return;
2507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _BidirectionalIterator __first_cut = __first;
2510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _BidirectionalIterator __second_cut = __middle;
2511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _Distance __len11 = 0;
2512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _Distance __len22 = 0;
2513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__len1 > __len2)
2514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __len11 = __len1 / 2;
2516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::advance(__first_cut, __len11);
2517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __second_cut
2518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    = std::__lower_bound(__middle, __last, *__first_cut,
2519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				 __gnu_cxx::__ops::__iter_comp_val(__comp));
2520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __len22 = std::distance(__middle, __second_cut);
2521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else
2523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __len22 = __len2 / 2;
2525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::advance(__second_cut, __len22);
2526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __first_cut
2527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    = std::__upper_bound(__first, __middle, *__second_cut,
2528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				 __gnu_cxx::__ops::__val_comp_iter(__comp));
2529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __len11 = std::distance(__first, __first_cut);
2530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
ARM GAS  /tmp/ccawPiBL.s 			page 82


2531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _BidirectionalIterator __new_middle
2533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	= std::rotate(__first_cut, __middle, __second_cut);
2534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__merge_without_buffer(__first, __first_cut, __new_middle,
2535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  __len11, __len22, __comp);
2536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__merge_without_buffer(__new_middle, __second_cut, __last,
2537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  __len1 - __len11, __len2 - __len22, __comp);
2538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator, typename _Compare>
2541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
2542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __inplace_merge(_BidirectionalIterator __first,
2543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		    _BidirectionalIterator __middle,
2544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		    _BidirectionalIterator __last,
2545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		    _Compare __comp)
2546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_BidirectionalIterator>::value_type
2548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _ValueType;
2549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_BidirectionalIterator>::difference_type
2550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _DistanceType;
2551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __middle || __middle == __last)
2553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return;
2554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       const _DistanceType __len1 = std::distance(__first, __middle);
2556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       const _DistanceType __len2 = std::distance(__middle, __last);
2557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
2559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _TmpBuf __buf(__first, __len1 + __len2);
2560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__buf.begin() == 0)
2562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::__merge_without_buffer
2563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  (__first, __middle, __last, __len1, __len2, __comp);
2564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else
2565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::__merge_adaptive
2566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  (__first, __middle, __last, __len1, __len2, __buf.begin(),
2567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   _DistanceType(__buf.size()), __comp);
2568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
2571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Merges two sorted ranges in place.
2572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
2573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
2574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __middle  Another iterator.
2575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
2576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  Nothing.
2577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Merges two sorted and consecutive ranges, [__first,__middle) and
2579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__middle,__last), and puts the result in [__first,__last).  The
2580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  output will be sorted.  The sort is @e stable, that is, for
2581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  equivalent elements in the two ranges, elements from the first
2582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  range will always come before elements from the second.
2583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  If enough additional memory is available, this takes (__last-__first)-1
2585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  comparisons.  Otherwise an NlogN algorithm is used, where N is
2586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  distance(__first,__last).
2587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
ARM GAS  /tmp/ccawPiBL.s 			page 83


2588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator>
2589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline void
2590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inplace_merge(_BidirectionalIterator __first,
2591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _BidirectionalIterator __middle,
2592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _BidirectionalIterator __last)
2593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
2595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
2596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    _BidirectionalIterator>)
2597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_LessThanComparableConcept<
2598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_BidirectionalIterator>::value_type>)
2599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_sorted(__first, __middle);
2600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_sorted(__middle, __last);
2601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive(__first, __last);
2602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__inplace_merge(__first, __middle, __last,
2604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   __gnu_cxx::__ops::__iter_less_iter());
2605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
2608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Merges two sorted ranges in place.
2609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
2610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
2611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __middle  Another iterator.
2612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
2613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp    A functor to use for comparisons.
2614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  Nothing.
2615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Merges two sorted and consecutive ranges, [__first,__middle) and
2617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [middle,last), and puts the result in [__first,__last).  The output will
2618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  be sorted.  The sort is @e stable, that is, for equivalent
2619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  elements in the two ranges, elements from the first range will always
2620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  come before elements from the second.
2621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  If enough additional memory is available, this takes (__last-__first)-1
2623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  comparisons.  Otherwise an NlogN algorithm is used, where N is
2624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  distance(__first,__last).
2625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  The comparison function should have the same effects on ordering as
2627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  the function used for the initial sort.
2628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
2629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator, typename _Compare>
2630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline void
2631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inplace_merge(_BidirectionalIterator __first,
2632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _BidirectionalIterator __middle,
2633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _BidirectionalIterator __last,
2634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		  _Compare __comp)
2635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
2637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
2638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    _BidirectionalIterator>)
2639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
2640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_BidirectionalIterator>::value_type,
2641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_BidirectionalIterator>::value_type>)
2642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_sorted_pred(__first, __middle, __comp);
2643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_sorted_pred(__middle, __last, __comp);
2644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
ARM GAS  /tmp/ccawPiBL.s 			page 84


2645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__inplace_merge(__first, __middle, __last,
2647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   __gnu_cxx::__ops::__iter_comp_iter(__comp));
2648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the __merge_sort_loop routines.
2652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator,
2653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Compare>
2654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
2655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __move_merge(_InputIterator __first1, _InputIterator __last1,
2656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		 _InputIterator __first2, _InputIterator __last2,
2657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		 _OutputIterator __result, _Compare __comp)
2658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__first1 != __last1 && __first2 != __last2)
2660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__comp(__first2, __first1))
2662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
2663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      *__result = _GLIBCXX_MOVE(*__first2);
2664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__first2;
2665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
2667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
2668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      *__result = _GLIBCXX_MOVE(*__first1);
2669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      ++__first1;
2670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__result;
2672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return _GLIBCXX_MOVE3(__first2, __last2,
2674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			    _GLIBCXX_MOVE3(__first1, __last1,
2675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					   __result));
2676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
2679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Distance, typename _Compare>
2680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
2681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __merge_sort_loop(_RandomAccessIterator1 __first,
2682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _RandomAccessIterator1 __last,
2683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _RandomAccessIterator2 __result, _Distance __step_size,
2684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _Compare __comp)
2685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       const _Distance __two_step = 2 * __step_size;
2687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__last - __first >= __two_step)
2689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __result = std::__move_merge(__first, __first + __step_size,
2691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				       __first + __step_size,
2692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				       __first + __two_step,
2693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				       __result, __comp);
2694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __first += __two_step;
2695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __step_size = std::min(_Distance(__last - __first), __step_size);
2697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__move_merge(__first, __first + __step_size,
2699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			__first + __step_size, __last, __result, __comp);
2700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
ARM GAS  /tmp/ccawPiBL.s 			page 85


2702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Distance,
2703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Compare>
2704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
2706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __chunk_insertion_sort(_RandomAccessIterator __first,
2707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   _RandomAccessIterator __last,
2708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   _Distance __chunk_size, _Compare __comp)
2709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__last - __first >= __chunk_size)
2711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__insertion_sort(__first, __first + __chunk_size, __comp);
2713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __first += __chunk_size;
2714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__insertion_sort(__first, __last, __comp);
2716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   enum { _S_chunk_size = 7 };
2719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
2721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
2722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __merge_sort_with_buffer(_RandomAccessIterator __first,
2723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     _RandomAccessIterator __last,
2724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     _Pointer __buffer, _Compare __comp)
2725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       typedef typename iterator_traits<_RandomAccessIterator>::difference_type
2727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	_Distance;
2728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       const _Distance __len = __last - __first;
2730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       const _Pointer __buffer_last = __buffer + __len;
2731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _Distance __step_size = _S_chunk_size;
2733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__chunk_insertion_sort(__first, __last, __step_size, __comp);
2734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__step_size < __len)
2736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__merge_sort_loop(__first, __last, __buffer,
2738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				 __step_size, __comp);
2739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __step_size *= 2;
2740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__merge_sort_loop(__buffer, __buffer_last, __first,
2741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				 __step_size, __comp);
2742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __step_size *= 2;
2743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Pointer,
2747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Distance, typename _Compare>
2748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
2749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __stable_sort_adaptive(_RandomAccessIterator __first,
2750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   _RandomAccessIterator __last,
2751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   _Pointer __buffer, _Distance __buffer_size,
2752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			   _Compare __comp)
2753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       const _Distance __len = (__last - __first + 1) / 2;
2755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       const _RandomAccessIterator __middle = __first + __len;
2756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__len > __buffer_size)
2757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__stable_sort_adaptive(__first, __middle, __buffer,
ARM GAS  /tmp/ccawPiBL.s 			page 86


2759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				      __buffer_size, __comp);
2760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__stable_sort_adaptive(__middle, __last, __buffer,
2761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				      __buffer_size, __comp);
2762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else
2764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
2766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
2767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__merge_adaptive(__first, __middle, __last,
2769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			    _Distance(__middle - __first),
2770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			    _Distance(__last - __middle),
2771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			    __buffer, __buffer_size,
2772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			    __comp);
2773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /// This is a helper function for the stable sorting routines.
2776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _RandomAccessIterator, typename _Compare>
2777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     void
2778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __inplace_stable_sort(_RandomAccessIterator __first,
2779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			  _RandomAccessIterator __last, _Compare __comp)
2780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__last - __first < 15)
2782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  std::__insertion_sort(__first, __last, __comp);
2784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  return;
2785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _RandomAccessIterator __middle = __first + (__last - __first) / 2;
2787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__inplace_stable_sort(__first, __middle, __comp);
2788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__inplace_stable_sort(__middle, __last, __comp);
2789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       std::__merge_without_buffer(__first, __middle, __last,
2790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  __middle - __first,
2791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  __last - __middle,
2792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  __comp);
2793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // stable_sort
2796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // Set algorithms: includes, set_union, set_intersection, set_difference,
2798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // set_symmetric_difference.  All of these algorithms have the precondition
2799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // that their input ranges are sorted and the postcondition that their output
2800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // ranges are sorted.
2801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator1, typename _InputIterator2,
2803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Compare>
2804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     bool
2806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __includes(_InputIterator1 __first1, _InputIterator1 __last1,
2807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _InputIterator2 __first2, _InputIterator2 __last2,
2808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	       _Compare __comp)
2809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__first1 != __last1 && __first2 != __last2)
2811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (__comp(__first2, __first1))
2812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  return false;
2813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	else if (__comp(__first1, __first2))
2814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first1;
2815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	else
ARM GAS  /tmp/ccawPiBL.s 			page 87


2816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  {
2817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__first1;
2818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    ++__first2;
2819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  }
2820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __first2 == __last2;
2822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
2825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Determines whether all elements of a sequence exists in a range.
2826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first1  Start of search range.
2827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last1   End of search range.
2828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first2  Start of sequence
2829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last2   End of sequence.
2830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  True if each element in [__first2,__last2) is contained in order
2831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  within [__first1,__last1).  False otherwise.
2832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup set_algorithms
2833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This operation expects both [__first1,__last1) and
2835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first2,__last2) to be sorted.  Searches for the presence of
2836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  each element in [__first2,__last2) within [__first1,__last1).
2837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  The iterators over each range only move forward, so this is a
2838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  linear algorithm.  If an element in [__first2,__last2) is not
2839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  found before the search iterator reaches @p __last2, false is
2840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  returned.
2841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
2842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator1, typename _InputIterator2>
2843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
2845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     includes(_InputIterator1 __first1, _InputIterator1 __last1,
2846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _InputIterator2 __first2, _InputIterator2 __last2)
2847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
2849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
2850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
2851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_LessThanOpConcept<
2852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator1>::value_type,
2853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator2>::value_type>)
2854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_LessThanOpConcept<
2855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator2>::value_type,
2856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator1>::value_type>)
2857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_sorted_set(__first1, __last1, __first2);
2858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_sorted_set(__first2, __last2, __first1);
2859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive2(__first1, __last1);
2860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive2(__first2, __last2);
2861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__includes(__first1, __last1, __first2, __last2,
2863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     __gnu_cxx::__ops::__iter_less_iter());
2864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
2867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Determines whether all elements of a sequence exists in a range
2868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  using comparison.
2869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup set_algorithms
2870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first1  Start of search range.
2871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last1   End of search range.
2872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first2  Start of sequence
ARM GAS  /tmp/ccawPiBL.s 			page 88


2873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last2   End of sequence.
2874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp    Comparison function to use.
2875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return True if each element in [__first2,__last2) is contained
2876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  in order within [__first1,__last1) according to comp.  False
2877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  otherwise.  @ingroup set_algorithms
2878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  This operation expects both [__first1,__last1) and
2880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first2,__last2) to be sorted.  Searches for the presence of
2881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  each element in [__first2,__last2) within [__first1,__last1),
2882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  using comp to decide.  The iterators over each range only move
2883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  forward, so this is a linear algorithm.  If an element in
2884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  [__first2,__last2) is not found before the search iterator
2885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  reaches @p __last2, false is returned.
2886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
2887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator1, typename _InputIterator2,
2888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Compare>
2889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
2891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     includes(_InputIterator1 __first1, _InputIterator1 __last1,
2892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _InputIterator2 __first2, _InputIterator2 __last2,
2893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	     _Compare __comp)
2894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
2896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
2897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
2898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
2899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator1>::value_type,
2900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator2>::value_type>)
2901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
2902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator2>::value_type,
2903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator1>::value_type>)
2904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
2905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
2906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
2907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
2908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__includes(__first1, __last1, __first2, __last2,
2910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     __gnu_cxx::__ops::__iter_comp_iter(__comp));
2911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // nth_element
2914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // merge
2915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // set_difference
2916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // set_intersection
2917:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // set_union
2918:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // stable_sort
2919:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // set_symmetric_difference
2920:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // min_element
2921:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // max_element
2922:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2923:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator, typename _Compare>
2924:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2925:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     bool
2926:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __next_permutation(_BidirectionalIterator __first,
2927:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		       _BidirectionalIterator __last, _Compare __comp)
2928:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2929:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
ARM GAS  /tmp/ccawPiBL.s 			page 89


2930:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return false;
2931:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _BidirectionalIterator __i = __first;
2932:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       ++__i;
2933:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__i == __last)
2934:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return false;
2935:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __i = __last;
2936:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       --__i;
2937:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2938:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for(;;)
2939:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
2940:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _BidirectionalIterator __ii = __i;
2941:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  --__i;
2942:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__comp(__i, __ii))
2943:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
2944:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      _BidirectionalIterator __j = __last;
2945:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      while (!__comp(__i, --__j))
2946:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		{}
2947:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      std::iter_swap(__i, __j);
2948:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      std::__reverse(__ii, __last,
2949:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     std::__iterator_category(__first));
2950:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      return true;
2951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2952:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__i == __first)
2953:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
2954:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      std::__reverse(__first, __last,
2955:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     std::__iterator_category(__first));
2956:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      return false;
2957:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
2958:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
2959:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2960:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2961:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
2962:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Permute range into the next @e dictionary ordering.
2963:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
2964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  Start of range.
2965:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   End of range.
2966:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  False if wrapped to first permutation, true otherwise.
2967:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
2968:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Treats all permutations of the range as a set of @e dictionary sorted
2969:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  sequences.  Permutes the current sequence into the next one of this set.
2970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Returns true if there are more sequences to generate.  If the sequence
2971:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  is the largest of the set, the smallest is generated and false returned.
2972:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
2973:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator>
2974:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
2975:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
2976:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     next_permutation(_BidirectionalIterator __first,
2977:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _BidirectionalIterator __last)
2978:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
2979:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
2980:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BidirectionalIteratorConcept<
2981:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _BidirectionalIterator>)
2982:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_LessThanComparableConcept<
2983:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_BidirectionalIterator>::value_type>)
2984:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
2985:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive(__first, __last);
2986:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
ARM GAS  /tmp/ccawPiBL.s 			page 90


2987:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__next_permutation
2988:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
2989:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
2990:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
2991:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
2992:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Permute range into the next @e dictionary ordering using
2993:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          comparison functor.
2994:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
2995:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  Start of range.
2996:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   End of range.
2997:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp   A comparison functor.
2998:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  False if wrapped to first permutation, true otherwise.
2999:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
3000:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Treats all permutations of the range [__first,__last) as a set of
3001:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
3002:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  sequence into the next one of this set.  Returns true if there are more
3003:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  sequences to generate.  If the sequence is the largest of the set, the
3004:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  smallest is generated and false returned.
3005:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3006:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator, typename _Compare>
3007:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3008:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
3009:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     next_permutation(_BidirectionalIterator __first,
3010:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _BidirectionalIterator __last, _Compare __comp)
3011:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3012:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
3013:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BidirectionalIteratorConcept<
3014:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _BidirectionalIterator>)
3015:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
3016:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_BidirectionalIterator>::value_type,
3017:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_BidirectionalIterator>::value_type>)
3018:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
3019:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
3020:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3021:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__next_permutation
3022:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
3023:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3024:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3025:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator, typename _Compare>
3026:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3027:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     bool
3028:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __prev_permutation(_BidirectionalIterator __first,
3029:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		       _BidirectionalIterator __last, _Compare __comp)
3030:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3031:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
3032:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return false;
3033:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _BidirectionalIterator __i = __first;
3034:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       ++__i;
3035:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__i == __last)
3036:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return false;
3037:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __i = __last;
3038:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       --__i;
3039:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3040:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for(;;)
3041:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
3042:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  _BidirectionalIterator __ii = __i;
3043:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  --__i;
ARM GAS  /tmp/ccawPiBL.s 			page 91


3044:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__comp(__ii, __i))
3045:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
3046:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      _BidirectionalIterator __j = __last;
3047:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      while (!__comp(--__j, __i))
3048:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		{}
3049:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      std::iter_swap(__i, __j);
3050:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      std::__reverse(__ii, __last,
3051:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     std::__iterator_category(__first));
3052:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      return true;
3053:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
3054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__i == __first)
3055:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
3056:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      std::__reverse(__first, __last,
3057:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			     std::__iterator_category(__first));
3058:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      return false;
3059:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
3060:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
3061:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3062:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3063:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3064:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Permute range into the previous @e dictionary ordering.
3065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
3066:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  Start of range.
3067:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   End of range.
3068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  False if wrapped to last permutation, true otherwise.
3069:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
3070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Treats all permutations of the range as a set of @e dictionary sorted
3071:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  sequences.  Permutes the current sequence into the previous one of this
3072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  set.  Returns true if there are more sequences to generate.  If the
3073:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  sequence is the smallest of the set, the largest is generated and false
3074:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  returned.
3075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3076:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator>
3077:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3078:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
3079:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     prev_permutation(_BidirectionalIterator __first,
3080:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _BidirectionalIterator __last)
3081:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3082:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
3083:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BidirectionalIteratorConcept<
3084:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _BidirectionalIterator>)
3085:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_LessThanComparableConcept<
3086:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_BidirectionalIterator>::value_type>)
3087:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
3088:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive(__first, __last);
3089:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3090:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__prev_permutation(__first, __last,
3091:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				     __gnu_cxx::__ops::__iter_less_iter());
3092:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3093:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3094:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3095:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Permute range into the previous @e dictionary ordering using
3096:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          comparison functor.
3097:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
3098:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  Start of range.
3099:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   End of range.
3100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp   A comparison functor.
ARM GAS  /tmp/ccawPiBL.s 			page 92


3101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  False if wrapped to last permutation, true otherwise.
3102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
3103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Treats all permutations of the range [__first,__last) as a set of
3104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
3105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  sequence into the previous one of this set.  Returns true if there are
3106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  more sequences to generate.  If the sequence is the smallest of the set,
3107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  the largest is generated and false returned.
3108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _BidirectionalIterator, typename _Compare>
3110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
3112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     prev_permutation(_BidirectionalIterator __first,
3113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _BidirectionalIterator __last, _Compare __comp)
3114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
3116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BidirectionalIteratorConcept<
3117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				  _BidirectionalIterator>)
3118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
3119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_BidirectionalIterator>::value_type,
3120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_BidirectionalIterator>::value_type>)
3121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
3122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
3123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__prev_permutation(__first, __last,
3125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__gnu_cxx::__ops::__iter_comp_iter(__comp));
3126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // replace
3129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // replace_if
3130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator,
3132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Predicate, typename _Tp>
3133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _OutputIterator
3135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __replace_copy_if(_InputIterator __first, _InputIterator __last,
3136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _OutputIterator __result,
3137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _Predicate __pred, const _Tp& __new_value)
3138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (; __first != __last; ++__first, (void)++__result)
3140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (__pred(__first))
3141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  *__result = __new_value;
3142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	else
3143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  *__result = *__first;
3144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __result;
3145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copy a sequence, replacing each element of one value with another
3149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *         value.
3150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first      An input iterator.
3151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last       An input iterator.
3152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result     An output iterator.
3153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __old_value  The value to be replaced.
3154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __new_value  The replacement value.
3155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   The end of the output sequence, @p result+(last-first).
3156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
3157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Copies each element in the input range @p [__first,__last) to the
ARM GAS  /tmp/ccawPiBL.s 			page 93


3158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  output range @p [__result,__result+(__last-__first)) replacing elements
3159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  equal to @p __old_value with @p __new_value.
3160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator, typename _Tp>
3162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _OutputIterator
3164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     replace_copy(_InputIterator __first, _InputIterator __last,
3165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		 _OutputIterator __result,
3166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		 const _Tp& __old_value, const _Tp& __new_value)
3167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
3169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
3170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
3171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
3172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_EqualOpConcept<
3173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
3174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
3175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__replace_copy_if(__first, __last, __result,
3177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			__gnu_cxx::__ops::__iter_equals_val(__old_value),
3178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					      __new_value);
3179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief Copy a sequence, replacing each value for which a predicate
3183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *         returns true with another value.
3184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup mutating_algorithms
3185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first      An input iterator.
3186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last       An input iterator.
3187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __result     An output iterator.
3188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred       A predicate.
3189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __new_value  The replacement value.
3190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return   The end of the output sequence, @p __result+(__last-__first).
3191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *
3192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  Copies each element in the range @p [__first,__last) to the range
3193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p [__result,__result+(__last-__first)) replacing elements for which
3194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @p __pred returns true with @p __new_value.
3195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _InputIterator, typename _OutputIterator,
3197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _Predicate, typename _Tp>
3198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _OutputIterator
3200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     replace_copy_if(_InputIterator __first, _InputIterator __last,
3201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		    _OutputIterator __result,
3202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		    _Predicate __pred, const _Tp& __new_value)
3203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
3205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
3206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
3207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
3208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
3209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_InputIterator>::value_type>)
3210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
3211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__replace_copy_if(__first, __last, __result,
3213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				__gnu_cxx::__ops::__pred_iter(__pred),
3214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 					      __new_value);
ARM GAS  /tmp/ccawPiBL.s 			page 94


3215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #if __cplusplus >= 201103L
3218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Determines whether the elements of a sequence are sorted.
3220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
3221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
3222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
3223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  True if the elements are sorted, false otherwise.
3224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator>
3226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
3228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     is_sorted(_ForwardIterator __first, _ForwardIterator __last)
3229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     { return std::is_sorted_until(__first, __last) == __last; }
3230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Determines whether the elements of a sequence are sorted
3233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          according to a comparison functor.
3234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
3235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
3236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
3237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp    A comparison functor.
3238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  True if the elements are sorted, false otherwise.
3239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Compare>
3241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
3243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     is_sorted(_ForwardIterator __first, _ForwardIterator __last,
3244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      _Compare __comp)
3245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     { return std::is_sorted_until(__first, __last, __comp) == __last; }
3246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Compare>
3248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _ForwardIterator
3250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
3251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		      _Compare __comp)
3252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last)
3254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return __last;
3255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __next = __first;
3257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (++__next; __next != __last; __first = __next, (void)++__next)
3258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (__comp(__next, __first))
3259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  return __next;
3260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __next;
3261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Determines the end of a sorted sequence.
3265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
3266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
3267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
3268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  An iterator pointing to the last iterator i in [__first, __last)
3269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *           for which the range [__first, i) is sorted.
3270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator>
ARM GAS  /tmp/ccawPiBL.s 			page 95


3272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
3274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
3275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
3277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
3278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_LessThanComparableConcept<
3279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator>::value_type>)
3280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
3281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive(__first, __last);
3282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__is_sorted_until(__first, __last,
3284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				    __gnu_cxx::__ops::__iter_less_iter());
3285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Determines the end of a sorted sequence using comparison functor.
3289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
3290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first   An iterator.
3291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last    Another iterator.
3292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp    A comparison functor.
3293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  An iterator pointing to the last iterator i in [__first, __last)
3294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *           for which the range [__first, i) is sorted.
3295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Compare>
3297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _ForwardIterator
3299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
3300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		    _Compare __comp)
3301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
3303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
3304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
3305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator>::value_type,
3306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator>::value_type>)
3307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
3308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
3309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__is_sorted_until(__first, __last,
3311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
3312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Determines min and max at once as an ordered pair.
3316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
3317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __a  A thing of arbitrary type.
3318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __b  Another thing of arbitrary type.
3319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
3320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  __b) otherwise.
3321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _Tp>
3323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX14_CONSTEXPR
3324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline pair<const _Tp&, const _Tp&>
3325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     minmax(const _Tp& __a, const _Tp& __b)
3326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
3328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
ARM GAS  /tmp/ccawPiBL.s 			page 96


3329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
3331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		       : pair<const _Tp&, const _Tp&>(__a, __b);
3332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Determines min and max at once as an ordered pair.
3336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
3337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __a  A thing of arbitrary type.
3338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __b  Another thing of arbitrary type.
3339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp  A @link comparison_functors comparison functor @endlink.
3340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
3341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  __b) otherwise.
3342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _Tp, typename _Compare>
3344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX14_CONSTEXPR
3345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline pair<const _Tp&, const _Tp&>
3346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
3347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
3349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			      : pair<const _Tp&, const _Tp&>(__a, __b);
3350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Compare>
3353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX14_CONSTEXPR
3354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     pair<_ForwardIterator, _ForwardIterator>
3355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
3356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _Compare __comp)
3357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __next = __first;
3359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__first == __last
3360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  || ++__next == __last)
3361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	return std::make_pair(__first, __first);
3362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       _ForwardIterator __min{}, __max{};
3364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__comp(__next, __first))
3365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
3366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __min = __next;
3367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __max = __first;
3368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
3369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else
3370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
3371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __min = __first;
3372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __max = __next;
3373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
3374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __first = __next;
3376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       ++__first;
3377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       while (__first != __last)
3379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
3380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __next = __first;
3381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (++__next == __last)
3382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
3383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (__comp(__first, __min))
3384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		__min = __first;
3385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      else if (!__comp(__first, __max))
ARM GAS  /tmp/ccawPiBL.s 			page 97


3386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		__max = __first;
3387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      break;
3388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
3389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__comp(__next, __first))
3391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
3392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (__comp(__next, __min))
3393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		__min = __next;
3394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (!__comp(__first, __max))
3395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		__max = __first;
3396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
3397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  else
3398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    {
3399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (__comp(__first, __min))
3400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		__min = __first;
3401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      if (!__comp(__next, __max))
3402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		__max = __next;
3403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    }
3404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  __first = __next;
3406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first;
3407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
3408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::make_pair(__min, __max);
3410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Return a pair of iterators pointing to the minimum and maximum
3414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          elements in a range.
3415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
3416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  Start of range.
3417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   End of range.
3418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  make_pair(m, M), where m is the first iterator i in 
3419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *           [__first, __last) such that no other element in the range is
3420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *           smaller, and where M is the last iterator i in [__first, __last)
3421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *           such that no other element in the range is larger.
3422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator>
3424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX14_CONSTEXPR
3425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline pair<_ForwardIterator, _ForwardIterator>
3426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     minmax_element(_ForwardIterator __first, _ForwardIterator __last)
3427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
3429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
3430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_LessThanComparableConcept<
3431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator>::value_type>)
3432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
3433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive(__first, __last);
3434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__minmax_element(__first, __last,
3436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				   __gnu_cxx::__ops::__iter_less_iter());
3437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Return a pair of iterators pointing to the minimum and maximum
3441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          elements in a range.
3442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
ARM GAS  /tmp/ccawPiBL.s 			page 98


3443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first  Start of range.
3444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last   End of range.
3445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __comp   Comparison functor.
3446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return  make_pair(m, M), where m is the first iterator i in 
3447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *           [__first, __last) such that no other element in the range is
3448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *           smaller, and where M is the last iterator i in [__first, __last)
3449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *           such that no other element in the range is larger.
3450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator, typename _Compare>
3452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX14_CONSTEXPR
3453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline pair<_ForwardIterator, _ForwardIterator>
3454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     minmax_element(_ForwardIterator __first, _ForwardIterator __last,
3455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _Compare __comp)
3456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
3458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
3459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
3460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator>::value_type,
3461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator>::value_type>)
3462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first, __last);
3463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
3464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__minmax_element(__first, __last,
3466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				   __gnu_cxx::__ops::__iter_comp_iter(__comp));
3467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   // N2722 + DR 915.
3470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _Tp>
3471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX14_CONSTEXPR
3472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _Tp
3473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     min(initializer_list<_Tp> __l)
3474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     { return *std::min_element(__l.begin(), __l.end()); }
3475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _Tp, typename _Compare>
3477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX14_CONSTEXPR
3478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _Tp
3479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     min(initializer_list<_Tp> __l, _Compare __comp)
3480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     { return *std::min_element(__l.begin(), __l.end(), __comp); }
3481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _Tp>
3483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX14_CONSTEXPR
3484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _Tp
3485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     max(initializer_list<_Tp> __l)
3486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     { return *std::max_element(__l.begin(), __l.end()); }
3487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _Tp, typename _Compare>
3489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX14_CONSTEXPR
3490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline _Tp
3491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     max(initializer_list<_Tp> __l, _Compare __comp)
3492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     { return *std::max_element(__l.begin(), __l.end(), __comp); }
3493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _Tp>
3495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX14_CONSTEXPR
3496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline pair<_Tp, _Tp>
3497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     minmax(initializer_list<_Tp> __l)
3498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       pair<const _Tp*, const _Tp*> __p =
ARM GAS  /tmp/ccawPiBL.s 			page 99


3500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::minmax_element(__l.begin(), __l.end());
3501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::make_pair(*__p.first, *__p.second);
3502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _Tp, typename _Compare>
3505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX14_CONSTEXPR
3506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline pair<_Tp, _Tp>
3507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     minmax(initializer_list<_Tp> __l, _Compare __comp)
3508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       pair<const _Tp*, const _Tp*> __p =
3510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::minmax_element(__l.begin(), __l.end(), __comp);
3511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::make_pair(*__p.first, *__p.second);
3512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Checks whether a permutation of the second sequence is equal
3516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          to the first sequence.
3517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
3518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first1  Start of first range.
3519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last1   End of first range.
3520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first2  Start of second range.
3521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A binary predicate.
3522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return true if there exists a permutation of the elements in
3523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          the range [__first2, __first2 + (__last1 - __first1)),
3524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          beginning with ForwardIterator2 begin, such that
3525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          equal(__first1, __last1, __begin, __pred) returns true;
3526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          otherwise, returns false.
3527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2,
3529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
3530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
3532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
3533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _ForwardIterator2 __first2, _BinaryPredicate __pred)
3534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // concept requirements
3536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
3537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
3538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
3539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator1>::value_type,
3540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    typename iterator_traits<_ForwardIterator2>::value_type>)
3541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first1, __last1);
3542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__is_permutation(__first1, __last1, __first2,
3544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				   __gnu_cxx::__ops::__iter_comp_iter(__pred));
3545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #if __cplusplus > 201103L
3548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2,
3549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
3550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     bool
3552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
3553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
3554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		     _BinaryPredicate __pred)
3555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       using _Cat1
ARM GAS  /tmp/ccawPiBL.s 			page 100


3557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	= typename iterator_traits<_ForwardIterator1>::iterator_category;
3558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       using _Cat2
3559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	= typename iterator_traits<_ForwardIterator2>::iterator_category;
3560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
3561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
3562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
3563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__ra_iters)
3564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
3565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  auto __d1 = std::distance(__first1, __last1);
3566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  auto __d2 = std::distance(__first2, __last2);
3567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__d1 != __d2)
3568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return false;
3569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
3570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // Efficiently compare identical prefixes:  O(N) if sequences
3572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       // have the same elements in the same order.
3573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (; __first1 != __last1 && __first2 != __last2;
3574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  ++__first1, (void)++__first2)
3575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	if (!__pred(__first1, __first2))
3576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  break;
3577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       if (__ra_iters)
3579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
3580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__first1 == __last1)
3581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return true;
3582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
3583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       else
3584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
3585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  auto __d1 = std::distance(__first1, __last1);
3586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  auto __d2 = std::distance(__first2, __last2);
3587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__d1 == 0 && __d2 == 0)
3588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return true;
3589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__d1 != __d2)
3590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return false;
3591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
3592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
3594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	{
3595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (__scan != std::__find_if(__first1, __scan,
3596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
3597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    continue; // We've seen this one before.
3598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  auto __matches = std::__count_if(__first2, __last2,
3600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
3601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	  if (0 == __matches
3602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      || std::__count_if(__scan, __last1,
3603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
3604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	      != __matches)
3605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	    return false;
3606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	}
3607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return true;
3608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Checks whether a permutaion of the second sequence is equal
3612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          to the first sequence.
3613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
ARM GAS  /tmp/ccawPiBL.s 			page 101


3614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first1  Start of first range.
3615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last1   End of first range.
3616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first2  Start of second range.
3617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last2   End of first range.
3618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return true if there exists a permutation of the elements in the range
3619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          [__first2, __last2), beginning with ForwardIterator2 begin,
3620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          such that equal(__first1, __last1, begin) returns true;
3621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          otherwise, returns false.
3622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2>
3624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
3626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
3627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _ForwardIterator2 __first2, _ForwardIterator2 __last2)
3628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first1, __last1);
3630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first2, __last2);
3631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return
3633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	std::__is_permutation(__first1, __last1, __first2, __last2,
3634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 			      __gnu_cxx::__ops::__iter_equal_to_iter());
3635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
3638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Checks whether a permutation of the second sequence is equal
3639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          to the first sequence.
3640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup non_mutating_algorithms
3641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first1  Start of first range.
3642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last1   End of first range.
3643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __first2  Start of second range.
3644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __last2   End of first range.
3645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __pred    A binary predicate.
3646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return true if there exists a permutation of the elements in the range
3647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          [__first2, __last2), beginning with ForwardIterator2 begin,
3648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          such that equal(__first1, __last1, __begin, __pred) returns true;
3649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *          otherwise, returns false.
3650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   */
3651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2,
3652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 	   typename _BinaryPredicate>
3653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     _GLIBCXX20_CONSTEXPR
3654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     inline bool
3655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
3656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
3657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 		   _BinaryPredicate __pred)
3658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first1, __last1);
3660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_requires_valid_range(__first2, __last2);
3661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return std::__is_permutation(__first1, __last1, __first2, __last2,
3663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 				   __gnu_cxx::__ops::__iter_comp_iter(__pred));
3664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     }
3665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #if __cplusplus > 201402L
3667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** #define __cpp_lib_clamp 201603
3669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h **** 
3670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   /**
ARM GAS  /tmp/ccawPiBL.s 			page 102


3671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @brief  Returns the value clamped between lo and hi.
3672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @ingroup sorting_algorithms
3673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __val  A value of arbitrary type.
3674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __lo   A lower limit of arbitrary type.
3675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @param  __hi   An upper limit of arbitrary type.
3676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    *  @return max(__val, __lo) if __val < __hi or min(__val, __hi) otherwise.
3677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****    */
3678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****   template<typename _Tp>
3679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     constexpr const _Tp&
3680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi)
 343              		.loc 6 3680 5 view .LVU75
 344              	.LBB558:
3681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
3682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       __glibcxx_assert(!(__hi < __lo));
3683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****       return (__val < __lo) ? __lo : (__hi < __val) ? __hi : __val;
 345              		.loc 6 3683 29 is_stmt 0 view .LVU76
 346 0022 B4EEE10A 		vcmpe.f32	s0, s3
 347 0026 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 348 002a 06DC     		bgt	.L23
 349 002c F4EEE17A 		vcmpe.f32	s15, s3
 350 0030 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 351 0034 06D5     		bpl	.L26
 352 0036 03AB     		add	r3, sp, #12
 353              	.LVL29:
 354              		.loc 6 3683 29 view .LVU77
 355 0038 00E0     		b	.L21
 356              	.LVL30:
 357              	.L23:
 358              		.loc 6 3683 29 view .LVU78
 359 003a 02AB     		add	r3, sp, #8
 360              	.LVL31:
 361              	.L21:
 362              		.loc 6 3683 29 view .LVU79
 363              	.LBE558:
 364              	.LBE557:
 141:MotorControl/controller.cpp **** }
 365              		.loc 3 141 1 view .LVU80
 366 003c 93ED000A 		vldr.32	s0, [r3]
 367 0040 04B0     		add	sp, sp, #16
 368              	.LCFI1:
 369              		.cfi_remember_state
 370              		.cfi_def_cfa_offset 0
 371              		@ sp needed
 372 0042 7047     		bx	lr
 373              	.LVL32:
 374              	.L26:
 375              	.LCFI2:
 376              		.cfi_restore_state
 377              	.LBB560:
 378              	.LBB559:
 379              		.loc 6 3683 29 view .LVU81
 380 0044 01AB     		add	r3, sp, #4
 381              	.LVL33:
 382              		.loc 6 3683 29 view .LVU82
 383 0046 F9E7     		b	.L21
 384              	.LBE559:
 385              	.LBE560:
ARM GAS  /tmp/ccawPiBL.s 			page 103


 386              		.cfi_endproc
 387              	.LFE5202:
 388              		.cantunwind
 389              		.fnend
 391              		.section	.text._ZNSt18bad_variant_accessD2Ev,"axG",%progbits,_ZNSt18bad_variant_accessD5Ev,comdat
 392              		.align	1
 393              		.weak	_ZNSt18bad_variant_accessD2Ev
 394              		.syntax unified
 395              		.thumb
 396              		.thumb_func
 398              	_ZNSt18bad_variant_accessD2Ev:
 399              		.fnstart
 400              	.LVL34:
 401              	.LFB6223:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 402              		.loc 1 1264 9 is_stmt 1 view -0
 403              		.cfi_startproc
 404              		@ args = 0, pretend = 0, frame = 0
 405              		@ frame_needed = 0, uses_anonymous_args = 0
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 406              		.loc 1 1264 9 is_stmt 0 view .LVU84
 407 0000 10B5     		push	{r4, lr}
 408              	.LCFI3:
 409              		.cfi_def_cfa_offset 8
 410              		.cfi_offset 4, -8
 411              		.cfi_offset 14, -4
 412 0002 0446     		mov	r4, r0
 413              	.LBB561:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 414              		.loc 1 1264 9 view .LVU85
 415 0004 024B     		ldr	r3, .L30
 416 0006 0360     		str	r3, [r0]
 417 0008 FFF7FEFF 		bl	_ZNSt9exceptionD2Ev
 418              	.LVL35:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 419              		.loc 1 1264 9 view .LVU86
 420              	.LBE561:
 421 000c 2046     		mov	r0, r4
 422 000e 10BD     		pop	{r4, pc}
 423              	.LVL36:
 424              	.L31:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 425              		.loc 1 1264 9 view .LVU87
 426              		.align	2
 427              	.L30:
 428 0010 08000000 		.word	_ZTVSt18bad_variant_access+8
 429              		.cfi_endproc
 430              	.LFE6223:
 431              		.cantunwind
 432              		.fnend
 434              		.weak	_ZNSt18bad_variant_accessD1Ev
 435              		.thumb_set _ZNSt18bad_variant_accessD1Ev,_ZNSt18bad_variant_accessD2Ev
 436              		.section	.text._ZNSt18bad_variant_accessD0Ev,"axG",%progbits,_ZNSt18bad_variant_accessD5Ev,comdat
 437              		.align	1
 438              		.weak	_ZNSt18bad_variant_accessD0Ev
 439              		.syntax unified
 440              		.thumb
ARM GAS  /tmp/ccawPiBL.s 			page 104


 441              		.thumb_func
 443              	_ZNSt18bad_variant_accessD0Ev:
 444              		.fnstart
 445              	.LVL37:
 446              	.LFB6225:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 447              		.loc 1 1264 9 is_stmt 1 view -0
 448              		.cfi_startproc
 449              		@ args = 0, pretend = 0, frame = 0
 450              		@ frame_needed = 0, uses_anonymous_args = 0
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 451              		.loc 1 1264 9 is_stmt 0 view .LVU89
 452 0000 10B5     		push	{r4, lr}
 453              	.LCFI4:
 454              		.cfi_def_cfa_offset 8
 455              		.cfi_offset 4, -8
 456              		.cfi_offset 14, -4
 457 0002 0446     		mov	r4, r0
 458              	.LVL38:
 459              	.LBB562:
 460              	.LBI562:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 461              		.loc 1 1264 9 is_stmt 1 view .LVU90
 462              	.LBB563:
 463 0004 044B     		ldr	r3, .L34
 464 0006 0360     		str	r3, [r0]
 465 0008 FFF7FEFF 		bl	_ZNSt9exceptionD2Ev
 466              	.LVL39:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 467              		.loc 1 1264 9 is_stmt 0 view .LVU91
 468              	.LBE563:
 469              	.LBE562:
 470 000c 0821     		movs	r1, #8
 471 000e 2046     		mov	r0, r4
 472 0010 FFF7FEFF 		bl	_ZdlPvj
 473              	.LVL40:
 474 0014 2046     		mov	r0, r4
 475 0016 10BD     		pop	{r4, pc}
 476              	.LVL41:
 477              	.L35:
1264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 478              		.loc 1 1264 9 view .LVU92
 479              		.align	2
 480              	.L34:
 481 0018 08000000 		.word	_ZTVSt18bad_variant_access+8
 482              		.cfi_endproc
 483              	.LFE6225:
 484              		.cantunwind
 485              		.fnend
 487              		.section	.text._ZSt26__throw_bad_variant_accessPKc,"axG",%progbits,_ZSt26__throw_bad_variant_acces
 488              		.align	1
 489              		.weak	_ZSt26__throw_bad_variant_accessPKc
 490              		.syntax unified
 491              		.thumb
 492              		.thumb_func
 494              	_ZSt26__throw_bad_variant_accessPKc:
 495              		.fnstart
ARM GAS  /tmp/ccawPiBL.s 			page 105


 496              	.LVL42:
 497              	.LFB3070:
1271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   private:
1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     bad_variant_access(const char* __reason) noexcept : _M_reason(__reason) { }
1274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     // Must point to a string with static storage duration:
1276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     const char* _M_reason = "bad variant access";
1277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     friend void __throw_bad_variant_access(const char* __what);
1279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   };
1280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   // Must only be called with a string literal
1282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   inline void
1283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   __throw_bad_variant_access(const char* __what)
1284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   { _GLIBCXX_THROW_OR_ABORT(bad_variant_access(__what)); }
 498              		.loc 1 1284 3 is_stmt 1 view -0
 499              		.cfi_startproc
 500              		@ args = 0, pretend = 0, frame = 0
 501              		@ frame_needed = 0, uses_anonymous_args = 0
 502              		.loc 1 1284 3 is_stmt 0 view .LVU94
 503 0000 10B5     		push	{r4, lr}
 504              		.save {r4, lr}
 505              	.LCFI5:
 506              		.cfi_def_cfa_offset 8
 507              		.cfi_offset 4, -8
 508              		.cfi_offset 14, -4
 509 0002 0446     		mov	r4, r0
 510              		.loc 1 1284 5 is_stmt 1 view .LVU95
 511 0004 0820     		movs	r0, #8
 512              	.LVL43:
 513              		.loc 1 1284 5 is_stmt 0 view .LVU96
 514 0006 FFF7FEFF 		bl	__cxa_allocate_exception
 515              	.LVL44:
 516              	.LBB564:
 517              	.LBI564:
1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 518              		.loc 1 1273 5 is_stmt 1 view .LVU97
 519              	.LBB565:
 520              	.LBB566:
 521              	.LBI566:
 522              		.file 7 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // Exception Handling support header for -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // Copyright (C) 2016-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // This file is part of GCC.
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** //
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // GCC is free software; you can redistribute it and/or modify
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // it under the terms of the GNU General Public License as published by
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // the Free Software Foundation; either version 3, or (at your option)
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // any later version.
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** //
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // GCC is distributed in the hope that it will be useful,
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // GNU General Public License for more details.
ARM GAS  /tmp/ccawPiBL.s 			page 106


  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** //
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // Under Section 7 of GPL version 3, you are granted additional
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // permissions described in the GCC Runtime Library Exception, version
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // 3.1, as published by the Free Software Foundation.
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // You should have received a copy of the GNU General Public License and
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // a copy of the GCC Runtime Library Exception along with this program;
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** // <http://www.gnu.org/licenses/>.
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** /** @file bits/exception.h
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****  *  This is an internal header file, included by other library headers.
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****  *  Do not attempt to use it directly.
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****  */
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #ifndef __EXCEPTION_H
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #define __EXCEPTION_H 1
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #pragma GCC system_header
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #pragma GCC visibility push(default)
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** #include <bits/c++config.h>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** extern "C++" {
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** namespace std
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** {
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   /**
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    * @defgroup exceptions Exceptions
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    * @ingroup diagnostics
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    * Classes and functions for reporting errors via exceptions.
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    * @{
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    */
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   /**
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  @brief Base class for all library exceptions.
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  This is the base class for all exceptions thrown by the standard
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  library, and by certain language expressions.  You are free to derive
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  your own %exception classes, or use a different hierarchy, or to
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    *  throw non-class data (e.g., fundamental types).
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****    */
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   class exception
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   {
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****   public:
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception.h ****     exception() _GLIBCXX_NOTHROW { }
 523              		.loc 7 63 5 view .LVU98
 524              	.LBB567:
 525              		.loc 7 63 34 is_stmt 0 view .LVU99
 526 000a 044A     		ldr	r2, .L38
 527 000c 0260     		str	r2, [r0]
 528              	.LVL45:
 529              		.loc 7 63 34 view .LVU100
 530              	.LBE567:
 531              	.LBE566:
ARM GAS  /tmp/ccawPiBL.s 			page 107


1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 532              		.loc 1 1273 75 view .LVU101
 533 000e 044A     		ldr	r2, .L38+4
 534 0010 0260     		str	r2, [r0]
 535 0012 4460     		str	r4, [r0, #4]
 536              	.LVL46:
1273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
 537              		.loc 1 1273 75 view .LVU102
 538              	.LBE565:
 539              	.LBE564:
 540              		.loc 1 1284 5 view .LVU103
 541 0014 034A     		ldr	r2, .L38+8
 542 0016 0449     		ldr	r1, .L38+12
 543 0018 FFF7FEFF 		bl	__cxa_throw
 544              	.LVL47:
 545              	.L39:
 546              		.align	2
 547              	.L38:
 548 001c 08000000 		.word	_ZTVSt9exception+8
 549 0020 08000000 		.word	_ZTVSt18bad_variant_access+8
 550 0024 00000000 		.word	_ZNSt18bad_variant_accessD1Ev
 551 0028 00000000 		.word	_ZTISt18bad_variant_access
 552              		.cfi_endproc
 553              	.LFE3070:
 554              		.fnend
 556              		.section	.text._ZoRRN10ODriveIntf14ControllerIntf5ErrorES1_,"axG",%progbits,_ZoRRN10ODriveIntf14Co
 557              		.align	1
 558              		.weak	_ZoRRN10ODriveIntf14ControllerIntf5ErrorES1_
 559              		.syntax unified
 560              		.thumb
 561              		.thumb_func
 563              	_ZoRRN10ODriveIntf14ControllerIntf5ErrorES1_:
 564              		.fnstart
 565              	.LVL48:
 566              	.LFB4184:
 567              		.file 8 "./autogen/interfaces.hpp"
   1:./autogen/interfaces.hpp **** /*
   2:./autogen/interfaces.hpp ****  * ============================ WARNING ============================
   3:./autogen/interfaces.hpp ****  * ==== This is an autogenerated file.                          ====
   4:./autogen/interfaces.hpp ****  * ==== Any changes to this file will be lost when recompiling. ====
   5:./autogen/interfaces.hpp ****  * =================================================================
   6:./autogen/interfaces.hpp ****  *
   7:./autogen/interfaces.hpp ****  * This file contains base classes that correspond to the interfaces defined in
   8:./autogen/interfaces.hpp ****  * your interface file. The objects you publish should inherit from these
   9:./autogen/interfaces.hpp ****  * interfaces.
  10:./autogen/interfaces.hpp ****  *
  11:./autogen/interfaces.hpp ****  */
  12:./autogen/interfaces.hpp **** #ifndef __FIBRE_INTERFACES_HPP
  13:./autogen/interfaces.hpp **** #define __FIBRE_INTERFACES_HPP
  14:./autogen/interfaces.hpp **** 
  15:./autogen/interfaces.hpp **** #include <tuple>
  16:./autogen/interfaces.hpp **** using float2D = std::pair<float, float>;
  17:./autogen/interfaces.hpp **** struct Iph_ABC_t { float phA; float phB; float phC; };
  18:./autogen/interfaces.hpp **** 
  19:./autogen/interfaces.hpp **** 
  20:./autogen/interfaces.hpp **** #include <fibre/../../protocol.hpp>
  21:./autogen/interfaces.hpp **** 
ARM GAS  /tmp/ccawPiBL.s 			page 108


  22:./autogen/interfaces.hpp **** #pragma GCC push_options
  23:./autogen/interfaces.hpp **** #pragma GCC optimize ("s")
  24:./autogen/interfaces.hpp **** 
  25:./autogen/interfaces.hpp **** 
  26:./autogen/interfaces.hpp **** 
  27:./autogen/interfaces.hpp **** class ODriveIntf {
  28:./autogen/interfaces.hpp **** public:
  29:./autogen/interfaces.hpp ****     class ConfigIntf {
  30:./autogen/interfaces.hpp ****     public:
  31:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_a(T* obj) { return Property<bool>{&
  32:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_a(T* obj, void* ptr) { new (ptr) Pr
  33:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_b(T* obj) { return Property<bool>{&
  34:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_b(T* obj, void* ptr) { new (ptr) Pr
  35:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_uart_c(T* obj) { return Property<bool>{&
  36:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_uart_c(T* obj, void* ptr) { new (ptr) Pr
  37:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_a_baudrate(T* obj) { return Property<uint3
  38:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_a_baudrate(T* obj, void* ptr) { new (ptr) 
  39:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_b_baudrate(T* obj) { return Property<uint3
  40:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_b_baudrate(T* obj, void* ptr) { new (ptr) 
  41:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart_c_baudrate(T* obj) { return Property<uint3
  42:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart_c_baudrate(T* obj, void* ptr) { new (ptr) 
  43:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_can_a(T* obj) { return Property<bool>{&o
  44:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_can_a(T* obj, void* ptr) { new (ptr) Pro
  45:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_i2c_a(T* obj) { return Property<bool>{&o
  46:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_i2c_a(T* obj, void* ptr) { new (ptr) Pro
  47:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_usb_cdc_protocol(T* obj) { return Property<ODri
  48:./autogen/interfaces.hpp ****         template<typename T> static inline void get_usb_cdc_protocol(T* obj, void* ptr) { new (ptr)
  49:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart0_protocol(T* obj) { return Property<ODrive
  50:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart0_protocol(T* obj, void* ptr) { new (ptr) P
  51:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart1_protocol(T* obj) { return Property<ODrive
  52:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart1_protocol(T* obj, void* ptr) { new (ptr) P
  53:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uart2_protocol(T* obj) { return Property<ODrive
  54:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uart2_protocol(T* obj, void* ptr) { new (ptr) P
  55:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_regen_current(T* obj) { return Property<flo
  56:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_regen_current(T* obj, void* ptr) { new (ptr
  57:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_brake_resistance(T* obj) { return Property<floa
  58:./autogen/interfaces.hpp ****         template<typename T> static inline void get_brake_resistance(T* obj, void* ptr) { new (ptr)
  59:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_brake_resistor(T* obj) { return Property
  60:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_brake_resistor(T* obj, void* ptr) { new 
  61:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_undervoltage_trip_level(T* obj) { return
  62:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_undervoltage_trip_level(T* obj, void* pt
  63:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_trip_level(T* obj) { return 
  64:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_trip_level(T* obj, void* ptr
  65:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_enable_dc_bus_overvoltage_ramp(T* obj) { return
  66:./autogen/interfaces.hpp ****         template<typename T> static inline void get_enable_dc_bus_overvoltage_ramp(T* obj, void* pt
  67:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_ramp_start(T* obj) { return 
  68:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_ramp_start(T* obj, void* ptr
  69:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_bus_overvoltage_ramp_end(T* obj) { return Pr
  70:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_bus_overvoltage_ramp_end(T* obj, void* ptr) 
  71:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_max_positive_current(T* obj) { return Proper
  72:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_max_positive_current(T* obj, void* ptr) { ne
  73:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_max_negative_current(T* obj) { return Proper
  74:./autogen/interfaces.hpp ****         template<typename T> static inline void get_dc_max_negative_current(T* obj, void* ptr) { ne
  75:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error_gpio_pin(T* obj) { return Property<uint32
  76:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error_gpio_pin(T* obj, void* ptr) { new (ptr) P
  77:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio3_analog_mapping(T* obj) { return &obj->ana
  78:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio4_analog_mapping(T* obj) { return &obj->ana
ARM GAS  /tmp/ccawPiBL.s 			page 109


  79:./autogen/interfaces.hpp ****     };
  80:./autogen/interfaces.hpp ****     class CanIntf {
  81:./autogen/interfaces.hpp ****     public:
  82:./autogen/interfaces.hpp ****         class ConfigIntf {
  83:./autogen/interfaces.hpp ****         public:
  84:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_baud_rate(T* obj) { return Property<uint32_
  85:./autogen/interfaces.hpp ****             template<typename T> static inline void get_baud_rate(T* obj, void* ptr) { new (ptr) Pr
  86:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_protocol(T* obj) { return Property<ODriveIn
  87:./autogen/interfaces.hpp ****             template<typename T> static inline void get_protocol(T* obj, void* ptr) { new (ptr) Pro
  88:./autogen/interfaces.hpp ****         };
  89:./autogen/interfaces.hpp ****         enum Error {
  90:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
  91:./autogen/interfaces.hpp ****             ERROR_DUPLICATE_CAN_IDS          = 0x00000001,
  92:./autogen/interfaces.hpp ****         };
  93:./autogen/interfaces.hpp ****         enum Protocol {
  94:./autogen/interfaces.hpp ****             PROTOCOL_SIMPLE                  = 0x00000001,
  95:./autogen/interfaces.hpp ****         };
  96:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Can
  97:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
  98:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
  99:./autogen/interfaces.hpp ****     };
 100:./autogen/interfaces.hpp ****     class EndpointIntf {
 101:./autogen/interfaces.hpp ****     public:
 102:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_endpoint(T* obj) { return Property<endpoint_ref
 103:./autogen/interfaces.hpp ****         template<typename T> static inline void get_endpoint(T* obj, void* ptr) { new (ptr) Propert
 104:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_min(T* obj) { return Property<float>{&obj->min}
 105:./autogen/interfaces.hpp ****         template<typename T> static inline void get_min(T* obj, void* ptr) { new (ptr) Property<flo
 106:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max(T* obj) { return Property<float>{&obj->max}
 107:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max(T* obj, void* ptr) { new (ptr) Property<flo
 108:./autogen/interfaces.hpp ****     };
 109:./autogen/interfaces.hpp ****     class AxisIntf {
 110:./autogen/interfaces.hpp ****     public:
 111:./autogen/interfaces.hpp ****         class LockinConfigIntf {
 112:./autogen/interfaces.hpp ****         public:
 113:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current(T* obj) { return Property<float>{&o
 114:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current(T* obj, void* ptr) { new (ptr) Prop
 115:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ramp_time(T* obj) { return Property<float>{
 116:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ramp_time(T* obj, void* ptr) { new (ptr) Pr
 117:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ramp_distance(T* obj) { return Property<flo
 118:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ramp_distance(T* obj, void* ptr) { new (ptr
 119:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_accel(T* obj) { return Property<float>{&obj
 120:./autogen/interfaces.hpp ****             template<typename T> static inline void get_accel(T* obj, void* ptr) { new (ptr) Proper
 121:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel(T* obj) { return Property<float>{&obj->
 122:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel(T* obj, void* ptr) { new (ptr) Property
 123:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_distance(T* obj) { return Property<f
 124:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_distance(T* obj, void* ptr) { new (p
 125:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_vel(T* obj) { return Property<boo
 126:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_vel(T* obj, void* ptr) { new (ptr
 127:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_distance(T* obj) { return Propert
 128:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_distance(T* obj, void* ptr) { new
 129:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_finish_on_enc_idx(T* obj) { return Property
 130:./autogen/interfaces.hpp ****             template<typename T> static inline void get_finish_on_enc_idx(T* obj, void* ptr) { new 
 131:./autogen/interfaces.hpp ****         };
 132:./autogen/interfaces.hpp ****         class CanConfigIntf {
 133:./autogen/interfaces.hpp ****         public:
 134:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_node_id(T* obj) { return Property<uint32_t>
 135:./autogen/interfaces.hpp ****             template<typename T> static inline void get_node_id(T* obj, void* ptr) { new (ptr) Prop
ARM GAS  /tmp/ccawPiBL.s 			page 110


 136:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_is_extended(T* obj) { return Property<bool>
 137:./autogen/interfaces.hpp ****             template<typename T> static inline void get_is_extended(T* obj, void* ptr) { new (ptr) 
 138:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_heartbeat_rate_ms(T* obj) { return Property
 139:./autogen/interfaces.hpp ****             template<typename T> static inline void get_heartbeat_rate_ms(T* obj, void* ptr) { new 
 140:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_rate_ms(T* obj) { return Property<u
 141:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_rate_ms(T* obj, void* ptr) { new (p
 142:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_error_rate_ms(T* obj) { return Proper
 143:./autogen/interfaces.hpp ****             template<typename T> static inline void get_motor_error_rate_ms(T* obj, void* ptr) { ne
 144:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_error_rate_ms(T* obj) { return Prop
 145:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_error_rate_ms(T* obj, void* ptr) { 
 146:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_controller_error_rate_ms(T* obj) { return P
 147:./autogen/interfaces.hpp ****             template<typename T> static inline void get_controller_error_rate_ms(T* obj, void* ptr)
 148:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_error_rate_ms(T* obj) { return P
 149:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sensorless_error_rate_ms(T* obj, void* ptr)
 150:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_count_rate_ms(T* obj) { return Prop
 151:./autogen/interfaces.hpp ****             template<typename T> static inline void get_encoder_count_rate_ms(T* obj, void* ptr) { 
 152:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_iq_rate_ms(T* obj) { return Property<uint32
 153:./autogen/interfaces.hpp ****             template<typename T> static inline void get_iq_rate_ms(T* obj, void* ptr) { new (ptr) P
 154:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_rate_ms(T* obj) { return Propert
 155:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sensorless_rate_ms(T* obj, void* ptr) { new
 156:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bus_vi_rate_ms(T* obj) { return Property<ui
 157:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bus_vi_rate_ms(T* obj, void* ptr) { new (pt
 158:./autogen/interfaces.hpp ****         };
 159:./autogen/interfaces.hpp ****         class ConfigIntf {
 160:./autogen/interfaces.hpp ****         public:
 161:./autogen/interfaces.hpp ****             class CalibrationLockinIntf {
 162:./autogen/interfaces.hpp ****             public:
 163:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_current(T* obj) { return Property<float
 164:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_current(T* obj, void* ptr) { new (ptr) 
 165:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_ramp_time(T* obj) { return Property<flo
 166:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_ramp_time(T* obj, void* ptr) { new (ptr
 167:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_ramp_distance(T* obj) { return Property
 168:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_ramp_distance(T* obj, void* ptr) { new 
 169:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_accel(T* obj) { return Property<float>{
 170:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_accel(T* obj, void* ptr) { new (ptr) Pr
 171:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_vel(T* obj) { return Property<float>{&o
 172:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_vel(T* obj, void* ptr) { new (ptr) Prop
 173:./autogen/interfaces.hpp ****             };
 174:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_motor_calibration(T* obj) { return 
 175:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_motor_calibration(T* obj, void* ptr
 176:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_encoder_index_search(T* obj) { retu
 177:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_encoder_index_search(T* obj, void* 
 178:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_encoder_offset_calibration(T* obj) 
 179:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_encoder_offset_calibration(T* obj, 
 180:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_closed_loop_control(T* obj) { retur
 181:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_closed_loop_control(T* obj, void* p
 182:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_startup_homing(T* obj) { return Property<bo
 183:./autogen/interfaces.hpp ****             template<typename T> static inline void get_startup_homing(T* obj, void* ptr) { new (pt
 184:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_step_dir(T* obj) { return Property<b
 185:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_step_dir(T* obj, void* ptr) { new (p
 186:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_step_dir_always_on(T* obj) { return Propert
 187:./autogen/interfaces.hpp ****             template<typename T> static inline void get_step_dir_always_on(T* obj, void* ptr) { new
 188:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_sensorless_mode(T* obj) { return Pro
 189:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_sensorless_mode(T* obj, void* ptr) {
 190:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_watchdog_timeout(T* obj) { return Property<
 191:./autogen/interfaces.hpp ****             template<typename T> static inline void get_watchdog_timeout(T* obj, void* ptr) { new (
 192:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_watchdog(T* obj) { return Property<b
ARM GAS  /tmp/ccawPiBL.s 			page 111


 193:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_watchdog(T* obj, void* ptr) { new (p
 194:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_step_gpio_pin(T* obj) { return Property<uin
 195:./autogen/interfaces.hpp ****             template<typename T> static inline void get_step_gpio_pin(T* obj, void* ptr) { new (ptr
 196:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dir_gpio_pin(T* obj) { return Property<uint
 197:./autogen/interfaces.hpp ****             template<typename T> static inline void get_dir_gpio_pin(T* obj, void* ptr) { new (ptr)
 198:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calibration_lockin(T* obj) { return &obj->c
 199:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_ramp(T* obj) { return &obj->sens
 200:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_general_lockin(T* obj) { return &obj->gener
 201:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_can(T* obj) { return &obj->can; }
 202:./autogen/interfaces.hpp ****         };
 203:./autogen/interfaces.hpp ****         class TaskTimesIntf {
 204:./autogen/interfaces.hpp ****         public:
 205:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_thermistor_update(T* obj) { return &obj->th
 206:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_encoder_update(T* obj) { return &obj->encod
 207:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sensorless_estimator_update(T* obj) { retur
 208:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_endstop_update(T* obj) { return &obj->endst
 209:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_can_heartbeat(T* obj) { return &obj->can_he
 210:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_controller_update(T* obj) { return &obj->co
 211:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_open_loop_controller_update(T* obj) { retur
 212:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_estimator_update(T* obj) { return &obj
 213:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_update(T* obj) { return &obj->motor_u
 214:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_controller_update(T* obj) { return 
 215:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dc_calib(T* obj) { return &obj->dc_calib; }
 216:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_sense(T* obj) { return &obj->curren
 217:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pwm_update(T* obj) { return &obj->pwm_updat
 218:./autogen/interfaces.hpp ****         };
 219:./autogen/interfaces.hpp ****         enum Error {
 220:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 221:./autogen/interfaces.hpp ****             ERROR_INVALID_STATE              = 0x00000001,
 222:./autogen/interfaces.hpp ****             ERROR_MOTOR_FAILED               = 0x00000040,
 223:./autogen/interfaces.hpp ****             ERROR_SENSORLESS_ESTIMATOR_FAILED = 0x00000080,
 224:./autogen/interfaces.hpp ****             ERROR_ENCODER_FAILED             = 0x00000100,
 225:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_FAILED          = 0x00000200,
 226:./autogen/interfaces.hpp ****             ERROR_WATCHDOG_TIMER_EXPIRED     = 0x00000800,
 227:./autogen/interfaces.hpp ****             ERROR_MIN_ENDSTOP_PRESSED        = 0x00001000,
 228:./autogen/interfaces.hpp ****             ERROR_MAX_ENDSTOP_PRESSED        = 0x00002000,
 229:./autogen/interfaces.hpp ****             ERROR_ESTOP_REQUESTED            = 0x00004000,
 230:./autogen/interfaces.hpp ****             ERROR_HOMING_WITHOUT_ENDSTOP     = 0x00020000,
 231:./autogen/interfaces.hpp ****             ERROR_OVER_TEMP                  = 0x00040000,
 232:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_POSITION           = 0x00080000,
 233:./autogen/interfaces.hpp ****         };
 234:./autogen/interfaces.hpp ****         enum AxisState {
 235:./autogen/interfaces.hpp ****             AXIS_STATE_UNDEFINED             = 0,
 236:./autogen/interfaces.hpp ****             AXIS_STATE_IDLE                  = 1,
 237:./autogen/interfaces.hpp ****             AXIS_STATE_STARTUP_SEQUENCE      = 2,
 238:./autogen/interfaces.hpp ****             AXIS_STATE_FULL_CALIBRATION_SEQUENCE = 3,
 239:./autogen/interfaces.hpp ****             AXIS_STATE_MOTOR_CALIBRATION     = 4,
 240:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_INDEX_SEARCH  = 6,
 241:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_OFFSET_CALIBRATION = 7,
 242:./autogen/interfaces.hpp ****             AXIS_STATE_CLOSED_LOOP_CONTROL   = 8,
 243:./autogen/interfaces.hpp ****             AXIS_STATE_LOCKIN_SPIN           = 9,
 244:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_DIR_FIND      = 10,
 245:./autogen/interfaces.hpp ****             AXIS_STATE_HOMING                = 11,
 246:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_HALL_POLARITY_CALIBRATION = 12,
 247:./autogen/interfaces.hpp ****             AXIS_STATE_ENCODER_HALL_PHASE_CALIBRATION = 13,
 248:./autogen/interfaces.hpp ****         };
 249:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Axi
ARM GAS  /tmp/ccawPiBL.s 			page 112


 250:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 251:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_step_dir_active(T* obj) { return Property<const
 252:./autogen/interfaces.hpp ****         template<typename T> static inline void get_step_dir_active(T* obj, void* ptr) { new (ptr) 
 253:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_drv_fault(T* obj) { return Property<const 
 254:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_drv_fault(T* obj, void* ptr) { new (ptr) P
 255:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_steps(T* obj) { return Property<const int64_t>{
 256:./autogen/interfaces.hpp ****         template<typename T> static inline void get_steps(T* obj, void* ptr) { new (ptr) Property<c
 257:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_state(T* obj) { return Property<const O
 258:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_state(T* obj, void* ptr) { new (ptr) Pr
 259:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_requested_state(T* obj) { return Property<ODriv
 260:./autogen/interfaces.hpp ****         template<typename T> static inline void get_requested_state(T* obj, void* ptr) { new (ptr) 
 261:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_homed(T* obj) { return Property<bool>{&obj->
 262:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_homed(T* obj, void* ptr) { new (ptr) Propert
 263:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 264:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_motor(T* obj) { return &obj->motor_; }
 265:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_controller(T* obj) { return &obj->controller_; 
 266:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_encoder(T* obj) { return &obj->encoder_; }
 267:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_acim_estimator(T* obj) { return &obj->acim_esti
 268:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_sensorless_estimator(T* obj) { return &obj->sen
 269:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_trap_traj(T* obj) { return &obj->trap_traj_; }
 270:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_min_endstop(T* obj) { return &obj->min_endstop_
 271:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_endstop(T* obj) { return &obj->max_endstop_
 272:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_mechanical_brake(T* obj) { return &obj->mechani
 273:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_task_times(T* obj) { return &obj->task_times_; 
 274:./autogen/interfaces.hpp ****         virtual void watchdog_feed() = 0;
 275:./autogen/interfaces.hpp ****     };
 276:./autogen/interfaces.hpp ****     class ThermistorCurrentLimiterIntf {
 277:./autogen/interfaces.hpp ****     public:
 278:./autogen/interfaces.hpp ****     };
 279:./autogen/interfaces.hpp ****     class OnboardThermistorCurrentLimiterIntf {
 280:./autogen/interfaces.hpp ****     public:
 281:./autogen/interfaces.hpp ****         class ConfigIntf {
 282:./autogen/interfaces.hpp ****         public:
 283:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_lower(T* obj) { return Property<
 284:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_lower(T* obj, void* ptr) { new (
 285:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_upper(T* obj) { return Property<
 286:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_upper(T* obj, void* ptr) { new (
 287:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{&ob
 288:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
 289:./autogen/interfaces.hpp ****         };
 290:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_temperature(T* obj) { return Property<const flo
 291:./autogen/interfaces.hpp ****         template<typename T> static inline void get_temperature(T* obj, void* ptr) { new (ptr) Prop
 292:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 293:./autogen/interfaces.hpp ****     };
 294:./autogen/interfaces.hpp ****     class OffboardThermistorCurrentLimiterIntf {
 295:./autogen/interfaces.hpp ****     public:
 296:./autogen/interfaces.hpp ****         class ConfigIntf {
 297:./autogen/interfaces.hpp ****         public:
 298:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gpio_pin(T* obj) { return Property<uint16_t
 299:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gpio_pin(T* obj, void* ptr) { new (ptr) Pro
 300:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_0(T* obj) { return Propert
 301:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_0(T* obj, void* ptr) { new
 302:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_1(T* obj) { return Propert
 303:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_1(T* obj, void* ptr) { new
 304:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_2(T* obj) { return Propert
 305:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_2(T* obj, void* ptr) { new
 306:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_poly_coefficient_3(T* obj) { return Propert
ARM GAS  /tmp/ccawPiBL.s 			page 113


 307:./autogen/interfaces.hpp ****             template<typename T> static inline void get_poly_coefficient_3(T* obj, void* ptr) { new
 308:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_lower(T* obj) { return Property<
 309:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_lower(T* obj, void* ptr) { new (
 310:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_temp_limit_upper(T* obj) { return Property<
 311:./autogen/interfaces.hpp ****             template<typename T> static inline void get_temp_limit_upper(T* obj, void* ptr) { new (
 312:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{&ob
 313:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
 314:./autogen/interfaces.hpp ****         };
 315:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_temperature(T* obj) { return Property<const flo
 316:./autogen/interfaces.hpp ****         template<typename T> static inline void get_temperature(T* obj, void* ptr) { new (ptr) Prop
 317:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 318:./autogen/interfaces.hpp ****     };
 319:./autogen/interfaces.hpp ****     class MotorIntf {
 320:./autogen/interfaces.hpp ****     public:
 321:./autogen/interfaces.hpp ****         class CurrentControlIntf {
 322:./autogen/interfaces.hpp ****         public:
 323:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_p_gain(T* obj) { return Property<const floa
 324:./autogen/interfaces.hpp ****             template<typename T> static inline void get_p_gain(T* obj, void* ptr) { new (ptr) Prope
 325:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_i_gain(T* obj) { return Property<const floa
 326:./autogen/interfaces.hpp ****             template<typename T> static inline void get_i_gain(T* obj, void* ptr) { new (ptr) Prope
 327:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_measured_report_filter_k(T* obj) { return
 328:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_measured_report_filter_k(T* obj, void* pt
 329:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Id_setpoint(T* obj) { return Property<const
 330:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Id_setpoint(T* obj, void* ptr) { new (ptr) 
 331:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Iq_setpoint(T* obj) { return Property<const
 332:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Iq_setpoint(T* obj, void* ptr) { new (ptr) 
 333:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Vd_setpoint(T* obj) { return Property<const
 334:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Vd_setpoint(T* obj, void* ptr) { new (ptr) 
 335:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Vq_setpoint(T* obj) { return Property<const
 336:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Vq_setpoint(T* obj, void* ptr) { new (ptr) 
 337:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase(T* obj) { return Property<const float
 338:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Proper
 339:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_vel(T* obj) { return Property<const f
 340:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_vel(T* obj, void* ptr) { new (ptr) Pr
 341:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Ialpha_measured(T* obj) { return Property<c
 342:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Ialpha_measured(T* obj, void* ptr) { new (p
 343:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Ibeta_measured(T* obj) { return Property<co
 344:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Ibeta_measured(T* obj, void* ptr) { new (pt
 345:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Id_measured(T* obj) { return Property<const
 346:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Id_measured(T* obj, void* ptr) { new (ptr) 
 347:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_Iq_measured(T* obj) { return Property<const
 348:./autogen/interfaces.hpp ****             template<typename T> static inline void get_Iq_measured(T* obj, void* ptr) { new (ptr) 
 349:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_power(T* obj) { return Property<const float
 350:./autogen/interfaces.hpp ****             template<typename T> static inline void get_power(T* obj, void* ptr) { new (ptr) Proper
 351:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_v_current_control_integral_d(T* obj) { retu
 352:./autogen/interfaces.hpp ****             template<typename T> static inline void get_v_current_control_integral_d(T* obj, void* 
 353:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_v_current_control_integral_q(T* obj) { retu
 354:./autogen/interfaces.hpp ****             template<typename T> static inline void get_v_current_control_integral_q(T* obj, void* 
 355:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_final_v_alpha(T* obj) { return Property<con
 356:./autogen/interfaces.hpp ****             template<typename T> static inline void get_final_v_alpha(T* obj, void* ptr) { new (ptr
 357:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_final_v_beta(T* obj) { return Property<cons
 358:./autogen/interfaces.hpp ****             template<typename T> static inline void get_final_v_beta(T* obj, void* ptr) { new (ptr)
 359:./autogen/interfaces.hpp ****         };
 360:./autogen/interfaces.hpp ****         class ConfigIntf {
 361:./autogen/interfaces.hpp ****         public:
 362:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bo
 363:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (pt
ARM GAS  /tmp/ccawPiBL.s 			page 114


 364:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pole_pairs(T* obj) { return Property<int32_
 365:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pole_pairs(T* obj, void* ptr) { new (ptr) P
 366:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calibration_current(T* obj) { return Proper
 367:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calibration_current(T* obj, void* ptr) { ne
 368:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_resistance_calib_max_voltage(T* obj) { retu
 369:./autogen/interfaces.hpp ****             template<typename T> static inline void get_resistance_calib_max_voltage(T* obj, void* 
 370:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_inductance(T* obj) { return Property<
 371:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_inductance(T* obj, void* ptr) { new (
 372:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_resistance(T* obj) { return Property<
 373:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_resistance(T* obj, void* ptr) { new (
 374:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_constant(T* obj) { return Property<f
 375:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_constant(T* obj, void* ptr) { new (p
 376:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_motor_type(T* obj) { return Property<ODrive
 377:./autogen/interfaces.hpp ****             template<typename T> static inline void get_motor_type(T* obj, void* ptr) { new (ptr) P
 378:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_lim(T* obj) { return Property<float
 379:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_lim(T* obj, void* ptr) { new (ptr) 
 380:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_lim_margin(T* obj) { return Propert
 381:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_lim_margin(T* obj, void* ptr) { new
 382:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_lim(T* obj) { return Property<float>
 383:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_lim(T* obj, void* ptr) { new (ptr) P
 384:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inverter_temp_limit_lower(T* obj) { return 
 385:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inverter_temp_limit_lower(T* obj, void* ptr
 386:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inverter_temp_limit_upper(T* obj) { return 
 387:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inverter_temp_limit_upper(T* obj, void* ptr
 388:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_requested_current_range(T* obj) { return Pr
 389:./autogen/interfaces.hpp ****             template<typename T> static inline void get_requested_current_range(T* obj, void* ptr) 
 390:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_current_control_bandwidth(T* obj) { return 
 391:./autogen/interfaces.hpp ****             template<typename T> static inline void get_current_control_bandwidth(T* obj, void* ptr
 392:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_gain_min_flux(T* obj) { return Propert
 393:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_gain_min_flux(T* obj, void* ptr) { new
 394:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_min_Id(T* obj) { return Prope
 395:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_min_Id(T* obj, void* ptr) { n
 396:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_enable(T* obj) { return Prope
 397:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_enable(T* obj, void* ptr) { n
 398:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_attack_gain(T* obj) { return 
 399:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_attack_gain(T* obj, void* ptr
 400:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_acim_autoflux_decay_gain(T* obj) { return P
 401:./autogen/interfaces.hpp ****             template<typename T> static inline void get_acim_autoflux_decay_gain(T* obj, void* ptr)
 402:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_R_wL_FF_enable(T* obj) { return Property<bo
 403:./autogen/interfaces.hpp ****             template<typename T> static inline void get_R_wL_FF_enable(T* obj, void* ptr) { new (pt
 404:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bEMF_FF_enable(T* obj) { return Property<bo
 405:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bEMF_FF_enable(T* obj, void* ptr) { new (pt
 406:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_bus_hard_min(T* obj) { return Property<fl
 407:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_bus_hard_min(T* obj, void* ptr) { new (pt
 408:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_bus_hard_max(T* obj) { return Property<fl
 409:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_bus_hard_max(T* obj, void* ptr) { new (pt
 410:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_I_leak_max(T* obj) { return Property<float>
 411:./autogen/interfaces.hpp ****             template<typename T> static inline void get_I_leak_max(T* obj, void* ptr) { new (ptr) P
 412:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_dc_calib_tau(T* obj) { return Property<floa
 413:./autogen/interfaces.hpp ****             template<typename T> static inline void get_dc_calib_tau(T* obj, void* ptr) { new (ptr)
 414:./autogen/interfaces.hpp ****         };
 415:./autogen/interfaces.hpp ****         enum Error {
 416:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 417:./autogen/interfaces.hpp ****             ERROR_PHASE_RESISTANCE_OUT_OF_RANGE = 0x00000001,
 418:./autogen/interfaces.hpp ****             ERROR_PHASE_INDUCTANCE_OUT_OF_RANGE = 0x00000002,
 419:./autogen/interfaces.hpp ****             ERROR_DRV_FAULT                  = 0x00000008,
 420:./autogen/interfaces.hpp ****             ERROR_CONTROL_DEADLINE_MISSED    = 0x00000010,
ARM GAS  /tmp/ccawPiBL.s 			page 115


 421:./autogen/interfaces.hpp ****             ERROR_MODULATION_MAGNITUDE       = 0x00000080,
 422:./autogen/interfaces.hpp ****             ERROR_CURRENT_SENSE_SATURATION   = 0x00000400,
 423:./autogen/interfaces.hpp ****             ERROR_CURRENT_LIMIT_VIOLATION    = 0x00001000,
 424:./autogen/interfaces.hpp ****             ERROR_MODULATION_IS_NAN          = 0x00010000,
 425:./autogen/interfaces.hpp ****             ERROR_MOTOR_THERMISTOR_OVER_TEMP = 0x00020000,
 426:./autogen/interfaces.hpp ****             ERROR_FET_THERMISTOR_OVER_TEMP   = 0x00040000,
 427:./autogen/interfaces.hpp ****             ERROR_TIMER_UPDATE_MISSED        = 0x00080000,
 428:./autogen/interfaces.hpp ****             ERROR_CURRENT_MEASUREMENT_UNAVAILABLE = 0x00100000,
 429:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_FAILED          = 0x00200000,
 430:./autogen/interfaces.hpp ****             ERROR_I_BUS_OUT_OF_RANGE         = 0x00400000,
 431:./autogen/interfaces.hpp ****             ERROR_BRAKE_RESISTOR_DISARMED    = 0x00800000,
 432:./autogen/interfaces.hpp ****             ERROR_SYSTEM_LEVEL               = 0x01000000,
 433:./autogen/interfaces.hpp ****             ERROR_BAD_TIMING                 = 0x02000000,
 434:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_PHASE_ESTIMATE     = 0x04000000,
 435:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_PHASE_VEL          = 0x08000000,
 436:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_TORQUE             = 0x10000000,
 437:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_COMMAND    = 0x20000000,
 438:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x40000000,
 439:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_VBUS_VOLTAGE       = 0x80000000,
 440:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_VOLTAGE_COMMAND    = 0x100000000,
 441:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_GAINS              = 0x200000000,
 442:./autogen/interfaces.hpp ****             ERROR_CONTROLLER_INITIALIZING    = 0x400000000,
 443:./autogen/interfaces.hpp ****             ERROR_UNBALANCED_PHASES          = 0x800000000,
 444:./autogen/interfaces.hpp ****         };
 445:./autogen/interfaces.hpp ****         enum MotorType {
 446:./autogen/interfaces.hpp ****             MOTOR_TYPE_HIGH_CURRENT          = 0,
 447:./autogen/interfaces.hpp ****             MOTOR_TYPE_GIMBAL                = 2,
 448:./autogen/interfaces.hpp ****             MOTOR_TYPE_ACIM                  = 3,
 449:./autogen/interfaces.hpp ****         };
 450:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_error_time(T* obj) { return Property<float
 451:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_error_time(T* obj, void* ptr) { new (ptr) 
 452:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Mot
 453:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 454:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_armed(T* obj) { return Property<const bool>{
 455:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_armed(T* obj, void* ptr) { new (ptr) Propert
 456:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_calibrated(T* obj) { return Property<const b
 457:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_calibrated(T* obj, void* ptr) { new (ptr) Pr
 458:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phA(T* obj) { return Property<cons
 459:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phA(T* obj, void* ptr) { new (ptr)
 460:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phB(T* obj) { return Property<cons
 461:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phB(T* obj, void* ptr) { new (ptr)
 462:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_meas_phC(T* obj) { return Property<cons
 463:./autogen/interfaces.hpp ****         template<typename T> static inline void get_current_meas_phC(T* obj, void* ptr) { new (ptr)
 464:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phA(T* obj) { return Property<float>{&
 465:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phA(T* obj, void* ptr) { new (ptr) Pro
 466:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phB(T* obj) { return Property<float>{&
 467:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phB(T* obj, void* ptr) { new (ptr) Pro
 468:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_DC_calib_phC(T* obj) { return Property<float>{&
 469:./autogen/interfaces.hpp ****         template<typename T> static inline void get_DC_calib_phC(T* obj, void* ptr) { new (ptr) Pro
 470:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_I_bus(T* obj) { return Property<const float>{&o
 471:./autogen/interfaces.hpp ****         template<typename T> static inline void get_I_bus(T* obj, void* ptr) { new (ptr) Property<c
 472:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_current_rev_gain(T* obj) { return Propert
 473:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_current_rev_gain(T* obj, void* ptr) { new
 474:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_effective_current_lim(T* obj) { return Property
 475:./autogen/interfaces.hpp ****         template<typename T> static inline void get_effective_current_lim(T* obj, void* ptr) { new 
 476:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_allowed_current(T* obj) { return Property<c
 477:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_allowed_current(T* obj, void* ptr) { new (p
ARM GAS  /tmp/ccawPiBL.s 			page 116


 478:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_dc_calib(T* obj) { return Property<const fl
 479:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_dc_calib(T* obj, void* ptr) { new (ptr) Pro
 480:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_fet_thermistor(T* obj) { return &obj->fet_therm
 481:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_motor_thermistor(T* obj) { return &obj->motor_t
 482:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_current_control(T* obj) { return &obj->current_
 483:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_n_evt_current_measurement(T* obj) { return Prop
 484:./autogen/interfaces.hpp ****         template<typename T> static inline void get_n_evt_current_measurement(T* obj, void* ptr) { 
 485:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_n_evt_pwm_update(T* obj) { return Property<cons
 486:./autogen/interfaces.hpp ****         template<typename T> static inline void get_n_evt_pwm_update(T* obj, void* ptr) { new (ptr)
 487:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 488:./autogen/interfaces.hpp ****     };
 489:./autogen/interfaces.hpp ****     class OscilloscopeIntf {
 490:./autogen/interfaces.hpp ****     public:
 491:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_size(T* obj) { return Property<const uint32_t>{
 492:./autogen/interfaces.hpp ****         template<typename T> static inline void get_size(T* obj, void* ptr) { new (ptr) Property<co
 493:./autogen/interfaces.hpp ****         virtual float get_val(uint32_t index) = 0;
 494:./autogen/interfaces.hpp ****         uint32_t get_val_in_index_; // for internal use by Fibre
 495:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_val_in_index_(T* obj) { return Property<uint32_t>{
 496:./autogen/interfaces.hpp ****         template<typename T> static void get_get_val_in_index_(T* obj, void* ptr) { new (ptr) Prope
 497:./autogen/interfaces.hpp ****         float get_val_out_val_; // for internal use by Fibre
 498:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_val_out_val_(T* obj) { return Property<const float
 499:./autogen/interfaces.hpp ****         template<typename T> static void get_get_val_out_val_(T* obj, void* ptr) { new (ptr) Proper
 500:./autogen/interfaces.hpp ****     };
 501:./autogen/interfaces.hpp ****     class AcimEstimatorIntf {
 502:./autogen/interfaces.hpp ****     public:
 503:./autogen/interfaces.hpp ****         class ConfigIntf {
 504:./autogen/interfaces.hpp ****         public:
 505:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_slip_velocity(T* obj) { return Property<flo
 506:./autogen/interfaces.hpp ****             template<typename T> static inline void get_slip_velocity(T* obj, void* ptr) { new (ptr
 507:./autogen/interfaces.hpp ****         };
 508:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_rotor_flux(T* obj) { return Property<const floa
 509:./autogen/interfaces.hpp ****         template<typename T> static inline void get_rotor_flux(T* obj, void* ptr) { new (ptr) Prope
 510:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_slip_vel(T* obj) { return Property<const float>
 511:./autogen/interfaces.hpp ****         template<typename T> static inline void get_slip_vel(T* obj, void* ptr) { new (ptr) Propert
 512:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_offset(T* obj) { return Property<const fl
 513:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_offset(T* obj, void* ptr) { new (ptr) Pro
 514:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stator_phase_vel(T* obj) { return Property<cons
 515:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stator_phase_vel(T* obj, void* ptr) { new (ptr)
 516:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stator_phase(T* obj) { return Property<const fl
 517:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stator_phase(T* obj, void* ptr) { new (ptr) Pro
 518:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 519:./autogen/interfaces.hpp ****     };
 520:./autogen/interfaces.hpp ****     class ControllerIntf {
 521:./autogen/interfaces.hpp ****     public:
 522:./autogen/interfaces.hpp ****         class ConfigIntf {
 523:./autogen/interfaces.hpp ****         public:
 524:./autogen/interfaces.hpp ****             class AnticoggingIntf {
 525:./autogen/interfaces.hpp ****             public:
 526:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_index(T* obj) { return Property<const u
 527:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_index(T* obj, void* ptr) { new (ptr) Pr
 528:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_pre_calibrated(T* obj) { return Propert
 529:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new
 530:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_anticogging(T* obj) { return Prop
 531:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_anticogging(T* obj, void* ptr) { 
 532:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_pos_threshold(T* obj) { return Pr
 533:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_pos_threshold(T* obj, void* ptr) 
 534:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_calib_vel_threshold(T* obj) { return Pr
ARM GAS  /tmp/ccawPiBL.s 			page 117


 535:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_calib_vel_threshold(T* obj, void* ptr) 
 536:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_cogging_ratio(T* obj) { return Property
 537:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_cogging_ratio(T* obj, void* ptr) { new 
 538:./autogen/interfaces.hpp ****                 template<typename T> static inline auto get_anticogging_enabled(T* obj) { return Pr
 539:./autogen/interfaces.hpp ****                 template<typename T> static inline void get_anticogging_enabled(T* obj, void* ptr) 
 540:./autogen/interfaces.hpp ****             };
 541:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gain_scheduling_width(T* obj) { return Prop
 542:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gain_scheduling_width(T* obj, void* ptr) { 
 543:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_vel_limit(T* obj) { return Property<
 544:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_vel_limit(T* obj, void* ptr) { new (
 545:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_torque_mode_vel_limit(T* obj) { retu
 546:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_torque_mode_vel_limit(T* obj, void* 
 547:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_gain_scheduling(T* obj) { return Pro
 548:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_gain_scheduling(T* obj, void* ptr) {
 549:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_overspeed_error(T* obj) { return Pro
 550:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_overspeed_error(T* obj, void* ptr) {
 551:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_control_mode(T* obj) { return Property<ODri
 552:./autogen/interfaces.hpp ****             template<typename T> static inline void get_control_mode(T* obj, void* ptr) { new (ptr)
 553:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_input_mode(T* obj) { return Property<ODrive
 554:./autogen/interfaces.hpp ****             template<typename T> static inline void get_input_mode(T* obj, void* ptr) { new (ptr) P
 555:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pos_gain(T* obj) { return Property<float>{&
 556:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pos_gain(T* obj, void* ptr) { new (ptr) Pro
 557:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_gain(T* obj) { return Property<float>{&
 558:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_gain(T* obj, void* ptr) { new (ptr) Pro
 559:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_integrator_gain(T* obj) { return Proper
 560:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_integrator_gain(T* obj, void* ptr) { ne
 561:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_integrator_limit(T* obj) { return Prope
 562:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_integrator_limit(T* obj, void* ptr) { n
 563:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit(T* obj) { return Property<float>{
 564:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit(T* obj, void* ptr) { new (ptr) Pr
 565:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit_tolerance(T* obj) { return Proper
 566:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit_tolerance(T* obj, void* ptr) { ne
 567:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_ramp_rate(T* obj) { return Property<flo
 568:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_ramp_rate(T* obj, void* ptr) { new (ptr
 569:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_ramp_rate(T* obj) { return Property<
 570:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_ramp_rate(T* obj, void* ptr) { new (
 571:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_circular_setpoints(T* obj) { return Propert
 572:./autogen/interfaces.hpp ****             template<typename T> static inline void get_circular_setpoints(T* obj, void* ptr) { new
 573:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_circular_setpoint_range(T* obj) { return Pr
 574:./autogen/interfaces.hpp ****             template<typename T> static inline void get_circular_setpoint_range(T* obj, void* ptr) 
 575:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_steps_per_circular_range(T* obj) { return P
 576:./autogen/interfaces.hpp ****             template<typename T> static inline void get_steps_per_circular_range(T* obj, void* ptr)
 577:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_homing_speed(T* obj) { return Property<floa
 578:./autogen/interfaces.hpp ****             template<typename T> static inline void get_homing_speed(T* obj, void* ptr) { new (ptr)
 579:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_inertia(T* obj) { return Property<float>{&o
 580:./autogen/interfaces.hpp ****             template<typename T> static inline void get_inertia(T* obj, void* ptr) { new (ptr) Prop
 581:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_axis_to_mirror(T* obj) { return Property<ui
 582:./autogen/interfaces.hpp ****             template<typename T> static inline void get_axis_to_mirror(T* obj, void* ptr) { new (pt
 583:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mirror_ratio(T* obj) { return Property<floa
 584:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mirror_ratio(T* obj, void* ptr) { new (ptr)
 585:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_mirror_ratio(T* obj) { return Proper
 586:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_mirror_ratio(T* obj, void* ptr) { ne
 587:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_load_encoder_axis(T* obj) { return Property
 588:./autogen/interfaces.hpp ****             template<typename T> static inline void get_load_encoder_axis(T* obj, void* ptr) { new 
 589:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_input_filter_bandwidth(T* obj) { return Pro
 590:./autogen/interfaces.hpp ****             template<typename T> static inline void get_input_filter_bandwidth(T* obj, void* ptr) {
 591:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_anticogging(T* obj) { return &obj->anticogg
ARM GAS  /tmp/ccawPiBL.s 			page 118


 592:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mechanical_power_bandwidth(T* obj) { return
 593:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mechanical_power_bandwidth(T* obj, void* pt
 594:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_electrical_power_bandwidth(T* obj) { return
 595:./autogen/interfaces.hpp ****             template<typename T> static inline void get_electrical_power_bandwidth(T* obj, void* pt
 596:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_spinout_mechanical_power_threshold(T* obj) 
 597:./autogen/interfaces.hpp ****             template<typename T> static inline void get_spinout_mechanical_power_threshold(T* obj, 
 598:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_spinout_electrical_power_threshold(T* obj) 
 599:./autogen/interfaces.hpp ****             template<typename T> static inline void get_spinout_electrical_power_threshold(T* obj, 
 600:./autogen/interfaces.hpp ****         };
 601:./autogen/interfaces.hpp ****         class AutotuningIntf {
 602:./autogen/interfaces.hpp ****         public:
 603:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_frequency(T* obj) { return Property<float>{
 604:./autogen/interfaces.hpp ****             template<typename T> static inline void get_frequency(T* obj, void* ptr) { new (ptr) Pr
 605:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pos_amplitude(T* obj) { return Property<flo
 606:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pos_amplitude(T* obj, void* ptr) { new (ptr
 607:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_amplitude(T* obj) { return Property<flo
 608:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_amplitude(T* obj, void* ptr) { new (ptr
 609:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_torque_amplitude(T* obj) { return Property<
 610:./autogen/interfaces.hpp ****             template<typename T> static inline void get_torque_amplitude(T* obj, void* ptr) { new (
 611:./autogen/interfaces.hpp ****         };
 612:./autogen/interfaces.hpp ****         enum Error {
 613:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 614:./autogen/interfaces.hpp ****             ERROR_OVERSPEED                  = 0x00000001,
 615:./autogen/interfaces.hpp ****             ERROR_INVALID_INPUT_MODE         = 0x00000002,
 616:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000004,
 617:./autogen/interfaces.hpp ****             ERROR_INVALID_MIRROR_AXIS        = 0x00000008,
 618:./autogen/interfaces.hpp ****             ERROR_INVALID_LOAD_ENCODER       = 0x00000010,
 619:./autogen/interfaces.hpp ****             ERROR_INVALID_ESTIMATE           = 0x00000020,
 620:./autogen/interfaces.hpp ****             ERROR_INVALID_CIRCULAR_RANGE     = 0x00000040,
 621:./autogen/interfaces.hpp ****             ERROR_SPINOUT_DETECTED           = 0x00000080,
 622:./autogen/interfaces.hpp ****         };
 623:./autogen/interfaces.hpp ****         enum ControlMode {
 624:./autogen/interfaces.hpp ****             CONTROL_MODE_VOLTAGE_CONTROL     = 0,
 625:./autogen/interfaces.hpp ****             CONTROL_MODE_TORQUE_CONTROL      = 1,
 626:./autogen/interfaces.hpp ****             CONTROL_MODE_VELOCITY_CONTROL    = 2,
 627:./autogen/interfaces.hpp ****             CONTROL_MODE_POSITION_CONTROL    = 3,
 628:./autogen/interfaces.hpp ****         };
 629:./autogen/interfaces.hpp ****         enum InputMode {
 630:./autogen/interfaces.hpp ****             INPUT_MODE_INACTIVE              = 0,
 631:./autogen/interfaces.hpp ****             INPUT_MODE_PASSTHROUGH           = 1,
 632:./autogen/interfaces.hpp ****             INPUT_MODE_VEL_RAMP              = 2,
 633:./autogen/interfaces.hpp ****             INPUT_MODE_POS_FILTER            = 3,
 634:./autogen/interfaces.hpp ****             INPUT_MODE_MIX_CHANNELS          = 4,
 635:./autogen/interfaces.hpp ****             INPUT_MODE_TRAP_TRAJ             = 5,
 636:./autogen/interfaces.hpp ****             INPUT_MODE_TORQUE_RAMP           = 6,
 637:./autogen/interfaces.hpp ****             INPUT_MODE_MIRROR                = 7,
 638:./autogen/interfaces.hpp ****             INPUT_MODE_TUNING                = 8,
 639:./autogen/interfaces.hpp ****         };
 640:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Con
 641:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 642:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_last_error_time(T* obj) { return Property<float
 643:./autogen/interfaces.hpp ****         template<typename T> static inline void get_last_error_time(T* obj, void* ptr) { new (ptr) 
 644:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_pos(T* obj) { return Property<float>{obj,
 645:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_pos(T* obj, void* ptr) { new (ptr) Proper
 646:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_vel(T* obj) { return Property<float>{&obj
 647:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_vel(T* obj, void* ptr) { new (ptr) Proper
 648:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_input_torque(T* obj) { return Property<float>{&
ARM GAS  /tmp/ccawPiBL.s 			page 119


 649:./autogen/interfaces.hpp ****         template<typename T> static inline void get_input_torque(T* obj, void* ptr) { new (ptr) Pro
 650:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_setpoint(T* obj) { return Property<const fl
 651:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_setpoint(T* obj, void* ptr) { new (ptr) Pro
 652:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_setpoint(T* obj) { return Property<const fl
 653:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_setpoint(T* obj, void* ptr) { new (ptr) Pro
 654:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_torque_setpoint(T* obj) { return Property<const
 655:./autogen/interfaces.hpp ****         template<typename T> static inline void get_torque_setpoint(T* obj, void* ptr) { new (ptr) 
 656:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_trajectory_done(T* obj) { return Property<const
 657:./autogen/interfaces.hpp ****         template<typename T> static inline void get_trajectory_done(T* obj, void* ptr) { new (ptr) 
 658:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_integrator_torque(T* obj) { return Property
 659:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_integrator_torque(T* obj, void* ptr) { new 
 660:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_anticogging_valid(T* obj) { return Property<boo
 661:./autogen/interfaces.hpp ****         template<typename T> static inline void get_anticogging_valid(T* obj, void* ptr) { new (ptr
 662:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_autotuning_phase(T* obj) { return Property<floa
 663:./autogen/interfaces.hpp ****         template<typename T> static inline void get_autotuning_phase(T* obj, void* ptr) { new (ptr)
 664:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 665:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_autotuning(T* obj) { return &obj->autotuning_; 
 666:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_mechanical_power(T* obj) { return Property<cons
 667:./autogen/interfaces.hpp ****         template<typename T> static inline void get_mechanical_power(T* obj, void* ptr) { new (ptr)
 668:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_electrical_power(T* obj) { return Property<cons
 669:./autogen/interfaces.hpp ****         template<typename T> static inline void get_electrical_power(T* obj, void* ptr) { new (ptr)
 670:./autogen/interfaces.hpp ****         virtual void move_incremental(float displacement, bool from_input_pos) = 0;
 671:./autogen/interfaces.hpp ****         virtual void start_anticogging_calibration() = 0;
 672:./autogen/interfaces.hpp ****         virtual float remove_anticogging_bias() = 0;
 673:./autogen/interfaces.hpp ****         virtual float get_anticogging_value(uint32_t index) = 0;
 674:./autogen/interfaces.hpp ****         float move_incremental_in_displacement_; // for internal use by Fibre
 675:./autogen/interfaces.hpp ****         template<typename T> static auto get_move_incremental_in_displacement_(T* obj) { return Pro
 676:./autogen/interfaces.hpp ****         template<typename T> static void get_move_incremental_in_displacement_(T* obj, void* ptr) {
 677:./autogen/interfaces.hpp ****         bool move_incremental_in_from_input_pos_; // for internal use by Fibre
 678:./autogen/interfaces.hpp ****         template<typename T> static auto get_move_incremental_in_from_input_pos_(T* obj) { return P
 679:./autogen/interfaces.hpp ****         template<typename T> static void get_move_incremental_in_from_input_pos_(T* obj, void* ptr)
 680:./autogen/interfaces.hpp ****         float remove_anticogging_bias_out_val_; // for internal use by Fibre
 681:./autogen/interfaces.hpp ****         template<typename T> static auto get_remove_anticogging_bias_out_val_(T* obj) { return Prop
 682:./autogen/interfaces.hpp ****         template<typename T> static void get_remove_anticogging_bias_out_val_(T* obj, void* ptr) { 
 683:./autogen/interfaces.hpp ****         uint32_t get_anticogging_value_in_index_; // for internal use by Fibre
 684:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_anticogging_value_in_index_(T* obj) { return Prope
 685:./autogen/interfaces.hpp ****         template<typename T> static void get_get_anticogging_value_in_index_(T* obj, void* ptr) { n
 686:./autogen/interfaces.hpp ****         float get_anticogging_value_out_val_; // for internal use by Fibre
 687:./autogen/interfaces.hpp ****         template<typename T> static auto get_get_anticogging_value_out_val_(T* obj) { return Proper
 688:./autogen/interfaces.hpp ****         template<typename T> static void get_get_anticogging_value_out_val_(T* obj, void* ptr) { ne
 689:./autogen/interfaces.hpp ****     };
 690:./autogen/interfaces.hpp ****     class EncoderIntf {
 691:./autogen/interfaces.hpp ****     public:
 692:./autogen/interfaces.hpp ****         class ConfigIntf {
 693:./autogen/interfaces.hpp ****         public:
 694:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_mode(T* obj) { return Property<ODriveIntf::
 695:./autogen/interfaces.hpp ****             template<typename T> static inline void get_mode(T* obj, void* ptr) { new (ptr) Propert
 696:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_use_index(T* obj) { return Property<bool>{o
 697:./autogen/interfaces.hpp ****             template<typename T> static inline void get_use_index(T* obj, void* ptr) { new (ptr) Pr
 698:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_index_offset(T* obj) { return Property<floa
 699:./autogen/interfaces.hpp ****             template<typename T> static inline void get_index_offset(T* obj, void* ptr) { new (ptr)
 700:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_use_index_offset(T* obj) { return Property<
 701:./autogen/interfaces.hpp ****             template<typename T> static inline void get_use_index_offset(T* obj, void* ptr) { new (
 702:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_find_idx_on_lockin_only(T* obj) { return Pr
 703:./autogen/interfaces.hpp ****             template<typename T> static inline void get_find_idx_on_lockin_only(T* obj, void* ptr) 
 704:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_abs_spi_cs_gpio_pin(T* obj) { return Proper
 705:./autogen/interfaces.hpp ****             template<typename T> static inline void get_abs_spi_cs_gpio_pin(T* obj, void* ptr) { ne
ARM GAS  /tmp/ccawPiBL.s 			page 120


 706:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_cpr(T* obj) { return Property<int32_t>{&obj
 707:./autogen/interfaces.hpp ****             template<typename T> static inline void get_cpr(T* obj, void* ptr) { new (ptr) Property
 708:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_offset(T* obj) { return Property<int3
 709:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_offset(T* obj, void* ptr) { new (ptr)
 710:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_phase_offset_float(T* obj) { return Propert
 711:./autogen/interfaces.hpp ****             template<typename T> static inline void get_phase_offset_float(T* obj, void* ptr) { new
 712:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_direction(T* obj) { return Property<int32_t
 713:./autogen/interfaces.hpp ****             template<typename T> static inline void get_direction(T* obj, void* ptr) { new (ptr) Pr
 714:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bo
 715:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (pt
 716:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enable_phase_interpolation(T* obj) { return
 717:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enable_phase_interpolation(T* obj, void* pt
 718:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_bandwidth(T* obj) { return Property<float>{
 719:./autogen/interfaces.hpp ****             template<typename T> static inline void get_bandwidth(T* obj, void* ptr) { new (ptr) Pr
 720:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_range(T* obj) { return Property<float
 721:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_range(T* obj, void* ptr) { new (ptr) 
 722:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_scan_distance(T* obj) { return Proper
 723:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_scan_distance(T* obj, void* ptr) { ne
 724:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_calib_scan_omega(T* obj) { return Property<
 725:./autogen/interfaces.hpp ****             template<typename T> static inline void get_calib_scan_omega(T* obj, void* ptr) { new (
 726:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_ignore_illegal_hall_state(T* obj) { return 
 727:./autogen/interfaces.hpp ****             template<typename T> static inline void get_ignore_illegal_hall_state(T* obj, void* ptr
 728:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_hall_polarity(T* obj) { return Property<uin
 729:./autogen/interfaces.hpp ****             template<typename T> static inline void get_hall_polarity(T* obj, void* ptr) { new (ptr
 730:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_hall_polarity_calibrated(T* obj) { return P
 731:./autogen/interfaces.hpp ****             template<typename T> static inline void get_hall_polarity_calibrated(T* obj, void* ptr)
 732:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sincos_gpio_pin_sin(T* obj) { return Proper
 733:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sincos_gpio_pin_sin(T* obj, void* ptr) { ne
 734:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_sincos_gpio_pin_cos(T* obj) { return Proper
 735:./autogen/interfaces.hpp ****             template<typename T> static inline void get_sincos_gpio_pin_cos(T* obj, void* ptr) { ne
 736:./autogen/interfaces.hpp ****         };
 737:./autogen/interfaces.hpp ****         enum Error {
 738:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 739:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000001,
 740:./autogen/interfaces.hpp ****             ERROR_CPR_POLEPAIRS_MISMATCH     = 0x00000002,
 741:./autogen/interfaces.hpp ****             ERROR_NO_RESPONSE                = 0x00000004,
 742:./autogen/interfaces.hpp ****             ERROR_UNSUPPORTED_ENCODER_MODE   = 0x00000008,
 743:./autogen/interfaces.hpp ****             ERROR_ILLEGAL_HALL_STATE         = 0x00000010,
 744:./autogen/interfaces.hpp ****             ERROR_INDEX_NOT_FOUND_YET        = 0x00000020,
 745:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_TIMEOUT            = 0x00000040,
 746:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_COM_FAIL           = 0x00000080,
 747:./autogen/interfaces.hpp ****             ERROR_ABS_SPI_NOT_READY          = 0x00000100,
 748:./autogen/interfaces.hpp ****             ERROR_HALL_NOT_CALIBRATED_YET    = 0x00000200,
 749:./autogen/interfaces.hpp ****         };
 750:./autogen/interfaces.hpp ****         enum Mode {
 751:./autogen/interfaces.hpp ****             MODE_INCREMENTAL                 = 0,
 752:./autogen/interfaces.hpp ****             MODE_HALL                        = 1,
 753:./autogen/interfaces.hpp ****             MODE_SINCOS                      = 2,
 754:./autogen/interfaces.hpp ****             MODE_SPI_ABS_CUI                 = 256,
 755:./autogen/interfaces.hpp ****             MODE_SPI_ABS_AMS                 = 257,
 756:./autogen/interfaces.hpp ****             MODE_SPI_ABS_AEAT                = 258,
 757:./autogen/interfaces.hpp ****             MODE_SPI_ABS_RLS                 = 259,
 758:./autogen/interfaces.hpp ****             MODE_SPI_ABS_MA732               = 260,
 759:./autogen/interfaces.hpp ****         };
 760:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Enc
 761:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
 762:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_is_ready(T* obj) { return Property<const bool>{
ARM GAS  /tmp/ccawPiBL.s 			page 121


 763:./autogen/interfaces.hpp ****         template<typename T> static inline void get_is_ready(T* obj, void* ptr) { new (ptr) Propert
 764:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_index_found(T* obj) { return Property<const boo
 765:./autogen/interfaces.hpp ****         template<typename T> static inline void get_index_found(T* obj, void* ptr) { new (ptr) Prop
 766:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_shadow_count(T* obj) { return Property<const in
 767:./autogen/interfaces.hpp ****         template<typename T> static inline void get_shadow_count(T* obj, void* ptr) { new (ptr) Pro
 768:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_count_in_cpr(T* obj) { return Property<const in
 769:./autogen/interfaces.hpp ****         template<typename T> static inline void get_count_in_cpr(T* obj, void* ptr) { new (ptr) Pro
 770:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_interpolation(T* obj) { return Property<const f
 771:./autogen/interfaces.hpp ****         template<typename T> static inline void get_interpolation(T* obj, void* ptr) { new (ptr) Pr
 772:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase(T* obj) { return Property<const float>{ob
 773:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<c
 774:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_estimate(T* obj) { return Property<const fl
 775:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_estimate(T* obj, void* ptr) { new (ptr) Pro
 776:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_estimate_counts(T* obj) { return Property<c
 777:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_estimate_counts(T* obj, void* ptr) { new (p
 778:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_circular(T* obj) { return Property<const fl
 779:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_circular(T* obj, void* ptr) { new (ptr) Pro
 780:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_cpr_counts(T* obj) { return Property<const 
 781:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_cpr_counts(T* obj, void* ptr) { new (ptr) P
 782:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_delta_pos_cpr_counts(T* obj) { return Property<
 783:./autogen/interfaces.hpp ****         template<typename T> static inline void get_delta_pos_cpr_counts(T* obj, void* ptr) { new (
 784:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_hall_state(T* obj) { return Property<const uint
 785:./autogen/interfaces.hpp ****         template<typename T> static inline void get_hall_state(T* obj, void* ptr) { new (ptr) Prope
 786:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate(T* obj) { return Property<const fl
 787:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate(T* obj, void* ptr) { new (ptr) Pro
 788:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate_counts(T* obj) { return Property<c
 789:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate_counts(T* obj, void* ptr) { new (p
 790:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_calib_scan_response(T* obj) { return Property<c
 791:./autogen/interfaces.hpp ****         template<typename T> static inline void get_calib_scan_response(T* obj, void* ptr) { new (p
 792:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pos_abs(T* obj) { return Property<int32_t>{&obj
 793:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pos_abs(T* obj, void* ptr) { new (ptr) Property
 794:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_spi_error_rate(T* obj) { return Property<const 
 795:./autogen/interfaces.hpp ****         template<typename T> static inline void get_spi_error_rate(T* obj, void* ptr) { new (ptr) P
 796:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 797:./autogen/interfaces.hpp ****         virtual void set_linear_count(int32_t count) = 0;
 798:./autogen/interfaces.hpp ****         int32_t set_linear_count_in_count_; // for internal use by Fibre
 799:./autogen/interfaces.hpp ****         template<typename T> static auto get_set_linear_count_in_count_(T* obj) { return Property<i
 800:./autogen/interfaces.hpp ****         template<typename T> static void get_set_linear_count_in_count_(T* obj, void* ptr) { new (p
 801:./autogen/interfaces.hpp ****     };
 802:./autogen/interfaces.hpp ****     class SensorlessEstimatorIntf {
 803:./autogen/interfaces.hpp ****     public:
 804:./autogen/interfaces.hpp ****         class ConfigIntf {
 805:./autogen/interfaces.hpp ****         public:
 806:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_observer_gain(T* obj) { return Property<flo
 807:./autogen/interfaces.hpp ****             template<typename T> static inline void get_observer_gain(T* obj, void* ptr) { new (ptr
 808:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pll_bandwidth(T* obj) { return Property<flo
 809:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pll_bandwidth(T* obj, void* ptr) { new (ptr
 810:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_pm_flux_linkage(T* obj) { return Property<f
 811:./autogen/interfaces.hpp ****             template<typename T> static inline void get_pm_flux_linkage(T* obj, void* ptr) { new (p
 812:./autogen/interfaces.hpp ****         };
 813:./autogen/interfaces.hpp ****         enum Error {
 814:./autogen/interfaces.hpp ****             ERROR_NONE                       = 0x00000000,
 815:./autogen/interfaces.hpp ****             ERROR_UNSTABLE_GAIN              = 0x00000001,
 816:./autogen/interfaces.hpp ****             ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x00000002,
 817:./autogen/interfaces.hpp ****         };
 818:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Sen
 819:./autogen/interfaces.hpp ****         template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<O
ARM GAS  /tmp/ccawPiBL.s 			page 122


 820:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase(T* obj) { return Property<const float>{ob
 821:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<c
 822:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_pll_pos(T* obj) { return Property<const float>{
 823:./autogen/interfaces.hpp ****         template<typename T> static inline void get_pll_pos(T* obj, void* ptr) { new (ptr) Property
 824:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_phase_vel(T* obj) { return Property<const float
 825:./autogen/interfaces.hpp ****         template<typename T> static inline void get_phase_vel(T* obj, void* ptr) { new (ptr) Proper
 826:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_vel_estimate(T* obj) { return Property<const fl
 827:./autogen/interfaces.hpp ****         template<typename T> static inline void get_vel_estimate(T* obj, void* ptr) { new (ptr) Pro
 828:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 829:./autogen/interfaces.hpp ****     };
 830:./autogen/interfaces.hpp ****     class TrapezoidalTrajectoryIntf {
 831:./autogen/interfaces.hpp ****     public:
 832:./autogen/interfaces.hpp ****         class ConfigIntf {
 833:./autogen/interfaces.hpp ****         public:
 834:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_vel_limit(T* obj) { return Property<float>{
 835:./autogen/interfaces.hpp ****             template<typename T> static inline void get_vel_limit(T* obj, void* ptr) { new (ptr) Pr
 836:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_accel_limit(T* obj) { return Property<float
 837:./autogen/interfaces.hpp ****             template<typename T> static inline void get_accel_limit(T* obj, void* ptr) { new (ptr) 
 838:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_decel_limit(T* obj) { return Property<float
 839:./autogen/interfaces.hpp ****             template<typename T> static inline void get_decel_limit(T* obj, void* ptr) { new (ptr) 
 840:./autogen/interfaces.hpp ****         };
 841:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 842:./autogen/interfaces.hpp ****     };
 843:./autogen/interfaces.hpp ****     class EndstopIntf {
 844:./autogen/interfaces.hpp ****     public:
 845:./autogen/interfaces.hpp ****         class ConfigIntf {
 846:./autogen/interfaces.hpp ****         public:
 847:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gpio_num(T* obj) { return Property<uint16_t
 848:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gpio_num(T* obj, void* ptr) { new (ptr) Pro
 849:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{obj
 850:./autogen/interfaces.hpp ****             template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Prop
 851:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_offset(T* obj) { return Property<float>{&ob
 852:./autogen/interfaces.hpp ****             template<typename T> static inline void get_offset(T* obj, void* ptr) { new (ptr) Prope
 853:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_is_active_high(T* obj) { return Property<bo
 854:./autogen/interfaces.hpp ****             template<typename T> static inline void get_is_active_high(T* obj, void* ptr) { new (pt
 855:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_debounce_ms(T* obj) { return Property<uint3
 856:./autogen/interfaces.hpp ****             template<typename T> static inline void get_debounce_ms(T* obj, void* ptr) { new (ptr) 
 857:./autogen/interfaces.hpp ****         };
 858:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_endstop_state(T* obj) { return Property<const b
 859:./autogen/interfaces.hpp ****         template<typename T> static inline void get_endstop_state(T* obj, void* ptr) { new (ptr) Pr
 860:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 861:./autogen/interfaces.hpp ****     };
 862:./autogen/interfaces.hpp ****     class MechanicalBrakeIntf {
 863:./autogen/interfaces.hpp ****     public:
 864:./autogen/interfaces.hpp ****         class ConfigIntf {
 865:./autogen/interfaces.hpp ****         public:
 866:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_gpio_num(T* obj) { return Property<uint16_t
 867:./autogen/interfaces.hpp ****             template<typename T> static inline void get_gpio_num(T* obj, void* ptr) { new (ptr) Pro
 868:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_is_active_low(T* obj) { return Property<boo
 869:./autogen/interfaces.hpp ****             template<typename T> static inline void get_is_active_low(T* obj, void* ptr) { new (ptr
 870:./autogen/interfaces.hpp ****         };
 871:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
 872:./autogen/interfaces.hpp ****         virtual void engage() = 0;
 873:./autogen/interfaces.hpp ****         virtual void release() = 0;
 874:./autogen/interfaces.hpp ****     };
 875:./autogen/interfaces.hpp ****     class TaskTimerIntf {
 876:./autogen/interfaces.hpp ****     public:
ARM GAS  /tmp/ccawPiBL.s 			page 123


 877:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_start_time(T* obj) { return Property<const uint
 878:./autogen/interfaces.hpp ****         template<typename T> static inline void get_start_time(T* obj, void* ptr) { new (ptr) Prope
 879:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_end_time(T* obj) { return Property<const uint32
 880:./autogen/interfaces.hpp ****         template<typename T> static inline void get_end_time(T* obj, void* ptr) { new (ptr) Propert
 881:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_length(T* obj) { return Property<const uint32_t
 882:./autogen/interfaces.hpp ****         template<typename T> static inline void get_length(T* obj, void* ptr) { new (ptr) Property<
 883:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_length(T* obj) { return Property<uint32_t>{
 884:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_length(T* obj, void* ptr) { new (ptr) Prope
 885:./autogen/interfaces.hpp ****     };
 886:./autogen/interfaces.hpp ****     class TaskTimesIntf {
 887:./autogen/interfaces.hpp ****     public:
 888:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_sampling(T* obj) { return &obj->sampling; }
 889:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_control_loop_misc(T* obj) { return &obj->contro
 890:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_control_loop_checks(T* obj) { return &obj->cont
 891:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_dc_calib_wait(T* obj) { return &obj->dc_calib_w
 892:./autogen/interfaces.hpp ****     };
 893:./autogen/interfaces.hpp ****     class SystemStatsIntf {
 894:./autogen/interfaces.hpp ****     public:
 895:./autogen/interfaces.hpp ****         class UsbIntf {
 896:./autogen/interfaces.hpp ****         public:
 897:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_rx_cnt(T* obj) { return Property<const uint
 898:./autogen/interfaces.hpp ****             template<typename T> static inline void get_rx_cnt(T* obj, void* ptr) { new (ptr) Prope
 899:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_tx_cnt(T* obj) { return Property<const uint
 900:./autogen/interfaces.hpp ****             template<typename T> static inline void get_tx_cnt(T* obj, void* ptr) { new (ptr) Prope
 901:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_tx_overrun_cnt(T* obj) { return Property<co
 902:./autogen/interfaces.hpp ****             template<typename T> static inline void get_tx_overrun_cnt(T* obj, void* ptr) { new (pt
 903:./autogen/interfaces.hpp ****         };
 904:./autogen/interfaces.hpp ****         class I2CIntf {
 905:./autogen/interfaces.hpp ****         public:
 906:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_addr(T* obj) { return Property<const uint8_
 907:./autogen/interfaces.hpp ****             template<typename T> static inline void get_addr(T* obj, void* ptr) { new (ptr) Propert
 908:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_addr_match_cnt(T* obj) { return Property<co
 909:./autogen/interfaces.hpp ****             template<typename T> static inline void get_addr_match_cnt(T* obj, void* ptr) { new (pt
 910:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_rx_cnt(T* obj) { return Property<const uint
 911:./autogen/interfaces.hpp ****             template<typename T> static inline void get_rx_cnt(T* obj, void* ptr) { new (ptr) Prope
 912:./autogen/interfaces.hpp ****             template<typename T> static inline auto get_error_cnt(T* obj) { return Property<const u
 913:./autogen/interfaces.hpp ****             template<typename T> static inline void get_error_cnt(T* obj, void* ptr) { new (ptr) Pr
 914:./autogen/interfaces.hpp ****         };
 915:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_uptime(T* obj) { return Property<const uint32_t
 916:./autogen/interfaces.hpp ****         template<typename T> static inline void get_uptime(T* obj, void* ptr) { new (ptr) Property<
 917:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_min_heap_space(T* obj) { return Property<const 
 918:./autogen/interfaces.hpp ****         template<typename T> static inline void get_min_heap_space(T* obj, void* ptr) { new (ptr) P
 919:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_axis(T* obj) { return Property<
 920:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_axis(T* obj, void* ptr) { new (
 921:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_usb(T* obj) { return Property<c
 922:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_usb(T* obj, void* ptr) { new (p
 923:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_uart(T* obj) { return Property<
 924:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_uart(T* obj, void* ptr) { new (
 925:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_can(T* obj) { return Property<c
 926:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_can(T* obj, void* ptr) { new (p
 927:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_startup(T* obj) { return Proper
 928:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_startup(T* obj, void* ptr) { ne
 929:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_max_stack_usage_analog(T* obj) { return Propert
 930:./autogen/interfaces.hpp ****         template<typename T> static inline void get_max_stack_usage_analog(T* obj, void* ptr) { new
 931:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_axis(T* obj) { return Property<const
 932:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_axis(T* obj, void* ptr) { new (ptr) 
 933:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_usb(T* obj) { return Property<const 
ARM GAS  /tmp/ccawPiBL.s 			page 124


 934:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_usb(T* obj, void* ptr) { new (ptr) P
 935:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_uart(T* obj) { return Property<const
 936:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_uart(T* obj, void* ptr) { new (ptr) 
 937:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_startup(T* obj) { return Property<co
 938:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_startup(T* obj, void* ptr) { new (pt
 939:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_can(T* obj) { return Property<const 
 940:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_can(T* obj, void* ptr) { new (ptr) P
 941:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_stack_size_analog(T* obj) { return Property<con
 942:./autogen/interfaces.hpp ****         template<typename T> static inline void get_stack_size_analog(T* obj, void* ptr) { new (ptr
 943:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_axis(T* obj) { return Property<const int32
 944:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_axis(T* obj, void* ptr) { new (ptr) Proper
 945:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_usb(T* obj) { return Property<const int32_
 946:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_usb(T* obj, void* ptr) { new (ptr) Propert
 947:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_uart(T* obj) { return Property<const int32
 948:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_uart(T* obj, void* ptr) { new (ptr) Proper
 949:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_startup(T* obj) { return Property<const in
 950:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_startup(T* obj, void* ptr) { new (ptr) Pro
 951:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_can(T* obj) { return Property<const int32_
 952:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_can(T* obj, void* ptr) { new (ptr) Propert
 953:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_prio_analog(T* obj) { return Property<const int
 954:./autogen/interfaces.hpp ****         template<typename T> static inline void get_prio_analog(T* obj, void* ptr) { new (ptr) Prop
 955:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_usb(T* obj) { return &obj->usb; }
 956:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_i2c(T* obj) { return &obj->i2c; }
 957:./autogen/interfaces.hpp ****     };
 958:./autogen/interfaces.hpp ****     enum Error {
 959:./autogen/interfaces.hpp ****         ERROR_NONE                       = 0x00000000,
 960:./autogen/interfaces.hpp ****         ERROR_CONTROL_ITERATION_MISSED   = 0x00000001,
 961:./autogen/interfaces.hpp ****         ERROR_DC_BUS_UNDER_VOLTAGE       = 0x00000002,
 962:./autogen/interfaces.hpp ****         ERROR_DC_BUS_OVER_VOLTAGE        = 0x00000004,
 963:./autogen/interfaces.hpp ****         ERROR_DC_BUS_OVER_REGEN_CURRENT  = 0x00000008,
 964:./autogen/interfaces.hpp ****         ERROR_DC_BUS_OVER_CURRENT        = 0x00000010,
 965:./autogen/interfaces.hpp ****         ERROR_BRAKE_DEADTIME_VIOLATION   = 0x00000020,
 966:./autogen/interfaces.hpp ****         ERROR_BRAKE_DUTY_CYCLE_NAN       = 0x00000040,
 967:./autogen/interfaces.hpp ****         ERROR_INVALID_BRAKE_RESISTANCE   = 0x00000080,
 968:./autogen/interfaces.hpp ****     };
 969:./autogen/interfaces.hpp ****     enum GpioMode {
 970:./autogen/interfaces.hpp ****         GPIO_MODE_DIGITAL                = 0,
 971:./autogen/interfaces.hpp ****         GPIO_MODE_DIGITAL_PULL_UP        = 1,
 972:./autogen/interfaces.hpp ****         GPIO_MODE_DIGITAL_PULL_DOWN      = 2,
 973:./autogen/interfaces.hpp ****         GPIO_MODE_ANALOG_IN              = 3,
 974:./autogen/interfaces.hpp ****         GPIO_MODE_UART_A                 = 4,
 975:./autogen/interfaces.hpp ****         GPIO_MODE_UART_B                 = 5,
 976:./autogen/interfaces.hpp ****         GPIO_MODE_UART_C                 = 6,
 977:./autogen/interfaces.hpp ****         GPIO_MODE_CAN_A                  = 7,
 978:./autogen/interfaces.hpp ****         GPIO_MODE_I2C_A                  = 8,
 979:./autogen/interfaces.hpp ****         GPIO_MODE_SPI_A                  = 9,
 980:./autogen/interfaces.hpp ****         GPIO_MODE_PWM                    = 10,
 981:./autogen/interfaces.hpp ****         GPIO_MODE_ENC0                   = 11,
 982:./autogen/interfaces.hpp ****         GPIO_MODE_ENC1                   = 12,
 983:./autogen/interfaces.hpp ****         GPIO_MODE_ENC2                   = 13,
 984:./autogen/interfaces.hpp ****         GPIO_MODE_MECH_BRAKE             = 14,
 985:./autogen/interfaces.hpp ****         GPIO_MODE_STATUS                 = 15,
 986:./autogen/interfaces.hpp ****     };
 987:./autogen/interfaces.hpp ****     enum StreamProtocolType {
 988:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_FIBRE       = 0,
 989:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_ASCII       = 1,
 990:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_STDOUT      = 2,
ARM GAS  /tmp/ccawPiBL.s 			page 125


 991:./autogen/interfaces.hpp ****         STREAM_PROTOCOL_TYPE_ASCII_AND_STDOUT = 3,
 992:./autogen/interfaces.hpp ****     };
 993:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Error>{
 994:./autogen/interfaces.hpp ****     template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriv
 995:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_vbus_voltage(T* obj) { return Property<const float>
 996:./autogen/interfaces.hpp ****     template<typename T> static inline void get_vbus_voltage(T* obj, void* ptr) { new (ptr) Propert
 997:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_ibus(T* obj) { return Property<const float>{&obj->i
 998:./autogen/interfaces.hpp ****     template<typename T> static inline void get_ibus(T* obj, void* ptr) { new (ptr) Property<const 
 999:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_ibus_report_filter_k(T* obj) { return Property<floa
1000:./autogen/interfaces.hpp ****     template<typename T> static inline void get_ibus_report_filter_k(T* obj, void* ptr) { new (ptr)
1001:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_serial_number(T* obj) { return Property<const uint6
1002:./autogen/interfaces.hpp ****     template<typename T> static inline void get_serial_number(T* obj, void* ptr) { new (ptr) Proper
1003:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_hw_version_major(T* obj) { return Property<const ui
1004:./autogen/interfaces.hpp ****     template<typename T> static inline void get_hw_version_major(T* obj, void* ptr) { new (ptr) Pro
1005:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_hw_version_minor(T* obj) { return Property<const ui
1006:./autogen/interfaces.hpp ****     template<typename T> static inline void get_hw_version_minor(T* obj, void* ptr) { new (ptr) Pro
1007:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_hw_version_variant(T* obj) { return Property<const 
1008:./autogen/interfaces.hpp ****     template<typename T> static inline void get_hw_version_variant(T* obj, void* ptr) { new (ptr) P
1009:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_major(T* obj) { return Property<const ui
1010:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_major(T* obj, void* ptr) { new (ptr) Pro
1011:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_minor(T* obj) { return Property<const ui
1012:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_minor(T* obj, void* ptr) { new (ptr) Pro
1013:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_revision(T* obj) { return Property<const
1014:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_revision(T* obj, void* ptr) { new (ptr) 
1015:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_fw_version_unreleased(T* obj) { return Property<con
1016:./autogen/interfaces.hpp ****     template<typename T> static inline void get_fw_version_unreleased(T* obj, void* ptr) { new (ptr
1017:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_brake_resistor_armed(T* obj) { return Property<cons
1018:./autogen/interfaces.hpp ****     template<typename T> static inline void get_brake_resistor_armed(T* obj, void* ptr) { new (ptr)
1019:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_brake_resistor_saturated(T* obj) { return Property<
1020:./autogen/interfaces.hpp ****     template<typename T> static inline void get_brake_resistor_saturated(T* obj, void* ptr) { new (
1021:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_brake_resistor_current(T* obj) { return Property<co
1022:./autogen/interfaces.hpp ****     template<typename T> static inline void get_brake_resistor_current(T* obj, void* ptr) { new (pt
1023:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_n_evt_sampling(T* obj) { return Property<const uint
1024:./autogen/interfaces.hpp ****     template<typename T> static inline void get_n_evt_sampling(T* obj, void* ptr) { new (ptr) Prope
1025:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_n_evt_control_loop(T* obj) { return Property<const 
1026:./autogen/interfaces.hpp ****     template<typename T> static inline void get_n_evt_control_loop(T* obj, void* ptr) { new (ptr) P
1027:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_task_timers_armed(T* obj) { return Property<bool>{&
1028:./autogen/interfaces.hpp ****     template<typename T> static inline void get_task_timers_armed(T* obj, void* ptr) { new (ptr) Pr
1029:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_task_times(T* obj) { return &obj->task_times_; }
1030:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_system_stats(T* obj) { return &obj->system_stats_; 
1031:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_user_config_loaded(T* obj) { return Property<const 
1032:./autogen/interfaces.hpp ****     template<typename T> static inline void get_user_config_loaded(T* obj, void* ptr) { new (ptr) P
1033:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_misconfigured(T* obj) { return Property<const bool>
1034:./autogen/interfaces.hpp ****     template<typename T> static inline void get_misconfigured(T* obj, void* ptr) { new (ptr) Proper
1035:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_oscilloscope(T* obj) { return &obj->oscilloscope_; 
1036:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_can(T* obj) { return &obj->can_; }
1037:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_test_property(T* obj) { return Property<uint32_t>{&
1038:./autogen/interfaces.hpp ****     template<typename T> static inline void get_test_property(T* obj, void* ptr) { new (ptr) Proper
1039:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_otp_valid(T* obj) { return Property<const bool>{&ob
1040:./autogen/interfaces.hpp ****     template<typename T> static inline void get_otp_valid(T* obj, void* ptr) { new (ptr) Property<c
1041:./autogen/interfaces.hpp ****     virtual int32_t test_function(int32_t delta) = 0;
1042:./autogen/interfaces.hpp ****     virtual float get_adc_voltage(uint32_t gpio) = 0;
1043:./autogen/interfaces.hpp ****     virtual bool save_configuration() = 0;
1044:./autogen/interfaces.hpp ****     virtual void erase_configuration() = 0;
1045:./autogen/interfaces.hpp ****     virtual void reboot() = 0;
1046:./autogen/interfaces.hpp ****     virtual void enter_dfu_mode() = 0;
1047:./autogen/interfaces.hpp ****     virtual uint32_t get_interrupt_status(int32_t irqn) = 0;
ARM GAS  /tmp/ccawPiBL.s 			page 126


1048:./autogen/interfaces.hpp ****     virtual uint32_t get_dma_status(uint8_t stream_num) = 0;
1049:./autogen/interfaces.hpp ****     virtual uint32_t get_gpio_states() = 0;
1050:./autogen/interfaces.hpp ****     virtual uint64_t get_drv_fault() = 0;
1051:./autogen/interfaces.hpp ****     virtual void clear_errors() = 0;
1052:./autogen/interfaces.hpp ****     int32_t test_function_in_delta_; // for internal use by Fibre
1053:./autogen/interfaces.hpp ****     template<typename T> static auto get_test_function_in_delta_(T* obj) { return Property<int32_t>
1054:./autogen/interfaces.hpp ****     template<typename T> static void get_test_function_in_delta_(T* obj, void* ptr) { new (ptr) Pro
1055:./autogen/interfaces.hpp ****     int32_t test_function_out_cnt_; // for internal use by Fibre
1056:./autogen/interfaces.hpp ****     template<typename T> static auto get_test_function_out_cnt_(T* obj) { return Property<const int
1057:./autogen/interfaces.hpp ****     template<typename T> static void get_test_function_out_cnt_(T* obj, void* ptr) { new (ptr) Prop
1058:./autogen/interfaces.hpp ****     uint32_t get_adc_voltage_in_gpio_; // for internal use by Fibre
1059:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_adc_voltage_in_gpio_(T* obj) { return Property<uint32_
1060:./autogen/interfaces.hpp ****     template<typename T> static void get_get_adc_voltage_in_gpio_(T* obj, void* ptr) { new (ptr) Pr
1061:./autogen/interfaces.hpp ****     float get_adc_voltage_out_voltage_; // for internal use by Fibre
1062:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_adc_voltage_out_voltage_(T* obj) { return Property<con
1063:./autogen/interfaces.hpp ****     template<typename T> static void get_get_adc_voltage_out_voltage_(T* obj, void* ptr) { new (ptr
1064:./autogen/interfaces.hpp ****     bool save_configuration_out_success_; // for internal use by Fibre
1065:./autogen/interfaces.hpp ****     template<typename T> static auto get_save_configuration_out_success_(T* obj) { return Property<
1066:./autogen/interfaces.hpp ****     template<typename T> static void get_save_configuration_out_success_(T* obj, void* ptr) { new (
1067:./autogen/interfaces.hpp ****     int32_t get_interrupt_status_in_irqn_; // for internal use by Fibre
1068:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_interrupt_status_in_irqn_(T* obj) { return Property<in
1069:./autogen/interfaces.hpp ****     template<typename T> static void get_get_interrupt_status_in_irqn_(T* obj, void* ptr) { new (pt
1070:./autogen/interfaces.hpp ****     uint32_t get_interrupt_status_out_status_; // for internal use by Fibre
1071:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_interrupt_status_out_status_(T* obj) { return Property
1072:./autogen/interfaces.hpp ****     template<typename T> static void get_get_interrupt_status_out_status_(T* obj, void* ptr) { new 
1073:./autogen/interfaces.hpp ****     uint8_t get_dma_status_in_stream_num_; // for internal use by Fibre
1074:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_dma_status_in_stream_num_(T* obj) { return Property<ui
1075:./autogen/interfaces.hpp ****     template<typename T> static void get_get_dma_status_in_stream_num_(T* obj, void* ptr) { new (pt
1076:./autogen/interfaces.hpp ****     uint32_t get_dma_status_out_status_; // for internal use by Fibre
1077:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_dma_status_out_status_(T* obj) { return Property<const
1078:./autogen/interfaces.hpp ****     template<typename T> static void get_get_dma_status_out_status_(T* obj, void* ptr) { new (ptr) 
1079:./autogen/interfaces.hpp ****     uint32_t get_gpio_states_out_status_; // for internal use by Fibre
1080:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_gpio_states_out_status_(T* obj) { return Property<cons
1081:./autogen/interfaces.hpp ****     template<typename T> static void get_get_gpio_states_out_status_(T* obj, void* ptr) { new (ptr)
1082:./autogen/interfaces.hpp ****     uint64_t get_drv_fault_out_drv_fault_; // for internal use by Fibre
1083:./autogen/interfaces.hpp ****     template<typename T> static auto get_get_drv_fault_out_drv_fault_(T* obj) { return Property<con
1084:./autogen/interfaces.hpp ****     template<typename T> static void get_get_drv_fault_out_drv_fault_(T* obj, void* ptr) { new (ptr
1085:./autogen/interfaces.hpp **** };
1086:./autogen/interfaces.hpp **** 
1087:./autogen/interfaces.hpp **** 
1088:./autogen/interfaces.hpp **** class ODrive3Intf : public ODriveIntf {
1089:./autogen/interfaces.hpp **** public:
1090:./autogen/interfaces.hpp ****     class ConfigIntf : public ODriveIntf::ConfigIntf {
1091:./autogen/interfaces.hpp ****     public:
1092:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio1_mode(T* obj) { return Property<ODriveIntf
1093:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio1_mode(T* obj, void* ptr) { new (ptr) Prope
1094:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio2_mode(T* obj) { return Property<ODriveIntf
1095:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio2_mode(T* obj, void* ptr) { new (ptr) Prope
1096:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio3_mode(T* obj) { return Property<ODriveIntf
1097:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio3_mode(T* obj, void* ptr) { new (ptr) Prope
1098:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio4_mode(T* obj) { return Property<ODriveIntf
1099:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio4_mode(T* obj, void* ptr) { new (ptr) Prope
1100:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio5_mode(T* obj) { return Property<ODriveIntf
1101:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio5_mode(T* obj, void* ptr) { new (ptr) Prope
1102:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio6_mode(T* obj) { return Property<ODriveIntf
1103:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio6_mode(T* obj, void* ptr) { new (ptr) Prope
1104:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio7_mode(T* obj) { return Property<ODriveIntf
ARM GAS  /tmp/ccawPiBL.s 			page 127


1105:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio7_mode(T* obj, void* ptr) { new (ptr) Prope
1106:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio8_mode(T* obj) { return Property<ODriveIntf
1107:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio8_mode(T* obj, void* ptr) { new (ptr) Prope
1108:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio9_mode(T* obj) { return Property<ODriveIntf
1109:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio9_mode(T* obj, void* ptr) { new (ptr) Prope
1110:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio10_mode(T* obj) { return Property<ODriveInt
1111:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio10_mode(T* obj, void* ptr) { new (ptr) Prop
1112:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio11_mode(T* obj) { return Property<ODriveInt
1113:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio11_mode(T* obj, void* ptr) { new (ptr) Prop
1114:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio12_mode(T* obj) { return Property<ODriveInt
1115:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio12_mode(T* obj, void* ptr) { new (ptr) Prop
1116:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio13_mode(T* obj) { return Property<ODriveInt
1117:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio13_mode(T* obj, void* ptr) { new (ptr) Prop
1118:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio14_mode(T* obj) { return Property<ODriveInt
1119:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio14_mode(T* obj, void* ptr) { new (ptr) Prop
1120:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio15_mode(T* obj) { return Property<ODriveInt
1121:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio15_mode(T* obj, void* ptr) { new (ptr) Prop
1122:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio16_mode(T* obj) { return Property<ODriveInt
1123:./autogen/interfaces.hpp ****         template<typename T> static inline void get_gpio16_mode(T* obj, void* ptr) { new (ptr) Prop
1124:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio1_pwm_mapping(T* obj) { return &obj->pwm_ma
1125:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio2_pwm_mapping(T* obj) { return &obj->pwm_ma
1126:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio3_pwm_mapping(T* obj) { return &obj->pwm_ma
1127:./autogen/interfaces.hpp ****         template<typename T> static inline auto get_gpio4_pwm_mapping(T* obj) { return &obj->pwm_ma
1128:./autogen/interfaces.hpp ****     };
1129:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
1130:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_axis0(T* obj) { return &obj->get_axis(0); }
1131:./autogen/interfaces.hpp ****     template<typename T> static inline auto get_axis1(T* obj) { return &obj->get_axis(1); }
1132:./autogen/interfaces.hpp **** };
1133:./autogen/interfaces.hpp **** 
1134:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1135:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator | (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIn
1136:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator & (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIn
1137:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator ^ (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIn
1138:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol& operator |= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::Ca
1139:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol& operator &= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::Ca
1140:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol& operator ^= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::Ca
1141:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Protocol operator ~ (ODriveIntf::CanIntf::Protocol a) { return static_c
1142:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1143:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator | (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast
1144:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator & (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast
1145:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator ^ (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast
1146:./autogen/interfaces.hpp **** inline ODriveIntf::Error& operator |= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterp
1147:./autogen/interfaces.hpp **** inline ODriveIntf::Error& operator &= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterp
1148:./autogen/interfaces.hpp **** inline ODriveIntf::Error& operator ^= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterp
1149:./autogen/interfaces.hpp **** inline ODriveIntf::Error operator ~ (ODriveIntf::Error a) { return static_cast<ODriveIntf::Error>(~
1150:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1151:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator | (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Er
1152:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator & (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Er
1153:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator ^ (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Er
1154:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error& operator |= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf:
1155:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error& operator &= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf:
1156:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error& operator ^= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf:
1157:./autogen/interfaces.hpp **** inline ODriveIntf::CanIntf::Error operator ~ (ODriveIntf::CanIntf::Error a) { return static_cast<OD
1158:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1159:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator | (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf:
1160:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator & (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf:
1161:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator ^ (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf:
ARM GAS  /tmp/ccawPiBL.s 			page 128


1162:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error& operator |= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIn
1163:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error& operator &= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIn
1164:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error& operator ^= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIn
1165:./autogen/interfaces.hpp **** inline ODriveIntf::AxisIntf::Error operator ~ (ODriveIntf::AxisIntf::Error a) { return static_cast<
1166:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1167:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error operator | (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIn
1168:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error operator & (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIn
1169:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error operator ^ (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIn
1170:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error& operator |= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::Moto
1171:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error& operator &= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::Moto
1172:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error& operator ^= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::Moto
1173:./autogen/interfaces.hpp **** inline ODriveIntf::MotorIntf::Error operator ~ (ODriveIntf::MotorIntf::Error a) { return static_cas
1174:./autogen/interfaces.hpp **** // this is technically not thread-safe but practically it might be
1175:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error operator | (ODriveIntf::ControllerIntf::Error a, ODriveInt
1176:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error operator & (ODriveIntf::ControllerIntf::Error a, ODriveInt
1177:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error operator ^ (ODriveIntf::ControllerIntf::Error a, ODriveInt
1178:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error& operator |= (ODriveIntf::ControllerIntf::Error &a, ODrive
 568              		.loc 8 1178 131 is_stmt 1 view -0
 569              		.cfi_startproc
 570              		@ args = 0, pretend = 0, frame = 0
 571              		@ frame_needed = 0, uses_anonymous_args = 0
 572              		@ link register save eliminated.
 573              		.loc 8 1178 133 view .LVU105
 574              		.loc 8 1178 273 is_stmt 0 view .LVU106
 575 0000 0278     		ldrb	r2, [r0]	@ zero_extendqisi2
 576 0002 1143     		orrs	r1, r1, r2
 577              	.LVL49:
 578              		.loc 8 1178 273 view .LVU107
 579 0004 0170     		strb	r1, [r0]
 580              		.loc 8 1178 352 view .LVU108
 581 0006 7047     		bx	lr
 582              		.cfi_endproc
 583              	.LFE4184:
 584              		.cantunwind
 585              		.fnend
 587              		.section	.text._ZaNRN10ODriveIntf14ControllerIntf5ErrorES1_,"axG",%progbits,_ZaNRN10ODriveIntf14Co
 588              		.align	1
 589              		.weak	_ZaNRN10ODriveIntf14ControllerIntf5ErrorES1_
 590              		.syntax unified
 591              		.thumb
 592              		.thumb_func
 594              	_ZaNRN10ODriveIntf14ControllerIntf5ErrorES1_:
 595              		.fnstart
 596              	.LVL50:
 597              	.LFB4185:
1179:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error& operator &= (ODriveIntf::ControllerIntf::Error &a, ODrive
 598              		.loc 8 1179 131 is_stmt 1 view -0
 599              		.cfi_startproc
 600              		@ args = 0, pretend = 0, frame = 0
 601              		@ frame_needed = 0, uses_anonymous_args = 0
 602              		@ link register save eliminated.
 603              		.loc 8 1179 133 view .LVU110
 604              		.loc 8 1179 273 is_stmt 0 view .LVU111
 605 0000 0278     		ldrb	r2, [r0]	@ zero_extendqisi2
 606 0002 1140     		ands	r1, r1, r2
 607              	.LVL51:
 608              		.loc 8 1179 273 view .LVU112
ARM GAS  /tmp/ccawPiBL.s 			page 129


 609 0004 0170     		strb	r1, [r0]
 610              		.loc 8 1179 352 view .LVU113
 611 0006 7047     		bx	lr
 612              		.cfi_endproc
 613              	.LFE4185:
 614              		.cantunwind
 615              		.fnend
 617              		.section	.text._ZcoN10ODriveIntf14ControllerIntf5ErrorE,"axG",%progbits,_ZcoN10ODriveIntf14Control
 618              		.align	1
 619              		.weak	_ZcoN10ODriveIntf14ControllerIntf5ErrorE
 620              		.syntax unified
 621              		.thumb
 622              		.thumb_func
 624              	_ZcoN10ODriveIntf14ControllerIntf5ErrorE:
 625              		.fnstart
 626              	.LVL52:
 627              	.LFB4187:
1180:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error& operator ^= (ODriveIntf::ControllerIntf::Error &a, ODrive
1181:./autogen/interfaces.hpp **** inline ODriveIntf::ControllerIntf::Error operator ~ (ODriveIntf::ControllerIntf::Error a) { return 
 628              		.loc 8 1181 91 is_stmt 1 view -0
 629              		.cfi_startproc
 630              		@ args = 0, pretend = 0, frame = 0
 631              		@ frame_needed = 0, uses_anonymous_args = 0
 632              		@ link register save eliminated.
 633              		.loc 8 1181 93 view .LVU115
 634              		.loc 8 1181 221 is_stmt 0 view .LVU116
 635 0000 C043     		mvns	r0, r0
 636              	.LVL53:
 637              		.loc 8 1181 224 view .LVU117
 638 0002 C0B2     		uxtb	r0, r0
 639 0004 7047     		bx	lr
 640              		.cfi_endproc
 641              	.LFE4187:
 642              		.cantunwind
 643              		.fnend
 645              		.section	.text._ZN10Controller5resetEv,"ax",%progbits
 646              		.align	1
 647              		.global	_ZN10Controller5resetEv
 648              		.syntax unified
 649              		.thumb
 650              		.thumb_func
 652              	_ZN10Controller5resetEv:
 653              		.fnstart
 654              	.LVL54:
 655              	.LFB5187:
  12:MotorControl/controller.cpp ****     // pos_setpoint is initialized in start_closed_loop_control
 656              		.loc 3 12 26 is_stmt 1 view -0
 657              		.cfi_startproc
 658              		@ args = 0, pretend = 0, frame = 0
 659              		@ frame_needed = 0, uses_anonymous_args = 0
 660              		@ link register save eliminated.
  14:MotorControl/controller.cpp ****     vel_integrator_torque_ = 0.0f;
 661              		.loc 3 14 5 view .LVU119
  14:MotorControl/controller.cpp ****     vel_integrator_torque_ = 0.0f;
 662              		.loc 3 14 19 is_stmt 0 view .LVU120
 663 0000 00F54053 		add	r3, r0, #12288
 664 0004 03F60811 		addw	r1, r3, #2312
ARM GAS  /tmp/ccawPiBL.s 			page 130


 665 0008 0022     		movs	r2, #0
 666 000a 0A60     		str	r2, [r1]	@ float
  15:MotorControl/controller.cpp ****     torque_setpoint_ = 0.0f;
 667              		.loc 3 15 5 is_stmt 1 view .LVU121
  15:MotorControl/controller.cpp ****     torque_setpoint_ = 0.0f;
 668              		.loc 3 15 28 is_stmt 0 view .LVU122
 669 000c 03F60C11 		addw	r1, r3, #2316
 670 0010 0A60     		str	r2, [r1]	@ float
  16:MotorControl/controller.cpp ****     mechanical_power_ = 0.0f;
 671              		.loc 3 16 5 is_stmt 1 view .LVU123
  16:MotorControl/controller.cpp ****     mechanical_power_ = 0.0f;
 672              		.loc 3 16 22 is_stmt 0 view .LVU124
 673 0012 03F51161 		add	r1, r3, #2320
 674 0016 0A60     		str	r2, [r1]	@ float
  17:MotorControl/controller.cpp ****     electrical_power_ = 0.0f;
 675              		.loc 3 17 5 is_stmt 1 view .LVU125
  17:MotorControl/controller.cpp ****     electrical_power_ = 0.0f;
 676              		.loc 3 17 23 is_stmt 0 view .LVU126
 677 0018 00F56550 		add	r0, r0, #14656
 678              	.LVL55:
  17:MotorControl/controller.cpp ****     electrical_power_ = 0.0f;
 679              		.loc 3 17 23 view .LVU127
 680 001c 0260     		str	r2, [r0]	@ float
  18:MotorControl/controller.cpp **** }
 681              		.loc 3 18 5 is_stmt 1 view .LVU128
  18:MotorControl/controller.cpp **** }
 682              		.loc 3 18 23 is_stmt 0 view .LVU129
 683 001e 03F64413 		addw	r3, r3, #2372
 684 0022 1A60     		str	r2, [r3]	@ float
  19:MotorControl/controller.cpp **** 
 685              		.loc 3 19 1 view .LVU130
 686 0024 7047     		bx	lr
 687              		.cfi_endproc
 688              	.LFE5187:
 689              		.cantunwind
 690              		.fnend
 692              		.section	.text._ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE,"ax",%progbits
 693              		.align	1
 694              		.global	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 695              		.syntax unified
 696              		.thumb
 697              		.thumb_func
 699              	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE:
 700              		.fnstart
 701              	.LVL56:
 702              	.LFB5188:
  21:MotorControl/controller.cpp ****     error_ |= error;
 703              		.loc 3 21 41 is_stmt 1 view -0
 704              		.cfi_startproc
 705              		@ args = 0, pretend = 0, frame = 0
 706              		@ frame_needed = 0, uses_anonymous_args = 0
  21:MotorControl/controller.cpp ****     error_ |= error;
 707              		.loc 3 21 41 is_stmt 0 view .LVU132
 708 0000 10B5     		push	{r4, lr}
 709              	.LCFI6:
 710              		.cfi_def_cfa_offset 8
 711              		.cfi_offset 4, -8
ARM GAS  /tmp/ccawPiBL.s 			page 131


 712              		.cfi_offset 14, -4
 713 0002 0446     		mov	r4, r0
  22:MotorControl/controller.cpp ****     last_error_time_ = odrv.n_evt_control_loop_ * current_meas_period;
 714              		.loc 3 22 5 is_stmt 1 view .LVU133
  22:MotorControl/controller.cpp ****     last_error_time_ = odrv.n_evt_control_loop_ * current_meas_period;
 715              		.loc 3 22 15 is_stmt 0 view .LVU134
 716 0004 00F56350 		add	r0, r0, #14528
 717              	.LVL57:
  22:MotorControl/controller.cpp ****     last_error_time_ = odrv.n_evt_control_loop_ * current_meas_period;
 718              		.loc 3 22 15 view .LVU135
 719 0008 1C30     		adds	r0, r0, #28
 720 000a FFF7FEFF 		bl	_ZoRRN10ODriveIntf14ControllerIntf5ErrorES1_
 721              	.LVL58:
  23:MotorControl/controller.cpp **** }
 722              		.loc 3 23 5 is_stmt 1 view .LVU136
  23:MotorControl/controller.cpp **** }
 723              		.loc 3 23 29 is_stmt 0 view .LVU137
 724 000e 074B     		ldr	r3, .L46
 725 0010 D3EDB77A 		vldr.32	s15, [r3, #732]	@ int
  23:MotorControl/controller.cpp **** }
 726              		.loc 3 23 49 view .LVU138
 727 0014 F8EE677A 		vcvt.f32.u32	s15, s15
 728 0018 9FED057A 		vldr.32	s14, .L46+4
 729 001c 67EE877A 		vmul.f32	s15, s15, s14
  23:MotorControl/controller.cpp **** }
 730              		.loc 3 23 22 view .LVU139
 731 0020 04F56350 		add	r0, r4, #14528
 732 0024 C0ED087A 		vstr.32	s15, [r0, #32]
  24:MotorControl/controller.cpp **** 
 733              		.loc 3 24 1 view .LVU140
 734 0028 10BD     		pop	{r4, pc}
 735              	.LVL59:
 736              	.L47:
  24:MotorControl/controller.cpp **** 
 737              		.loc 3 24 1 view .LVU141
 738 002a 00BF     		.align	2
 739              	.L46:
 740 002c 00400000 		.word	odrv+16384
 741 0030 6F120339 		.word	956502639
 742              		.cfi_endproc
 743              	.LFE5188:
 744              		.cantunwind
 745              		.fnend
 747              		.section	.text._ZN10Controller11move_to_posEf,"ax",%progbits
 748              		.align	1
 749              		.global	_ZN10Controller11move_to_posEf
 750              		.syntax unified
 751              		.thumb
 752              		.thumb_func
 754              	_ZN10Controller11move_to_posEf:
 755              		.fnstart
 756              	.LVL60:
 757              	.LFB5189:
  31:MotorControl/controller.cpp ****     axis_->trap_traj_.planTrapezoidal(goal_point, pos_setpoint_, vel_setpoint_,
 758              		.loc 3 31 48 is_stmt 1 view -0
 759              		.cfi_startproc
 760              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccawPiBL.s 			page 132


 761              		@ frame_needed = 0, uses_anonymous_args = 0
  31:MotorControl/controller.cpp ****     axis_->trap_traj_.planTrapezoidal(goal_point, pos_setpoint_, vel_setpoint_,
 762              		.loc 3 31 48 is_stmt 0 view .LVU143
 763 0000 10B5     		push	{r4, lr}
 764              		.save {r4, lr}
 765              	.LCFI7:
 766              		.cfi_def_cfa_offset 8
 767              		.cfi_offset 4, -8
 768              		.cfi_offset 14, -4
  32:MotorControl/controller.cpp ****                                  axis_->trap_traj_.config_.vel_limit,
 769              		.loc 3 32 5 is_stmt 1 view .LVU144
 770 0002 00F54054 		add	r4, r0, #12288
 771 0006 D4F8D838 		ldr	r3, [r4, #2264]
  32:MotorControl/controller.cpp ****                                  axis_->trap_traj_.config_.vel_limit,
 772              		.loc 3 32 12 is_stmt 0 view .LVU145
 773 000a D3F85C01 		ldr	r0, [r3, #348]
 774              	.LVL61:
  32:MotorControl/controller.cpp ****                                  axis_->trap_traj_.config_.vel_limit,
 775              		.loc 3 32 38 view .LVU146
 776 000e 04F60812 		addw	r2, r4, #2312
 777 0012 04F60413 		addw	r3, r4, #2308
 778 0016 D0ED032A 		vldr.32	s5, [r0, #12]
 779 001a 90ED022A 		vldr.32	s4, [r0, #8]
 780 001e D0ED011A 		vldr.32	s3, [r0, #4]
 781 0022 92ED001A 		vldr.32	s2, [r2]
 782 0026 D3ED000A 		vldr.32	s1, [r3]
 783 002a FFF7FEFF 		bl	_ZN21TrapezoidalTrajectory15planTrapezoidalEffffff
 784              	.LVL62:
  36:MotorControl/controller.cpp ****     trajectory_done_ = false;
 785              		.loc 3 36 5 is_stmt 1 view .LVU147
 786 002e D4F8D838 		ldr	r3, [r4, #2264]
  36:MotorControl/controller.cpp ****     trajectory_done_ = false;
 787              		.loc 3 36 12 is_stmt 0 view .LVU148
 788 0032 D3F85C31 		ldr	r3, [r3, #348]
  36:MotorControl/controller.cpp ****     trajectory_done_ = false;
 789              		.loc 3 36 26 view .LVU149
 790 0036 0022     		movs	r2, #0
 791 0038 DA63     		str	r2, [r3, #60]	@ float
  37:MotorControl/controller.cpp **** }
 792              		.loc 3 37 5 is_stmt 1 view .LVU150
  37:MotorControl/controller.cpp **** }
 793              		.loc 3 37 22 is_stmt 0 view .LVU151
 794 003a 0023     		movs	r3, #0
 795 003c 84F83D39 		strb	r3, [r4, #2365]
  38:MotorControl/controller.cpp **** 
 796              		.loc 3 38 1 view .LVU152
 797 0040 10BD     		pop	{r4, pc}
  38:MotorControl/controller.cpp **** 
 798              		.loc 3 38 1 view .LVU153
 799              		.cfi_endproc
 800              	.LFE5189:
 801              		.fnend
 803              		.section	.text._ZN10Controller23anticogging_calibrationEff,"ax",%progbits
 804              		.align	1
 805              		.global	_ZN10Controller23anticogging_calibrationEff
 806              		.syntax unified
 807              		.thumb
ARM GAS  /tmp/ccawPiBL.s 			page 133


 808              		.thumb_func
 810              	_ZN10Controller23anticogging_calibrationEff:
 811              		.fnstart
 812              	.LVL63:
 813              	.LFB5193:
  79:MotorControl/controller.cpp ****     float pos_err = input_pos_ - pos_estimate;
 814              		.loc 3 79 82 is_stmt 1 view -0
 815              		.cfi_startproc
 816              		@ args = 0, pretend = 0, frame = 8
 817              		@ frame_needed = 0, uses_anonymous_args = 0
 818              		@ link register save eliminated.
  79:MotorControl/controller.cpp ****     float pos_err = input_pos_ - pos_estimate;
 819              		.loc 3 79 82 is_stmt 0 view .LVU155
 820 0000 82B0     		sub	sp, sp, #8
 821              	.LCFI8:
 822              		.cfi_def_cfa_offset 8
  80:MotorControl/controller.cpp ****     if (std::abs(pos_err) <= config_.anticogging.calib_pos_threshold / (float)axis_->encoder_.confi
 823              		.loc 3 80 5 is_stmt 1 view .LVU156
  80:MotorControl/controller.cpp ****     if (std::abs(pos_err) <= config_.anticogging.calib_pos_threshold / (float)axis_->encoder_.confi
 824              		.loc 3 80 21 is_stmt 0 view .LVU157
 825 0002 00F54053 		add	r3, r0, #12288
 826 0006 03F61412 		addw	r2, r3, #2324
 827 000a D2ED007A 		vldr.32	s15, [r2]
  80:MotorControl/controller.cpp ****     if (std::abs(pos_err) <= config_.anticogging.calib_pos_threshold / (float)axis_->encoder_.confi
 828              		.loc 3 80 11 view .LVU158
 829 000e 77EEC07A 		vsub.f32	s15, s15, s0
 830              	.LVL64:
  81:MotorControl/controller.cpp ****         std::abs(vel_estimate) < config_.anticogging.calib_vel_threshold / (float)axis_->encoder_.c
 831              		.loc 3 81 5 is_stmt 1 view .LVU159
 832              	.LBB568:
 833              	.LBI568:
 834              		.file 9 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // -*- C++ -*- C library enhancements header.
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // Copyright (C) 2016-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** /** @file include/bits/std_abs.h
ARM GAS  /tmp/ccawPiBL.s 			page 134


  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****  *  This is an internal header file, included by other library headers.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****  *  Do not attempt to use it directly. @headername{cmath, cstdlib}
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****  */
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #ifndef _GLIBCXX_BITS_STD_ABS_H
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #define _GLIBCXX_BITS_STD_ABS_H
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #pragma GCC system_header
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #include <bits/c++config.h>
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #define _GLIBCXX_INCLUDE_NEXT_C_HEADERS
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #include_next <stdlib.h>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #ifdef __CORRECT_ISO_CPP_MATH_H_PROTO
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** # include_next <math.h>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #endif
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #undef _GLIBCXX_INCLUDE_NEXT_C_HEADERS
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #undef abs
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** extern "C++"
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** {
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** namespace std _GLIBCXX_VISIBILITY(default)
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** {
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   using ::abs;
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #ifndef __CORRECT_ISO_CPP_STDLIB_H_PROTO
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   inline long
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   abs(long __i) { return __builtin_labs(__i); }
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #endif
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #ifdef _GLIBCXX_USE_LONG_LONG
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   inline long long
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   abs(long long __x) { return __builtin_llabs (__x); }
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #endif
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // _GLIBCXX_RESOLVE_LIB_DEFECTS
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // 2192. Validity and return type of std::abs(0u) is unclear
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // 2294. <cstdlib> should declare abs(double)
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** // 2735. std::abs(short), std::abs(signed char) and others should return int
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   inline _GLIBCXX_CONSTEXPR double
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   abs(double __x)
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   { return __builtin_fabs(__x); }
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h **** 
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   inline _GLIBCXX_CONSTEXPR float
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   abs(float __x)
 835              		.loc 9 75 3 view .LVU160
 836              	.LBB569:
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   { return __builtin_fabsf(__x); }
 837              		.loc 9 76 5 view .LVU161
 838              		.loc 9 76 31 is_stmt 0 view .LVU162
 839 0012 F0EEE77A 		vabs.f32	s15, s15
 840              	.LVL65:
ARM GAS  /tmp/ccawPiBL.s 			page 135


 841              		.loc 9 76 31 view .LVU163
 842              	.LBE569:
 843              	.LBE568:
  81:MotorControl/controller.cpp ****         std::abs(vel_estimate) < config_.anticogging.calib_vel_threshold / (float)axis_->encoder_.c
 844              		.loc 3 81 50 view .LVU164
 845 0016 03F69C02 		addw	r2, r3, #2204
 846              	.LVL66:
  81:MotorControl/controller.cpp ****         std::abs(vel_estimate) < config_.anticogging.calib_vel_threshold / (float)axis_->encoder_.c
 847              		.loc 3 81 50 view .LVU165
 848 001a 92ED006A 		vldr.32	s12, [r2]
  81:MotorControl/controller.cpp ****         std::abs(vel_estimate) < config_.anticogging.calib_vel_threshold / (float)axis_->encoder_.c
 849              		.loc 3 81 79 view .LVU166
 850 001e D3F8D838 		ldr	r3, [r3, #2264]
 851              	.LVL67:
  81:MotorControl/controller.cpp ****         std::abs(vel_estimate) < config_.anticogging.calib_vel_threshold / (float)axis_->encoder_.c
 852              		.loc 3 81 86 view .LVU167
 853 0022 D3F8AC30 		ldr	r3, [r3, #172]
  81:MotorControl/controller.cpp ****         std::abs(vel_estimate) < config_.anticogging.calib_vel_threshold / (float)axis_->encoder_.c
 854              		.loc 3 81 103 view .LVU168
 855 0026 93ED147A 		vldr.32	s14, [r3, #80]	@ int
  81:MotorControl/controller.cpp ****         std::abs(vel_estimate) < config_.anticogging.calib_vel_threshold / (float)axis_->encoder_.c
 856              		.loc 3 81 72 view .LVU169
 857 002a B8EEC77A 		vcvt.f32.s32	s14, s14
  81:MotorControl/controller.cpp ****         std::abs(vel_estimate) < config_.anticogging.calib_vel_threshold / (float)axis_->encoder_.c
 858              		.loc 3 81 70 view .LVU170
 859 002e C6EE076A 		vdiv.f32	s13, s12, s14
  81:MotorControl/controller.cpp ****         std::abs(vel_estimate) < config_.anticogging.calib_vel_threshold / (float)axis_->encoder_.c
 860              		.loc 3 81 107 view .LVU171
 861 0032 F4EEE76A 		vcmpe.f32	s13, s15
 862 0036 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 863 003a 1EDB     		blt	.L51
 864              	.LVL68:
 865              	.LBB570:
 866              	.LBI570:
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   { return __builtin_fabsf(__x); }
 867              		.loc 9 75 3 is_stmt 1 view .LVU172
 868              	.LBB571:
 869              		.loc 9 76 5 view .LVU173
 870              		.loc 9 76 31 is_stmt 0 view .LVU174
 871 003c F0EEE00A 		vabs.f32	s1, s1
 872              	.LVL69:
 873              		.loc 9 76 31 view .LVU175
 874              	.LBE571:
 875              	.LBE570:
  82:MotorControl/controller.cpp ****         config_.anticogging.cogging_map[std::clamp<uint32_t>(config_.anticogging.index++, 0, 3600)]
 876              		.loc 3 82 54 view .LVU176
 877 0040 00F56253 		add	r3, r0, #14464
 878 0044 D3ED086A 		vldr.32	s13, [r3, #32]
  82:MotorControl/controller.cpp ****         config_.anticogging.cogging_map[std::clamp<uint32_t>(config_.anticogging.index++, 0, 3600)]
 879              		.loc 3 82 74 view .LVU177
 880 0048 C6EE877A 		vdiv.f32	s15, s13, s14
  81:MotorControl/controller.cpp ****         std::abs(vel_estimate) < config_.anticogging.calib_vel_threshold / (float)axis_->encoder_.c
 881              		.loc 3 81 107 view .LVU178
 882 004c F4EEE07A 		vcmpe.f32	s15, s1
 883 0050 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 884 0054 11DD     		ble	.L51
  83:MotorControl/controller.cpp ****     }
ARM GAS  /tmp/ccawPiBL.s 			page 136


 885              		.loc 3 83 9 is_stmt 1 view .LVU179
  83:MotorControl/controller.cpp ****     }
 886              		.loc 3 83 103 is_stmt 0 view .LVU180
 887 0056 00F56453 		add	r3, r0, #14592
 888 005a DA68     		ldr	r2, [r3, #12]	@ float
 889              	.LVL70:
  83:MotorControl/controller.cpp ****     }
 890              		.loc 3 83 82 view .LVU181
 891 005c 436D     		ldr	r3, [r0, #84]
  83:MotorControl/controller.cpp ****     }
 892              		.loc 3 83 87 view .LVU182
 893 005e 591C     		adds	r1, r3, #1
 894 0060 4165     		str	r1, [r0, #84]
 895 0062 0093     		str	r3, [sp]
  83:MotorControl/controller.cpp ****     }
 896              		.loc 3 83 94 view .LVU183
 897 0064 4FF46161 		mov	r1, #3600
 898 0068 0191     		str	r1, [sp, #4]
 899              	.LVL71:
 900              	.LBB572:
 901              	.LBI572:
3680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 902              		.loc 6 3680 5 is_stmt 1 view .LVU184
 903              	.LBB573:
 904              		.loc 6 3683 29 is_stmt 0 view .LVU185
 905 006a 8B42     		cmp	r3, r1
 906 006c 26D9     		bls	.L57
 907 006e 01AB     		add	r3, sp, #4
 908              	.LVL72:
 909              	.L54:
 910              		.loc 6 3683 29 view .LVU186
 911              	.LBE573:
 912              	.LBE572:
  83:MotorControl/controller.cpp ****     }
 913              		.loc 3 83 61 view .LVU187
 914 0070 1B68     		ldr	r3, [r3]
  83:MotorControl/controller.cpp ****     }
 915              		.loc 3 83 101 view .LVU188
 916 0072 1433     		adds	r3, r3, #20
 917 0074 00EB8303 		add	r3, r0, r3, lsl #2
 918 0078 9A60     		str	r2, [r3, #8]	@ float
 919              	.LVL73:
 920              	.L51:
  85:MotorControl/controller.cpp ****         config_.control_mode = CONTROL_MODE_POSITION_CONTROL;
 921              		.loc 3 85 5 is_stmt 1 view .LVU189
  85:MotorControl/controller.cpp ****         config_.control_mode = CONTROL_MODE_POSITION_CONTROL;
 922              		.loc 3 85 29 is_stmt 0 view .LVU190
 923 007a 436D     		ldr	r3, [r0, #84]
  85:MotorControl/controller.cpp ****         config_.control_mode = CONTROL_MODE_POSITION_CONTROL;
 924              		.loc 3 85 5 view .LVU191
 925 007c B3F5616F 		cmp	r3, #3600
 926 0080 1ED2     		bcs	.L55
  86:MotorControl/controller.cpp ****         input_pos_ = config_.anticogging.index * axis_->encoder_.getCoggingRatio();
 927              		.loc 3 86 9 is_stmt 1 view .LVU192
  86:MotorControl/controller.cpp ****         input_pos_ = config_.anticogging.index * axis_->encoder_.getCoggingRatio();
 928              		.loc 3 86 30 is_stmt 0 view .LVU193
 929 0082 0322     		movs	r2, #3
ARM GAS  /tmp/ccawPiBL.s 			page 137


 930 0084 0276     		strb	r2, [r0, #24]
  87:MotorControl/controller.cpp ****         input_vel_ = 0.0f;
 931              		.loc 3 87 9 is_stmt 1 view .LVU194
 932              	.LVL74:
 933              		.file 10 "./MotorControl/encoder.hpp"
   1:./MotorControl/encoder.hpp **** #ifndef __ENCODER_HPP
   2:./MotorControl/encoder.hpp **** #define __ENCODER_HPP
   3:./MotorControl/encoder.hpp **** 
   4:./MotorControl/encoder.hpp **** class Encoder;
   5:./MotorControl/encoder.hpp **** 
   6:./MotorControl/encoder.hpp **** #include <board.h> // needed for arm_math.h
   7:./MotorControl/encoder.hpp **** #include <Drivers/STM32/stm32_spi_arbiter.hpp>
   8:./MotorControl/encoder.hpp **** #include "utils.hpp"
   9:./MotorControl/encoder.hpp **** #include <autogen/interfaces.hpp>
  10:./MotorControl/encoder.hpp **** #include "component.hpp"
  11:./MotorControl/encoder.hpp **** 
  12:./MotorControl/encoder.hpp **** 
  13:./MotorControl/encoder.hpp **** class Encoder : public ODriveIntf::EncoderIntf {
  14:./MotorControl/encoder.hpp **** public:
  15:./MotorControl/encoder.hpp ****     static constexpr uint32_t MODE_FLAG_ABS = 0x100;
  16:./MotorControl/encoder.hpp ****     static constexpr std::array<float, 6> hall_edge_defaults = 
  17:./MotorControl/encoder.hpp ****         {0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f};
  18:./MotorControl/encoder.hpp **** 
  19:./MotorControl/encoder.hpp ****     struct Config_t {
  20:./MotorControl/encoder.hpp ****         Mode mode = MODE_INCREMENTAL;
  21:./MotorControl/encoder.hpp ****         float calib_range = 0.02f; // Accuracy required to pass encoder cpr check
  22:./MotorControl/encoder.hpp ****         float calib_scan_distance = 16.0f * M_PI; // rad electrical
  23:./MotorControl/encoder.hpp ****         float calib_scan_omega = 4.0f * M_PI; // rad/s electrical
  24:./MotorControl/encoder.hpp ****         float bandwidth = 1000.0f;
  25:./MotorControl/encoder.hpp ****         int32_t phase_offset = 0;        // Offset between encoder count and rotor electrical phase
  26:./MotorControl/encoder.hpp ****         float phase_offset_float = 0.0f; // Sub-count phase alignment offset
  27:./MotorControl/encoder.hpp ****         int32_t cpr = (2048 * 4);   // Default resolution of CUI-AMT102 encoder,
  28:./MotorControl/encoder.hpp ****         float index_offset = 0.0f;
  29:./MotorControl/encoder.hpp ****         bool use_index = false;
  30:./MotorControl/encoder.hpp ****         bool pre_calibrated = false; // If true, this means the offset stored in
  31:./MotorControl/encoder.hpp ****                                     // configuration is valid and does not need
  32:./MotorControl/encoder.hpp ****                                     // be determined by run_offset_calibration.
  33:./MotorControl/encoder.hpp ****                                     // In this case the encoder will enter ready
  34:./MotorControl/encoder.hpp ****                                     // state as soon as the index is found.
  35:./MotorControl/encoder.hpp ****         int32_t direction = 0; // direction with respect to motor
  36:./MotorControl/encoder.hpp ****         bool use_index_offset = true;
  37:./MotorControl/encoder.hpp ****         bool enable_phase_interpolation = true; // Use velocity to interpolate inside the count sta
  38:./MotorControl/encoder.hpp ****         bool find_idx_on_lockin_only = false; // Only be sensitive during lockin scan constant vel 
  39:./MotorControl/encoder.hpp ****         bool ignore_illegal_hall_state = false; // dont error on bad states like 000 or 111
  40:./MotorControl/encoder.hpp ****         uint8_t hall_polarity = 0;
  41:./MotorControl/encoder.hpp ****         bool hall_polarity_calibrated = false;
  42:./MotorControl/encoder.hpp ****         std::array<float, 6> hall_edge_phcnt = hall_edge_defaults;
  43:./MotorControl/encoder.hpp ****         uint16_t abs_spi_cs_gpio_pin = 1;
  44:./MotorControl/encoder.hpp ****         uint16_t sincos_gpio_pin_sin = 3;
  45:./MotorControl/encoder.hpp ****         uint16_t sincos_gpio_pin_cos = 4;
  46:./MotorControl/encoder.hpp **** 
  47:./MotorControl/encoder.hpp **** 
  48:./MotorControl/encoder.hpp ****         // custom setters
  49:./MotorControl/encoder.hpp ****         Encoder* parent = nullptr;
  50:./MotorControl/encoder.hpp ****         void set_use_index(bool value) { use_index = value; parent->set_idx_subscribe(); }
  51:./MotorControl/encoder.hpp ****         void set_find_idx_on_lockin_only(bool value) { find_idx_on_lockin_only = value; parent->set
  52:./MotorControl/encoder.hpp ****         void set_abs_spi_cs_gpio_pin(uint16_t value) { abs_spi_cs_gpio_pin = value; parent->abs_spi
ARM GAS  /tmp/ccawPiBL.s 			page 138


  53:./MotorControl/encoder.hpp ****         void set_pre_calibrated(bool value) { pre_calibrated = value; parent->check_pre_calibrated(
  54:./MotorControl/encoder.hpp ****         void set_bandwidth(float value) { bandwidth = value; parent->update_pll_gains(); }
  55:./MotorControl/encoder.hpp ****     };
  56:./MotorControl/encoder.hpp **** 
  57:./MotorControl/encoder.hpp ****     Encoder(TIM_HandleTypeDef* timer, Stm32Gpio index_gpio,
  58:./MotorControl/encoder.hpp ****             Stm32Gpio hallA_gpio, Stm32Gpio hallB_gpio, Stm32Gpio hallC_gpio,
  59:./MotorControl/encoder.hpp ****             Stm32SpiArbiter* spi_arbiter);
  60:./MotorControl/encoder.hpp ****     
  61:./MotorControl/encoder.hpp ****     bool apply_config(ODriveIntf::MotorIntf::MotorType motor_type);
  62:./MotorControl/encoder.hpp ****     void setup();
  63:./MotorControl/encoder.hpp ****     void set_error(Error error);
  64:./MotorControl/encoder.hpp ****     bool do_checks();
  65:./MotorControl/encoder.hpp **** 
  66:./MotorControl/encoder.hpp ****     void enc_index_cb();
  67:./MotorControl/encoder.hpp ****     void set_idx_subscribe(bool override_enable = false);
  68:./MotorControl/encoder.hpp ****     void update_pll_gains();
  69:./MotorControl/encoder.hpp ****     void check_pre_calibrated();
  70:./MotorControl/encoder.hpp **** 
  71:./MotorControl/encoder.hpp ****     void set_linear_count(int32_t count);
  72:./MotorControl/encoder.hpp ****     void set_circular_count(int32_t count, bool update_offset);
  73:./MotorControl/encoder.hpp ****     bool calib_enc_offset(float voltage_magnitude);
  74:./MotorControl/encoder.hpp **** 
  75:./MotorControl/encoder.hpp ****     bool run_index_search();
  76:./MotorControl/encoder.hpp ****     bool run_direction_find();
  77:./MotorControl/encoder.hpp ****     bool run_hall_polarity_calibration();
  78:./MotorControl/encoder.hpp ****     bool run_hall_phase_calibration();
  79:./MotorControl/encoder.hpp ****     bool run_offset_calibration();
  80:./MotorControl/encoder.hpp ****     void sample_now();
  81:./MotorControl/encoder.hpp ****     bool read_sampled_gpio(Stm32Gpio gpio);
  82:./MotorControl/encoder.hpp ****     void decode_hall_samples();
  83:./MotorControl/encoder.hpp ****     int32_t hall_model(float internal_pos);
  84:./MotorControl/encoder.hpp ****     bool update();
  85:./MotorControl/encoder.hpp **** 
  86:./MotorControl/encoder.hpp ****     TIM_HandleTypeDef* timer_;
  87:./MotorControl/encoder.hpp ****     Stm32Gpio index_gpio_;
  88:./MotorControl/encoder.hpp ****     Stm32Gpio hallA_gpio_;
  89:./MotorControl/encoder.hpp ****     Stm32Gpio hallB_gpio_;
  90:./MotorControl/encoder.hpp ****     Stm32Gpio hallC_gpio_;
  91:./MotorControl/encoder.hpp ****     Stm32SpiArbiter* spi_arbiter_;
  92:./MotorControl/encoder.hpp ****     Axis* axis_ = nullptr; // set by Axis constructor
  93:./MotorControl/encoder.hpp **** 
  94:./MotorControl/encoder.hpp ****     Config_t config_;
  95:./MotorControl/encoder.hpp **** 
  96:./MotorControl/encoder.hpp ****     Error error_ = ERROR_NONE;
  97:./MotorControl/encoder.hpp ****     bool index_found_ = false;
  98:./MotorControl/encoder.hpp ****     bool is_ready_ = false;
  99:./MotorControl/encoder.hpp ****     int32_t shadow_count_ = 0;
 100:./MotorControl/encoder.hpp ****     int32_t count_in_cpr_ = 0;
 101:./MotorControl/encoder.hpp ****     float interpolation_ = 0.0f;
 102:./MotorControl/encoder.hpp ****     OutputPort<float> phase_ = 0.0f;     // [rad]
 103:./MotorControl/encoder.hpp ****     OutputPort<float> phase_vel_ = 0.0f; // [rad/s]
 104:./MotorControl/encoder.hpp ****     float pos_estimate_counts_ = 0.0f;  // [count]
 105:./MotorControl/encoder.hpp ****     float pos_cpr_counts_ = 0.0f;  // [count]
 106:./MotorControl/encoder.hpp ****     float delta_pos_cpr_counts_ = 0.0f;  // [count] phase detector result for debug
 107:./MotorControl/encoder.hpp ****     float vel_estimate_counts_ = 0.0f;  // [count/s]
 108:./MotorControl/encoder.hpp ****     float pll_kp_ = 0.0f;   // [count/s / count]
 109:./MotorControl/encoder.hpp ****     float pll_ki_ = 0.0f;   // [(count/s^2) / count]
ARM GAS  /tmp/ccawPiBL.s 			page 139


 110:./MotorControl/encoder.hpp ****     float calib_scan_response_ = 0.0f; // debug report from offset calib
 111:./MotorControl/encoder.hpp ****     int32_t pos_abs_ = 0;
 112:./MotorControl/encoder.hpp ****     float spi_error_rate_ = 0.0f;
 113:./MotorControl/encoder.hpp **** 
 114:./MotorControl/encoder.hpp ****     OutputPort<float> pos_estimate_ = 0.0f; // [turn]
 115:./MotorControl/encoder.hpp ****     OutputPort<float> vel_estimate_ = 0.0f; // [turn/s]
 116:./MotorControl/encoder.hpp ****     OutputPort<float> pos_circular_ = 0.0f; // [turn]
 117:./MotorControl/encoder.hpp **** 
 118:./MotorControl/encoder.hpp ****     bool pos_estimate_valid_ = false;
 119:./MotorControl/encoder.hpp ****     bool vel_estimate_valid_ = false;
 120:./MotorControl/encoder.hpp **** 
 121:./MotorControl/encoder.hpp ****     int16_t tim_cnt_sample_ = 0; // 
 122:./MotorControl/encoder.hpp ****     static const constexpr GPIO_TypeDef* ports_to_sample[] = { GPIOA, GPIOB, GPIOC };
 123:./MotorControl/encoder.hpp ****     uint16_t port_samples_[sizeof(ports_to_sample) / sizeof(ports_to_sample[0])];
 124:./MotorControl/encoder.hpp ****     // Updated by low_level pwm_adc_cb
 125:./MotorControl/encoder.hpp ****     uint8_t hall_state_ = 0x0; // bit[0] = HallA, .., bit[2] = HallC
 126:./MotorControl/encoder.hpp ****     std::optional<uint8_t> last_hall_cnt_ = std::nullopt; // Used to find hall edges for calibratio
 127:./MotorControl/encoder.hpp ****     bool calibrate_hall_phase_ = false;
 128:./MotorControl/encoder.hpp ****     bool sample_hall_states_ = false;
 129:./MotorControl/encoder.hpp ****     bool sample_hall_phase_ = false;
 130:./MotorControl/encoder.hpp ****     std::array<int, 8> states_seen_count_; // for hall polarity calibration
 131:./MotorControl/encoder.hpp ****     std::array<int, 6> hall_phase_calib_seen_count_;
 132:./MotorControl/encoder.hpp **** 
 133:./MotorControl/encoder.hpp ****     float sincos_sample_s_ = 0.0f;
 134:./MotorControl/encoder.hpp ****     float sincos_sample_c_ = 0.0f;
 135:./MotorControl/encoder.hpp **** 
 136:./MotorControl/encoder.hpp ****     bool abs_spi_start_transaction();
 137:./MotorControl/encoder.hpp ****     void abs_spi_cb(bool success);
 138:./MotorControl/encoder.hpp ****     void abs_spi_cs_pin_init();
 139:./MotorControl/encoder.hpp ****     bool abs_spi_pos_updated_ = false;
 140:./MotorControl/encoder.hpp ****     Mode mode_ = MODE_INCREMENTAL;
 141:./MotorControl/encoder.hpp ****     Stm32Gpio abs_spi_cs_gpio_;
 142:./MotorControl/encoder.hpp ****     uint32_t abs_spi_cr1;
 143:./MotorControl/encoder.hpp ****     uint32_t abs_spi_cr2;
 144:./MotorControl/encoder.hpp ****     uint16_t abs_spi_dma_tx_[1] = {0xFFFF};
 145:./MotorControl/encoder.hpp ****     uint16_t abs_spi_dma_rx_[1];
 146:./MotorControl/encoder.hpp ****     Stm32SpiArbiter::SpiTask spi_task_;
 147:./MotorControl/encoder.hpp **** 
 148:./MotorControl/encoder.hpp ****     constexpr float getCoggingRatio(){
 149:./MotorControl/encoder.hpp ****         return 1.0f / 3600.0f;
 934              		.loc 10 149 9 view .LVU195
  87:MotorControl/controller.cpp ****         input_vel_ = 0.0f;
 935              		.loc 3 87 48 is_stmt 0 view .LVU196
 936 0086 07EE903A 		vmov	s15, r3	@ int
 937 008a F8EE677A 		vcvt.f32.u32	s15, s15
 938 008e 9FED187A 		vldr.32	s14, .L61
 939 0092 67EE877A 		vmul.f32	s15, s15, s14
  87:MotorControl/controller.cpp ****         input_vel_ = 0.0f;
 940              		.loc 3 87 20 view .LVU197
 941 0096 00F54050 		add	r0, r0, #12288
 942              	.LVL75:
  87:MotorControl/controller.cpp ****         input_vel_ = 0.0f;
 943              		.loc 3 87 20 view .LVU198
 944 009a 00F61413 		addw	r3, r0, #2324
 945 009e C3ED007A 		vstr.32	s15, [r3]
  88:MotorControl/controller.cpp ****         input_torque_ = 0.0f;
 946              		.loc 3 88 9 is_stmt 1 view .LVU199
ARM GAS  /tmp/ccawPiBL.s 			page 140


  88:MotorControl/controller.cpp ****         input_torque_ = 0.0f;
 947              		.loc 3 88 20 is_stmt 0 view .LVU200
 948 00a2 00F61812 		addw	r2, r0, #2328
 949 00a6 0023     		movs	r3, #0
 950 00a8 1360     		str	r3, [r2]	@ float
  89:MotorControl/controller.cpp ****         input_pos_updated();
 951              		.loc 3 89 9 is_stmt 1 view .LVU201
  89:MotorControl/controller.cpp ****         input_pos_updated();
 952              		.loc 3 89 23 is_stmt 0 view .LVU202
 953 00aa 00F61C12 		addw	r2, r0, #2332
 954 00ae 1360     		str	r3, [r2]	@ float
  90:MotorControl/controller.cpp ****         return false;
 955              		.loc 3 90 9 is_stmt 1 view .LVU203
 956              	.LVL76:
 957              	.LBB575:
 958              	.LBI575:
  70:MotorControl/controller.hpp ****         input_pos_updated_ = true;
 959              		.loc 2 70 20 view .LVU204
 960              	.LBB576:
  71:MotorControl/controller.hpp ****     }
 961              		.loc 2 71 9 view .LVU205
  71:MotorControl/controller.hpp ****     }
 962              		.loc 2 71 28 is_stmt 0 view .LVU206
 963 00b0 0123     		movs	r3, #1
 964 00b2 80F83C39 		strb	r3, [r0, #2364]
 965              	.LVL77:
  71:MotorControl/controller.hpp ****     }
 966              		.loc 2 71 28 view .LVU207
 967              	.LBE576:
 968              	.LBE575:
  91:MotorControl/controller.cpp ****     } else {
 969              		.loc 3 91 9 is_stmt 1 view .LVU208
  91:MotorControl/controller.cpp ****     } else {
 970              		.loc 3 91 16 is_stmt 0 view .LVU209
 971 00b6 0020     		movs	r0, #0
 972              	.LVL78:
 973              	.L56:
 103:MotorControl/controller.cpp **** 
 974              		.loc 3 103 1 view .LVU210
 975 00b8 02B0     		add	sp, sp, #8
 976              	.LCFI9:
 977              		.cfi_remember_state
 978              		.cfi_def_cfa_offset 0
 979              		@ sp needed
 980 00ba 7047     		bx	lr
 981              	.LVL79:
 982              	.L57:
 983              	.LCFI10:
 984              		.cfi_restore_state
 985              	.LBB577:
 986              	.LBB574:
 987              		.loc 6 3683 29 view .LVU211
 988 00bc 6B46     		mov	r3, sp
 989 00be D7E7     		b	.L54
 990              	.LVL80:
 991              	.L55:
 992              		.loc 6 3683 29 view .LVU212
ARM GAS  /tmp/ccawPiBL.s 			page 141


 993              	.LBE574:
 994              	.LBE577:
  93:MotorControl/controller.cpp ****         config_.control_mode = CONTROL_MODE_POSITION_CONTROL;
 995              		.loc 3 93 9 is_stmt 1 view .LVU213
  93:MotorControl/controller.cpp ****         config_.control_mode = CONTROL_MODE_POSITION_CONTROL;
 996              		.loc 3 93 35 is_stmt 0 view .LVU214
 997 00c0 0021     		movs	r1, #0
 998 00c2 4165     		str	r1, [r0, #84]
  94:MotorControl/controller.cpp ****         input_pos_ = 0.0f;  // Send the motor home
 999              		.loc 3 94 9 is_stmt 1 view .LVU215
  94:MotorControl/controller.cpp ****         input_pos_ = 0.0f;  // Send the motor home
 1000              		.loc 3 94 30 is_stmt 0 view .LVU216
 1001 00c4 0323     		movs	r3, #3
 1002 00c6 0376     		strb	r3, [r0, #24]
  95:MotorControl/controller.cpp ****         input_vel_ = 0.0f;
 1003              		.loc 3 95 9 is_stmt 1 view .LVU217
  95:MotorControl/controller.cpp ****         input_vel_ = 0.0f;
 1004              		.loc 3 95 20 is_stmt 0 view .LVU218
 1005 00c8 00F54053 		add	r3, r0, #12288
 1006 00cc 03F61410 		addw	r0, r3, #2324
 1007              	.LVL81:
  95:MotorControl/controller.cpp ****         input_vel_ = 0.0f;
 1008              		.loc 3 95 20 view .LVU219
 1009 00d0 0022     		movs	r2, #0
 1010 00d2 0260     		str	r2, [r0]	@ float
  96:MotorControl/controller.cpp ****         input_torque_ = 0.0f;
 1011              		.loc 3 96 9 is_stmt 1 view .LVU220
  96:MotorControl/controller.cpp ****         input_torque_ = 0.0f;
 1012              		.loc 3 96 20 is_stmt 0 view .LVU221
 1013 00d4 03F61810 		addw	r0, r3, #2328
 1014 00d8 0260     		str	r2, [r0]	@ float
  97:MotorControl/controller.cpp ****         input_pos_updated();
 1015              		.loc 3 97 9 is_stmt 1 view .LVU222
  97:MotorControl/controller.cpp ****         input_pos_updated();
 1016              		.loc 3 97 23 is_stmt 0 view .LVU223
 1017 00da 03F61C10 		addw	r0, r3, #2332
 1018 00de 0260     		str	r2, [r0]	@ float
  98:MotorControl/controller.cpp ****         anticogging_valid_ = true;
 1019              		.loc 3 98 9 is_stmt 1 view .LVU224
 1020              	.LVL82:
 1021              	.LBB578:
 1022              	.LBI578:
  70:MotorControl/controller.hpp ****         input_pos_updated_ = true;
 1023              		.loc 2 70 20 view .LVU225
 1024              	.LBB579:
  71:MotorControl/controller.hpp ****     }
 1025              		.loc 2 71 9 view .LVU226
  71:MotorControl/controller.hpp ****     }
 1026              		.loc 2 71 28 is_stmt 0 view .LVU227
 1027 00e0 0120     		movs	r0, #1
 1028 00e2 83F83C09 		strb	r0, [r3, #2364]
 1029              	.LVL83:
  71:MotorControl/controller.hpp ****     }
 1030              		.loc 2 71 28 view .LVU228
 1031              	.LBE579:
 1032              	.LBE578:
  99:MotorControl/controller.cpp ****         config_.anticogging.calib_anticogging = false;
ARM GAS  /tmp/ccawPiBL.s 			page 142


 1033              		.loc 3 99 9 is_stmt 1 view .LVU229
  99:MotorControl/controller.cpp ****         config_.anticogging.calib_anticogging = false;
 1034              		.loc 3 99 28 is_stmt 0 view .LVU230
 1035 00e6 83F83E09 		strb	r0, [r3, #2366]
 100:MotorControl/controller.cpp ****         return true;
 1036              		.loc 3 100 9 is_stmt 1 view .LVU231
 100:MotorControl/controller.cpp ****         return true;
 1037              		.loc 3 100 47 is_stmt 0 view .LVU232
 1038 00ea 83F89918 		strb	r1, [r3, #2201]
 101:MotorControl/controller.cpp ****     }
 1039              		.loc 3 101 9 is_stmt 1 view .LVU233
 101:MotorControl/controller.cpp ****     }
 1040              		.loc 3 101 16 is_stmt 0 view .LVU234
 1041 00ee E3E7     		b	.L56
 1042              	.L62:
 1043              		.align	2
 1044              	.L61:
 1045 00f0 B4A29139 		.word	965845684
 1046              		.cfi_endproc
 1047              	.LFE5193:
 1048              		.cantunwind
 1049              		.fnend
 1051              		.global	__aeabi_f2lz
 1052              		.section	.text._ZN10Controller23set_input_pos_and_stepsEf,"ax",%progbits
 1053              		.align	1
 1054              		.global	_ZN10Controller23set_input_pos_and_stepsEf
 1055              		.syntax unified
 1056              		.thumb
 1057              		.thumb_func
 1059              	_ZN10Controller23set_input_pos_and_stepsEf:
 1060              		.fnstart
 1061              	.LVL84:
 1062              	.LFB5194:
 105:MotorControl/controller.cpp ****     input_pos_ = pos;
 1063              		.loc 3 105 59 is_stmt 1 view -0
 1064              		.cfi_startproc
 1065              		@ args = 0, pretend = 0, frame = 0
 1066              		@ frame_needed = 0, uses_anonymous_args = 0
 105:MotorControl/controller.cpp ****     input_pos_ = pos;
 1067              		.loc 3 105 59 is_stmt 0 view .LVU236
 1068 0000 10B5     		push	{r4, lr}
 1069              	.LCFI11:
 1070              		.cfi_def_cfa_offset 8
 1071              		.cfi_offset 4, -8
 1072              		.cfi_offset 14, -4
 106:MotorControl/controller.cpp ****     if (config_.circular_setpoints) {
 1073              		.loc 3 106 5 is_stmt 1 view .LVU237
 106:MotorControl/controller.cpp ****     if (config_.circular_setpoints) {
 1074              		.loc 3 106 16 is_stmt 0 view .LVU238
 1075 0002 00F56453 		add	r3, r0, #14592
 1076 0006 83ED050A 		vstr.32	s0, [r3, #20]
 107:MotorControl/controller.cpp ****         float const range = config_.circular_setpoint_range;
 1077              		.loc 3 107 5 is_stmt 1 view .LVU239
 1078              	.LBB580:
 107:MotorControl/controller.cpp ****         float const range = config_.circular_setpoint_range;
 1079              		.loc 3 107 17 is_stmt 0 view .LVU240
 1080 000a 90F83C30 		ldrb	r3, [r0, #60]	@ zero_extendqisi2
ARM GAS  /tmp/ccawPiBL.s 			page 143


 107:MotorControl/controller.cpp ****         float const range = config_.circular_setpoint_range;
 1081              		.loc 3 107 5 view .LVU241
 1082 000e 33B3     		cbz	r3, .L64
 1083              	.LBB581:
 108:MotorControl/controller.cpp ****         axis_->steps_ = (int64_t)(fmodf_pos(pos, range) / range * config_.steps_per_circular_range)
 1084              		.loc 3 108 9 is_stmt 1 view .LVU242
 108:MotorControl/controller.cpp ****         axis_->steps_ = (int64_t)(fmodf_pos(pos, range) / range * config_.steps_per_circular_range)
 1085              		.loc 3 108 21 is_stmt 0 view .LVU243
 1086 0010 90ED107A 		vldr.32	s14, [r0, #64]
 1087              	.LVL85:
 109:MotorControl/controller.cpp ****     } else {
 1088              		.loc 3 109 9 is_stmt 1 view .LVU244
 1089              	.LBB582:
 1090              	.LBI582:
 1091              		.file 11 "./MotorControl/utils.hpp"
   1:./MotorControl/utils.hpp **** #pragma once
   2:./MotorControl/utils.hpp **** 
   3:./MotorControl/utils.hpp **** #include <stdint.h>
   4:./MotorControl/utils.hpp **** #include <limits>
   5:./MotorControl/utils.hpp **** #include <algorithm>
   6:./MotorControl/utils.hpp **** #include <array>
   7:./MotorControl/utils.hpp **** #include <tuple>
   8:./MotorControl/utils.hpp **** #include <cmath>
   9:./MotorControl/utils.hpp **** 
  10:./MotorControl/utils.hpp **** /**
  11:./MotorControl/utils.hpp ****  * @brief Flash size register address
  12:./MotorControl/utils.hpp ****  */
  13:./MotorControl/utils.hpp **** #define ID_FLASH_ADDRESS (0x1FFF7A22)
  14:./MotorControl/utils.hpp **** 
  15:./MotorControl/utils.hpp **** /**
  16:./MotorControl/utils.hpp ****  * @brief Device ID register address
  17:./MotorControl/utils.hpp ****  */
  18:./MotorControl/utils.hpp **** #define ID_DBGMCU_IDCODE (0xE0042000)
  19:./MotorControl/utils.hpp **** 
  20:./MotorControl/utils.hpp **** /**
  21:./MotorControl/utils.hpp ****  * "Returns" the device signature
  22:./MotorControl/utils.hpp ****  *
  23:./MotorControl/utils.hpp ****  * Possible returns:
  24:./MotorControl/utils.hpp ****  *    - 0x0413: STM32F405xx/07xx and STM32F415xx/17xx)
  25:./MotorControl/utils.hpp ****  *    - 0x0419: STM32F42xxx and STM32F43xxx
  26:./MotorControl/utils.hpp ****  *    - 0x0423: STM32F401xB/C
  27:./MotorControl/utils.hpp ****  *    - 0x0433: STM32F401xD/E
  28:./MotorControl/utils.hpp ****  *    - 0x0431: STM32F411xC/E
  29:./MotorControl/utils.hpp ****  *
  30:./MotorControl/utils.hpp ****  * Returned data is in 16-bit mode, but only bits 11:0 are valid, bits 15:12 are always 0.
  31:./MotorControl/utils.hpp ****  * Defined as macro
  32:./MotorControl/utils.hpp ****  */
  33:./MotorControl/utils.hpp **** #define STM_ID_GetSignature() ((*(uint16_t *)(ID_DBGMCU_IDCODE)) & 0x0FFF)
  34:./MotorControl/utils.hpp **** 
  35:./MotorControl/utils.hpp **** /**
  36:./MotorControl/utils.hpp ****  * "Returns" the device revision
  37:./MotorControl/utils.hpp ****  *
  38:./MotorControl/utils.hpp ****  * Revisions possible:
  39:./MotorControl/utils.hpp ****  *    - 0x1000: Revision A
  40:./MotorControl/utils.hpp ****  *    - 0x1001: Revision Z
  41:./MotorControl/utils.hpp ****  *    - 0x1003: Revision Y
  42:./MotorControl/utils.hpp ****  *    - 0x1007: Revision 1
ARM GAS  /tmp/ccawPiBL.s 			page 144


  43:./MotorControl/utils.hpp ****  *    - 0x2001: Revision 3
  44:./MotorControl/utils.hpp ****  *
  45:./MotorControl/utils.hpp ****  * Returned data is in 16-bit mode.
  46:./MotorControl/utils.hpp ****  */
  47:./MotorControl/utils.hpp **** #define STM_ID_GetRevision() (*(uint16_t *)(ID_DBGMCU_IDCODE + 2))
  48:./MotorControl/utils.hpp **** 
  49:./MotorControl/utils.hpp **** /**
  50:./MotorControl/utils.hpp **** * "Returns" the Flash size
  51:./MotorControl/utils.hpp **** *
  52:./MotorControl/utils.hpp **** * Returned data is in 16-bit mode, returned value is flash size in kB (kilo bytes).
  53:./MotorControl/utils.hpp **** */
  54:./MotorControl/utils.hpp **** #define STM_ID_GetFlashSize() (*(uint16_t *)(ID_FLASH_ADDRESS))
  55:./MotorControl/utils.hpp **** 
  56:./MotorControl/utils.hpp **** #ifdef M_PI
  57:./MotorControl/utils.hpp **** #undef M_PI
  58:./MotorControl/utils.hpp **** #endif
  59:./MotorControl/utils.hpp **** 
  60:./MotorControl/utils.hpp **** // Math Constants
  61:./MotorControl/utils.hpp **** constexpr float M_PI = 3.14159265358979323846f;
  62:./MotorControl/utils.hpp **** constexpr float one_by_sqrt3 = 0.57735026919f;
  63:./MotorControl/utils.hpp **** constexpr float two_by_sqrt3 = 1.15470053838f;
  64:./MotorControl/utils.hpp **** constexpr float sqrt3_by_2 = 0.86602540378f;
  65:./MotorControl/utils.hpp **** 
  66:./MotorControl/utils.hpp **** // Function prototypes for implementations in utils.cpp
  67:./MotorControl/utils.hpp **** std::tuple<float, float, float, bool> SVM(float alpha, float beta);
  68:./MotorControl/utils.hpp **** float fast_atan2(float y, float x);
  69:./MotorControl/utils.hpp **** uint32_t deadline_to_timeout(uint32_t deadline_ms);
  70:./MotorControl/utils.hpp **** uint32_t timeout_to_deadline(uint32_t timeout_ms);
  71:./MotorControl/utils.hpp **** int is_in_the_future(uint32_t time_ms);
  72:./MotorControl/utils.hpp **** uint32_t micros(void);
  73:./MotorControl/utils.hpp **** void delay_us(uint32_t us);
  74:./MotorControl/utils.hpp **** 
  75:./MotorControl/utils.hpp **** extern "C" {
  76:./MotorControl/utils.hpp **** float our_arm_sin_f32(float x);
  77:./MotorControl/utils.hpp **** float our_arm_cos_f32(float x);
  78:./MotorControl/utils.hpp **** }
  79:./MotorControl/utils.hpp **** 
  80:./MotorControl/utils.hpp **** // ----------------
  81:./MotorControl/utils.hpp **** // Inline functions
  82:./MotorControl/utils.hpp **** 
  83:./MotorControl/utils.hpp **** template<typename T>
  84:./MotorControl/utils.hpp **** constexpr T SQ(const T& x){
  85:./MotorControl/utils.hpp ****     return x * x;
  86:./MotorControl/utils.hpp **** }
  87:./MotorControl/utils.hpp **** 
  88:./MotorControl/utils.hpp **** /**
  89:./MotorControl/utils.hpp ****  * @brief Small helper to make array with known size
  90:./MotorControl/utils.hpp ****  * in contrast to initializer lists the number of arguments
  91:./MotorControl/utils.hpp ****  * has to match exactly. Whereas initializer lists allow
  92:./MotorControl/utils.hpp ****  * less arguments.
  93:./MotorControl/utils.hpp ****  */
  94:./MotorControl/utils.hpp **** template <class T, class... Tail>
  95:./MotorControl/utils.hpp **** std::array<T, 1 + sizeof...(Tail)> make_array(T head, Tail... tail) {
  96:./MotorControl/utils.hpp ****     return std::array<T, 1 + sizeof...(Tail)>({head, tail...});
  97:./MotorControl/utils.hpp **** }
  98:./MotorControl/utils.hpp **** 
  99:./MotorControl/utils.hpp **** // To allow use of -ffast-math we need to have a special check for nan
ARM GAS  /tmp/ccawPiBL.s 			page 145


 100:./MotorControl/utils.hpp **** // that bypasses the "ignore nan" flag
 101:./MotorControl/utils.hpp **** __attribute__((optimize("-fno-finite-math-only")))
 102:./MotorControl/utils.hpp **** inline bool is_nan(float x) {
 103:./MotorControl/utils.hpp ****     return __builtin_isnan(x);
 104:./MotorControl/utils.hpp **** }
 105:./MotorControl/utils.hpp **** 
 106:./MotorControl/utils.hpp **** // Round to integer
 107:./MotorControl/utils.hpp **** // Default rounding mode: round to nearest
 108:./MotorControl/utils.hpp **** inline int round_int(float x) {
 109:./MotorControl/utils.hpp **** #ifdef __arm__
 110:./MotorControl/utils.hpp ****     int res;
 111:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 112:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 113:./MotorControl/utils.hpp ****         : [x] "w" (x) );
 114:./MotorControl/utils.hpp ****     return res;
 115:./MotorControl/utils.hpp **** #else
 116:./MotorControl/utils.hpp ****     return (int)nearbyint(x);
 117:./MotorControl/utils.hpp **** #endif
 118:./MotorControl/utils.hpp **** }
 119:./MotorControl/utils.hpp **** 
 120:./MotorControl/utils.hpp **** // Wrap value to range.
 121:./MotorControl/utils.hpp **** // With default rounding mode (round to nearest),
 122:./MotorControl/utils.hpp **** // the result will be in range -y/2 to y/2
 123:./MotorControl/utils.hpp **** inline float wrap_pm(float x, float y) {
 124:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 125:./MotorControl/utils.hpp ****     float intval = (float)round_int(x / y);
 126:./MotorControl/utils.hpp **** #else
 127:./MotorControl/utils.hpp ****     float intval = nearbyintf(x / y);
 128:./MotorControl/utils.hpp **** #endif
 129:./MotorControl/utils.hpp ****     return x - intval * y;
 130:./MotorControl/utils.hpp **** }
 131:./MotorControl/utils.hpp **** 
 132:./MotorControl/utils.hpp **** // Same as fmodf but result is positive and y must be positive
 133:./MotorControl/utils.hpp **** inline float fmodf_pos(float x, float y) {
 1092              		.loc 11 133 14 view .LVU245
 1093              	.LBB583:
 134:./MotorControl/utils.hpp ****     float res = wrap_pm(x, y);
 1094              		.loc 11 134 5 view .LVU246
 1095              	.LBB584:
 1096              	.LBI584:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 1097              		.loc 11 123 14 view .LVU247
 1098              	.LBB585:
 125:./MotorControl/utils.hpp **** #else
 1099              		.loc 11 125 5 view .LVU248
 125:./MotorControl/utils.hpp **** #else
 1100              		.loc 11 125 36 is_stmt 0 view .LVU249
 1101 0014 C0EE077A 		vdiv.f32	s15, s0, s14
 1102              	.LVL86:
 1103              	.LBB586:
 1104              	.LBI586:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 1105              		.loc 11 108 12 is_stmt 1 view .LVU250
 1106              	.LBB587:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 1107              		.loc 11 110 5 view .LVU251
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
ARM GAS  /tmp/ccawPiBL.s 			page 146


 1108              		.loc 11 111 5 view .LVU252
 1109              		.syntax unified
 1110              	@ 111 "./MotorControl/utils.hpp" 1
 1111 0018 FDEE677A 		vcvtr.s32.f32   s15, s15
 1112              	@ 0 "" 2
 1113              	.LVL87:
 114:./MotorControl/utils.hpp **** #else
 1114              		.loc 11 114 5 view .LVU253
 114:./MotorControl/utils.hpp **** #else
 1115              		.loc 11 114 5 is_stmt 0 view .LVU254
 1116              		.thumb
 1117              		.syntax unified
 1118              	.LBE587:
 1119              	.LBE586:
 125:./MotorControl/utils.hpp **** #else
 1120              		.loc 11 125 42 view .LVU255
 1121 001c F8EEE77A 		vcvt.f32.s32	s15, s15
 1122              	.LVL88:
 129:./MotorControl/utils.hpp **** }
 1123              		.loc 11 129 5 is_stmt 1 view .LVU256
 129:./MotorControl/utils.hpp **** }
 1124              		.loc 11 129 23 is_stmt 0 view .LVU257
 1125 0020 67EE277A 		vmul.f32	s15, s14, s15
 1126              	.LVL89:
 129:./MotorControl/utils.hpp **** }
 1127              		.loc 11 129 25 view .LVU258
 1128 0024 30EE670A 		vsub.f32	s0, s0, s15
 1129              	.LVL90:
 129:./MotorControl/utils.hpp **** }
 1130              		.loc 11 129 25 view .LVU259
 1131              	.LBE585:
 1132              	.LBE584:
 135:./MotorControl/utils.hpp ****     if (res < 0) res += y;
 1133              		.loc 11 135 5 is_stmt 1 view .LVU260
 1134 0028 B5EEC00A 		vcmpe.f32	s0, #0
 1135 002c F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 1136 0030 12D4     		bmi	.L70
 1137              	.L65:
 136:./MotorControl/utils.hpp ****     return res;
 1138              		.loc 11 136 5 view .LVU261
 1139              	.LVL91:
 1140              		.loc 11 136 5 is_stmt 0 view .LVU262
 1141              	.LBE583:
 1142              	.LBE582:
 109:MotorControl/controller.cpp ****     } else {
 1143              		.loc 3 109 57 view .LVU263
 1144 0032 C0EE076A 		vdiv.f32	s13, s0, s14
 109:MotorControl/controller.cpp ****     } else {
 1145              		.loc 3 109 65 view .LVU264
 1146 0036 D0ED117A 		vldr.32	s15, [r0, #68]	@ int
 1147 003a F8EE677A 		vcvt.f32.u32	s15, s15
 109:MotorControl/controller.cpp ****     } else {
 1148              		.loc 3 109 9 view .LVU265
 1149 003e 00F54050 		add	r0, r0, #12288
 1150              	.LVL92:
 109:MotorControl/controller.cpp ****     } else {
 1151              		.loc 3 109 9 view .LVU266
ARM GAS  /tmp/ccawPiBL.s 			page 147


 1152 0042 D0F8D848 		ldr	r4, [r0, #2264]
 109:MotorControl/controller.cpp ****     } else {
 1153              		.loc 3 109 25 view .LVU267
 1154 0046 67EEA67A 		vmul.f32	s15, s15, s13
 1155 004a 17EE900A 		vmov	r0, s15
 1156              	.LVL93:
 109:MotorControl/controller.cpp ****     } else {
 1157              		.loc 3 109 25 view .LVU268
 1158 004e FFF7FEFF 		bl	__aeabi_f2lz
 1159              	.LVL94:
 109:MotorControl/controller.cpp ****     } else {
 1160              		.loc 3 109 23 view .LVU269
 1161 0052 C4E99401 		strd	r0, [r4, #592]
 1162              	.L63:
 109:MotorControl/controller.cpp ****     } else {
 1163              		.loc 3 109 23 view .LVU270
 1164              	.LBE581:
 1165              	.LBE580:
 113:MotorControl/controller.cpp **** 
 1166              		.loc 3 113 1 view .LVU271
 1167 0056 10BD     		pop	{r4, pc}
 1168              	.LVL95:
 1169              	.L70:
 1170              	.LBB591:
 1171              	.LBB590:
 1172              	.LBB589:
 1173              	.LBB588:
 135:./MotorControl/utils.hpp ****     return res;
 1174              		.loc 11 135 18 is_stmt 1 view .LVU272
 135:./MotorControl/utils.hpp ****     return res;
 1175              		.loc 11 135 22 is_stmt 0 view .LVU273
 1176 0058 30EE070A 		vadd.f32	s0, s0, s14
 1177              	.LVL96:
 135:./MotorControl/utils.hpp ****     return res;
 1178              		.loc 11 135 22 view .LVU274
 1179 005c E9E7     		b	.L65
 1180              	.LVL97:
 1181              	.L64:
 135:./MotorControl/utils.hpp ****     return res;
 1182              		.loc 11 135 22 view .LVU275
 1183              	.LBE588:
 1184              	.LBE589:
 1185              	.LBE590:
 111:MotorControl/controller.cpp ****     }
 1186              		.loc 3 111 9 is_stmt 1 view .LVU276
 111:MotorControl/controller.cpp ****     }
 1187              		.loc 3 111 39 is_stmt 0 view .LVU277
 1188 005e D0ED117A 		vldr.32	s15, [r0, #68]	@ int
 1189 0062 F8EE677A 		vcvt.f32.u32	s15, s15
 111:MotorControl/controller.cpp ****     }
 1190              		.loc 3 111 9 view .LVU278
 1191 0066 00F54050 		add	r0, r0, #12288
 1192              	.LVL98:
 111:MotorControl/controller.cpp ****     }
 1193              		.loc 3 111 9 view .LVU279
 1194 006a D0F8D848 		ldr	r4, [r0, #2264]
 111:MotorControl/controller.cpp ****     }
ARM GAS  /tmp/ccawPiBL.s 			page 148


 1195              		.loc 3 111 25 view .LVU280
 1196 006e 67EE807A 		vmul.f32	s15, s15, s0
 1197 0072 17EE900A 		vmov	r0, s15
 1198              	.LVL99:
 111:MotorControl/controller.cpp ****     }
 1199              		.loc 3 111 25 view .LVU281
 1200 0076 FFF7FEFF 		bl	__aeabi_f2lz
 1201              	.LVL100:
 111:MotorControl/controller.cpp ****     }
 1202              		.loc 3 111 23 view .LVU282
 1203 007a C4E99401 		strd	r0, [r4, #592]
 1204              	.LBE591:
 113:MotorControl/controller.cpp **** 
 1205              		.loc 3 113 1 view .LVU283
 1206 007e EAE7     		b	.L63
 1207              		.cfi_endproc
 1208              	.LFE5194:
 1209              		.cantunwind
 1210              		.fnend
 1212              		.section	.rodata._ZN10Controller20control_mode_updatedEv.str1.4,"aMS",%progbits,1
 1213              		.align	2
 1214              	.LC0:
 1215 0000 7374643A 		.ascii	"std::get: wrong index for variant\000"
 1215      3A676574 
 1215      3A207772 
 1215      6F6E6720 
 1215      696E6465 
 1216              		.section	.text._ZN10Controller20control_mode_updatedEv,"ax",%progbits
 1217              		.align	1
 1218              		.global	_ZN10Controller20control_mode_updatedEv
 1219              		.syntax unified
 1220              		.thumb
 1221              		.thumb_func
 1223              	_ZN10Controller20control_mode_updatedEv:
 1224              		.fnstart
 1225              	.LVL101:
 1226              	.LFB5195:
 115:MotorControl/controller.cpp ****     if (config_.control_mode >= CONTROL_MODE_POSITION_CONTROL) {
 1227              		.loc 3 115 41 is_stmt 1 view -0
 1228              		.cfi_startproc
 1229              		@ args = 0, pretend = 0, frame = 8
 1230              		@ frame_needed = 0, uses_anonymous_args = 0
 115:MotorControl/controller.cpp ****     if (config_.control_mode >= CONTROL_MODE_POSITION_CONTROL) {
 1231              		.loc 3 115 41 is_stmt 0 view .LVU285
 1232 0000 10B5     		push	{r4, lr}
 1233              		.save {r4, lr}
 1234              	.LCFI12:
 1235              		.cfi_def_cfa_offset 8
 1236              		.cfi_offset 4, -8
 1237              		.cfi_offset 14, -4
 1238              		.pad #8
 1239 0002 82B0     		sub	sp, sp, #8
 1240              	.LCFI13:
 1241              		.cfi_def_cfa_offset 16
 116:MotorControl/controller.cpp ****         std::optional<float> estimate = (config_.circular_setpoints ?
 1242              		.loc 3 116 5 is_stmt 1 view .LVU286
 1243              	.LBB721:
ARM GAS  /tmp/ccawPiBL.s 			page 149


 116:MotorControl/controller.cpp ****         std::optional<float> estimate = (config_.circular_setpoints ?
 1244              		.loc 3 116 17 is_stmt 0 view .LVU287
 1245 0004 037E     		ldrb	r3, [r0, #24]	@ zero_extendqisi2
 116:MotorControl/controller.cpp ****         std::optional<float> estimate = (config_.circular_setpoints ?
 1246              		.loc 3 116 5 view .LVU288
 1247 0006 022B     		cmp	r3, #2
 1248 0008 47D9     		bls	.L84
 1249              	.LBB722:
 117:MotorControl/controller.cpp ****                                 pos_estimate_circular_src_ :
 1250              		.loc 3 117 9 is_stmt 1 view .LVU289
 117:MotorControl/controller.cpp ****                                 pos_estimate_circular_src_ :
 1251              		.loc 3 117 50 is_stmt 0 view .LVU290
 1252 000a 90F83C30 		ldrb	r3, [r0, #60]	@ zero_extendqisi2
 119:MotorControl/controller.cpp ****         if (!estimate.has_value()) {
 1253              		.loc 3 119 63 view .LVU291
 1254 000e DBB1     		cbz	r3, .L73
 119:MotorControl/controller.cpp ****         if (!estimate.has_value()) {
 1255              		.loc 3 119 63 discriminator 1 view .LVU292
 1256 0010 00F56353 		add	r3, r0, #14528
 1257 0014 2C33     		adds	r3, r3, #44
 1258              	.L74:
 1259              	.LVL102:
 1260              	.LBB723:
 1261              	.LBI723:
 1262              		.file 12 "./MotorControl/component.hpp"
   1:./MotorControl/component.hpp **** #ifndef __COMPONENT_HPP
   2:./MotorControl/component.hpp **** #define __COMPONENT_HPP
   3:./MotorControl/component.hpp **** 
   4:./MotorControl/component.hpp **** #include <stdint.h>
   5:./MotorControl/component.hpp **** #include <optional>
   6:./MotorControl/component.hpp **** #include <variant>
   7:./MotorControl/component.hpp **** 
   8:./MotorControl/component.hpp **** class ComponentBase {
   9:./MotorControl/component.hpp **** public:
  10:./MotorControl/component.hpp ****     /**
  11:./MotorControl/component.hpp ****      * @brief Shall run the update action of this component.
  12:./MotorControl/component.hpp ****      * 
  13:./MotorControl/component.hpp ****      * This function gets called in a low priority interrupt context and is
  14:./MotorControl/component.hpp ****      * allowed to call CMSIS functions.
  15:./MotorControl/component.hpp ****      * 
  16:./MotorControl/component.hpp ****      * @param timestamp: The timestamp (in HCLK ticks) for which this update
  17:./MotorControl/component.hpp ****      * is run.
  18:./MotorControl/component.hpp ****      */
  19:./MotorControl/component.hpp ****     virtual void update(uint32_t timestamp) = 0;
  20:./MotorControl/component.hpp **** };
  21:./MotorControl/component.hpp **** 
  22:./MotorControl/component.hpp **** 
  23:./MotorControl/component.hpp **** template<typename T>
  24:./MotorControl/component.hpp **** class InputPort;
  25:./MotorControl/component.hpp **** 
  26:./MotorControl/component.hpp **** /**
  27:./MotorControl/component.hpp ****  * @brief An output port stores a value for consumption by a connecting input
  28:./MotorControl/component.hpp ****  * port.
  29:./MotorControl/component.hpp ****  * 
  30:./MotorControl/component.hpp ****  * Output ports are supposed to be reset at the beginning of a control loop
  31:./MotorControl/component.hpp ****  * iteration. This ensures that connecting input ports don't use an outdated
  32:./MotorControl/component.hpp ****  * value and, more importantly, ensures proper handling if the producer of the
ARM GAS  /tmp/ccawPiBL.s 			page 150


  33:./MotorControl/component.hpp ****  * value is incapable of producing the value for any reason.
  34:./MotorControl/component.hpp ****  * 
  35:./MotorControl/component.hpp ****  * Member functions of this class are not thread-safe unless noted otherwise.
  36:./MotorControl/component.hpp ****  */
  37:./MotorControl/component.hpp **** template<typename T>
  38:./MotorControl/component.hpp **** class OutputPort {
  39:./MotorControl/component.hpp **** public:
  40:./MotorControl/component.hpp ****     /**
  41:./MotorControl/component.hpp ****      * @brief Initializes the output port with the specified value.
  42:./MotorControl/component.hpp ****      * 
  43:./MotorControl/component.hpp ****      * An initialization value is required for any() to work properly.
  44:./MotorControl/component.hpp ****      * present() and previous() cannot be used to fetch the
  45:./MotorControl/component.hpp ****      * initialization value.
  46:./MotorControl/component.hpp ****      */
  47:./MotorControl/component.hpp ****     OutputPort(T val) : content_(val) {}
  48:./MotorControl/component.hpp ****     
  49:./MotorControl/component.hpp ****     /**
  50:./MotorControl/component.hpp ****      * @brief Updates the underlying value of this output port.
  51:./MotorControl/component.hpp ****      */
  52:./MotorControl/component.hpp ****     void operator=(T value) {
  53:./MotorControl/component.hpp ****         content_ = value;
  54:./MotorControl/component.hpp ****         age_ = 0;
  55:./MotorControl/component.hpp ****     }
  56:./MotorControl/component.hpp **** 
  57:./MotorControl/component.hpp ****     /**
  58:./MotorControl/component.hpp ****      * @brief Marks the contained value as outdated. The value is not actually
  59:./MotorControl/component.hpp ****      * deleted and can still be accessed through some of the member functions
  60:./MotorControl/component.hpp ****      * of this class.
  61:./MotorControl/component.hpp ****      */
  62:./MotorControl/component.hpp ****     void reset() {
  63:./MotorControl/component.hpp ****         // This will eventually overflow to 0 so present() could
  64:./MotorControl/component.hpp ****         // theoretically return a very old value however it is very likely that
  65:./MotorControl/component.hpp ****         // the motor will be long disarmed by then.
  66:./MotorControl/component.hpp ****         age_++;
  67:./MotorControl/component.hpp ****     }
  68:./MotorControl/component.hpp **** 
  69:./MotorControl/component.hpp ****     /**
  70:./MotorControl/component.hpp ****      * @brief Returns the value from this control loop iteration or std::nullopt
  71:./MotorControl/component.hpp ****      * if the value was not yet set during this control loop iteration.
  72:./MotorControl/component.hpp ****      */
  73:./MotorControl/component.hpp ****     std::optional<T> present() {
  74:./MotorControl/component.hpp ****         if (age_ == 0) {
  75:./MotorControl/component.hpp ****             return content_;
  76:./MotorControl/component.hpp ****         } else {
  77:./MotorControl/component.hpp ****             return std::nullopt;
  78:./MotorControl/component.hpp ****         }
  79:./MotorControl/component.hpp ****     }
  80:./MotorControl/component.hpp **** 
  81:./MotorControl/component.hpp ****     /**
  82:./MotorControl/component.hpp ****      * @brief Returns the value from exactly the previous control loop iteration.
  83:./MotorControl/component.hpp ****      * 
  84:./MotorControl/component.hpp ****      * If during the last iteration no value was set or the value was already
  85:./MotorControl/component.hpp ****      * overwritten during this control loop iteration then this function returns
  86:./MotorControl/component.hpp ****      * std::nullopt.
  87:./MotorControl/component.hpp ****      */
  88:./MotorControl/component.hpp ****     std::optional<T> previous() {
  89:./MotorControl/component.hpp ****         if (age_ == 1) {
ARM GAS  /tmp/ccawPiBL.s 			page 151


  90:./MotorControl/component.hpp ****             return content_;
  91:./MotorControl/component.hpp ****         } else {
  92:./MotorControl/component.hpp ****             return std::nullopt;
  93:./MotorControl/component.hpp ****         }
  94:./MotorControl/component.hpp ****     }
  95:./MotorControl/component.hpp **** 
  96:./MotorControl/component.hpp ****     /**
  97:./MotorControl/component.hpp ****      * @brief Returns the value contained in this output port with disregard of
  98:./MotorControl/component.hpp ****      * when the value was set.
  99:./MotorControl/component.hpp ****      * 
 100:./MotorControl/component.hpp ****      * This function is thread-safe if load/store operations of T are atomic.
 101:./MotorControl/component.hpp ****      */
 102:./MotorControl/component.hpp ****     std::optional<T> any() {
 103:./MotorControl/component.hpp ****         return content_;
 104:./MotorControl/component.hpp ****     }
 105:./MotorControl/component.hpp ****     
 106:./MotorControl/component.hpp **** private:
 107:./MotorControl/component.hpp ****     uint32_t age_ = 2; // Age in number of control loop iterations
 108:./MotorControl/component.hpp ****     T content_;
 109:./MotorControl/component.hpp **** };
 110:./MotorControl/component.hpp **** 
 111:./MotorControl/component.hpp **** /**
 112:./MotorControl/component.hpp ****  * @brief An input port provides a value from the source to which it's configured.
 113:./MotorControl/component.hpp ****  * 
 114:./MotorControl/component.hpp ****  * The source can be one of:
 115:./MotorControl/component.hpp ****  *  - an internally stored value
 116:./MotorControl/component.hpp ****  *  - an externally stored value (referenced by a pointer)
 117:./MotorControl/component.hpp ****  *  - an external OutputPort (referenced by a pointer)
 118:./MotorControl/component.hpp ****  *  - none (all queries will return std::nullopt)
 119:./MotorControl/component.hpp ****  * 
 120:./MotorControl/component.hpp ****  * Member functions of this class are not thread-safe unless otherwise noted.
 121:./MotorControl/component.hpp ****  */
 122:./MotorControl/component.hpp **** template<typename T>
 123:./MotorControl/component.hpp **** class InputPort {
 124:./MotorControl/component.hpp **** public:
 125:./MotorControl/component.hpp ****     void connect_to(OutputPort<T>* input_port) {
 126:./MotorControl/component.hpp ****         content_ = input_port;
 127:./MotorControl/component.hpp ****     }
 128:./MotorControl/component.hpp **** 
 129:./MotorControl/component.hpp ****     void connect_to(T* input_ptr) {
 130:./MotorControl/component.hpp ****         content_ = input_ptr;
 131:./MotorControl/component.hpp ****     }
 132:./MotorControl/component.hpp **** 
 133:./MotorControl/component.hpp ****     void disconnect() {
 134:./MotorControl/component.hpp ****         content_ = (OutputPort<T>*)nullptr;
 135:./MotorControl/component.hpp ****     }
 136:./MotorControl/component.hpp **** 
 137:./MotorControl/component.hpp ****     std::optional<T> present() {
 138:./MotorControl/component.hpp ****         if (content_.index() == 2) {
 139:./MotorControl/component.hpp ****             OutputPort<T>* ptr = std::get<2>(content_);
 140:./MotorControl/component.hpp ****             return ptr ? ptr->present() : std::nullopt;
 141:./MotorControl/component.hpp ****         } else if (content_.index() == 1) {
 142:./MotorControl/component.hpp ****             T* ptr = std::get<1>(content_);
 143:./MotorControl/component.hpp ****             return ptr ? std::make_optional(*ptr) : std::nullopt;
 144:./MotorControl/component.hpp ****         } else {
 145:./MotorControl/component.hpp ****             return std::get<0>(content_);
 146:./MotorControl/component.hpp ****         }
ARM GAS  /tmp/ccawPiBL.s 			page 152


 147:./MotorControl/component.hpp ****     }
 148:./MotorControl/component.hpp **** 
 149:./MotorControl/component.hpp ****     // TODO: probably it makes sense to let the application define that it's
 150:./MotorControl/component.hpp ****     // ok for this input port to fetch the value from the last iteration.
 151:./MotorControl/component.hpp ****     // This would provide a general way to resolve same-iteration data path cycles.
 152:./MotorControl/component.hpp **** 
 153:./MotorControl/component.hpp ****     //std::optional<T> previous() {
 154:./MotorControl/component.hpp ****     //    if (content_.index() == 2) {
 155:./MotorControl/component.hpp ****     //        OutputPort<T>* ptr = std::get<2>(content_);
 156:./MotorControl/component.hpp ****     //        return ptr ? ptr->previous() : std::nullopt;
 157:./MotorControl/component.hpp ****     //    } else if (content_.index() == 1) {
 158:./MotorControl/component.hpp ****     //        T* ptr = std::get<1>(content_);
 159:./MotorControl/component.hpp ****     //        return ptr ? std::make_optional(*ptr) : std::nullopt;
 160:./MotorControl/component.hpp ****     //    } else {
 161:./MotorControl/component.hpp ****     //        return std::get<0>(content_);
 162:./MotorControl/component.hpp ****     //    }
 163:./MotorControl/component.hpp ****     //}
 164:./MotorControl/component.hpp **** 
 165:./MotorControl/component.hpp ****     std::optional<T> any() {
 1263              		.loc 12 165 22 is_stmt 1 discriminator 4 view .LVU293
 1264              	.LBB724:
 1265              	.LBB725:
 1266              	.LBI725:
1285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   inline void
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   __throw_bad_variant_access(bool __valueless)
1288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     if (__valueless) [[__unlikely__]]
1290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
1291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     else
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: wrong index for variant");
1293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
1294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<typename... _Types>
1296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     class variant
1297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     : private __detail::__variant::_Variant_base<_Types...>,
1298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       private _Enable_default_constructor<
1299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_default_ctor,
1300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  variant<_Types...>>,
1301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       private _Enable_copy_move<
1302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_copy_ctor,
1303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_copy_assign,
1304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_move_ctor,
1305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::_Traits<_Types...>::_S_move_assign,
1306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant<_Types...>>
1307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     private:
1309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template <typename... _UTypes, typename _Tp>
1310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend decltype(auto) __variant_cast(_Tp&&);
1311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename _Variant, typename... _Args>
1312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend void __variant_construct_by_index(_Variant& __v,
1313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						 _Args&&... __args);
1314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(sizeof...(_Types) > 0,
1316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "variant must have at least one alternative");
1317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!(std::is_reference_v<_Types> || ...),
1318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "variant must have no reference alternative");
ARM GAS  /tmp/ccawPiBL.s 			page 153


1319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(!(std::is_void_v<_Types> || ...),
1320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "variant must have no void alternative");
1321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base = __detail::__variant::_Variant_base<_Types...>;
1323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Default_ctor_enabler =
1324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Enable_default_constructor<
1325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __detail::__variant::_Traits<_Types...>::_S_default_ctor,
1326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    variant<_Types...>>;
1327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr bool __not_self
1330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  = !is_same_v<__remove_cvref_t<_Tp>, variant>;
1331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr bool
1334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__exactly_once = __detail::__variant::__exactly_once<_Tp, _Types...>;
1335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr size_t __accepted_index
1338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  = __detail::__variant::__accepted_index<_Tp, variant>::value;
1339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename = enable_if_t<(_Np < sizeof...(_Types))>>
1341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	using __to_type = variant_alternative_t<_Np, variant>;
1342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename = enable_if_t<__not_self<_Tp>>>
1344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	using __accepted_type = __to_type<__accepted_index<_Tp>>;
1345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr size_t __index_of =
1348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  __detail::__variant::__index_of_v<_Tp, _Types...>;
1349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Traits = __detail::__variant::_Traits<_Types...>;
1351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __is_in_place_tag : false_type { };
1354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __is_in_place_tag<in_place_type_t<_Tp>> : true_type { };
1356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np>
1357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	struct __is_in_place_tag<in_place_index_t<_Np>> : true_type { };
1358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	static constexpr bool __not_in_place_tag
1361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  = !__is_in_place_tag<__remove_cvref_t<_Tp>>::value;
1362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     public:
1364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant() = default;
1365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant(const variant& __rhs) = default;
1366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant(variant&&) = default;
1367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant& operator=(const variant&) = default;
1368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       variant& operator=(variant&&) = default;
1369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       ~variant() = default;
1370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp,
1372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<sizeof...(_Types) != 0>,
1373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<__not_in_place_tag<_Tp>>,
1374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename _Tj = __accepted_type<_Tp&&>,
1375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<__exactly_once<_Tj>
ARM GAS  /tmp/ccawPiBL.s 			page 154


1376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				      && is_constructible_v<_Tj, _Tp>>>
1377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr
1378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(_Tp&& __t)
1379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	noexcept(is_nothrow_constructible_v<_Tj, _Tp>)
1380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: variant(in_place_index<__accepted_index<_Tp>>,
1381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Tp>(__t))
1382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
1383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename... _Args,
1385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<__exactly_once<_Tp>
1386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				      && is_constructible_v<_Tp, _Args...>>>
1387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
1388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(in_place_type_t<_Tp>, _Args&&... __args)
1389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: variant(in_place_index<__index_of<_Tp>>,
1390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...)
1391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
1392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename _Up, typename... _Args,
1394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<__exactly_once<_Tp>
1395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				      && is_constructible_v<_Tp,
1396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 					   initializer_list<_Up>&, _Args...>>>
1397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
1398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(in_place_type_t<_Tp>, initializer_list<_Up> __il,
1399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		_Args&&... __args)
1400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: variant(in_place_index<__index_of<_Tp>>, __il,
1401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...)
1402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
1403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args,
1405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename _Tp = __to_type<_Np>,
1406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<is_constructible_v<_Tp, _Args...>>>
1407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
1408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(in_place_index_t<_Np>, _Args&&... __args)
1409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _Base(in_place_index<_Np>, std::forward<_Args>(__args)...),
1410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Default_ctor_enabler(_Enable_default_constructor_tag{})
1411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
1412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename _Up, typename... _Args,
1414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename _Tp = __to_type<_Np>,
1415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       typename = enable_if_t<is_constructible_v<_Tp,
1416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 							 initializer_list<_Up>&,
1417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 							 _Args...>>>
1418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	constexpr explicit
1419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	variant(in_place_index_t<_Np>, initializer_list<_Up> __il,
1420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		_Args&&... __args)
1421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	: _Base(in_place_index<_Np>, __il, std::forward<_Args>(__args)...),
1422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	_Default_ctor_enabler(_Enable_default_constructor_tag{})
1423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{ }
1424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp>
1426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<__exactly_once<__accepted_type<_Tp&&>>
1427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    && is_constructible_v<__accepted_type<_Tp&&>, _Tp>
1428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    && is_assignable_v<__accepted_type<_Tp&&>&, _Tp>,
1429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    variant&>
1430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	operator=(_Tp&& __rhs)
1431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
1432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		 && is_nothrow_constructible_v<__accepted_type<_Tp&&>, _Tp>)
ARM GAS  /tmp/ccawPiBL.s 			page 155


1433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  constexpr auto __index = __accepted_index<_Tp>;
1435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if (index() == __index)
1436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
1437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
1438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      using _Tj = __accepted_type<_Tp&&>;
1440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      if constexpr (is_nothrow_constructible_v<_Tj, _Tp>
1441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			    || !is_nothrow_move_constructible_v<_Tj>)
1442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		this->emplace<__index>(std::forward<_Tp>(__rhs));
1443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      else
1444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		operator=(variant(std::forward<_Tp>(__rhs)));
1445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return *this;
1447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename... _Args>
1450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<is_constructible_v<_Tp, _Args...> && __exactly_once<_Tp>,
1451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    _Tp&>
1452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	emplace(_Args&&... __args)
1453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  constexpr size_t __index = __index_of<_Tp>;
1455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return this->emplace<__index>(std::forward<_Args>(__args)...);
1456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Tp, typename _Up, typename... _Args>
1459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>
1460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    && __exactly_once<_Tp>,
1461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    _Tp&>
1462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	emplace(initializer_list<_Up> __il, _Args&&... __args)
1463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  constexpr size_t __index = __index_of<_Tp>;
1465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return this->emplace<__index>(__il, std::forward<_Args>(__args)...);
1466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename... _Args>
1469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<is_constructible_v<variant_alternative_t<_Np, variant>,
1470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				       _Args...>,
1471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    variant_alternative_t<_Np, variant>&>
1472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	emplace(_Args&&... __args)
1473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  static_assert(_Np < sizeof...(_Types),
1475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			"The index must be in [0, number of alternatives)");
1476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  using type = variant_alternative_t<_Np, variant>;
1477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // Provide the strong exception-safety guarantee when possible,
1478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // to avoid becoming valueless.
1479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (is_nothrow_constructible_v<type, _Args...>)
1480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
1482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __variant_construct_by_index<_Np>(*this,
1483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
1484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else if constexpr (is_scalar_v<type>)
1486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This might invoke a potentially-throwing conversion operator:
1488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      const type __tmp(std::forward<_Args>(__args)...);
1489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // But these steps won't throw:
ARM GAS  /tmp/ccawPiBL.s 			page 156


1490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
1491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __variant_construct_by_index<_Np>(*this, __tmp);
1492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()
1494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      && _Traits::_S_move_assign)
1495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This construction might throw:
1497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      variant __tmp(in_place_index<_Np>,
1498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			    std::forward<_Args>(__args)...);
1499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // But _Never_valueless_alt<type> means this won't:
1500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      *this = std::move(__tmp);
1501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
1503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This case only provides the basic exception-safety guarantee,
1505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // i.e. the variant can become valueless.
1506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
1507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __try
1508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant_construct_by_index<_Np>(*this,
1510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    std::forward<_Args>(__args)...);
1511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __catch (...)
1513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  this->_M_index = variant_npos;
1515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __throw_exception_again;
1516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return std::get<_Np>(*this);
1519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename _Up, typename... _Args>
1522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	enable_if_t<is_constructible_v<variant_alternative_t<_Np, variant>,
1523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 				       initializer_list<_Up>&, _Args...>,
1524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    variant_alternative_t<_Np, variant>&>
1525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	emplace(initializer_list<_Up> __il, _Args&&... __args)
1526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	{
1527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  static_assert(_Np < sizeof...(_Types),
1528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			"The index must be in [0, number of alternatives)");
1529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  using type = variant_alternative_t<_Np, variant>;
1530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // Provide the strong exception-safety guarantee when possible,
1531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  // to avoid becoming valueless.
1532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  if constexpr (is_nothrow_constructible_v<type,
1533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						   initializer_list<_Up>&,
1534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						   _Args...>)
1535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
1537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __variant_construct_by_index<_Np>(*this, __il,
1538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  std::forward<_Args>(__args)...);
1539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()
1541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      && _Traits::_S_move_assign)
1542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This construction might throw:
1544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      variant __tmp(in_place_index<_Np>, __il,
1545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			    std::forward<_Args>(__args)...);
1546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // But _Never_valueless_alt<type> means this won't:
ARM GAS  /tmp/ccawPiBL.s 			page 157


1547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      *this = std::move(__tmp);
1548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  else
1550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    {
1551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // This case only provides the basic exception-safety guarantee,
1552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      // i.e. the variant can become valueless.
1553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      this->_M_reset();
1554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __try
1555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __variant_construct_by_index<_Np>(*this, __il,
1557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    std::forward<_Args>(__args)...);
1558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      __catch (...)
1560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		{
1561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  this->_M_index = variant_npos;
1562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  __throw_exception_again;
1563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		}
1564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    }
1565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return std::get<_Np>(*this);
1566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	}
1567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr bool valueless_by_exception() const noexcept
1569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return !this->_M_valid(); }
1570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       constexpr size_t index() const noexcept
 1267              		.loc 1 1571 24 discriminator 4 view .LVU294
 1268              	.LBB726:
1572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
1573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	using __index_type = typename _Base::__index_type;
1574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	if constexpr (__detail::__variant::__never_valueless<_Types...>())
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return this->_M_index;
 1269              		.loc 1 1575 17 is_stmt 0 discriminator 4 view .LVU295
 1270 0016 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 1271              	.LVL103:
 1272              		.loc 1 1575 17 discriminator 4 view .LVU296
 1273              	.LBE726:
 1274              	.LBE725:
 166:./MotorControl/component.hpp ****         if (content_.index() == 2) {
 1275              		.loc 12 166 9 discriminator 4 view .LVU297
 1276 0018 022A     		cmp	r2, #2
 1277 001a 19D0     		beq	.L86
 1278              	.LBB727:
 167:./MotorControl/component.hpp ****             OutputPort<T>* ptr = std::get<2>(content_);
 168:./MotorControl/component.hpp ****             return ptr ? ptr->any() : std::nullopt;
 169:./MotorControl/component.hpp ****         } else if (content_.index() == 1) {
 1279              		.loc 12 169 16 view .LVU298
 1280 001c 012A     		cmp	r2, #1
 1281 001e 27D0     		beq	.L87
 1282              	.LVL104:
 1283              	.LBB728:
 1284              	.LBI728:
1576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
1577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return make_signed_t<__index_type>(this->_M_index);
1578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else
1579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  return size_t(__index_type(this->_M_index + 1)) - 1;
1580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
1581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/ccawPiBL.s 			page 158


1582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       void
1583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       swap(variant& __rhs)
1584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       noexcept((__is_nothrow_swappable<_Types>::value && ...)
1585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	       && is_nothrow_move_constructible_v<variant>)
1586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
1587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::__raw_idx_visit(
1588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  [this, &__rhs](auto&& __rhs_mem, auto __rhs_index) mutable
1589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  {
1590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    if constexpr (__rhs_index != variant_npos)
1591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      {
1592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		if (this->index() == __rhs_index)
1593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  {
1594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    auto& __this_mem =
1595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      std::get<__rhs_index>(*this);
1596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    using std::swap;
1597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    swap(__this_mem, __rhs_mem);
1598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  }
1599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		else
1600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  {
1601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    if (!this->valueless_by_exception()) [[__likely__]]
1602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      {
1603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			auto __tmp(std::move(__rhs_mem));
1604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			__rhs = std::move(*this);
1605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			this->_M_destructive_move(__rhs_index,
1606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						  std::move(__tmp));
1607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      }
1608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    else
1609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      {
1610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			this->_M_destructive_move(__rhs_index,
1611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 						  std::move(__rhs_mem));
1612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 			__rhs._M_reset();
1613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      }
1614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  }
1615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      }
1616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	    else
1617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      {
1618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		if (!this->valueless_by_exception()) [[__likely__]]
1619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  {
1620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    __rhs = std::move(*this);
1621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    this->_M_reset();
1622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		  }
1623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	      }
1624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	  }, __rhs);
1625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       }
1626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     private:
1628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #if defined(__clang__) && __clang_major__ <= 7
1630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     public:
1631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       using _Base::_M_u; // See https://bugs.llvm.org/show_bug.cgi?id=31852
1632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     private:
1633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #endif
1634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<size_t _Np, typename _Vp>
1636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend constexpr decltype(auto)
1637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::__get(_Vp&& __v) noexcept;
1638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
ARM GAS  /tmp/ccawPiBL.s 			page 159


1639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename _Vp>
1640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend void*
1641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	__detail::__variant::__get_storage(_Vp&& __v) noexcept;
1642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP) \
1644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       template<typename... _Tp> \
1645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	friend constexpr bool \
1646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	operator __OP(const variant<_Tp...>& __lhs, \
1647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		      const variant<_Tp...>& __rhs);
1648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(<)
1650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(<=)
1651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(==)
1652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(!=)
1653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(>=)
1654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       _VARIANT_RELATION_FUNCTION_TEMPLATE(>)
1655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** #undef _VARIANT_RELATION_FUNCTION_TEMPLATE
1657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     };
1658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 
1659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   template<size_t _Np, typename... _Types>
1660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     constexpr variant_alternative_t<_Np, variant<_Types...>>&
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     get(variant<_Types...>& __v)
 1285              		.loc 1 1661 5 is_stmt 1 view .LVU299
 1286              	.LBB729:
 1287              	.LBB730:
 1288              	.LBI730:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 1289              		.loc 1 1571 24 view .LVU300
 1290              	.LBB731:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 1291              		.loc 1 1575 17 is_stmt 0 view .LVU301
 1292 0020 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 1293              	.LVL105:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 1294              		.loc 1 1575 17 view .LVU302
 1295              	.LBE731:
 1296              	.LBE730:
1662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
1663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       static_assert(_Np < sizeof...(_Types),
1664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 		    "The index must be in [0, number of alternatives)");
1665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       if (__v.index() != _Np)
 1297              		.loc 1 1665 7 view .LVU303
 1298 0022 002A     		cmp	r2, #0
 1299 0024 36D1     		bne	.L88
 1300              	.LVL106:
 1301              	.LBB732:
 1302              	.LBI732:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 1303              		.loc 1 276 5 is_stmt 1 view .LVU304
 1304              	.LBB733:
 1305              	.LBB734:
 1306              	.LBI734:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 1307              		.loc 1 262 5 view .LVU305
 1308              	.LBB735:
 1309              	.LBI735:
ARM GAS  /tmp/ccawPiBL.s 			page 160


 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 1310              		.loc 1 222 24 view .LVU306
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 1311              		.loc 1 222 24 is_stmt 0 view .LVU307
 1312              	.LBE735:
 1313              	.LBE734:
 1314              	.LBE733:
 1315              	.LBE732:
 1316              	.LBE729:
 1317              	.LBE728:
 1318              	.LBB739:
 1319              	.LBI739:
 1320              		.file 13 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // <optional> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Copyright (C) 2013-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** /** @file include/optional
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****  *  This is a Standard C++ Library header.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****  */
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #ifndef _GLIBCXX_OPTIONAL
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #define _GLIBCXX_OPTIONAL 1
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #pragma GCC system_header
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #if __cplusplus >= 201703L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <utility>
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <type_traits>
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <exception>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <new>
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <initializer_list>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/exception_defines.h>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/functional_hash.h>
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #include <bits/enable_special_members.h>
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #if __cplusplus > 201703L
ARM GAS  /tmp/ccawPiBL.s 			page 161


  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** # include <compare>
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #endif
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** namespace std _GLIBCXX_VISIBILITY(default)
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** {
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @addtogroup utilities
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @{
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    */
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #define __cpp_lib_optional 201606L
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class optional;
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /// Tag type to disengage optional objects.
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   struct nullopt_t
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   {
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Do not user-declare default constructor at all for
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // optional_value = {} syntax to work.
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // nullopt_t() = delete;
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Used for constructing nullopt.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     enum class _Construct { _Token };
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     // Must be constexpr for nullopt_t to be literal.
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     explicit constexpr nullopt_t(_Construct) { }
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   };
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /// Tag to disengage optional objects.
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   inline constexpr nullopt_t nullopt { nullopt_t::_Construct::_Token };
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @brief Exception class thrown when a disengaged optional object is
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  dereferenced.
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    *  @ingroup exceptions
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****    */
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   class bad_optional_access : public exception
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   {
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   public:
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     bad_optional_access() = default;
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     virtual ~bad_optional_access() = default;
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     const char* what() const noexcept override
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return "bad optional access"; }
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   };
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   void
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __throw_bad_optional_access()
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __attribute__((__noreturn__));
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // XXX Does not belong here.
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   inline void
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   __throw_bad_optional_access()
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   { _GLIBCXX_THROW_OR_ABORT(bad_optional_access()); }
ARM GAS  /tmp/ccawPiBL.s 			page 162


 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // This class template manages construction/destruction of
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // the contained value for a std::optional.
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload_base
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Stored_type = remove_const_t<_Tp>;
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base() = default;
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_Optional_payload_base(in_place_t __tag, _Args&&... __args)
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_engaged(true)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args>
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_Optional_payload_base(std::initializer_list<_Up> __il,
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			       _Args&&... __args)
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__il, std::forward<_Args>(__args)...),
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_engaged(true)
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructor used by _Optional_base copy constructor when the
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // contained value is not trivially copy constructible.
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(bool __engaged,
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			     const _Optional_payload_base& __other)
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (__other._M_engaged)
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(__other._M_get());
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructor used by _Optional_base move constructor when the
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // contained value is not trivially move constructible.
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(bool __engaged,
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			     _Optional_payload_base&& __other)
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (__other._M_engaged)
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(std::move(__other._M_get()));
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy constructor is only used to when the contained value is
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // trivially copy constructible.
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(const _Optional_payload_base&) = default;
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Move constructor is only used to when the contained value is
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // trivially copy constructible.
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base(_Optional_payload_base&&) = default;
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base&
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload_base&) = default;
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/ccawPiBL.s 			page 163


 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload_base&
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload_base&&) = default;
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // used to perform non-trivial copy assignment.
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_copy_assign(const _Optional_payload_base& __other)
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         if (this->_M_engaged && __other._M_engaged)
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           this->_M_get() = __other._M_get();
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         else
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    if (__other._M_engaged)
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_construct(__other._M_get());
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    else
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // used to perform non-trivial move assignment.
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_move_assign(_Optional_payload_base&& __other)
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_engaged && __other._M_engaged)
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_get() = std::move(__other._M_get());
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    if (__other._M_engaged)
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_construct(std::move(__other._M_get()));
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    else
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       struct _Empty_byte { };
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, bool = is_trivially_destructible_v<_Up>>
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	union _Storage
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  constexpr _Storage() noexcept : _M_empty() { }
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename... _Args>
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(in_place_t, _Args&&... __args)
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename _Vp, typename... _Args>
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(__il, std::forward<_Args>(__args)...)
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _Empty_byte _M_empty;
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           _Up _M_value;
 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	};
ARM GAS  /tmp/ccawPiBL.s 			page 164


 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	union _Storage<_Up, false>
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  constexpr _Storage() noexcept : _M_empty() { }
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename... _Args>
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(in_place_t, _Args&&... __args)
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  template<typename _Vp, typename... _Args>
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    constexpr
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(__il, std::forward<_Args>(__args)...)
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  // User-provided destructor is needed when _Up has non-trivial dtor.
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ~_Storage() { }
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _Empty_byte _M_empty;
 238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           _Up _M_value;
 239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	};
 240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Storage<_Stored_type> _M_payload;
 242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 243:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       bool _M_engaged = false;
 244:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 245:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 246:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         void
 247:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         _M_construct(_Args&&... __args)
 248:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 249:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         {
 250:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           ::new ((void *) std::__addressof(this->_M_payload))
 251:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****             _Stored_type(std::forward<_Args>(__args)...);
 252:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****           this->_M_engaged = true;
 253:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         }
 254:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 255:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 256:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_destroy() noexcept
 257:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 258:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_engaged = false;
 259:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_payload._M_value.~_Stored_type();
 260:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 261:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_get() operations have _M_engaged as a precondition.
 263:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // They exist to access the contained value with the appropriate
 264:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // const-qualification, because _M_payload has had the const removed.
 265:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 266:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() noexcept
 268:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_payload._M_value; }
 269:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 270:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 271:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() const noexcept
 272:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_payload._M_value; }
ARM GAS  /tmp/ccawPiBL.s 			page 165


 273:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 274:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // _M_reset is a 'safe' operation with no precondition.
 275:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_reset() noexcept
 277:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 278:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_engaged)
 279:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  _M_destroy();
 280:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 281:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 282:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 283:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Class template that manages the payload for optionals.
 284:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp,
 285:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialDestructor*/ =
 286:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_destructible_v<_Tp>,
 287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialCopy */ =
 288:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_copy_assignable_v<_Tp>
 289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      && is_trivially_copy_constructible_v<_Tp>,
 290:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    bool /*_HasTrivialMove */ =
 291:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      is_trivially_move_assignable_v<_Tp>
 292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      && is_trivially_move_constructible_v<_Tp>>
 293:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload;
 294:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 295:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for potentially-constexpr optionals (trivial copy/move/destroy).
 296:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 297:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, true, true>
 298:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 299:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 301:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 303:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 304:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 305:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial copy construction/assignment.
 306:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 307:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, false, true>
 308:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 309:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 310:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 311:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 312:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 313:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 314:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 315:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 316:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(_Optional_payload&&) = default;
 317:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 318:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial copy assignment.
 319:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 320:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 321:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload& __other)
 322:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 323:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_copy_assign(__other);
 324:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 325:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 326:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 327:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 328:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial move construction/assignment.
 329:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
ARM GAS  /tmp/ccawPiBL.s 			page 166


 330:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, true, false>
 331:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 332:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 333:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 334:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 335:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 336:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 337:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 338:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 339:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(const _Optional_payload&) = default;
 340:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 341:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial move assignment.
 342:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 343:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 344:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload&& __other)
 345:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 346:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 347:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 348:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_move_assign(std::move(__other));
 349:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 350:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 351:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 352:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 353:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial copy and move assignment.
 354:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp>
 355:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, true, false, false>
 356:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload_base<_Tp>
 357:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 358:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload_base<_Tp>::_Optional_payload_base;
 359:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 360:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 361:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() = default;
 362:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 363:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 364:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 365:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial copy assignment.
 366:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 367:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 368:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(const _Optional_payload& __other)
 369:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 370:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_copy_assign(__other);
 371:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 372:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 373:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 374:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Non-trivial move assignment.
 375:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr
 376:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload&
 377:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(_Optional_payload&& __other)
 378:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
 379:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		       is_nothrow_move_assignable<_Tp>>)
 380:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 381:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_move_assign(std::move(__other));
 382:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 383:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 384:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 385:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 386:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Payload for optionals with non-trivial destructors.
ARM GAS  /tmp/ccawPiBL.s 			page 167


 387:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template <typename _Tp, bool _Copy, bool _Move>
 388:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_payload<_Tp, false, _Copy, _Move>
 389:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : _Optional_payload<_Tp, true, false, false>
 390:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 391:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Base class implements all the constructors and assignment operators:
 392:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Optional_payload<_Tp, true, false, false>::_Optional_payload;
 393:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload() = default;
 394:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(const _Optional_payload&) = default;
 395:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload(_Optional_payload&&) = default;
 396:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(const _Optional_payload&) = default;
 397:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload& operator=(_Optional_payload&&) = default;
 398:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 399:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Destructor needs to destroy the contained value:
 400:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload() { this->_M_reset(); }
 401:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 402:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 403:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Common base class for _Optional_base<T> to avoid repeating these
 404:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // member functions in each specialization.
 405:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Dp>
 406:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class _Optional_base_impl
 407:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 408:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     protected:
 409:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Stored_type = remove_const_t<_Tp>;
 410:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 411:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_construct operation has !_M_engaged as a precondition
 412:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // while _M_destruct has _M_engaged as a precondition.
 413:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 414:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	void
 415:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	_M_construct(_Args&&... __args)
 416:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 417:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 418:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ::new
 419:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    (std::__addressof(static_cast<_Dp*>(this)->_M_payload._M_payload))
 420:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    _Stored_type(std::forward<_Args>(__args)...);
 421:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_cast<_Dp*>(this)->_M_payload._M_engaged = true;
 422:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 423:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 424:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       void
 425:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_destruct() noexcept
 426:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { static_cast<_Dp*>(this)->_M_payload._M_destroy(); }
 427:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 428:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // _M_reset is a 'safe' operation with no precondition.
 429:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr void
 430:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_reset() noexcept
 431:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { static_cast<_Dp*>(this)->_M_payload._M_reset(); }
 432:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr bool _M_is_engaged() const noexcept
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 435:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 436:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // The _M_get operations have _M_engaged as a precondition.
 437:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 438:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() noexcept
 439:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 440:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__glibcxx_assert(this->_M_is_engaged());
 441:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return static_cast<_Dp*>(this)->_M_payload._M_get();
 442:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 443:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/ccawPiBL.s 			page 168


 444:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 445:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _M_get() const noexcept
 446:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 447:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__glibcxx_assert(this->_M_is_engaged());
 448:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return static_cast<const _Dp*>(this)->_M_payload._M_get();
 449:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 450:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 451:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 452:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
 453:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @brief Class template that provides copy/move constructors of optional.
 454:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 455:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * Such a separate base class template is necessary in order to
 456:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * conditionally make copy/move constructors trivial.
 457:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 458:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * When the contained value is trivially copy/move constructible,
 459:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * the copy/move constructors of _Optional_base will invoke the
 460:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * trivial copy/move constructor of _Optional_payload. Otherwise,
 461:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * they will invoke _Optional_payload(bool, const _Optional_payload&)
 462:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * or _Optional_payload(bool, _Optional_payload&&) to initialize
 463:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * the contained value, if copying/moving an engaged optional.
 464:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 465:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * Whether the other special members are trivial is determined by the
 466:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * _Optional_payload<_Tp> specialization used for the _M_payload member.
 467:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     *
 468:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @see optional, _Enable_special_members
 469:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     */
 470:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp,
 471:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	   bool = is_trivially_copy_constructible_v<_Tp>,
 472:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	   bool = is_trivially_move_constructible_v<_Tp>>
 473:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base
 474:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 475:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 476:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 477:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 478:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 479:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 480:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 481:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 482:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 483:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 484:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 485:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 486:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 487:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 488:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 489:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 490:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 491:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 492:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 493:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 494:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 495:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 496:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 497:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 498:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other)
 499:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 500:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __other._M_payload)
ARM GAS  /tmp/ccawPiBL.s 			page 169


 501:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 502:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 503:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other)
 504:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>)
 505:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 506:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::move(__other._M_payload))
 507:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 508:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 509:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 510:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 511:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 512:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 513:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 514:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 515:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 516:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 517:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, false, true>
 518:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 519:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 520:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 521:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 522:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 523:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 524:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 525:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 526:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 527:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 528:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 529:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 530:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 531:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 532:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 533:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 534:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 535:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 536:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 537:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 538:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 539:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 540:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 541:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 542:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other)
 543:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 544:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __other._M_payload)
 545:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 546:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 547:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other) = default;
 548:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 549:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 550:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 551:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 552:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 553:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 554:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 555:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 556:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 557:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, true, false>
ARM GAS  /tmp/ccawPiBL.s 			page 170


 558:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 559:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 560:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 561:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 562:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 563:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 564:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 565:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 566:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 567:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 568:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 569:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 570:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 572:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 573:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
 574:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 576:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 577:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 578:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 579:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 580:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 581:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 582:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other) = default;
 583:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 584:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other)
 585:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>)
 586:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__other._M_payload._M_engaged,
 587:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::move(__other._M_payload))
 588:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { }
 589:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 590:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 591:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 592:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 593:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 594:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 595:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 596:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 597:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 598:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     struct _Optional_base<_Tp, true, true>
 599:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
 600:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
 601:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for disengaged optionals.
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base() = default;
 603:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 604:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Constructors for engaged optionals.
 605:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 606:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
 608:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 609:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     std::forward<_Args>(__args)...) { }
 610:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 611:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 612:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                enable_if_t<is_constructible_v<_Tp,
 613:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      initializer_list<_Up>&,
 614:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					      _Args&&...>, bool> = false>
ARM GAS  /tmp/ccawPiBL.s 			page 171


 615:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         constexpr explicit _Optional_base(in_place_t,
 616:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           initializer_list<_Up> __il,
 617:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****                                           _Args&&... __args)
 618:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 619:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		     __il, std::forward<_Args>(__args)...)
 620:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         { }
 621:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 622:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Copy and move constructors.
 623:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(const _Optional_base& __other) = default;
 624:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Optional_base(_Optional_base&& __other) = default;
 625:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 626:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 627:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(const _Optional_base&) = default;
 628:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_base& operator=(_Optional_base&&) = default;
 629:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 630:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       _Optional_payload<_Tp> _M_payload;
 631:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 632:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 633:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 634:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   class optional;
 635:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 636:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 637:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __converts_from_optional =
 638:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       __or_<is_constructible<_Tp, const optional<_Up>&>,
 639:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, optional<_Up>&>,
 640:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, const optional<_Up>&&>,
 641:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_constructible<_Tp, optional<_Up>&&>,
 642:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<const optional<_Up>&, _Tp>,
 643:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<optional<_Up>&, _Tp>,
 644:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<const optional<_Up>&&, _Tp>,
 645:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_convertible<optional<_Up>&&, _Tp>>;
 646:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 647:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 648:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __assigns_from_optional =
 649:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       __or_<is_assignable<_Tp&, const optional<_Up>&>,
 650:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, optional<_Up>&>,
 651:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, const optional<_Up>&&>,
 652:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    is_assignable<_Tp&, optional<_Up>&&>>;
 653:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 654:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   /**
 655:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     * @brief Class template for optional values.
 656:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     */
 657:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 658:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     class optional
 659:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     : private _Optional_base<_Tp>,
 660:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       private _Enable_copy_move<
 661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Copy constructor.
 662:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	is_copy_constructible_v<_Tp>,
 663:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Copy assignment.
 664:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__and_v<is_copy_constructible<_Tp>, is_copy_assignable<_Tp>>,
 665:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Move constructor.
 666:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	is_move_constructible_v<_Tp>,
 667:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Move assignment.
 668:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	__and_v<is_move_constructible<_Tp>, is_move_assignable<_Tp>>,
 669:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	// Unique tag type.
 670:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional<_Tp>>
 671:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
ARM GAS  /tmp/ccawPiBL.s 			page 172


 672:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_same_v<remove_cv_t<_Tp>, nullopt_t>);
 673:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_same_v<remove_cv_t<_Tp>, in_place_t>);
 674:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       static_assert(!is_reference_v<_Tp>);
 675:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 676:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     private:
 677:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using _Base = _Optional_base<_Tp>;
 678:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 679:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // SFINAE helpers
 680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 681:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using __not_self = __not_<is_same<optional, __remove_cvref_t<_Up>>>;
 682:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 683:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using __not_tag = __not_<is_same<in_place_t, __remove_cvref_t<_Up>>>;
 684:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Cond>
 685:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using _Requires = enable_if_t<__and_v<_Cond...>, bool>;
 686:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 687:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     public:
 688:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       using value_type = _Tp;
 689:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 690:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr optional() = default;
 691:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr optional(nullopt_t) noexcept { }
 693:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 694:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Converting constructors for engaged optionals.
 695:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp,
 696:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_self<_Up>, __not_tag<_Up>,
 697:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, _Up&&>,
 698:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_convertible<_Up&&, _Tp>> = true>
 699:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(_Up&& __t)
 1321              		.loc 13 700 2 is_stmt 1 view .LVU308
 1322              	.LBB740:
 1323              	.LBB741:
 1324              	.LBB742:
 1325              	.LBI742:
 1326              		.file 14 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Move, forward and identity for C++11 + swap -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Copyright (C) 2007-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
ARM GAS  /tmp/ccawPiBL.s 			page 173


  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** /** @file bits/move.h
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****  *  This is an internal header file, included by other library headers.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****  *  Do not attempt to use it directly. @headername{utility}
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****  */
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #ifndef _MOVE_H
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #define _MOVE_H 1
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #include <bits/c++config.h>
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #if __cplusplus < 201103L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** # include <bits/concept_check.h>
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #endif
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** namespace std _GLIBCXX_VISIBILITY(default)
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** {
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   // Used, in C++03 mode too, by allocators, etc.
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief Same as C++11 std::addressof
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @ingroup utilities
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     inline _GLIBCXX_CONSTEXPR _Tp*
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     { return __builtin_addressof(__r); }
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #if __cplusplus >= 201103L
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** _GLIBCXX_END_NAMESPACE_VERSION
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** } // namespace
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** #include <type_traits> // Brings in std::declval too.
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** namespace std _GLIBCXX_VISIBILITY(default)
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** {
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @addtogroup utilities
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @{
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h **** 
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   /**
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @brief  Forward an lvalue.
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  @return The parameter cast to the specified type.
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    *  This function is used to implement "perfect forwarding".
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****    */
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****   template<typename _Tp>
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     constexpr _Tp&&
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/move.h ****     forward(typename std::remove_reference<_Tp>::type& __t) noexcept
 1327              		.loc 14 76 5 view .LVU309
 1328              		.loc 14 76 5 is_stmt 0 view .LVU310
 1329              	.LBE742:
ARM GAS  /tmp/ccawPiBL.s 			page 174


 1330              	.LBB743:
 1331              	.LBI743:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 1332              		.loc 13 607 28 is_stmt 1 view .LVU311
 1333              	.LBB744:
 1334              	.LBB745:
 1335              	.LBB746:
 1336              	.LBI746:
 1337              		.loc 14 76 5 view .LVU312
 1338              		.loc 14 76 5 is_stmt 0 view .LVU313
 1339              	.LBE746:
 1340              	.LBB747:
 1341              	.LBI747:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1342              		.loc 13 300 42 is_stmt 1 view .LVU314
 1343              	.LBB748:
 1344              	.LBB749:
 1345              	.LBB750:
 1346              	.LBI750:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 1347              		.loc 13 115 2 view .LVU315
 1348              	.LBB751:
 1349              	.LBB752:
 1350              	.LBB753:
 1351              	.LBI753:
 1352              		.loc 14 76 5 view .LVU316
 1353              		.loc 14 76 5 is_stmt 0 view .LVU317
 1354              	.LBE753:
 1355              	.LBB754:
 1356              	.LBI754:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 1357              		.loc 13 203 6 is_stmt 1 view .LVU318
 1358              	.LBB755:
 1359              	.LBB756:
 1360              	.LBB757:
 1361              	.LBI757:
 1362              		.loc 14 76 5 view .LVU319
 1363              		.loc 14 76 5 is_stmt 0 view .LVU320
 1364              	.LBE757:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 1365              		.loc 13 204 47 view .LVU321
 1366 0026 1B68     		ldr	r3, [r3]	@ float
 1367              	.LVL107:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 1368              		.loc 13 204 47 view .LVU322
 1369 0028 0093     		str	r3, [sp]	@ float
 1370              	.LVL108:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 1371              		.loc 13 204 47 view .LVU323
 1372              	.LBE756:
 1373              	.LBE755:
 1374              	.LBE754:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 1375              		.loc 13 117 19 view .LVU324
 1376 002a 0123     		movs	r3, #1
 1377 002c 8DF80430 		strb	r3, [sp, #4]
 1378              	.LVL109:
ARM GAS  /tmp/ccawPiBL.s 			page 175


 1379              	.L78:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 1380              		.loc 13 117 19 view .LVU325
 1381              	.LBE752:
 1382              	.LBE751:
 1383              	.LBE750:
 1384              	.LBE749:
 1385              	.LBE748:
 1386              	.LBE747:
 1387              	.LBE745:
 1388              	.LBE744:
 1389              	.LBE743:
 1390              	.LBE741:
 1391              	.LBE740:
 1392              	.LBE739:
 1393              	.LBE727:
 1394              	.LBE724:
 1395              	.LBE723:
 120:MotorControl/controller.cpp ****             return false;
 1396              		.loc 3 120 9 is_stmt 1 view .LVU326
 1397              	.LBB848:
 1398              	.LBI848:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 702:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 703:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp,
 704:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_self<_Up>, __not_tag<_Up>,
 705:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, _Up&&>,
 706:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<is_convertible<_Up&&, _Tp>>> = false>
 707:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 708:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(_Up&& __t)
 709:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _Base(std::in_place, std::forward<_Up>(__t)) { }
 710:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 711:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up,
 712:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_<is_same<_Tp, _Up>>,
 713:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, const _Up&>,
 714:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_convertible<const _Up&, _Tp>,
 715:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<__converts_from_optional<_Tp, _Up>>> = true>
 716:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 717:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(const optional<_Up>& __t)
 718:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 719:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 720:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(*__t);
 721:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 722:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 723:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up,
 724:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<__not_<is_same<_Tp, _Up>>,
 725:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 is_constructible<_Tp, const _Up&>,
 726:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<is_convertible<const _Up&, _Tp>>,
 727:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			 __not_<__converts_from_optional<_Tp, _Up>>> = false>
 728:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 729:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(const optional<_Up>& __t)
 730:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 731:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 732:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(*__t);
 733:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 734:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 735:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template <typename _Up,
ARM GAS  /tmp/ccawPiBL.s 			page 176


 736:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		_Requires<__not_<is_same<_Tp, _Up>>,
 737:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_constructible<_Tp, _Up&&>,
 738:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_convertible<_Up&&, _Tp>,
 739:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<__converts_from_optional<_Tp, _Up>>> = true>
 740:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr
 741:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(optional<_Up>&& __t)
 742:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 743:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 744:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(std::move(*__t));
 745:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 746:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 747:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template <typename _Up,
 748:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		_Requires<__not_<is_same<_Tp, _Up>>,
 749:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  is_constructible<_Tp, _Up&&>,
 750:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<is_convertible<_Up&&, _Tp>>,
 751:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			  __not_<__converts_from_optional<_Tp, _Up>>> = false>
 752:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 753:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(optional<_Up>&& __t)
 754:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 755:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__t)
 756:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    emplace(std::move(*__t));
 757:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 758:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 759:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args,
 760:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<is_constructible<_Tp, _Args&&...>> = false>
 761:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 762:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(in_place_t, _Args&&... __args)
 763:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Args>(__args)...) { }
 764:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 765:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args,
 766:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       _Requires<is_constructible<_Tp,
 767:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  initializer_list<_Up>&,
 768:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  _Args&&...>> = false>
 769:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	explicit constexpr
 770:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	optional(in_place_t, initializer_list<_Up> __il, _Args&&... __args)
 771:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, __il, std::forward<_Args>(__args)...) { }
 772:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 773:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Assignment operators.
 774:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       optional&
 775:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator=(nullopt_t) noexcept
 776:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 777:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	this->_M_reset();
 778:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return *this;
 779:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 780:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 781:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up = _Tp>
 782:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<__and_v<__not_self<_Up>,
 783:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__and_<is_scalar<_Tp>,
 784:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 					  is_same<_Tp, decay_t<_Up>>>>,
 785:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, _Up>,
 786:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, _Up>>,
 787:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 788:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(_Up&& __u)
 789:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 790:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (this->_M_is_engaged())
 791:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_get() = std::forward<_Up>(__u);
 792:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
ARM GAS  /tmp/ccawPiBL.s 			page 177


 793:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_construct(std::forward<_Up>(__u));
 794:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 795:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
 796:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 797:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 798:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 799:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
 800:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, const _Up&>,
 801:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, const _Up&>,
 802:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__converts_from_optional<_Tp, _Up>>,
 803:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__assigns_from_optional<_Tp, _Up>>>,
 804:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 805:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(const optional<_Up>& __u)
 806:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 807:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__u)
 808:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 809:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      if (this->_M_is_engaged())
 810:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_get() = *__u;
 811:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      else
 812:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_construct(*__u);
 813:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 814:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 815:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 816:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 817:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 818:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
 819:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 820:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 821:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 822:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
 823:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_constructible<_Tp, _Up>,
 824:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    is_assignable<_Tp&, _Up>,
 825:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__converts_from_optional<_Tp, _Up>>,
 826:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 			    __not_<__assigns_from_optional<_Tp, _Up>>>,
 827:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		    optional&>
 828:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	operator=(optional<_Up>&& __u)
 829:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 830:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  if (__u)
 831:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 832:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      if (this->_M_is_engaged())
 833:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_get() = std::move(*__u);
 834:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      else
 835:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 		this->_M_construct(std::move(*__u));
 836:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 837:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  else
 838:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    {
 839:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	      this->_M_reset();
 840:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    }
 841:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 842:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return *this;
 843:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 844:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 845:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename... _Args>
 846:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<is_constructible_v<_Tp, _Args&&...>, _Tp&>
 847:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	emplace(_Args&&... __args)
 848:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 849:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_reset();
ARM GAS  /tmp/ccawPiBL.s 			page 178


 850:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(std::forward<_Args>(__args)...);
 851:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_get();
 852:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 853:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 854:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up, typename... _Args>
 855:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&,
 856:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 				       _Args&&...>, _Tp&>
 857:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	emplace(initializer_list<_Up> __il, _Args&&... __args)
 858:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 859:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_reset();
 860:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  this->_M_construct(__il, std::forward<_Args>(__args)...);
 861:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_get();
 862:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 863:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 864:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Destructor is implicit, implemented in _Optional_base.
 865:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 866:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Swap.
 867:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       void
 868:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       swap(optional& __other)
 869:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       noexcept(is_nothrow_move_constructible_v<_Tp>
 870:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	       && is_nothrow_swappable_v<_Tp>)
 871:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 872:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	using std::swap;
 873:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 874:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	if (this->_M_is_engaged() && __other._M_is_engaged())
 875:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  swap(this->_M_get(), __other._M_get());
 876:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else if (this->_M_is_engaged())
 877:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 878:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    __other._M_construct(std::move(this->_M_get()));
 879:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_destruct();
 880:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 881:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	else if (__other._M_is_engaged())
 882:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  {
 883:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    this->_M_construct(std::move(__other._M_get()));
 884:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    __other._M_destruct();
 885:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  }
 886:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 887:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 888:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       // Observers.
 889:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp*
 890:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator->() const
 891:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::__addressof(this->_M_get()); }
 892:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 893:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp*
 894:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator->()
 895:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::__addressof(this->_M_get()); }
 896:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 897:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 898:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*() const&
 899:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_get(); }
 900:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 901:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 902:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*()&
 903:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_get(); }
 904:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 905:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&&
 906:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*()&&
ARM GAS  /tmp/ccawPiBL.s 			page 179


 907:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::move(this->_M_get()); }
 908:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 909:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&&
 910:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       operator*() const&&
 911:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return std::move(this->_M_get()); }
 912:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 913:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr explicit operator bool() const noexcept
 914:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 915:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr bool has_value() const noexcept
 1399              		.loc 13 916 22 view .LVU327
 1400              	.LBB849:
 1401              	.LBI849:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 1402              		.loc 13 433 22 view .LVU328
 1403              	.LBB850:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1404              		.loc 13 434 58 is_stmt 0 view .LVU329
 1405 0030 9DF80440 		ldrb	r4, [sp, #4]	@ zero_extendqisi2
 1406              	.LVL110:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1407              		.loc 13 434 58 view .LVU330
 1408              	.LBE850:
 1409              	.LBE849:
 1410              	.LBE848:
 120:MotorControl/controller.cpp ****             return false;
 1411              		.loc 3 120 9 view .LVU331
 1412 0034 94B3     		cbz	r4, .L72
 124:MotorControl/controller.cpp ****         set_input_pos_and_steps(*estimate);
 1413              		.loc 3 124 9 is_stmt 1 view .LVU332
 124:MotorControl/controller.cpp ****         set_input_pos_and_steps(*estimate);
 1414              		.loc 3 124 25 is_stmt 0 view .LVU333
 1415 0036 9DED000A 		vldr.32	s0, [sp]
 124:MotorControl/controller.cpp ****         set_input_pos_and_steps(*estimate);
 1416              		.loc 3 124 23 view .LVU334
 1417 003a 00F56453 		add	r3, r0, #14592
 1418 003e 83ED010A 		vstr.32	s0, [r3, #4]
 125:MotorControl/controller.cpp ****     }
 1419              		.loc 3 125 9 is_stmt 1 view .LVU335
 125:MotorControl/controller.cpp ****     }
 1420              		.loc 3 125 32 is_stmt 0 view .LVU336
 1421 0042 FFF7FEFF 		bl	_ZN10Controller23set_input_pos_and_stepsEf
 1422              	.LVL111:
 125:MotorControl/controller.cpp ****     }
 1423              		.loc 3 125 32 view .LVU337
 1424              	.LBE722:
 1425 0046 29E0     		b	.L72
 1426              	.LVL112:
 1427              	.L73:
 1428              	.LBB852:
 119:MotorControl/controller.cpp ****         if (!estimate.has_value()) {
 1429              		.loc 3 119 63 discriminator 2 view .LVU338
 1430 0048 00F56353 		add	r3, r0, #14528
 1431 004c 2433     		adds	r3, r3, #36
 1432 004e E2E7     		b	.L74
 1433              	.LVL113:
 1434              	.L86:
ARM GAS  /tmp/ccawPiBL.s 			page 180


 1435              	.LBB851:
 1436              	.LBB847:
 1437              	.LBB802:
 1438              	.LBB803:
 1439              	.LBI803:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 1440              		.loc 1 1661 5 is_stmt 1 view .LVU339
 1441              	.LBB804:
 1442              	.LBB805:
 1443              	.LBI805:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 1444              		.loc 1 1571 24 view .LVU340
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 1445              		.loc 1 1571 24 is_stmt 0 view .LVU341
 1446              	.LBE805:
 1447              		.loc 1 1665 7 view .LVU342
 1448 0050 07D1     		bne	.L89
 1449              	.LVL114:
 1450              	.LBB806:
 1451              	.LBI806:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 1452              		.loc 1 276 5 is_stmt 1 view .LVU343
 1453              	.LBB807:
 1454              	.LBB808:
 1455              	.LBI808:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 1456              		.loc 1 267 5 view .LVU344
 1457              	.LBB809:
 1458              	.LBB810:
 1459              	.LBI810:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 1460              		.loc 1 267 5 view .LVU345
 1461              	.LBB811:
 1462              	.LBB812:
 1463              	.LBI812:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 1464              		.loc 1 262 5 view .LVU346
 1465              	.LBB813:
 1466              	.LBI813:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 1467              		.loc 1 222 24 view .LVU347
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 1468              		.loc 1 222 24 is_stmt 0 view .LVU348
 1469              	.LBE813:
 1470              	.LBE812:
 1471              	.LBE811:
 1472              	.LBE810:
 1473              	.LBE809:
 1474              	.LBE808:
 1475              	.LBE807:
 1476              	.LBE806:
 1477              	.LBE804:
 1478              	.LBE803:
 167:./MotorControl/component.hpp ****             return ptr ? ptr->any() : std::nullopt;
 1479              		.loc 12 167 28 view .LVU349
 1480 0052 1B68     		ldr	r3, [r3]
 1481              	.LVL115:
ARM GAS  /tmp/ccawPiBL.s 			page 181


 168:./MotorControl/component.hpp ****         } else if (content_.index() == 1) {
 1482              		.loc 12 168 44 view .LVU350
 1483 0054 43B1     		cbz	r3, .L77
 1484              	.LVL116:
 1485              	.LBB817:
 1486              	.LBI817:
 102:./MotorControl/component.hpp ****         return content_;
 1487              		.loc 12 102 22 is_stmt 1 view .LVU351
 1488              	.LBB818:
 1489              	.LBB819:
 1490              	.LBI819:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 1491              		.loc 13 700 2 view .LVU352
 1492              	.LBB820:
 1493              	.LBB821:
 1494              	.LBB822:
 1495              	.LBI822:
 1496              		.loc 14 76 5 view .LVU353
 1497              		.loc 14 76 5 is_stmt 0 view .LVU354
 1498              	.LBE822:
 1499              	.LBB823:
 1500              	.LBI823:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 1501              		.loc 13 607 28 is_stmt 1 view .LVU355
 1502              	.LBB824:
 1503              	.LBB825:
 1504              	.LBB826:
 1505              	.LBI826:
 1506              		.loc 14 76 5 view .LVU356
 1507              		.loc 14 76 5 is_stmt 0 view .LVU357
 1508              	.LBE826:
 1509              	.LBB827:
 1510              	.LBI827:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1511              		.loc 13 300 42 is_stmt 1 view .LVU358
 1512              	.LBB828:
 1513              	.LBB829:
 1514              	.LBB830:
 1515              	.LBI830:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 1516              		.loc 13 115 2 view .LVU359
 1517              	.LBB831:
 1518              	.LBB832:
 1519              	.LBB833:
 1520              	.LBI833:
 1521              		.loc 14 76 5 view .LVU360
 1522              		.loc 14 76 5 is_stmt 0 view .LVU361
 1523              	.LBE833:
 1524              	.LBB834:
 1525              	.LBI834:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 1526              		.loc 13 203 6 is_stmt 1 view .LVU362
 1527              	.LBB835:
 1528              	.LBB836:
 1529              	.LBB837:
 1530              	.LBI837:
 1531              		.loc 14 76 5 view .LVU363
ARM GAS  /tmp/ccawPiBL.s 			page 182


 1532              		.loc 14 76 5 is_stmt 0 view .LVU364
 1533              	.LBE837:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 1534              		.loc 13 204 47 view .LVU365
 1535 0056 5B68     		ldr	r3, [r3, #4]	@ float
 1536              	.LVL117:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 1537              		.loc 13 204 47 view .LVU366
 1538 0058 0093     		str	r3, [sp]	@ float
 1539              	.LVL118:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 1540              		.loc 13 204 47 view .LVU367
 1541              	.LBE836:
 1542              	.LBE835:
 1543              	.LBE834:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 1544              		.loc 13 117 19 view .LVU368
 1545 005a 0123     		movs	r3, #1
 1546 005c 8DF80430 		strb	r3, [sp, #4]
 1547              	.LVL119:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 1548              		.loc 13 117 19 view .LVU369
 1549              	.LBE832:
 1550              	.LBE831:
 1551              	.LBE830:
 1552              	.LBE829:
 1553              	.LBE828:
 1554              	.LBE827:
 1555              	.LBE825:
 1556              	.LBE824:
 1557              	.LBE823:
 1558              	.LBE821:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1559              		.loc 13 701 51 view .LVU370
 1560 0060 E6E7     		b	.L78
 1561              	.LVL120:
 1562              	.L89:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1563              		.loc 13 701 51 view .LVU371
 1564              	.LBE820:
 1565              	.LBE819:
 1566              	.LBE818:
 1567              	.LBE817:
 1568              	.LBB838:
 1569              	.LBB816:
 1570              	.LBB814:
 1571              	.LBI814:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 1572              		.loc 1 1287 3 is_stmt 1 view .LVU372
 1573              	.LBB815:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 1574              		.loc 1 1289 5 view .LVU373
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 1575              		.loc 1 1292 7 view .LVU374
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 1576              		.loc 1 1292 33 is_stmt 0 view .LVU375
 1577 0062 1048     		ldr	r0, .L91
ARM GAS  /tmp/ccawPiBL.s 			page 183


 1578              	.LVL121:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 1579              		.loc 1 1292 33 view .LVU376
 1580 0064 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 1581              	.LVL122:
 1582              	.L77:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 1583              		.loc 1 1292 33 view .LVU377
 1584              	.LBE815:
 1585              	.LBE814:
 1586              	.LBE816:
 1587              	.LBE838:
 1588              	.LBB839:
 1589              	.LBI839:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1590              		.loc 13 692 17 is_stmt 1 view .LVU378
 1591              	.LBB840:
 1592              	.LBB841:
 1593              	.LBI841:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1594              		.loc 13 602 17 view .LVU379
 1595              	.LBB842:
 1596              	.LBI842:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 1597              		.loc 13 302 7 view .LVU380
 1598              	.LBB843:
 1599              	.LBI843:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 1600              		.loc 13 110 7 view .LVU381
 1601              	.LBB844:
 1602              	.LBB845:
 1603              	.LBI845:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1604              		.loc 13 199 14 view .LVU382
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1605              		.loc 13 199 14 is_stmt 0 view .LVU383
 1606              	.LBE845:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 1607              		.loc 13 110 7 view .LVU384
 1608 0068 0023     		movs	r3, #0
 1609              	.LVL123:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 1610              		.loc 13 110 7 view .LVU385
 1611 006a 8DF80430 		strb	r3, [sp, #4]
 1612              	.LVL124:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 1613              		.loc 13 110 7 view .LVU386
 1614 006e DFE7     		b	.L78
 1615              	.LVL125:
 1616              	.L87:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 1617              		.loc 13 110 7 view .LVU387
 1618              	.LBE844:
 1619              	.LBE843:
 1620              	.LBE842:
 1621              	.LBE841:
 1622              	.LBE840:
ARM GAS  /tmp/ccawPiBL.s 			page 184


 1623              	.LBE839:
 1624              	.LBE802:
 1625              	.LBB846:
 1626              	.LBB758:
 1627              	.LBB759:
 1628              	.LBI759:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 1629              		.loc 1 1661 5 is_stmt 1 view .LVU388
 1630              	.LBB760:
 1631              	.LBB761:
 1632              	.LBI761:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 1633              		.loc 1 1571 24 view .LVU389
 1634              	.LBB762:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 1635              		.loc 1 1575 17 is_stmt 0 view .LVU390
 1636 0070 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 1637              	.LVL126:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 1638              		.loc 1 1575 17 view .LVU391
 1639              	.LBE762:
 1640              	.LBE761:
 1641              		.loc 1 1665 7 view .LVU392
 1642 0072 012A     		cmp	r2, #1
 1643 0074 07D1     		bne	.L90
 1644              	.LVL127:
 1645              	.LBB763:
 1646              	.LBI763:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 1647              		.loc 1 276 5 is_stmt 1 view .LVU393
 1648              	.LBB764:
 1649              	.LBB765:
 1650              	.LBI765:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 1651              		.loc 1 267 5 view .LVU394
 1652              	.LBB766:
 1653              	.LBB767:
 1654              	.LBI767:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 1655              		.loc 1 262 5 view .LVU395
 1656              	.LBB768:
 1657              	.LBI768:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 1658              		.loc 1 222 24 view .LVU396
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 1659              		.loc 1 222 24 is_stmt 0 view .LVU397
 1660              	.LBE768:
 1661              	.LBE767:
 1662              	.LBE766:
 1663              	.LBE765:
 1664              	.LBE764:
 1665              	.LBE763:
 1666              	.LBE760:
 1667              	.LBE759:
 170:./MotorControl/component.hpp ****             T* ptr = std::get<1>(content_);
 1668              		.loc 12 170 16 view .LVU398
 1669 0076 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccawPiBL.s 			page 185


 1670              	.LVL128:
 171:./MotorControl/component.hpp ****             return ptr ? std::make_optional(*ptr) : std::nullopt;
 1671              		.loc 12 171 58 view .LVU399
 1672 0078 43B1     		cbz	r3, .L81
 1673              	.LVL129:
 1674              	.LBB772:
 1675              	.LBI772:
 917:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 918:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 919:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&
 920:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value() const&
 921:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 922:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 923:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? this->_M_get()
 924:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), this->_M_get());
 925:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 926:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 927:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&
 928:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value()&
 929:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 930:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 931:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? this->_M_get()
 932:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), this->_M_get());
 933:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 934:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 935:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr _Tp&&
 936:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value()&&
 937:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 938:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 939:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? std::move(this->_M_get())
 940:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), std::move(this->_M_get()));
 941:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 942:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 943:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       constexpr const _Tp&&
 944:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       value() const&&
 945:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       {
 946:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	return this->_M_is_engaged()
 947:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  ? std::move(this->_M_get())
 948:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  : (__throw_bad_optional_access(), std::move(this->_M_get()));
 949:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       }
 950:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 951:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 952:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr _Tp
 953:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	value_or(_Up&& __u) const&
 954:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 955:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_copy_constructible_v<_Tp>);
 956:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_convertible_v<_Up&&, _Tp>);
 957:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 958:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_is_engaged()
 959:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    ? this->_M_get() : static_cast<_Tp>(std::forward<_Up>(__u));
 960:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 961:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 962:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       template<typename _Up>
 963:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	constexpr _Tp
 964:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	value_or(_Up&& __u) &&
 965:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{
 966:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_move_constructible_v<_Tp>);
ARM GAS  /tmp/ccawPiBL.s 			page 186


 967:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  static_assert(is_convertible_v<_Up&&, _Tp>);
 968:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 969:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	  return this->_M_is_engaged()
 970:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    ? std::move(this->_M_get())
 971:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : static_cast<_Tp>(std::forward<_Up>(__u));
 972:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	}
 973:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 974:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       void reset() noexcept { this->_M_reset(); }
 975:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 976:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 977:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
 978:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __optional_relop_t =
 979:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       enable_if_t<is_convertible<_Tp, bool>::value, bool>;
 980:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 981:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 982:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __optional_eq_t = __optional_relop_t<
 983:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       decltype(std::declval<const _Tp&>() == std::declval<const _Up&>())
 984:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       >;
 985:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 986:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 987:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __optional_ne_t = __optional_relop_t<
 988:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       decltype(std::declval<const _Tp&>() != std::declval<const _Up&>())
 989:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       >;
 990:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 991:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 992:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __optional_lt_t = __optional_relop_t<
 993:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       decltype(std::declval<const _Tp&>() < std::declval<const _Up&>())
 994:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       >;
 995:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 996:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
 997:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __optional_gt_t = __optional_relop_t<
 998:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       decltype(std::declval<const _Tp&>() > std::declval<const _Up&>())
 999:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       >;
1000:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1001:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1002:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __optional_le_t = __optional_relop_t<
1003:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       decltype(std::declval<const _Tp&>() <= std::declval<const _Up&>())
1004:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       >;
1005:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1006:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1007:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     using __optional_ge_t = __optional_relop_t<
1008:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       decltype(std::declval<const _Tp&>() >= std::declval<const _Up&>())
1009:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       >;
1010:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1011:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Comparisons between optional values.
1012:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1013:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1014:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator==(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
1015:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_eq_t<_Tp, _Up>
1016:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
1017:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       return static_cast<bool>(__lhs) == static_cast<bool>(__rhs)
1018:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	     && (!__lhs || *__lhs == *__rhs);
1019:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     }
1020:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1021:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1022:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1023:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator!=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
ARM GAS  /tmp/ccawPiBL.s 			page 187


1024:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_ne_t<_Tp, _Up>
1025:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
1026:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       return static_cast<bool>(__lhs) != static_cast<bool>(__rhs)
1027:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	|| (static_cast<bool>(__lhs) && *__lhs != *__rhs);
1028:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     }
1029:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1030:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1031:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1032:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
1033:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_lt_t<_Tp, _Up>
1034:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
1035:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       return static_cast<bool>(__rhs) && (!__lhs || *__lhs < *__rhs);
1036:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     }
1037:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1038:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1039:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1040:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
1041:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_gt_t<_Tp, _Up>
1042:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
1043:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       return static_cast<bool>(__lhs) && (!__rhs || *__lhs > *__rhs);
1044:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     }
1045:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1046:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1047:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1048:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
1049:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_le_t<_Tp, _Up>
1050:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
1051:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       return !__lhs || (static_cast<bool>(__rhs) && *__lhs <= *__rhs);
1052:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     }
1053:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1054:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1055:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1056:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
1057:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_ge_t<_Tp, _Up>
1058:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
1059:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       return !__rhs || (static_cast<bool>(__lhs) && *__lhs >= *__rhs);
1060:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     }
1061:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1062:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #ifdef __cpp_lib_three_way_comparison
1063:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, three_way_comparable_with<_Tp> _Up>
1064:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr compare_three_way_result_t<_Tp, _Up>
1065:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=>(const optional<_Tp>& __x, const optional<_Up>& __y)
1066:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     {
1067:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       return __x && __y ? *__x <=> *__y : bool(__x) <=> bool(__y);
1068:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     }
1069:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #endif
1070:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1071:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Comparisons with nullopt.
1072:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1073:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1074:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator==(const optional<_Tp>& __lhs, nullopt_t) noexcept
1075:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__lhs; }
1076:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1077:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #ifdef __cpp_lib_three_way_comparison
1078:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1079:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr strong_ordering
1080:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=>(const optional<_Tp>& __x, nullopt_t) noexcept
ARM GAS  /tmp/ccawPiBL.s 			page 188


1081:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return bool(__x) <=> false; }
1082:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #else
1083:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1084:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1085:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator==(nullopt_t, const optional<_Tp>& __rhs) noexcept
1086:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__rhs; }
1087:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1088:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1089:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1090:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator!=(const optional<_Tp>& __lhs, nullopt_t) noexcept
1091:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return static_cast<bool>(__lhs); }
1092:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1093:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1094:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1095:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator!=(nullopt_t, const optional<_Tp>& __rhs) noexcept
1096:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return static_cast<bool>(__rhs); }
1097:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1098:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1099:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<(const optional<_Tp>& /* __lhs */, nullopt_t) noexcept
1101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return false; }
1102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<(nullopt_t, const optional<_Tp>& __rhs) noexcept
1106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return static_cast<bool>(__rhs); }
1107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>(const optional<_Tp>& __lhs, nullopt_t) noexcept
1111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return static_cast<bool>(__lhs); }
1112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>(nullopt_t, const optional<_Tp>& /* __rhs */) noexcept
1116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return false; }
1117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=(const optional<_Tp>& __lhs, nullopt_t) noexcept
1121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__lhs; }
1122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=(nullopt_t, const optional<_Tp>& /* __rhs */) noexcept
1126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return true; }
1127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>=(const optional<_Tp>& /* __lhs */, nullopt_t) noexcept
1131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return true; }
1132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr bool
1135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>=(nullopt_t, const optional<_Tp>& __rhs) noexcept
1136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__rhs; }
1137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #endif // three-way-comparison
ARM GAS  /tmp/ccawPiBL.s 			page 189


1138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Comparisons with value type.
1140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator==(const optional<_Tp>& __lhs, const _Up& __rhs)
1143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_eq_t<_Tp, _Up>
1144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return __lhs && *__lhs == __rhs; }
1145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator==(const _Up& __lhs, const optional<_Tp>& __rhs)
1149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_eq_t<_Up, _Tp>
1150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return __rhs && __lhs == *__rhs; }
1151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator!=(const optional<_Tp>& __lhs, const _Up& __rhs)
1155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_ne_t<_Tp, _Up>
1156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__lhs || *__lhs != __rhs; }
1157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator!=(const _Up& __lhs, const optional<_Tp>& __rhs)
1161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_ne_t<_Up, _Tp>
1162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__rhs || __lhs != *__rhs; }
1163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<(const optional<_Tp>& __lhs, const _Up& __rhs)
1167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_lt_t<_Tp, _Up>
1168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__lhs || *__lhs < __rhs; }
1169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<(const _Up& __lhs, const optional<_Tp>& __rhs)
1173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_lt_t<_Up, _Tp>
1174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return __rhs && __lhs < *__rhs; }
1175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>(const optional<_Tp>& __lhs, const _Up& __rhs)
1179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_gt_t<_Tp, _Up>
1180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return __lhs && *__lhs > __rhs; }
1181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>(const _Up& __lhs, const optional<_Tp>& __rhs)
1185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_gt_t<_Up, _Tp>
1186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__rhs || __lhs > *__rhs; }
1187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=(const optional<_Tp>& __lhs, const _Up& __rhs)
1191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_le_t<_Tp, _Up>
1192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__lhs || *__lhs <= __rhs; }
1193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
ARM GAS  /tmp/ccawPiBL.s 			page 190


1195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=(const _Up& __lhs, const optional<_Tp>& __rhs)
1197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_le_t<_Up, _Tp>
1198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return __rhs && __lhs <= *__rhs; }
1199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>=(const optional<_Tp>& __lhs, const _Up& __rhs)
1203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_ge_t<_Tp, _Up>
1204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return __lhs && *__lhs >= __rhs; }
1205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr auto
1208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator>=(const _Up& __lhs, const optional<_Tp>& __rhs)
1209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     -> __optional_ge_t<_Up, _Tp>
1210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return !__rhs || __lhs >= *__rhs; }
1211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #ifdef __cpp_lib_three_way_comparison
1213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     inline constexpr bool __is_optional_v = false;
1215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     inline constexpr bool __is_optional_v<optional<_Tp>> = true;
1217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp, typename _Up>
1219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     requires (!__is_optional_v<_Up>)
1220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       && three_way_comparable_with<_Tp, _Up>
1221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr compare_three_way_result_t<_Tp, _Up>
1222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     operator<=>(const optional<_Tp>& __x, const _Up& __v)
1223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { return bool(__x) ? *__x <=> __v : strong_ordering::less; }
1224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** #endif
1225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // Swap and creation functions.
1227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // _GLIBCXX_RESOLVE_LIB_DEFECTS
1229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   // 2748. swappable traits for optionals
1230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     inline enable_if_t<is_move_constructible_v<_Tp> && is_swappable_v<_Tp>>
1232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     swap(optional<_Tp>& __lhs, optional<_Tp>& __rhs)
1233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     noexcept(noexcept(__lhs.swap(__rhs)))
1234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     { __lhs.swap(__rhs); }
1235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1237:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     enable_if_t<!(is_move_constructible_v<_Tp> && is_swappable_v<_Tp>)>
1238:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     swap(optional<_Tp>&, optional<_Tp>&) = delete;
1239:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
1240:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****   template<typename _Tp>
1241:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     constexpr optional<decay_t<_Tp>>
1242:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     make_optional(_Tp&& __t)
 1676              		.loc 13 1242 5 is_stmt 1 view .LVU400
 1677              	.LBB773:
 1678              	.LBB774:
 1679              	.LBI774:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 1680              		.loc 13 700 2 view .LVU401
 1681              	.LBB775:
 1682              	.LBB776:
 1683              	.LBB777:
ARM GAS  /tmp/ccawPiBL.s 			page 191


 1684              	.LBI777:
 1685              		.loc 14 76 5 view .LVU402
 1686              		.loc 14 76 5 is_stmt 0 view .LVU403
 1687              	.LBE777:
 1688              	.LBB778:
 1689              	.LBI778:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 1690              		.loc 13 607 28 is_stmt 1 view .LVU404
 1691              	.LBB779:
 1692              	.LBB780:
 1693              	.LBB781:
 1694              	.LBI781:
 1695              		.loc 14 76 5 view .LVU405
 1696              		.loc 14 76 5 is_stmt 0 view .LVU406
 1697              	.LBE781:
 1698              	.LBB782:
 1699              	.LBI782:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1700              		.loc 13 300 42 is_stmt 1 view .LVU407
 1701              	.LBB783:
 1702              	.LBB784:
 1703              	.LBB785:
 1704              	.LBI785:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 1705              		.loc 13 115 2 view .LVU408
 1706              	.LBB786:
 1707              	.LBB787:
 1708              	.LBB788:
 1709              	.LBI788:
 1710              		.loc 14 76 5 view .LVU409
 1711              		.loc 14 76 5 is_stmt 0 view .LVU410
 1712              	.LBE788:
 1713              	.LBB789:
 1714              	.LBI789:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 1715              		.loc 13 203 6 is_stmt 1 view .LVU411
 1716              	.LBB790:
 1717              	.LBB791:
 1718              	.LBB792:
 1719              	.LBI792:
 1720              		.loc 14 76 5 view .LVU412
 1721              		.loc 14 76 5 is_stmt 0 view .LVU413
 1722              	.LBE792:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 1723              		.loc 13 204 47 view .LVU414
 1724 007a 1B68     		ldr	r3, [r3]	@ float
 1725              	.LVL130:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 1726              		.loc 13 204 47 view .LVU415
 1727 007c 0093     		str	r3, [sp]	@ float
 1728              	.LVL131:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 1729              		.loc 13 204 47 view .LVU416
 1730              	.LBE791:
 1731              	.LBE790:
 1732              	.LBE789:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
ARM GAS  /tmp/ccawPiBL.s 			page 192


 1733              		.loc 13 117 19 view .LVU417
 1734 007e 0123     		movs	r3, #1
 1735 0080 8DF80430 		strb	r3, [sp, #4]
 1736              	.LVL132:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 1737              		.loc 13 117 19 view .LVU418
 1738              	.LBE787:
 1739              	.LBE786:
 1740              	.LBE785:
 1741              	.LBE784:
 1742              	.LBE783:
 1743              	.LBE782:
 1744              	.LBE780:
 1745              	.LBE779:
 1746              	.LBE778:
 1747              	.LBE776:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1748              		.loc 13 701 51 view .LVU419
 1749 0084 D4E7     		b	.L78
 1750              	.LVL133:
 1751              	.L90:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1752              		.loc 13 701 51 view .LVU420
 1753              	.LBE775:
 1754              	.LBE774:
 1755              	.LBE773:
 1756              	.LBE772:
 1757              	.LBB793:
 1758              	.LBB771:
 1759              	.LBB769:
 1760              	.LBI769:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 1761              		.loc 1 1287 3 is_stmt 1 view .LVU421
 1762              	.LBB770:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 1763              		.loc 1 1289 5 view .LVU422
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 1764              		.loc 1 1292 7 view .LVU423
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 1765              		.loc 1 1292 33 is_stmt 0 view .LVU424
 1766 0086 0748     		ldr	r0, .L91
 1767              	.LVL134:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 1768              		.loc 1 1292 33 view .LVU425
 1769 0088 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 1770              	.LVL135:
 1771              	.L81:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 1772              		.loc 1 1292 33 view .LVU426
 1773              	.LBE770:
 1774              	.LBE769:
 1775              	.LBE771:
 1776              	.LBE793:
 1777              	.LBB794:
 1778              	.LBI794:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1779              		.loc 13 692 17 is_stmt 1 view .LVU427
ARM GAS  /tmp/ccawPiBL.s 			page 193


 1780              	.LBB795:
 1781              	.LBB796:
 1782              	.LBI796:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1783              		.loc 13 602 17 view .LVU428
 1784              	.LBB797:
 1785              	.LBI797:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 1786              		.loc 13 302 7 view .LVU429
 1787              	.LBB798:
 1788              	.LBI798:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 1789              		.loc 13 110 7 view .LVU430
 1790              	.LBB799:
 1791              	.LBB800:
 1792              	.LBI800:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1793              		.loc 13 199 14 view .LVU431
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 1794              		.loc 13 199 14 is_stmt 0 view .LVU432
 1795              	.LBE800:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 1796              		.loc 13 110 7 view .LVU433
 1797 008c 0023     		movs	r3, #0
 1798              	.LVL136:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 1799              		.loc 13 110 7 view .LVU434
 1800 008e 8DF80430 		strb	r3, [sp, #4]
 1801              	.LVL137:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 1802              		.loc 13 110 7 view .LVU435
 1803 0092 CDE7     		b	.L78
 1804              	.LVL138:
 1805              	.L88:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 1806              		.loc 13 110 7 view .LVU436
 1807              	.LBE799:
 1808              	.LBE798:
 1809              	.LBE797:
 1810              	.LBE796:
 1811              	.LBE795:
 1812              	.LBE794:
 1813              	.LBE758:
 1814              	.LBB801:
 1815              	.LBB738:
 1816              	.LBB736:
 1817              	.LBI736:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 1818              		.loc 1 1287 3 is_stmt 1 view .LVU437
 1819              	.LBB737:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 1820              		.loc 1 1289 5 view .LVU438
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 1821              		.loc 1 1292 7 view .LVU439
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 1822              		.loc 1 1292 33 is_stmt 0 view .LVU440
 1823 0094 0348     		ldr	r0, .L91
ARM GAS  /tmp/ccawPiBL.s 			page 194


 1824              	.LVL139:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 1825              		.loc 1 1292 33 view .LVU441
 1826 0096 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 1827              	.LVL140:
 1828              	.L84:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 1829              		.loc 1 1292 33 view .LVU442
 1830              	.LBE737:
 1831              	.LBE736:
 1832              	.LBE738:
 1833              	.LBE801:
 1834              	.LBE846:
 1835              	.LBE847:
 1836              	.LBE851:
 1837              	.LBE852:
 1838              	.LBE721:
 127:MotorControl/controller.cpp **** }
 1839              		.loc 3 127 12 view .LVU443
 1840 009a 0124     		movs	r4, #1
 1841              	.LVL141:
 1842              	.L72:
 128:MotorControl/controller.cpp **** 
 1843              		.loc 3 128 1 view .LVU444
 1844 009c 2046     		mov	r0, r4
 1845 009e 02B0     		add	sp, sp, #8
 1846              	.LCFI14:
 1847              		.cfi_def_cfa_offset 8
 1848              		@ sp needed
 1849 00a0 10BD     		pop	{r4, pc}
 1850              	.L92:
 1851 00a2 00BF     		.align	2
 1852              	.L91:
 1853 00a4 00000000 		.word	.LC0
 1854              		.cfi_endproc
 1855              	.LFE5195:
 1856              		.fnend
 1858              		.section	.text._ZN10Controller19update_filter_gainsEv,"ax",%progbits
 1859              		.align	1
 1860              		.global	_ZN10Controller19update_filter_gainsEv
 1861              		.syntax unified
 1862              		.thumb
 1863              		.thumb_func
 1865              	_ZN10Controller19update_filter_gainsEv:
 1866              		.fnstart
 1867              	.LVL142:
 1868              	.LFB5201:
 131:MotorControl/controller.cpp ****     float bandwidth = std::min(config_.input_filter_bandwidth, 0.25f * current_meas_hz);
 1869              		.loc 3 131 40 is_stmt 1 view -0
 1870              		.cfi_startproc
 1871              		@ args = 0, pretend = 0, frame = 8
 1872              		@ frame_needed = 0, uses_anonymous_args = 0
 1873              		@ link register save eliminated.
 131:MotorControl/controller.cpp ****     float bandwidth = std::min(config_.input_filter_bandwidth, 0.25f * current_meas_hz);
 1874              		.loc 3 131 40 is_stmt 0 view .LVU446
 1875 0000 82B0     		sub	sp, sp, #8
 1876              	.LCFI15:
ARM GAS  /tmp/ccawPiBL.s 			page 195


 1877              		.cfi_def_cfa_offset 8
 132:MotorControl/controller.cpp ****     input_filter_ki_ = 2.0f * bandwidth;  // basic conversion to discrete time
 1878              		.loc 3 132 5 is_stmt 1 view .LVU447
 132:MotorControl/controller.cpp ****     input_filter_ki_ = 2.0f * bandwidth;  // basic conversion to discrete time
 1879              		.loc 3 132 40 is_stmt 0 view .LVU448
 1880 0002 00F14C03 		add	r3, r0, #76
 132:MotorControl/controller.cpp ****     input_filter_ki_ = 2.0f * bandwidth;  // basic conversion to discrete time
 1881              		.loc 3 132 70 view .LVU449
 1882 0006 DFED117A 		vldr.32	s15, .L98
 1883 000a CDED017A 		vstr.32	s15, [sp, #4]
 1884              	.LVL143:
 1885              	.LBB853:
 1886              	.LBI853:
 1887              		.file 15 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Core algorithmic facilities -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Copyright (C) 2001-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** /*
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Copyright (c) 1994
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Hewlett-Packard Company
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Permission to use, copy, modify, distribute and sell this software
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * and its documentation for any purpose is hereby granted without fee,
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * provided that the above copyright notice appear in all copies and
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * that both that copyright notice and this permission notice appear
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * in supporting documentation.  Hewlett-Packard Company makes no
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * representations about the suitability of this software for any
  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Copyright (c) 1996-1998
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Silicon Graphics Computer Systems, Inc.
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * Permission to use, copy, modify, distribute and sell this software
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * and its documentation for any purpose is hereby granted without fee,
ARM GAS  /tmp/ccawPiBL.s 			page 196


  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * provided that the above copyright notice appear in all copies and
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * that both that copyright notice and this permission notice appear
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * in supporting documentation.  Silicon Graphics makes no
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * representations about the suitability of this software for any
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  * purpose.  It is provided "as is" without express or implied warranty.
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  */
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** /** @file bits/stl_algobase.h
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *  This is an internal header file, included by other library headers.
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  *  Do not attempt to use it directly. @headername{algorithm}
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****  */
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #ifndef _STL_ALGOBASE_H
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #define _STL_ALGOBASE_H 1
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/c++config.h>
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/functexcept.h>
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/cpp_type_traits.h>
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <ext/type_traits.h>
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <ext/numeric_traits.h>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_pair.h>
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator_base_types.h>
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator_base_funcs.h>
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/stl_iterator.h>
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/concept_check.h>
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <debug/debug.h>
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/move.h> // For std::swap
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #include <bits/predefined_ops.h>
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** # include <type_traits>
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus > 201703L
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** # include <compare>
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** namespace std _GLIBCXX_VISIBILITY(default)
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** {
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** _GLIBCXX_BEGIN_NAMESPACE_VERSION
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /*
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    * A constexpr wrapper for __builtin_memcmp.
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    * @param __num The number of elements of type _Tp (not bytes).
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    */
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp, typename _Up>
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline int
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus >= 201103L
  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #ifdef __cpp_lib_is_constant_evaluated
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (std::is_constant_evaluated())
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  for(; __num > 0; ++__first1, ++__first2, --__num)
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    if (*__first1 != *__first2)
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	      return *__first1 < *__first2 ? -1 : 1;
ARM GAS  /tmp/ccawPiBL.s 			page 197


 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  return 0;
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       else
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus < 201103L
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // nutshell, we are partially implementing the resolution of DR 187,
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   // when it's safe, i.e., the value_types are equal.
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<bool _BoolType>
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __iter_swap
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _ForwardIterator1, typename _ForwardIterator2>
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static void
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  typedef typename iterator_traits<_ForwardIterator1>::value_type
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	    _ValueType1;
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  _ValueType1 __tmp = *__a;
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  *__a = *__b;
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  *__b = __tmp;
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<>
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     struct __iter_swap<true>
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       template<typename _ForwardIterator1, typename _ForwardIterator2>
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	static void
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	{
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	  swap(*__a, *__b);
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	}
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     };
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif // C++03
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Swaps the contents of two iterators.
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  An iterator.
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another iterator.
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   Nothing.
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This function swaps the values pointed to by two iterators, not the
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  iterators themselves.
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2>
 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline void
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator1>)
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
ARM GAS  /tmp/ccawPiBL.s 			page 198


 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator2>)
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #if __cplusplus < 201103L
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator1>::value_type
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ValueType1;
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator2>::value_type
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ValueType2;
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ValueType2>)
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ValueType1>)
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator1>::reference
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ReferenceType1;
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       typedef typename iterator_traits<_ForwardIterator2>::reference
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	_ReferenceType2;
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	&& __are_same<_ValueType1&, _ReferenceType1>::__value
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	&& __are_same<_ValueType2&, _ReferenceType2>::__value>::
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	iter_swap(__a, __b);
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #else
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // _GLIBCXX_RESOLVE_LIB_DEFECTS
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // 187. iter_swap underspecified
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       swap(*__a, *__b);
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** #endif
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 186:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 187:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief Swap the elements of two sequences.
 188:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup mutating_algorithms
 189:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first1  A forward iterator.
 190:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __last1   A forward iterator.
 191:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __first2  A forward iterator.
 192:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   An iterator equal to @p first2+(last1-first1).
 193:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 194:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  Swaps each element in the range @p [first1,last1) with the
 195:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  corresponding element in the range @p [first2,(last1-first1)).
 196:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  The ranges must not overlap.
 197:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 198:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _ForwardIterator1, typename _ForwardIterator2>
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX20_CONSTEXPR
 200:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _ForwardIterator2
 201:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
 202:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 		_ForwardIterator2 __first2)
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 205:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 206:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator1>)
 207:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
 208:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 				  _ForwardIterator2>)
 209:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_requires_valid_range(__first1, __last1);
 210:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 211:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       for (; __first1 != __last1; ++__first1, (void)++__first2)
 212:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	std::iter_swap(__first1, __first2);
 213:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       return __first2;
 214:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     }
ARM GAS  /tmp/ccawPiBL.s 			page 199


 215:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 
 216:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   /**
 217:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @brief This does what you think it does.
 218:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @ingroup sorting_algorithms
 219:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __a  A thing of arbitrary type.
 220:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @param  __b  Another thing of arbitrary type.
 221:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  @return   The lesser of the parameters.
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *
 223:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  This is the simple classic generic implementation.  It will work on
 224:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  temporary expressions, since they are only evaluated once, unlike a
 225:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****    *  preprocessor macro.
 226:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   */
 227:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****   template<typename _Tp>
 228:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     _GLIBCXX14_CONSTEXPR
 229:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     inline const _Tp&
 230:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     min(const _Tp& __a, const _Tp& __b)
 1888              		.loc 15 230 5 is_stmt 1 view .LVU450
 1889              	.LBB854:
 231:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****     {
 232:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       // concept requirements
 233:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
 234:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       //return __b < __a ? __b : __a;
 235:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h ****       if (__b < __a)
 1890              		.loc 15 235 15 is_stmt 0 view .LVU451
 1891 000e 90ED137A 		vldr.32	s14, [r0, #76]
 1892              		.loc 15 235 7 view .LVU452
 1893 0012 B4EEE77A 		vcmpe.f32	s14, s15
 1894 0016 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 1895 001a 15DC     		bgt	.L97
 1896              	.LVL144:
 1897              	.L94:
 1898              		.loc 15 235 7 view .LVU453
 1899              	.LBE854:
 1900              	.LBE853:
 132:MotorControl/controller.cpp ****     input_filter_ki_ = 2.0f * bandwidth;  // basic conversion to discrete time
 1901              		.loc 3 132 87 view .LVU454
 1902 001c D3ED007A 		vldr.32	s15, [r3]
 1903              	.LVL145:
 133:MotorControl/controller.cpp ****     input_filter_kp_ = 0.25f * (input_filter_ki_ * input_filter_ki_); // Critically damped
 1904              		.loc 3 133 5 is_stmt 1 view .LVU455
 133:MotorControl/controller.cpp ****     input_filter_kp_ = 0.25f * (input_filter_ki_ * input_filter_ki_); // Critically damped
 1905              		.loc 3 133 29 is_stmt 0 view .LVU456
 1906 0020 77EEA77A 		vadd.f32	s15, s15, s15
 1907              	.LVL146:
 133:MotorControl/controller.cpp ****     input_filter_kp_ = 0.25f * (input_filter_ki_ * input_filter_ki_); // Critically damped
 1908              		.loc 3 133 22 view .LVU457
 1909 0024 00F54050 		add	r0, r0, #12288
 1910              	.LVL147:
 133:MotorControl/controller.cpp ****     input_filter_kp_ = 0.25f * (input_filter_ki_ * input_filter_ki_); // Critically damped
 1911              		.loc 3 133 22 view .LVU458
 1912 0028 00F62413 		addw	r3, r0, #2340
 1913              	.LVL148:
 133:MotorControl/controller.cpp ****     input_filter_kp_ = 0.25f * (input_filter_ki_ * input_filter_ki_); // Critically damped
 1914              		.loc 3 133 22 view .LVU459
 1915 002c C3ED007A 		vstr.32	s15, [r3]
 134:MotorControl/controller.cpp **** }
 1916              		.loc 3 134 5 is_stmt 1 view .LVU460
ARM GAS  /tmp/ccawPiBL.s 			page 200


 134:MotorControl/controller.cpp **** }
 1917              		.loc 3 134 50 is_stmt 0 view .LVU461
 1918 0030 67EEA77A 		vmul.f32	s15, s15, s15
 134:MotorControl/controller.cpp **** }
 1919              		.loc 3 134 30 view .LVU462
 1920 0034 B5EE007A 		vmov.f32	s14, #2.5e-1
 1921 0038 67EE877A 		vmul.f32	s15, s15, s14
 134:MotorControl/controller.cpp **** }
 1922              		.loc 3 134 22 view .LVU463
 1923 003c 00F51260 		add	r0, r0, #2336
 1924              	.LVL149:
 134:MotorControl/controller.cpp **** }
 1925              		.loc 3 134 22 view .LVU464
 1926 0040 C0ED007A 		vstr.32	s15, [r0]
 135:MotorControl/controller.cpp **** 
 1927              		.loc 3 135 1 view .LVU465
 1928 0044 02B0     		add	sp, sp, #8
 1929              	.LCFI16:
 1930              		.cfi_remember_state
 1931              		.cfi_def_cfa_offset 0
 1932              		@ sp needed
 1933 0046 7047     		bx	lr
 1934              	.LVL150:
 1935              	.L97:
 1936              	.LCFI17:
 1937              		.cfi_restore_state
 1938              	.LBB856:
 1939              	.LBB855:
 236:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algobase.h **** 	return __b;
 1940              		.loc 15 236 9 view .LVU466
 1941 0048 01AB     		add	r3, sp, #4
 1942              	.LVL151:
 1943              		.loc 15 236 9 view .LVU467
 1944 004a E7E7     		b	.L94
 1945              	.L99:
 1946              		.align	2
 1947              	.L98:
 1948 004c 0000FA44 		.word	1157234688
 1949              	.LBE855:
 1950              	.LBE856:
 1951              		.cfi_endproc
 1952              	.LFE5201:
 1953              		.cantunwind
 1954              		.fnend
 1956              		.section	.text._ZN10Controller12apply_configEv,"ax",%progbits
 1957              		.align	1
 1958              		.global	_ZN10Controller12apply_configEv
 1959              		.syntax unified
 1960              		.thumb
 1961              		.thumb_func
 1963              	_ZN10Controller12apply_configEv:
 1964              		.fnstart
 1965              	.LVL152:
 1966              	.LFB5186:
   6:MotorControl/controller.cpp ****     config_.parent = this;
 1967              		.loc 3 6 33 is_stmt 1 view -0
 1968              		.cfi_startproc
ARM GAS  /tmp/ccawPiBL.s 			page 201


 1969              		@ args = 0, pretend = 0, frame = 0
 1970              		@ frame_needed = 0, uses_anonymous_args = 0
   6:MotorControl/controller.cpp ****     config_.parent = this;
 1971              		.loc 3 6 33 is_stmt 0 view .LVU469
 1972 0000 08B5     		push	{r3, lr}
 1973              	.LCFI18:
 1974              		.cfi_def_cfa_offset 8
 1975              		.cfi_offset 3, -8
 1976              		.cfi_offset 14, -4
   7:MotorControl/controller.cpp ****     update_filter_gains();
 1977              		.loc 3 7 5 is_stmt 1 view .LVU470
   7:MotorControl/controller.cpp ****     update_filter_gains();
 1978              		.loc 3 7 20 is_stmt 0 view .LVU471
 1979 0002 00F54052 		add	r2, r0, #12288
 1980 0006 C2F8D408 		str	r0, [r2, #2260]
   8:MotorControl/controller.cpp ****     return true;
 1981              		.loc 3 8 5 is_stmt 1 view .LVU472
   8:MotorControl/controller.cpp ****     return true;
 1982              		.loc 3 8 24 is_stmt 0 view .LVU473
 1983 000a FFF7FEFF 		bl	_ZN10Controller19update_filter_gainsEv
 1984              	.LVL153:
   9:MotorControl/controller.cpp **** }
 1985              		.loc 3 9 5 is_stmt 1 view .LVU474
  10:MotorControl/controller.cpp **** 
 1986              		.loc 3 10 1 is_stmt 0 view .LVU475
 1987 000e 0120     		movs	r0, #1
 1988 0010 08BD     		pop	{r3, pc}
 1989              		.cfi_endproc
 1990              	.LFE5186:
 1991              		.cantunwind
 1992              		.fnend
 1994              		.section	.text._ZN9InputPortIfE7presentEv,"axG",%progbits,_ZN9InputPortIfE7presentEv,comdat
 1995              		.align	1
 1996              		.weak	_ZN9InputPortIfE7presentEv
 1997              		.syntax unified
 1998              		.thumb
 1999              		.thumb_func
 2001              	_ZN9InputPortIfE7presentEv:
 2002              		.fnstart
 2003              	.LVL154:
 2004              	.LFB5617:
 137:./MotorControl/component.hpp ****         if (content_.index() == 2) {
 2005              		.loc 12 137 22 is_stmt 1 view -0
 2006              		.cfi_startproc
 2007              		@ args = 0, pretend = 0, frame = 0
 2008              		@ frame_needed = 0, uses_anonymous_args = 0
 137:./MotorControl/component.hpp ****         if (content_.index() == 2) {
 2009              		.loc 12 137 22 is_stmt 0 view .LVU477
 2010 0000 08B5     		push	{r3, lr}
 2011              		.save {r3, lr}
 2012              	.LCFI19:
 2013              		.cfi_def_cfa_offset 8
 2014              		.cfi_offset 3, -8
 2015              		.cfi_offset 14, -4
 2016              	.LVL155:
 2017              	.LBB987:
 2018              	.LBB988:
ARM GAS  /tmp/ccawPiBL.s 			page 202


 2019              	.LBI988:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 2020              		.loc 1 1571 24 is_stmt 1 view .LVU478
 2021              	.LBB989:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 2022              		.loc 1 1575 17 is_stmt 0 view .LVU479
 2023 0002 0B79     		ldrb	r3, [r1, #4]	@ zero_extendqisi2
 2024              	.LVL156:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 2025              		.loc 1 1575 17 view .LVU480
 2026              	.LBE989:
 2027              	.LBE988:
 138:./MotorControl/component.hpp ****             OutputPort<T>* ptr = std::get<2>(content_);
 2028              		.loc 12 138 9 view .LVU481
 2029 0004 022B     		cmp	r3, #2
 2030 0006 08D0     		beq	.L114
 2031              	.LBB990:
 141:./MotorControl/component.hpp ****             T* ptr = std::get<1>(content_);
 2032              		.loc 12 141 16 view .LVU482
 2033 0008 012B     		cmp	r3, #1
 2034 000a 19D0     		beq	.L115
 2035              	.LVL157:
 2036              	.LBB991:
 2037              	.LBI991:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2038              		.loc 1 1661 5 is_stmt 1 view .LVU483
 2039              	.LBB992:
 2040              	.LBB993:
 2041              	.LBI993:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 2042              		.loc 1 1571 24 view .LVU484
 2043              	.LBB994:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 2044              		.loc 1 1575 17 is_stmt 0 view .LVU485
 2045 000c 0B79     		ldrb	r3, [r1, #4]	@ zero_extendqisi2
 2046              	.LVL158:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 2047              		.loc 1 1575 17 view .LVU486
 2048              	.LBE994:
 2049              	.LBE993:
 2050              		.loc 1 1665 7 view .LVU487
 2051 000e 3BBB     		cbnz	r3, .L116
 2052              	.LVL159:
 2053              	.LBB995:
 2054              	.LBI995:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2055              		.loc 1 276 5 is_stmt 1 view .LVU488
 2056              	.LBB996:
 2057              	.LBB997:
 2058              	.LBI997:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 2059              		.loc 1 262 5 view .LVU489
 2060              	.LBB998:
 2061              	.LBI998:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2062              		.loc 1 222 24 view .LVU490
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
ARM GAS  /tmp/ccawPiBL.s 			page 203


 2063              		.loc 1 222 24 is_stmt 0 view .LVU491
 2064              	.LBE998:
 2065              	.LBE997:
 2066              	.LBE996:
 2067              	.LBE995:
 2068              	.LBE992:
 2069              	.LBE991:
 2070              	.LBB1002:
 2071              	.LBI1002:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 2072              		.loc 13 700 2 is_stmt 1 view .LVU492
 2073              	.LBB1003:
 2074              	.LBB1004:
 2075              	.LBB1005:
 2076              	.LBI1005:
 2077              		.loc 14 76 5 view .LVU493
 2078              		.loc 14 76 5 is_stmt 0 view .LVU494
 2079              	.LBE1005:
 2080              	.LBB1006:
 2081              	.LBI1006:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 2082              		.loc 13 607 28 is_stmt 1 view .LVU495
 2083              	.LBB1007:
 2084              	.LBB1008:
 2085              	.LBB1009:
 2086              	.LBI1009:
 2087              		.loc 14 76 5 view .LVU496
 2088              		.loc 14 76 5 is_stmt 0 view .LVU497
 2089              	.LBE1009:
 2090              	.LBB1010:
 2091              	.LBI1010:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2092              		.loc 13 300 42 is_stmt 1 view .LVU498
 2093              	.LBB1011:
 2094              	.LBB1012:
 2095              	.LBB1013:
 2096              	.LBI1013:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 2097              		.loc 13 115 2 view .LVU499
 2098              	.LBB1014:
 2099              	.LBB1015:
 2100              	.LBB1016:
 2101              	.LBI1016:
 2102              		.loc 14 76 5 view .LVU500
 2103              		.loc 14 76 5 is_stmt 0 view .LVU501
 2104              	.LBE1016:
 2105              	.LBB1017:
 2106              	.LBI1017:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 2107              		.loc 13 203 6 is_stmt 1 view .LVU502
 2108              	.LBB1018:
 2109              	.LBB1019:
 2110              	.LBB1020:
 2111              	.LBI1020:
 2112              		.loc 14 76 5 view .LVU503
 2113              		.loc 14 76 5 is_stmt 0 view .LVU504
 2114              	.LBE1020:
ARM GAS  /tmp/ccawPiBL.s 			page 204


 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2115              		.loc 13 204 47 view .LVU505
 2116 0010 0B68     		ldr	r3, [r1]	@ float
 2117 0012 0360     		str	r3, [r0]	@ float
 2118              	.LVL160:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2119              		.loc 13 204 47 view .LVU506
 2120              	.LBE1019:
 2121              	.LBE1018:
 2122              	.LBE1017:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2123              		.loc 13 117 19 view .LVU507
 2124 0014 0123     		movs	r3, #1
 2125 0016 0371     		strb	r3, [r0, #4]
 2126              	.LVL161:
 2127              	.L102:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2128              		.loc 13 117 19 view .LVU508
 2129              	.LBE1015:
 2130              	.LBE1014:
 2131              	.LBE1013:
 2132              	.LBE1012:
 2133              	.LBE1011:
 2134              	.LBE1010:
 2135              	.LBE1008:
 2136              	.LBE1007:
 2137              	.LBE1006:
 2138              	.LBE1004:
 2139              	.LBE1003:
 2140              	.LBE1002:
 2141              	.LBE990:
 2142              	.LBE987:
 147:./MotorControl/component.hpp **** 
 2143              		.loc 12 147 5 view .LVU509
 2144 0018 08BD     		pop	{r3, pc}
 2145              	.L114:
 2146              	.LVL162:
 2147              	.LBB1119:
 2148              	.LBB1065:
 2149              	.LBB1066:
 2150              	.LBI1066:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2151              		.loc 1 1661 5 is_stmt 1 view .LVU510
 2152              	.LBB1067:
 2153              	.LBB1068:
 2154              	.LBI1068:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 2155              		.loc 1 1571 24 view .LVU511
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 2156              		.loc 1 1571 24 is_stmt 0 view .LVU512
 2157              	.LBE1068:
 2158              		.loc 1 1665 7 view .LVU513
 2159 001a 06D1     		bne	.L117
 2160              	.LVL163:
 2161              	.LBB1069:
 2162              	.LBI1069:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
ARM GAS  /tmp/ccawPiBL.s 			page 205


 2163              		.loc 1 276 5 is_stmt 1 view .LVU514
 2164              	.LBB1070:
 2165              	.LBB1071:
 2166              	.LBI1071:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2167              		.loc 1 267 5 view .LVU515
 2168              	.LBB1072:
 2169              	.LBB1073:
 2170              	.LBI1073:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2171              		.loc 1 267 5 view .LVU516
 2172              	.LBB1074:
 2173              	.LBB1075:
 2174              	.LBI1075:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 2175              		.loc 1 262 5 view .LVU517
 2176              	.LBB1076:
 2177              	.LBI1076:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2178              		.loc 1 222 24 view .LVU518
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2179              		.loc 1 222 24 is_stmt 0 view .LVU519
 2180              	.LBE1076:
 2181              	.LBE1075:
 2182              	.LBE1074:
 2183              	.LBE1073:
 2184              	.LBE1072:
 2185              	.LBE1071:
 2186              	.LBE1070:
 2187              	.LBE1069:
 2188              	.LBE1067:
 2189              	.LBE1066:
 139:./MotorControl/component.hpp ****             return ptr ? ptr->present() : std::nullopt;
 2190              		.loc 12 139 28 view .LVU520
 2191 001c 0B68     		ldr	r3, [r1]
 2192              	.LVL164:
 140:./MotorControl/component.hpp ****         } else if (content_.index() == 1) {
 2193              		.loc 12 140 48 view .LVU521
 2194 001e 63B1     		cbz	r3, .L105
 2195              	.LVL165:
 2196              	.LBB1080:
 2197              	.LBI1080:
  73:./MotorControl/component.hpp ****         if (age_ == 0) {
 2198              		.loc 12 73 22 is_stmt 1 view .LVU522
 2199              	.LBB1081:
  74:./MotorControl/component.hpp ****             return content_;
 2200              		.loc 12 74 13 is_stmt 0 view .LVU523
 2201 0020 1A68     		ldr	r2, [r3]
  74:./MotorControl/component.hpp ****             return content_;
 2202              		.loc 12 74 9 view .LVU524
 2203 0022 2AB1     		cbz	r2, .L118
 2204              	.LVL166:
 2205              	.LBB1082:
 2206              	.LBI1082:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2207              		.loc 13 692 17 is_stmt 1 view .LVU525
 2208              	.LBB1083:
ARM GAS  /tmp/ccawPiBL.s 			page 206


 2209              	.LBB1084:
 2210              	.LBI1084:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2211              		.loc 13 602 17 view .LVU526
 2212              	.LBB1085:
 2213              	.LBI1085:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 2214              		.loc 13 302 7 view .LVU527
 2215              	.LBB1086:
 2216              	.LBI1086:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2217              		.loc 13 110 7 view .LVU528
 2218              	.LBB1087:
 2219              	.LBB1088:
 2220              	.LBI1088:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2221              		.loc 13 199 14 view .LVU529
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2222              		.loc 13 199 14 is_stmt 0 view .LVU530
 2223              	.LBE1088:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2224              		.loc 13 110 7 view .LVU531
 2225 0024 0023     		movs	r3, #0
 2226              	.LVL167:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2227              		.loc 13 110 7 view .LVU532
 2228 0026 0371     		strb	r3, [r0, #4]
 2229              	.LVL168:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2230              		.loc 13 110 7 view .LVU533
 2231              	.LBE1087:
 2232              	.LBE1086:
 2233              	.LBE1085:
 2234              	.LBE1084:
 2235              	.LBE1083:
 2236              	.LBE1082:
  77:./MotorControl/component.hpp ****         }
 2237              		.loc 12 77 25 view .LVU534
 2238 0028 F6E7     		b	.L102
 2239              	.LVL169:
 2240              	.L117:
  77:./MotorControl/component.hpp ****         }
 2241              		.loc 12 77 25 view .LVU535
 2242              	.LBE1081:
 2243              	.LBE1080:
 2244              	.LBB1109:
 2245              	.LBB1079:
 2246              	.LBB1077:
 2247              	.LBI1077:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 2248              		.loc 1 1287 3 is_stmt 1 view .LVU536
 2249              	.LBB1078:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 2250              		.loc 1 1289 5 view .LVU537
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2251              		.loc 1 1292 7 view .LVU538
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
ARM GAS  /tmp/ccawPiBL.s 			page 207


 2252              		.loc 1 1292 33 is_stmt 0 view .LVU539
 2253 002a 0F48     		ldr	r0, .L120
 2254              	.LVL170:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2255              		.loc 1 1292 33 view .LVU540
 2256 002c FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 2257              	.LVL171:
 2258              	.L118:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2259              		.loc 1 1292 33 view .LVU541
 2260              	.LBE1078:
 2261              	.LBE1077:
 2262              	.LBE1079:
 2263              	.LBE1109:
 2264              	.LBB1110:
 2265              	.LBB1108:
 2266              	.LBB1089:
 2267              	.LBI1089:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 2268              		.loc 13 700 2 is_stmt 1 view .LVU542
 2269              	.LBB1090:
 2270              	.LBB1091:
 2271              	.LBB1092:
 2272              	.LBI1092:
 2273              		.loc 14 76 5 view .LVU543
 2274              		.loc 14 76 5 is_stmt 0 view .LVU544
 2275              	.LBE1092:
 2276              	.LBB1093:
 2277              	.LBI1093:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 2278              		.loc 13 607 28 is_stmt 1 view .LVU545
 2279              	.LBB1094:
 2280              	.LBB1095:
 2281              	.LBB1096:
 2282              	.LBI1096:
 2283              		.loc 14 76 5 view .LVU546
 2284              		.loc 14 76 5 is_stmt 0 view .LVU547
 2285              	.LBE1096:
 2286              	.LBB1097:
 2287              	.LBI1097:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2288              		.loc 13 300 42 is_stmt 1 view .LVU548
 2289              	.LBB1098:
 2290              	.LBB1099:
 2291              	.LBB1100:
 2292              	.LBI1100:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 2293              		.loc 13 115 2 view .LVU549
 2294              	.LBB1101:
 2295              	.LBB1102:
 2296              	.LBB1103:
 2297              	.LBI1103:
 2298              		.loc 14 76 5 view .LVU550
 2299              		.loc 14 76 5 is_stmt 0 view .LVU551
 2300              	.LBE1103:
 2301              	.LBB1104:
 2302              	.LBI1104:
ARM GAS  /tmp/ccawPiBL.s 			page 208


 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 2303              		.loc 13 203 6 is_stmt 1 view .LVU552
 2304              	.LBB1105:
 2305              	.LBB1106:
 2306              	.LBB1107:
 2307              	.LBI1107:
 2308              		.loc 14 76 5 view .LVU553
 2309              		.loc 14 76 5 is_stmt 0 view .LVU554
 2310              	.LBE1107:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2311              		.loc 13 204 47 view .LVU555
 2312 0030 5B68     		ldr	r3, [r3, #4]	@ float
 2313              	.LVL172:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2314              		.loc 13 204 47 view .LVU556
 2315 0032 0360     		str	r3, [r0]	@ float
 2316              	.LVL173:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2317              		.loc 13 204 47 view .LVU557
 2318              	.LBE1106:
 2319              	.LBE1105:
 2320              	.LBE1104:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2321              		.loc 13 117 19 view .LVU558
 2322 0034 0123     		movs	r3, #1
 2323 0036 0371     		strb	r3, [r0, #4]
 2324              	.LVL174:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2325              		.loc 13 117 19 view .LVU559
 2326              	.LBE1102:
 2327              	.LBE1101:
 2328              	.LBE1100:
 2329              	.LBE1099:
 2330              	.LBE1098:
 2331              	.LBE1097:
 2332              	.LBE1095:
 2333              	.LBE1094:
 2334              	.LBE1093:
 2335              	.LBE1091:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2336              		.loc 13 701 51 view .LVU560
 2337 0038 EEE7     		b	.L102
 2338              	.LVL175:
 2339              	.L105:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2340              		.loc 13 701 51 view .LVU561
 2341              	.LBE1090:
 2342              	.LBE1089:
 2343              	.LBE1108:
 2344              	.LBE1110:
 2345              	.LBB1111:
 2346              	.LBI1111:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2347              		.loc 13 692 17 is_stmt 1 discriminator 2 view .LVU562
 2348              	.LBB1112:
 2349              	.LBB1113:
 2350              	.LBI1113:
ARM GAS  /tmp/ccawPiBL.s 			page 209


 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2351              		.loc 13 602 17 discriminator 2 view .LVU563
 2352              	.LBB1114:
 2353              	.LBI1114:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 2354              		.loc 13 302 7 discriminator 2 view .LVU564
 2355              	.LBB1115:
 2356              	.LBI1115:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2357              		.loc 13 110 7 discriminator 2 view .LVU565
 2358              	.LBB1116:
 2359              	.LBB1117:
 2360              	.LBI1117:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2361              		.loc 13 199 14 discriminator 2 view .LVU566
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2362              		.loc 13 199 14 is_stmt 0 discriminator 2 view .LVU567
 2363              	.LBE1117:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2364              		.loc 13 110 7 discriminator 2 view .LVU568
 2365 003a 0023     		movs	r3, #0
 2366              	.LVL176:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2367              		.loc 13 110 7 discriminator 2 view .LVU569
 2368 003c 0371     		strb	r3, [r0, #4]
 2369              	.LVL177:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2370              		.loc 13 110 7 discriminator 2 view .LVU570
 2371 003e EBE7     		b	.L102
 2372              	.L115:
 2373              	.LVL178:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2374              		.loc 13 110 7 discriminator 2 view .LVU571
 2375              	.LBE1116:
 2376              	.LBE1115:
 2377              	.LBE1114:
 2378              	.LBE1113:
 2379              	.LBE1112:
 2380              	.LBE1111:
 2381              	.LBE1065:
 2382              	.LBB1118:
 2383              	.LBB1021:
 2384              	.LBB1022:
 2385              	.LBI1022:
1661:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2386              		.loc 1 1661 5 is_stmt 1 view .LVU572
 2387              	.LBB1023:
 2388              	.LBB1024:
 2389              	.LBI1024:
1571:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       {
 2390              		.loc 1 1571 24 view .LVU573
 2391              	.LBB1025:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
 2392              		.loc 1 1575 17 is_stmt 0 view .LVU574
 2393 0040 0B79     		ldrb	r3, [r1, #4]	@ zero_extendqisi2
 2394              	.LVL179:
1575:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant **** 	else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
ARM GAS  /tmp/ccawPiBL.s 			page 210


 2395              		.loc 1 1575 17 view .LVU575
 2396              	.LBE1025:
 2397              	.LBE1024:
 2398              		.loc 1 1665 7 view .LVU576
 2399 0042 012B     		cmp	r3, #1
 2400 0044 06D1     		bne	.L119
 2401              	.LVL180:
 2402              	.LBB1026:
 2403              	.LBI1026:
 276:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2404              		.loc 1 276 5 is_stmt 1 view .LVU577
 2405              	.LBB1027:
 2406              	.LBB1028:
 2407              	.LBI1028:
 267:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     {
 2408              		.loc 1 267 5 view .LVU578
 2409              	.LBB1029:
 2410              	.LBB1030:
 2411              	.LBI1030:
 262:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****     { return std::forward<_Union>(__u)._M_first._M_get(); }
 2412              		.loc 1 262 5 view .LVU579
 2413              	.LBB1031:
 2414              	.LBI1031:
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2415              		.loc 1 222 24 view .LVU580
 222:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       { return _M_storage; }
 2416              		.loc 1 222 24 is_stmt 0 view .LVU581
 2417              	.LBE1031:
 2418              	.LBE1030:
 2419              	.LBE1029:
 2420              	.LBE1028:
 2421              	.LBE1027:
 2422              	.LBE1026:
 2423              	.LBE1023:
 2424              	.LBE1022:
 142:./MotorControl/component.hpp ****             return ptr ? std::make_optional(*ptr) : std::nullopt;
 2425              		.loc 12 142 16 view .LVU582
 2426 0046 0B68     		ldr	r3, [r1]
 2427              	.LVL181:
 143:./MotorControl/component.hpp ****         } else {
 2428              		.loc 12 143 58 view .LVU583
 2429 0048 3BB1     		cbz	r3, .L111
 2430              	.LVL182:
 2431              	.LBB1035:
 2432              	.LBI1035:
 2433              		.loc 13 1242 5 is_stmt 1 view .LVU584
 2434              	.LBB1036:
 2435              	.LBB1037:
 2436              	.LBI1037:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 2437              		.loc 13 700 2 view .LVU585
 2438              	.LBB1038:
 2439              	.LBB1039:
 2440              	.LBB1040:
 2441              	.LBI1040:
 2442              		.loc 14 76 5 view .LVU586
 2443              		.loc 14 76 5 is_stmt 0 view .LVU587
ARM GAS  /tmp/ccawPiBL.s 			page 211


 2444              	.LBE1040:
 2445              	.LBB1041:
 2446              	.LBI1041:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 2447              		.loc 13 607 28 is_stmt 1 view .LVU588
 2448              	.LBB1042:
 2449              	.LBB1043:
 2450              	.LBB1044:
 2451              	.LBI1044:
 2452              		.loc 14 76 5 view .LVU589
 2453              		.loc 14 76 5 is_stmt 0 view .LVU590
 2454              	.LBE1044:
 2455              	.LBB1045:
 2456              	.LBI1045:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2457              		.loc 13 300 42 is_stmt 1 view .LVU591
 2458              	.LBB1046:
 2459              	.LBB1047:
 2460              	.LBB1048:
 2461              	.LBI1048:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 2462              		.loc 13 115 2 view .LVU592
 2463              	.LBB1049:
 2464              	.LBB1050:
 2465              	.LBB1051:
 2466              	.LBI1051:
 2467              		.loc 14 76 5 view .LVU593
 2468              		.loc 14 76 5 is_stmt 0 view .LVU594
 2469              	.LBE1051:
 2470              	.LBB1052:
 2471              	.LBI1052:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 2472              		.loc 13 203 6 is_stmt 1 view .LVU595
 2473              	.LBB1053:
 2474              	.LBB1054:
 2475              	.LBB1055:
 2476              	.LBI1055:
 2477              		.loc 14 76 5 view .LVU596
 2478              		.loc 14 76 5 is_stmt 0 view .LVU597
 2479              	.LBE1055:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2480              		.loc 13 204 47 view .LVU598
 2481 004a 1B68     		ldr	r3, [r3]	@ float
 2482              	.LVL183:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2483              		.loc 13 204 47 view .LVU599
 2484 004c 0360     		str	r3, [r0]	@ float
 2485              	.LVL184:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2486              		.loc 13 204 47 view .LVU600
 2487              	.LBE1054:
 2488              	.LBE1053:
 2489              	.LBE1052:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2490              		.loc 13 117 19 view .LVU601
 2491 004e 0123     		movs	r3, #1
 2492 0050 0371     		strb	r3, [r0, #4]
ARM GAS  /tmp/ccawPiBL.s 			page 212


 2493              	.LVL185:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2494              		.loc 13 117 19 view .LVU602
 2495              	.LBE1050:
 2496              	.LBE1049:
 2497              	.LBE1048:
 2498              	.LBE1047:
 2499              	.LBE1046:
 2500              	.LBE1045:
 2501              	.LBE1043:
 2502              	.LBE1042:
 2503              	.LBE1041:
 2504              	.LBE1039:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2505              		.loc 13 701 51 view .LVU603
 2506 0052 E1E7     		b	.L102
 2507              	.LVL186:
 2508              	.L119:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2509              		.loc 13 701 51 view .LVU604
 2510              	.LBE1038:
 2511              	.LBE1037:
 2512              	.LBE1036:
 2513              	.LBE1035:
 2514              	.LBB1056:
 2515              	.LBB1034:
 2516              	.LBB1032:
 2517              	.LBI1032:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 2518              		.loc 1 1287 3 is_stmt 1 view .LVU605
 2519              	.LBB1033:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 2520              		.loc 1 1289 5 view .LVU606
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2521              		.loc 1 1292 7 view .LVU607
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2522              		.loc 1 1292 33 is_stmt 0 view .LVU608
 2523 0054 0448     		ldr	r0, .L120
 2524              	.LVL187:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2525              		.loc 1 1292 33 view .LVU609
 2526 0056 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 2527              	.LVL188:
 2528              	.L111:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2529              		.loc 1 1292 33 view .LVU610
 2530              	.LBE1033:
 2531              	.LBE1032:
 2532              	.LBE1034:
 2533              	.LBE1056:
 2534              	.LBB1057:
 2535              	.LBI1057:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2536              		.loc 13 692 17 is_stmt 1 discriminator 2 view .LVU611
 2537              	.LBB1058:
 2538              	.LBB1059:
 2539              	.LBI1059:
ARM GAS  /tmp/ccawPiBL.s 			page 213


 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2540              		.loc 13 602 17 discriminator 2 view .LVU612
 2541              	.LBB1060:
 2542              	.LBI1060:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 2543              		.loc 13 302 7 discriminator 2 view .LVU613
 2544              	.LBB1061:
 2545              	.LBI1061:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2546              		.loc 13 110 7 discriminator 2 view .LVU614
 2547              	.LBB1062:
 2548              	.LBB1063:
 2549              	.LBI1063:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2550              		.loc 13 199 14 discriminator 2 view .LVU615
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2551              		.loc 13 199 14 is_stmt 0 discriminator 2 view .LVU616
 2552              	.LBE1063:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2553              		.loc 13 110 7 discriminator 2 view .LVU617
 2554 005a 0023     		movs	r3, #0
 2555              	.LVL189:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2556              		.loc 13 110 7 discriminator 2 view .LVU618
 2557 005c 0371     		strb	r3, [r0, #4]
 2558              	.LVL190:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2559              		.loc 13 110 7 discriminator 2 view .LVU619
 2560 005e DBE7     		b	.L102
 2561              	.LVL191:
 2562              	.L116:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2563              		.loc 13 110 7 discriminator 2 view .LVU620
 2564              	.LBE1062:
 2565              	.LBE1061:
 2566              	.LBE1060:
 2567              	.LBE1059:
 2568              	.LBE1058:
 2569              	.LBE1057:
 2570              	.LBE1021:
 2571              	.LBB1064:
 2572              	.LBB1001:
 2573              	.LBB999:
 2574              	.LBI999:
1287:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   {
 2575              		.loc 1 1287 3 is_stmt 1 view .LVU621
 2576              	.LBB1000:
1289:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****       __throw_bad_variant_access("std::get: variant is valueless");
 2577              		.loc 1 1289 5 view .LVU622
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2578              		.loc 1 1292 7 view .LVU623
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2579              		.loc 1 1292 33 is_stmt 0 view .LVU624
 2580 0060 0148     		ldr	r0, .L120
 2581              	.LVL192:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2582              		.loc 1 1292 33 view .LVU625
ARM GAS  /tmp/ccawPiBL.s 			page 214


 2583 0062 FFF7FEFF 		bl	_ZSt26__throw_bad_variant_accessPKc
 2584              	.LVL193:
 2585              	.L121:
1292:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/variant ****   }
 2586              		.loc 1 1292 33 view .LVU626
 2587 0066 00BF     		.align	2
 2588              	.L120:
 2589 0068 00000000 		.word	.LC0
 2590              	.LBE1000:
 2591              	.LBE999:
 2592              	.LBE1001:
 2593              	.LBE1064:
 2594              	.LBE1118:
 2595              	.LBE1119:
 2596              		.cfi_endproc
 2597              	.LFE5617:
 2598              		.fnend
 2600              		.global	__aeabi_ldivmod
 2601              		.global	__aeabi_l2f
 2602              		.section	.text._ZN10Controller6updateEv,"ax",%progbits
 2603              		.align	1
 2604              		.global	_ZN10Controller6updateEv
 2605              		.syntax unified
 2606              		.thumb
 2607              		.thumb_func
 2609              	_ZN10Controller6updateEv:
 2610              		.fnstart
 2611              	.LVL194:
 2612              	.LFB5203:
 142:MotorControl/controller.cpp **** 
 143:MotorControl/controller.cpp **** bool Controller::update() {
 2613              		.loc 3 143 27 is_stmt 1 view -0
 2614              		.cfi_startproc
 2615              		@ args = 0, pretend = 0, frame = 136
 2616              		@ frame_needed = 0, uses_anonymous_args = 0
 2617              		.loc 3 143 27 is_stmt 0 view .LVU628
 2618 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2619              		.save {r4, r5, r6, r7, lr}
 2620              	.LCFI20:
 2621              		.cfi_def_cfa_offset 20
 2622              		.cfi_offset 4, -20
 2623              		.cfi_offset 5, -16
 2624              		.cfi_offset 6, -12
 2625              		.cfi_offset 7, -8
 2626              		.cfi_offset 14, -4
 2627 0002 2DED068B 		vpush.64	{d8, d9, d10}
 2628              		.vsave {d8, d9, d10}
 2629              	.LCFI21:
 2630              		.cfi_def_cfa_offset 44
 2631              		.cfi_offset 80, -44
 2632              		.cfi_offset 81, -40
 2633              		.cfi_offset 82, -36
 2634              		.cfi_offset 83, -32
 2635              		.cfi_offset 84, -28
 2636              		.cfi_offset 85, -24
 2637              		.pad #140
 2638 0006 A3B0     		sub	sp, sp, #140
ARM GAS  /tmp/ccawPiBL.s 			page 215


 2639              	.LCFI22:
 2640              		.cfi_def_cfa_offset 184
 2641 0008 0446     		mov	r4, r0
 144:MotorControl/controller.cpp ****     std::optional<float> pos_estimate_linear = pos_estimate_linear_src_.present();
 2642              		.loc 3 144 5 is_stmt 1 view .LVU629
 2643              		.loc 3 144 81 is_stmt 0 view .LVU630
 2644 000a 00F56351 		add	r1, r0, #14528
 2645 000e 2431     		adds	r1, r1, #36
 2646 0010 15A8     		add	r0, sp, #84
 2647              	.LVL195:
 2648              		.loc 3 144 81 view .LVU631
 2649 0012 FFF7FEFF 		bl	_ZN9InputPortIfE7presentEv
 2650              	.LVL196:
 145:MotorControl/controller.cpp ****     std::optional<float> pos_estimate_circular = pos_estimate_circular_src_.present();
 2651              		.loc 3 145 5 is_stmt 1 view .LVU632
 2652              		.loc 3 145 85 is_stmt 0 view .LVU633
 2653 0016 04F56351 		add	r1, r4, #14528
 2654 001a 2C31     		adds	r1, r1, #44
 2655 001c 13A8     		add	r0, sp, #76
 2656 001e FFF7FEFF 		bl	_ZN9InputPortIfE7presentEv
 2657              	.LVL197:
 146:MotorControl/controller.cpp ****     std::optional<float> pos_wrap = pos_wrap_src_.present();
 2658              		.loc 3 146 5 is_stmt 1 view .LVU634
 2659              		.loc 3 146 59 is_stmt 0 view .LVU635
 2660 0022 04F56351 		add	r1, r4, #14528
 2661 0026 3C31     		adds	r1, r1, #60
 2662 0028 11A8     		add	r0, sp, #68
 2663 002a FFF7FEFF 		bl	_ZN9InputPortIfE7presentEv
 2664              	.LVL198:
 147:MotorControl/controller.cpp ****     std::optional<float> vel_estimate = vel_estimate_src_.present();
 2665              		.loc 3 147 5 is_stmt 1 view .LVU636
 2666              		.loc 3 147 67 is_stmt 0 view .LVU637
 2667 002e 04F56351 		add	r1, r4, #14528
 2668 0032 3431     		adds	r1, r1, #52
 2669 0034 0FA8     		add	r0, sp, #60
 2670 0036 FFF7FEFF 		bl	_ZN9InputPortIfE7presentEv
 2671              	.LVL199:
 148:MotorControl/controller.cpp **** 
 149:MotorControl/controller.cpp ****     std::optional<float> anticogging_pos_estimate = axis_->encoder_.pos_estimate_.present();
 2672              		.loc 3 149 5 is_stmt 1 view .LVU638
 2673              		.loc 3 149 53 is_stmt 0 view .LVU639
 2674 003a 04F54053 		add	r3, r4, #12288
 2675 003e D3F8D838 		ldr	r3, [r3, #2264]
 2676              		.loc 3 149 60 view .LVU640
 2677 0042 D3F8AC30 		ldr	r3, [r3, #172]
 2678              		.loc 3 149 91 view .LVU641
 2679 0046 03F1D002 		add	r2, r3, #208
 2680              	.LVL200:
 2681              	.LBB1409:
 2682              	.LBI1409:
  73:./MotorControl/component.hpp ****         if (age_ == 0) {
 2683              		.loc 12 73 22 is_stmt 1 view .LVU642
 2684              	.LBB1410:
  74:./MotorControl/component.hpp ****             return content_;
 2685              		.loc 12 74 13 is_stmt 0 view .LVU643
 2686 004a D3F8D030 		ldr	r3, [r3, #208]
  74:./MotorControl/component.hpp ****             return content_;
ARM GAS  /tmp/ccawPiBL.s 			page 216


 2687              		.loc 12 74 9 view .LVU644
 2688 004e D3B3     		cbz	r3, .L246
 2689              	.LVL201:
 2690              	.LBB1411:
 2691              	.LBI1411:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2692              		.loc 13 692 17 is_stmt 1 view .LVU645
 2693              	.LBB1412:
 2694              	.LBB1413:
 2695              	.LBI1413:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2696              		.loc 13 602 17 view .LVU646
 2697              	.LBB1414:
 2698              	.LBI1414:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 2699              		.loc 13 302 7 view .LVU647
 2700              	.LBB1415:
 2701              	.LBI1415:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2702              		.loc 13 110 7 view .LVU648
 2703              	.LBB1416:
 2704              	.LBB1417:
 2705              	.LBI1417:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2706              		.loc 13 199 14 view .LVU649
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2707              		.loc 13 199 14 is_stmt 0 view .LVU650
 2708              	.LBE1417:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2709              		.loc 13 110 7 view .LVU651
 2710 0050 0023     		movs	r3, #0
 2711 0052 8DF83830 		strb	r3, [sp, #56]
 2712              	.LVL202:
 2713              	.L124:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2714              		.loc 13 110 7 view .LVU652
 2715              	.LBE1416:
 2716              	.LBE1415:
 2717              	.LBE1414:
 2718              	.LBE1413:
 2719              	.LBE1412:
 2720              	.LBE1411:
 2721              	.LBE1410:
 2722              	.LBE1409:
 150:MotorControl/controller.cpp ****     std::optional<float> anticogging_vel_estimate = axis_->encoder_.vel_estimate_.present();
 2723              		.loc 3 150 5 is_stmt 1 view .LVU653
 2724              		.loc 3 150 53 is_stmt 0 view .LVU654
 2725 0056 04F54053 		add	r3, r4, #12288
 2726 005a D3F8D838 		ldr	r3, [r3, #2264]
 2727              		.loc 3 150 60 view .LVU655
 2728 005e D3F8AC30 		ldr	r3, [r3, #172]
 2729              		.loc 3 150 91 view .LVU656
 2730 0062 03F1D802 		add	r2, r3, #216
 2731              	.LVL203:
 2732              	.LBB1438:
 2733              	.LBI1438:
  73:./MotorControl/component.hpp ****         if (age_ == 0) {
ARM GAS  /tmp/ccawPiBL.s 			page 217


 2734              		.loc 12 73 22 is_stmt 1 view .LVU657
 2735              	.LBB1439:
  74:./MotorControl/component.hpp ****             return content_;
 2736              		.loc 12 74 13 is_stmt 0 view .LVU658
 2737 0066 D3F8D830 		ldr	r3, [r3, #216]
  74:./MotorControl/component.hpp ****             return content_;
 2738              		.loc 12 74 9 view .LVU659
 2739 006a 93B3     		cbz	r3, .L247
 2740              	.LVL204:
 2741              	.LBB1440:
 2742              	.LBI1440:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2743              		.loc 13 692 17 is_stmt 1 view .LVU660
 2744              	.LBB1441:
 2745              	.LBB1442:
 2746              	.LBI1442:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2747              		.loc 13 602 17 view .LVU661
 2748              	.LBB1443:
 2749              	.LBI1443:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 2750              		.loc 13 302 7 view .LVU662
 2751              	.LBB1444:
 2752              	.LBI1444:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2753              		.loc 13 110 7 view .LVU663
 2754              	.LBB1445:
 2755              	.LBB1446:
 2756              	.LBI1446:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2757              		.loc 13 199 14 view .LVU664
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2758              		.loc 13 199 14 is_stmt 0 view .LVU665
 2759              	.LBE1446:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2760              		.loc 13 110 7 view .LVU666
 2761 006c 0023     		movs	r3, #0
 2762 006e 8DF83030 		strb	r3, [sp, #48]
 2763              	.LVL205:
 2764              	.L126:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 2765              		.loc 13 110 7 view .LVU667
 2766              	.LBE1445:
 2767              	.LBE1444:
 2768              	.LBE1443:
 2769              	.LBE1442:
 2770              	.LBE1441:
 2771              	.LBE1440:
 2772              	.LBE1439:
 2773              	.LBE1438:
 151:MotorControl/controller.cpp **** 
 152:MotorControl/controller.cpp ****     if (axis_->step_dir_active_) {
 2774              		.loc 3 152 5 is_stmt 1 view .LVU668
 2775              		.loc 3 152 9 is_stmt 0 view .LVU669
 2776 0072 04F54053 		add	r3, r4, #12288
 2777 0076 D3F8D818 		ldr	r1, [r3, #2264]
 2778              		.loc 3 152 16 view .LVU670
ARM GAS  /tmp/ccawPiBL.s 			page 218


 2779 007a 91F84C32 		ldrb	r3, [r1, #588]	@ zero_extendqisi2
 2780              		.loc 3 152 5 view .LVU671
 2781 007e 002B     		cmp	r3, #0
 2782 0080 42D0     		beq	.L127
 153:MotorControl/controller.cpp ****         if (config_.circular_setpoints) {
 2783              		.loc 3 153 9 is_stmt 1 view .LVU672
 2784              		.loc 3 153 21 is_stmt 0 view .LVU673
 2785 0082 94F83C30 		ldrb	r3, [r4, #60]	@ zero_extendqisi2
 2786              		.loc 3 153 9 view .LVU674
 2787 0086 7BB3     		cbz	r3, .L128
 154:MotorControl/controller.cpp ****             if (!pos_wrap.has_value()) {
 2788              		.loc 3 154 13 is_stmt 1 view .LVU675
 2789              	.LVL206:
 2790              	.LBB1467:
 2791              	.LBI1467:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 2792              		.loc 13 916 22 view .LVU676
 2793              	.LBB1468:
 2794              	.LBI1468:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 2795              		.loc 13 433 22 view .LVU677
 2796              	.LBB1469:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2797              		.loc 13 434 58 is_stmt 0 view .LVU678
 2798 0088 9DF84850 		ldrb	r5, [sp, #72]	@ zero_extendqisi2
 2799              	.LVL207:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2800              		.loc 13 434 58 view .LVU679
 2801              	.LBE1469:
 2802              	.LBE1468:
 2803              	.LBE1467:
 2804              		.loc 3 154 13 view .LVU680
 2805 008c 3DB3     		cbz	r5, .L248
 155:MotorControl/controller.cpp ****                 set_error(ERROR_INVALID_CIRCULAR_RANGE);
 156:MotorControl/controller.cpp ****                 return false;
 157:MotorControl/controller.cpp ****             }
 158:MotorControl/controller.cpp ****             input_pos_ = (float)(axis_->steps_ % config_.steps_per_circular_range) * (*pos_wrap / (
 2806              		.loc 3 158 13 is_stmt 1 view .LVU681
 2807              		.loc 3 158 58 is_stmt 0 view .LVU682
 2808 008e 656C     		ldr	r5, [r4, #68]
 2809              		.loc 3 158 48 view .LVU683
 2810 0090 2A46     		mov	r2, r5
 2811 0092 0023     		movs	r3, #0
 2812 0094 D1E99401 		ldrd	r0, [r1, #592]
 2813 0098 FFF7FEFF 		bl	__aeabi_ldivmod
 2814              	.LVL208:
 2815              		.loc 3 158 26 view .LVU684
 2816 009c 1046     		mov	r0, r2
 2817 009e 1946     		mov	r1, r3
 2818 00a0 FFF7FEFF 		bl	__aeabi_l2f
 2819              	.LVL209:
 2820 00a4 07EE100A 		vmov	s14, r0
 2821              		.loc 3 158 99 view .LVU685
 2822 00a8 07EE905A 		vmov	s15, r5	@ int
 2823 00ac F8EE677A 		vcvt.f32.u32	s15, s15
 2824              		.loc 3 158 97 view .LVU686
 2825 00b0 9DED116A 		vldr.32	s12, [sp, #68]
ARM GAS  /tmp/ccawPiBL.s 			page 219


 2826 00b4 C6EE276A 		vdiv.f32	s13, s12, s15
 2827              		.loc 3 158 84 view .LVU687
 2828 00b8 67EE267A 		vmul.f32	s15, s14, s13
 2829              		.loc 3 158 24 view .LVU688
 2830 00bc 04F56453 		add	r3, r4, #14592
 2831 00c0 C3ED057A 		vstr.32	s15, [r3, #20]
 2832 00c4 20E0     		b	.L127
 2833              	.LVL210:
 2834              	.L246:
 2835              	.LBB1470:
 2836              	.LBB1437:
 2837              	.LBB1418:
 2838              	.LBI1418:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 2839              		.loc 13 700 2 is_stmt 1 view .LVU689
 2840              	.LBB1419:
 2841              	.LBB1420:
 2842              	.LBB1421:
 2843              	.LBI1421:
 2844              		.loc 14 76 5 view .LVU690
 2845              		.loc 14 76 5 is_stmt 0 view .LVU691
 2846              	.LBE1421:
 2847              	.LBB1422:
 2848              	.LBI1422:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 2849              		.loc 13 607 28 is_stmt 1 view .LVU692
 2850              	.LBB1423:
 2851              	.LBB1424:
 2852              	.LBB1425:
 2853              	.LBI1425:
 2854              		.loc 14 76 5 view .LVU693
 2855              		.loc 14 76 5 is_stmt 0 view .LVU694
 2856              	.LBE1425:
 2857              	.LBB1426:
 2858              	.LBI1426:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2859              		.loc 13 300 42 is_stmt 1 view .LVU695
 2860              	.LBB1427:
 2861              	.LBB1428:
 2862              	.LBB1429:
 2863              	.LBI1429:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 2864              		.loc 13 115 2 view .LVU696
 2865              	.LBB1430:
 2866              	.LBB1431:
 2867              	.LBB1432:
 2868              	.LBI1432:
 2869              		.loc 14 76 5 view .LVU697
 2870              		.loc 14 76 5 is_stmt 0 view .LVU698
 2871              	.LBE1432:
 2872              	.LBB1433:
 2873              	.LBI1433:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 2874              		.loc 13 203 6 is_stmt 1 view .LVU699
 2875              	.LBB1434:
 2876              	.LBB1435:
 2877              	.LBB1436:
ARM GAS  /tmp/ccawPiBL.s 			page 220


 2878              	.LBI1436:
 2879              		.loc 14 76 5 view .LVU700
 2880              		.loc 14 76 5 is_stmt 0 view .LVU701
 2881              	.LBE1436:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2882              		.loc 13 204 47 view .LVU702
 2883 00c6 5368     		ldr	r3, [r2, #4]	@ float
 2884 00c8 0D93     		str	r3, [sp, #52]	@ float
 2885              	.LVL211:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2886              		.loc 13 204 47 view .LVU703
 2887              	.LBE1435:
 2888              	.LBE1434:
 2889              	.LBE1433:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2890              		.loc 13 117 19 view .LVU704
 2891 00ca 0123     		movs	r3, #1
 2892 00cc 8DF83830 		strb	r3, [sp, #56]
 2893              	.LVL212:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2894              		.loc 13 117 19 view .LVU705
 2895              	.LBE1431:
 2896              	.LBE1430:
 2897              	.LBE1429:
 2898              	.LBE1428:
 2899              	.LBE1427:
 2900              	.LBE1426:
 2901              	.LBE1424:
 2902              	.LBE1423:
 2903              	.LBE1422:
 2904              	.LBE1420:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2905              		.loc 13 701 51 view .LVU706
 2906 00d0 C1E7     		b	.L124
 2907              	.LVL213:
 2908              	.L247:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2909              		.loc 13 701 51 view .LVU707
 2910              	.LBE1419:
 2911              	.LBE1418:
 2912              	.LBE1437:
 2913              	.LBE1470:
 2914              	.LBB1471:
 2915              	.LBB1466:
 2916              	.LBB1447:
 2917              	.LBI1447:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 2918              		.loc 13 700 2 is_stmt 1 view .LVU708
 2919              	.LBB1448:
 2920              	.LBB1449:
 2921              	.LBB1450:
 2922              	.LBI1450:
 2923              		.loc 14 76 5 view .LVU709
 2924              		.loc 14 76 5 is_stmt 0 view .LVU710
 2925              	.LBE1450:
 2926              	.LBB1451:
 2927              	.LBI1451:
ARM GAS  /tmp/ccawPiBL.s 			page 221


 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 2928              		.loc 13 607 28 is_stmt 1 view .LVU711
 2929              	.LBB1452:
 2930              	.LBB1453:
 2931              	.LBB1454:
 2932              	.LBI1454:
 2933              		.loc 14 76 5 view .LVU712
 2934              		.loc 14 76 5 is_stmt 0 view .LVU713
 2935              	.LBE1454:
 2936              	.LBB1455:
 2937              	.LBI1455:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2938              		.loc 13 300 42 is_stmt 1 view .LVU714
 2939              	.LBB1456:
 2940              	.LBB1457:
 2941              	.LBB1458:
 2942              	.LBI1458:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 2943              		.loc 13 115 2 view .LVU715
 2944              	.LBB1459:
 2945              	.LBB1460:
 2946              	.LBB1461:
 2947              	.LBI1461:
 2948              		.loc 14 76 5 view .LVU716
 2949              		.loc 14 76 5 is_stmt 0 view .LVU717
 2950              	.LBE1461:
 2951              	.LBB1462:
 2952              	.LBI1462:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 2953              		.loc 13 203 6 is_stmt 1 view .LVU718
 2954              	.LBB1463:
 2955              	.LBB1464:
 2956              	.LBB1465:
 2957              	.LBI1465:
 2958              		.loc 14 76 5 view .LVU719
 2959              		.loc 14 76 5 is_stmt 0 view .LVU720
 2960              	.LBE1465:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2961              		.loc 13 204 47 view .LVU721
 2962 00d2 5368     		ldr	r3, [r2, #4]	@ float
 2963 00d4 0B93     		str	r3, [sp, #44]	@ float
 2964              	.LVL214:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 2965              		.loc 13 204 47 view .LVU722
 2966              	.LBE1464:
 2967              	.LBE1463:
 2968              	.LBE1462:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2969              		.loc 13 117 19 view .LVU723
 2970 00d6 0123     		movs	r3, #1
 2971 00d8 8DF83030 		strb	r3, [sp, #48]
 2972              	.LVL215:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 2973              		.loc 13 117 19 view .LVU724
 2974              	.LBE1460:
 2975              	.LBE1459:
 2976              	.LBE1458:
ARM GAS  /tmp/ccawPiBL.s 			page 222


 2977              	.LBE1457:
 2978              	.LBE1456:
 2979              	.LBE1455:
 2980              	.LBE1453:
 2981              	.LBE1452:
 2982              	.LBE1451:
 2983              	.LBE1449:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2984              		.loc 13 701 51 view .LVU725
 2985 00dc C9E7     		b	.L126
 2986              	.LVL216:
 2987              	.L248:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 2988              		.loc 13 701 51 view .LVU726
 2989              	.LBE1448:
 2990              	.LBE1447:
 2991              	.LBE1466:
 2992              	.LBE1471:
 155:MotorControl/controller.cpp ****                 return false;
 2993              		.loc 3 155 17 is_stmt 1 view .LVU727
 155:MotorControl/controller.cpp ****                 return false;
 2994              		.loc 3 155 26 is_stmt 0 view .LVU728
 2995 00de 4021     		movs	r1, #64
 2996 00e0 2046     		mov	r0, r4
 2997 00e2 FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 2998              	.LVL217:
 156:MotorControl/controller.cpp ****             }
 2999              		.loc 3 156 17 is_stmt 1 view .LVU729
 156:MotorControl/controller.cpp ****             }
 3000              		.loc 3 156 24 is_stmt 0 view .LVU730
 3001 00e6 1FE0     		b	.L130
 3002              	.L128:
 159:MotorControl/controller.cpp ****         } else {
 160:MotorControl/controller.cpp ****             input_pos_ = (float)(axis_->steps_) / (float)(config_.steps_per_circular_range);
 3003              		.loc 3 160 13 is_stmt 1 view .LVU731
 3004              		.loc 3 160 26 is_stmt 0 view .LVU732
 3005 00e8 D1E99401 		ldrd	r0, [r1, #592]
 3006 00ec FFF7FEFF 		bl	__aeabi_l2f
 3007              	.LVL218:
 3008 00f0 06EE900A 		vmov	s13, r0
 3009              		.loc 3 160 51 view .LVU733
 3010 00f4 D4ED117A 		vldr.32	s15, [r4, #68]	@ int
 3011 00f8 F8EE677A 		vcvt.f32.u32	s15, s15
 3012              		.loc 3 160 49 view .LVU734
 3013 00fc 86EEA77A 		vdiv.f32	s14, s13, s15
 3014              		.loc 3 160 24 view .LVU735
 3015 0100 04F56453 		add	r3, r4, #14592
 3016 0104 83ED057A 		vstr.32	s14, [r3, #20]
 3017              	.L127:
 161:MotorControl/controller.cpp ****         }
 162:MotorControl/controller.cpp ****     }
 163:MotorControl/controller.cpp **** 
 164:MotorControl/controller.cpp ****     if (config_.anticogging.calib_anticogging) {
 3018              		.loc 3 164 5 is_stmt 1 view .LVU736
 3019              		.loc 3 164 29 is_stmt 0 view .LVU737
 3020 0108 04F54053 		add	r3, r4, #12288
 3021 010c 93F89938 		ldrb	r3, [r3, #2201]	@ zero_extendqisi2
ARM GAS  /tmp/ccawPiBL.s 			page 223


 3022              		.loc 3 164 5 view .LVU738
 3023 0110 B3B1     		cbz	r3, .L131
 165:MotorControl/controller.cpp ****         if (!anticogging_pos_estimate.has_value() || !anticogging_vel_estimate.has_value()) {
 3024              		.loc 3 165 9 is_stmt 1 view .LVU739
 3025              	.LVL219:
 3026              	.LBB1472:
 3027              	.LBI1472:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 3028              		.loc 13 916 22 view .LVU740
 3029              	.LBB1473:
 3030              	.LBI1473:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 3031              		.loc 13 433 22 view .LVU741
 3032              	.LBB1474:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3033              		.loc 13 434 58 is_stmt 0 view .LVU742
 3034 0112 9DF83830 		ldrb	r3, [sp, #56]	@ zero_extendqisi2
 3035              	.LVL220:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3036              		.loc 13 434 58 view .LVU743
 3037              	.LBE1474:
 3038              	.LBE1473:
 3039              	.LBE1472:
 3040              		.loc 3 165 51 view .LVU744
 3041 0116 13B1     		cbz	r3, .L132
 3042              	.LVL221:
 3043              	.LBB1475:
 3044              	.LBI1475:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 3045              		.loc 13 916 22 is_stmt 1 view .LVU745
 3046              	.LBB1476:
 3047              	.LBI1476:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 3048              		.loc 13 433 22 view .LVU746
 3049              	.LBB1477:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3050              		.loc 13 434 58 is_stmt 0 view .LVU747
 3051 0118 9DF83030 		ldrb	r3, [sp, #48]	@ zero_extendqisi2
 3052              	.LVL222:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3053              		.loc 13 434 58 view .LVU748
 3054              	.LBE1477:
 3055              	.LBE1476:
 3056              	.LBE1475:
 3057              		.loc 3 165 51 view .LVU749
 3058 011c 4BB9     		cbnz	r3, .L133
 3059              	.L132:
 166:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_ESTIMATE);
 3060              		.loc 3 166 13 is_stmt 1 discriminator 3 view .LVU750
 3061              		.loc 3 166 22 is_stmt 0 discriminator 3 view .LVU751
 3062 011e 2021     		movs	r1, #32
 3063 0120 2046     		mov	r0, r4
 3064 0122 FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 3065              	.LVL223:
 167:MotorControl/controller.cpp ****             return false;
 3066              		.loc 3 167 13 is_stmt 1 discriminator 3 view .LVU752
 3067              		.loc 3 167 20 is_stmt 0 discriminator 3 view .LVU753
ARM GAS  /tmp/ccawPiBL.s 			page 224


 3068 0126 0025     		movs	r5, #0
 3069              	.L130:
 168:MotorControl/controller.cpp ****         }
 169:MotorControl/controller.cpp ****         // non-blocking
 170:MotorControl/controller.cpp ****         anticogging_calibration(*anticogging_pos_estimate, *anticogging_vel_estimate);
 171:MotorControl/controller.cpp ****     }
 172:MotorControl/controller.cpp **** 
 173:MotorControl/controller.cpp ****     // TODO also enable circular deltas for 2nd order filter, etc.
 174:MotorControl/controller.cpp ****     if (config_.circular_setpoints) {
 175:MotorControl/controller.cpp ****         if (!pos_wrap.has_value()) {
 176:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_CIRCULAR_RANGE);
 177:MotorControl/controller.cpp ****             return false;
 178:MotorControl/controller.cpp ****         }
 179:MotorControl/controller.cpp ****         input_pos_ = fmodf_pos(input_pos_, *pos_wrap);
 180:MotorControl/controller.cpp ****     }
 181:MotorControl/controller.cpp **** 
 182:MotorControl/controller.cpp ****     // Update inputs
 183:MotorControl/controller.cpp ****     switch (config_.input_mode) {
 184:MotorControl/controller.cpp ****         case INPUT_MODE_INACTIVE: {
 185:MotorControl/controller.cpp ****             // do nothing
 186:MotorControl/controller.cpp ****         } break;
 187:MotorControl/controller.cpp ****         case INPUT_MODE_PASSTHROUGH: {
 188:MotorControl/controller.cpp ****             pos_setpoint_ = input_pos_;
 189:MotorControl/controller.cpp ****             vel_setpoint_ = input_vel_;
 190:MotorControl/controller.cpp ****             torque_setpoint_ = input_torque_; 
 191:MotorControl/controller.cpp ****         } break;
 192:MotorControl/controller.cpp ****         case INPUT_MODE_VEL_RAMP: {
 193:MotorControl/controller.cpp ****             float max_step_size = std::abs(current_meas_period * config_.vel_ramp_rate);
 194:MotorControl/controller.cpp ****             float full_step = input_vel_ - vel_setpoint_;
 195:MotorControl/controller.cpp ****             float step = std::clamp(full_step, -max_step_size, max_step_size);
 196:MotorControl/controller.cpp **** 
 197:MotorControl/controller.cpp ****             vel_setpoint_ += step;
 198:MotorControl/controller.cpp ****             torque_setpoint_ = (step / current_meas_period) * config_.inertia;
 199:MotorControl/controller.cpp ****         } break;
 200:MotorControl/controller.cpp ****         case INPUT_MODE_TORQUE_RAMP: {
 201:MotorControl/controller.cpp ****             float max_step_size = std::abs(current_meas_period * config_.torque_ramp_rate);
 202:MotorControl/controller.cpp ****             float full_step = input_torque_ - torque_setpoint_;
 203:MotorControl/controller.cpp ****             float step = std::clamp(full_step, -max_step_size, max_step_size);
 204:MotorControl/controller.cpp **** 
 205:MotorControl/controller.cpp ****             torque_setpoint_ += step;
 206:MotorControl/controller.cpp ****         } break;
 207:MotorControl/controller.cpp ****         case INPUT_MODE_POS_FILTER: {
 208:MotorControl/controller.cpp ****             // 2nd order pos tracking filter
 209:MotorControl/controller.cpp ****             float delta_pos = input_pos_ - pos_setpoint_; // Pos error
 210:MotorControl/controller.cpp ****             if (config_.circular_setpoints) {
 211:MotorControl/controller.cpp ****                 if (!pos_wrap.has_value()) {
 212:MotorControl/controller.cpp ****                     set_error(ERROR_INVALID_CIRCULAR_RANGE);
 213:MotorControl/controller.cpp ****                     return false;
 214:MotorControl/controller.cpp ****                 }
 215:MotorControl/controller.cpp ****                 delta_pos = wrap_pm(delta_pos, *pos_wrap);
 216:MotorControl/controller.cpp ****             }
 217:MotorControl/controller.cpp ****             float delta_vel = input_vel_ - vel_setpoint_; // Vel error
 218:MotorControl/controller.cpp ****             float accel = input_filter_kp_*delta_pos + input_filter_ki_*delta_vel; // Feedback
 219:MotorControl/controller.cpp ****             torque_setpoint_ = accel * config_.inertia; // Accel
 220:MotorControl/controller.cpp ****             vel_setpoint_ += current_meas_period * accel; // delta vel
 221:MotorControl/controller.cpp ****             pos_setpoint_ += current_meas_period * vel_setpoint_; // Delta pos
 222:MotorControl/controller.cpp ****         } break;
ARM GAS  /tmp/ccawPiBL.s 			page 225


 223:MotorControl/controller.cpp ****         case INPUT_MODE_MIRROR: {
 224:MotorControl/controller.cpp ****             if (config_.axis_to_mirror < AXIS_COUNT) {
 225:MotorControl/controller.cpp ****                 std::optional<float> other_pos = axes[config_.axis_to_mirror].encoder_.pos_estimate
 226:MotorControl/controller.cpp ****                 std::optional<float> other_vel = axes[config_.axis_to_mirror].encoder_.vel_estimate
 227:MotorControl/controller.cpp ****                 std::optional<float> other_torque = axes[config_.axis_to_mirror].controller_.torque
 228:MotorControl/controller.cpp **** 
 229:MotorControl/controller.cpp ****                 if (!other_pos.has_value() || !other_vel.has_value() || !other_torque.has_value()) 
 230:MotorControl/controller.cpp ****                     set_error(ERROR_INVALID_ESTIMATE);
 231:MotorControl/controller.cpp ****                     return false;
 232:MotorControl/controller.cpp ****                 }
 233:MotorControl/controller.cpp **** 
 234:MotorControl/controller.cpp ****                 pos_setpoint_ = *other_pos * config_.mirror_ratio;
 235:MotorControl/controller.cpp ****                 vel_setpoint_ = *other_vel * config_.mirror_ratio;
 236:MotorControl/controller.cpp ****                 torque_setpoint_ = *other_torque * config_.torque_mirror_ratio;
 237:MotorControl/controller.cpp ****             } else {
 238:MotorControl/controller.cpp ****                 set_error(ERROR_INVALID_MIRROR_AXIS);
 239:MotorControl/controller.cpp ****                 return false;
 240:MotorControl/controller.cpp ****             }
 241:MotorControl/controller.cpp ****         } break;
 242:MotorControl/controller.cpp ****         // case INPUT_MODE_MIX_CHANNELS: {
 243:MotorControl/controller.cpp ****         //     // NOT YET IMPLEMENTED
 244:MotorControl/controller.cpp ****         // } break;
 245:MotorControl/controller.cpp ****         case INPUT_MODE_TRAP_TRAJ: {
 246:MotorControl/controller.cpp ****             if(input_pos_updated_){
 247:MotorControl/controller.cpp ****                 move_to_pos(input_pos_);
 248:MotorControl/controller.cpp ****                 input_pos_updated_ = false;
 249:MotorControl/controller.cpp ****             }
 250:MotorControl/controller.cpp ****             // Avoid updating uninitialized trajectory
 251:MotorControl/controller.cpp ****             if (trajectory_done_)
 252:MotorControl/controller.cpp ****                 break;
 253:MotorControl/controller.cpp ****             
 254:MotorControl/controller.cpp ****             if (axis_->trap_traj_.t_ > axis_->trap_traj_.Tf_) {
 255:MotorControl/controller.cpp ****                 // Drop into position control mode when done to avoid problems on loop counter delt
 256:MotorControl/controller.cpp ****                 config_.control_mode = CONTROL_MODE_POSITION_CONTROL;
 257:MotorControl/controller.cpp ****                 pos_setpoint_ = axis_->trap_traj_.Xf_;
 258:MotorControl/controller.cpp ****                 vel_setpoint_ = 0.0f;
 259:MotorControl/controller.cpp ****                 torque_setpoint_ = 0.0f;
 260:MotorControl/controller.cpp ****                 trajectory_done_ = true;
 261:MotorControl/controller.cpp ****             } else {
 262:MotorControl/controller.cpp ****                 TrapezoidalTrajectory::Step_t traj_step = axis_->trap_traj_.eval(axis_->trap_traj_.
 263:MotorControl/controller.cpp ****                 pos_setpoint_ = traj_step.Y;
 264:MotorControl/controller.cpp ****                 vel_setpoint_ = traj_step.Yd;
 265:MotorControl/controller.cpp ****                 torque_setpoint_ = traj_step.Ydd * config_.inertia;
 266:MotorControl/controller.cpp ****                 axis_->trap_traj_.t_ += current_meas_period;
 267:MotorControl/controller.cpp ****             }
 268:MotorControl/controller.cpp ****             anticogging_pos_estimate = pos_setpoint_; // FF the position setpoint instead of the po
 269:MotorControl/controller.cpp ****         } break;
 270:MotorControl/controller.cpp ****         case INPUT_MODE_TUNING: {
 271:MotorControl/controller.cpp ****             autotuning_phase_ = wrap_pm_pi(autotuning_phase_ + (2.0f * M_PI * autotuning_.frequency
 272:MotorControl/controller.cpp ****             float c = our_arm_cos_f32(autotuning_phase_);
 273:MotorControl/controller.cpp ****             float s = our_arm_sin_f32(autotuning_phase_);
 274:MotorControl/controller.cpp ****             pos_setpoint_ = input_pos_ + autotuning_.pos_amplitude * s; // + pos_amp_c * c
 275:MotorControl/controller.cpp ****             vel_setpoint_ = input_vel_ + autotuning_.vel_amplitude * c;
 276:MotorControl/controller.cpp ****             torque_setpoint_ = input_torque_ + autotuning_.torque_amplitude * -s;
 277:MotorControl/controller.cpp ****         } break;
 278:MotorControl/controller.cpp ****         default: {
 279:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_INPUT_MODE);
ARM GAS  /tmp/ccawPiBL.s 			page 226


 280:MotorControl/controller.cpp ****             return false;
 281:MotorControl/controller.cpp ****         }
 282:MotorControl/controller.cpp ****         
 283:MotorControl/controller.cpp ****     }
 284:MotorControl/controller.cpp **** 
 285:MotorControl/controller.cpp ****     // Never command a setpoint beyond its limit
 286:MotorControl/controller.cpp ****     if(config_.enable_vel_limit) {
 287:MotorControl/controller.cpp ****         vel_setpoint_ = std::clamp(vel_setpoint_, -config_.vel_limit, config_.vel_limit);
 288:MotorControl/controller.cpp ****     }
 289:MotorControl/controller.cpp ****     const float Tlim = axis_->motor_.max_available_torque();
 290:MotorControl/controller.cpp ****     torque_setpoint_ = std::clamp(torque_setpoint_, -Tlim, Tlim);
 291:MotorControl/controller.cpp **** 
 292:MotorControl/controller.cpp ****     // Position control
 293:MotorControl/controller.cpp ****     // TODO Decide if we want to use encoder or pll position here
 294:MotorControl/controller.cpp ****     float gain_scheduling_multiplier = 1.0f;
 295:MotorControl/controller.cpp ****     float vel_des = vel_setpoint_;
 296:MotorControl/controller.cpp ****     if (config_.control_mode >= CONTROL_MODE_POSITION_CONTROL) {
 297:MotorControl/controller.cpp ****         float pos_err;
 298:MotorControl/controller.cpp **** 
 299:MotorControl/controller.cpp ****         if (config_.circular_setpoints) {
 300:MotorControl/controller.cpp ****             if (!pos_estimate_circular.has_value() || !pos_wrap.has_value()) {
 301:MotorControl/controller.cpp ****                 set_error(ERROR_INVALID_ESTIMATE);
 302:MotorControl/controller.cpp ****                 return false;
 303:MotorControl/controller.cpp ****             }
 304:MotorControl/controller.cpp ****             // Keep pos setpoint from drifting
 305:MotorControl/controller.cpp ****             pos_setpoint_ = fmodf_pos(pos_setpoint_, *pos_wrap);
 306:MotorControl/controller.cpp ****             // Circular delta
 307:MotorControl/controller.cpp ****             pos_err = pos_setpoint_ - *pos_estimate_circular;
 308:MotorControl/controller.cpp ****             pos_err = wrap_pm(pos_err, *pos_wrap);
 309:MotorControl/controller.cpp ****         } else {
 310:MotorControl/controller.cpp ****             if (!pos_estimate_linear.has_value()) {
 311:MotorControl/controller.cpp ****                 set_error(ERROR_INVALID_ESTIMATE);
 312:MotorControl/controller.cpp ****                 return false;
 313:MotorControl/controller.cpp ****             }
 314:MotorControl/controller.cpp ****             pos_err = pos_setpoint_ - *pos_estimate_linear;
 315:MotorControl/controller.cpp ****         }
 316:MotorControl/controller.cpp **** 
 317:MotorControl/controller.cpp ****         vel_des += config_.pos_gain * pos_err;
 318:MotorControl/controller.cpp ****         // V-shaped gain shedule based on position error
 319:MotorControl/controller.cpp ****         float abs_pos_err = std::abs(pos_err);
 320:MotorControl/controller.cpp ****         if (config_.enable_gain_scheduling && abs_pos_err <= config_.gain_scheduling_width) {
 321:MotorControl/controller.cpp ****             gain_scheduling_multiplier = abs_pos_err / config_.gain_scheduling_width;
 322:MotorControl/controller.cpp ****         }
 323:MotorControl/controller.cpp ****     }
 324:MotorControl/controller.cpp **** 
 325:MotorControl/controller.cpp ****     // Velocity limiting
 326:MotorControl/controller.cpp ****     float vel_lim = config_.vel_limit;
 327:MotorControl/controller.cpp ****     if (config_.enable_vel_limit) {
 328:MotorControl/controller.cpp ****         vel_des = std::clamp(vel_des, -vel_lim, vel_lim);
 329:MotorControl/controller.cpp ****     }
 330:MotorControl/controller.cpp **** 
 331:MotorControl/controller.cpp ****     // Check for overspeed fault (done in this module (controller) for cohesion with vel_lim)
 332:MotorControl/controller.cpp ****     if (config_.enable_overspeed_error) {  // 0.0f to disable
 333:MotorControl/controller.cpp ****         if (!vel_estimate.has_value()) {
 334:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_ESTIMATE);
 335:MotorControl/controller.cpp ****             return false;
 336:MotorControl/controller.cpp ****         }
ARM GAS  /tmp/ccawPiBL.s 			page 227


 337:MotorControl/controller.cpp ****         if (std::abs(*vel_estimate) > config_.vel_limit_tolerance * vel_lim) {
 338:MotorControl/controller.cpp ****             set_error(ERROR_OVERSPEED);
 339:MotorControl/controller.cpp ****             return false;
 340:MotorControl/controller.cpp ****         }
 341:MotorControl/controller.cpp ****     }
 342:MotorControl/controller.cpp **** 
 343:MotorControl/controller.cpp ****     // TODO: Change to controller working in torque units
 344:MotorControl/controller.cpp ****     // Torque per amp gain scheduling (ACIM)
 345:MotorControl/controller.cpp ****     float vel_gain = config_.vel_gain;
 346:MotorControl/controller.cpp ****     float vel_integrator_gain = config_.vel_integrator_gain;
 347:MotorControl/controller.cpp ****     if (axis_->motor_.config_.motor_type == Motor::MOTOR_TYPE_ACIM) {
 348:MotorControl/controller.cpp ****         float effective_flux = axis_->acim_estimator_.rotor_flux_;
 349:MotorControl/controller.cpp ****         float minflux = axis_->motor_.config_.acim_gain_min_flux;
 350:MotorControl/controller.cpp ****         if (std::abs(effective_flux) < minflux)
 351:MotorControl/controller.cpp ****             effective_flux = std::copysignf(minflux, effective_flux);
 352:MotorControl/controller.cpp ****         vel_gain /= effective_flux;
 353:MotorControl/controller.cpp ****         vel_integrator_gain /= effective_flux;
 354:MotorControl/controller.cpp ****         // TODO: also scale the integral value which is also changing units.
 355:MotorControl/controller.cpp ****         // (or again just do control in torque units)
 356:MotorControl/controller.cpp ****     }
 357:MotorControl/controller.cpp **** 
 358:MotorControl/controller.cpp ****     // Velocity control
 359:MotorControl/controller.cpp ****     float torque = torque_setpoint_;
 360:MotorControl/controller.cpp **** 
 361:MotorControl/controller.cpp ****     // Anti-cogging is enabled after calibration
 362:MotorControl/controller.cpp ****     // We get the current position and apply a current feed-forward
 363:MotorControl/controller.cpp ****     // ensuring that we handle negative encoder positions properly (-1 == motor->encoder.encoder_cp
 364:MotorControl/controller.cpp ****     if (anticogging_valid_ && config_.anticogging.anticogging_enabled) {
 365:MotorControl/controller.cpp ****         if (!anticogging_pos_estimate.has_value()) {
 366:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_ESTIMATE);
 367:MotorControl/controller.cpp ****             return false;
 368:MotorControl/controller.cpp ****         }
 369:MotorControl/controller.cpp ****         float anticogging_pos = *anticogging_pos_estimate / axis_->encoder_.getCoggingRatio();
 370:MotorControl/controller.cpp ****         torque += config_.anticogging.cogging_map[std::clamp(mod((int)anticogging_pos, 3600), 0, 36
 371:MotorControl/controller.cpp ****     }
 372:MotorControl/controller.cpp **** 
 373:MotorControl/controller.cpp ****     float v_err = 0.0f;
 374:MotorControl/controller.cpp ****     if (config_.control_mode >= CONTROL_MODE_VELOCITY_CONTROL) {
 375:MotorControl/controller.cpp ****         if (!vel_estimate.has_value()) {
 376:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_ESTIMATE);
 377:MotorControl/controller.cpp ****             return false;
 378:MotorControl/controller.cpp ****         }
 379:MotorControl/controller.cpp **** 
 380:MotorControl/controller.cpp ****         v_err = vel_des - *vel_estimate;
 381:MotorControl/controller.cpp ****         torque += (vel_gain * gain_scheduling_multiplier) * v_err;
 382:MotorControl/controller.cpp **** 
 383:MotorControl/controller.cpp ****         // Velocity integral action before limiting
 384:MotorControl/controller.cpp ****         torque += vel_integrator_torque_;
 385:MotorControl/controller.cpp ****     }
 386:MotorControl/controller.cpp **** 
 387:MotorControl/controller.cpp ****     // Velocity limiting in current mode
 388:MotorControl/controller.cpp ****     if (config_.control_mode < CONTROL_MODE_VELOCITY_CONTROL && config_.enable_torque_mode_vel_limi
 389:MotorControl/controller.cpp ****         if (!vel_estimate.has_value()) {
 390:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_ESTIMATE);
 391:MotorControl/controller.cpp ****             return false;
 392:MotorControl/controller.cpp ****         }
 393:MotorControl/controller.cpp ****         torque = limitVel(config_.vel_limit, *vel_estimate, vel_gain, torque);
ARM GAS  /tmp/ccawPiBL.s 			page 228


 394:MotorControl/controller.cpp ****     }
 395:MotorControl/controller.cpp **** 
 396:MotorControl/controller.cpp ****     // Torque limiting
 397:MotorControl/controller.cpp ****     bool limited = false;
 398:MotorControl/controller.cpp ****     if (torque > Tlim) {
 399:MotorControl/controller.cpp ****         limited = true;
 400:MotorControl/controller.cpp ****         torque = Tlim;
 401:MotorControl/controller.cpp ****     }
 402:MotorControl/controller.cpp ****     if (torque < -Tlim) {
 403:MotorControl/controller.cpp ****         limited = true;
 404:MotorControl/controller.cpp ****         torque = -Tlim;
 405:MotorControl/controller.cpp ****     }
 406:MotorControl/controller.cpp **** 
 407:MotorControl/controller.cpp ****     // Velocity integrator (behaviour dependent on limiting)
 408:MotorControl/controller.cpp ****     if (config_.control_mode < CONTROL_MODE_VELOCITY_CONTROL) {
 409:MotorControl/controller.cpp ****         // reset integral if not in use
 410:MotorControl/controller.cpp ****         vel_integrator_torque_ = 0.0f;
 411:MotorControl/controller.cpp ****     } else {
 412:MotorControl/controller.cpp ****         if (limited) {
 413:MotorControl/controller.cpp ****             // TODO make decayfactor configurable
 414:MotorControl/controller.cpp ****             vel_integrator_torque_ *= 0.99f;
 415:MotorControl/controller.cpp ****         } else {
 416:MotorControl/controller.cpp ****             vel_integrator_torque_ += ((vel_integrator_gain * gain_scheduling_multiplier) * current
 417:MotorControl/controller.cpp ****         }
 418:MotorControl/controller.cpp ****         // integrator limiting to prevent windup 
 419:MotorControl/controller.cpp ****         vel_integrator_torque_ = std::clamp(vel_integrator_torque_, -config_.vel_integrator_limit, 
 420:MotorControl/controller.cpp ****     }
 421:MotorControl/controller.cpp **** 
 422:MotorControl/controller.cpp ****     float ideal_electrical_power = 0.0f;
 423:MotorControl/controller.cpp ****     if (axis_->motor_.config_.motor_type != Motor::MOTOR_TYPE_GIMBAL) {
 424:MotorControl/controller.cpp ****         ideal_electrical_power = axis_->motor_.current_control_.power_ - \
 425:MotorControl/controller.cpp ****             SQ(axis_->motor_.current_control_.Iq_measured_) * 1.5f * axis_->motor_.config_.phase_re
 426:MotorControl/controller.cpp ****             SQ(axis_->motor_.current_control_.Id_measured_) * 1.5f * axis_->motor_.config_.phase_re
 427:MotorControl/controller.cpp ****     }
 428:MotorControl/controller.cpp ****     else {
 429:MotorControl/controller.cpp ****         ideal_electrical_power = axis_->motor_.current_control_.power_;
 430:MotorControl/controller.cpp ****     }
 431:MotorControl/controller.cpp ****     mechanical_power_ += config_.mechanical_power_bandwidth * current_meas_period * (torque * *vel_
 432:MotorControl/controller.cpp ****     electrical_power_ += config_.electrical_power_bandwidth * current_meas_period * (ideal_electric
 433:MotorControl/controller.cpp **** 
 434:MotorControl/controller.cpp ****     // Spinout check
 435:MotorControl/controller.cpp ****     // If mechanical power is negative (braking) and measured power is positive, something is wrong
 436:MotorControl/controller.cpp ****     // This indicates that the controller is trying to stop, but torque is being produced.
 437:MotorControl/controller.cpp ****     // Usually caused by an incorrect encoder offset
 438:MotorControl/controller.cpp ****     if (mechanical_power_ < config_.spinout_mechanical_power_threshold && electrical_power_ > confi
 439:MotorControl/controller.cpp ****         set_error(ERROR_SPINOUT_DETECTED);
 440:MotorControl/controller.cpp ****         return false;
 441:MotorControl/controller.cpp ****     }
 442:MotorControl/controller.cpp **** 
 443:MotorControl/controller.cpp ****     torque_output_ = torque;
 444:MotorControl/controller.cpp **** 
 445:MotorControl/controller.cpp ****     // TODO: this is inconsistent with the other errors which are sticky.
 446:MotorControl/controller.cpp ****     // However if we make ERROR_INVALID_ESTIMATE sticky then it will be
 447:MotorControl/controller.cpp ****     // confusing that a normal sequence of motor calibration + encoder
 448:MotorControl/controller.cpp ****     // calibration would leave the controller in an error state.
 449:MotorControl/controller.cpp ****     error_ &= ~ERROR_INVALID_ESTIMATE;
 450:MotorControl/controller.cpp ****     return true;
ARM GAS  /tmp/ccawPiBL.s 			page 229


 451:MotorControl/controller.cpp **** }
 3070              		.loc 3 451 1 view .LVU754
 3071 0128 2846     		mov	r0, r5
 3072 012a 23B0     		add	sp, sp, #140
 3073              	.LCFI23:
 3074              		.cfi_remember_state
 3075              		.cfi_def_cfa_offset 44
 3076              		@ sp needed
 3077 012c BDEC068B 		vldm	sp!, {d8-d10}
 3078              	.LCFI24:
 3079              		.cfi_restore 84
 3080              		.cfi_restore 85
 3081              		.cfi_restore 82
 3082              		.cfi_restore 83
 3083              		.cfi_restore 80
 3084              		.cfi_restore 81
 3085              		.cfi_def_cfa_offset 20
 3086 0130 F0BD     		pop	{r4, r5, r6, r7, pc}
 3087              	.LVL224:
 3088              	.L133:
 3089              	.LCFI25:
 3090              		.cfi_restore_state
 170:MotorControl/controller.cpp ****     }
 3091              		.loc 3 170 9 is_stmt 1 view .LVU755
 170:MotorControl/controller.cpp ****     }
 3092              		.loc 3 170 32 is_stmt 0 view .LVU756
 3093 0132 DDED0B0A 		vldr.32	s1, [sp, #44]
 3094 0136 9DED0D0A 		vldr.32	s0, [sp, #52]
 3095 013a 2046     		mov	r0, r4
 3096 013c FFF7FEFF 		bl	_ZN10Controller23anticogging_calibrationEff
 3097              	.LVL225:
 3098              	.L131:
 174:MotorControl/controller.cpp ****         if (!pos_wrap.has_value()) {
 3099              		.loc 3 174 5 is_stmt 1 view .LVU757
 174:MotorControl/controller.cpp ****         if (!pos_wrap.has_value()) {
 3100              		.loc 3 174 17 is_stmt 0 view .LVU758
 3101 0140 94F83C20 		ldrb	r2, [r4, #60]	@ zero_extendqisi2
 174:MotorControl/controller.cpp ****         if (!pos_wrap.has_value()) {
 3102              		.loc 3 174 5 view .LVU759
 3103 0144 DAB1     		cbz	r2, .L134
 175:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_CIRCULAR_RANGE);
 3104              		.loc 3 175 9 is_stmt 1 view .LVU760
 3105              	.LVL226:
 3106              	.LBB1478:
 3107              	.LBI1478:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 3108              		.loc 13 916 22 view .LVU761
 3109              	.LBB1479:
 3110              	.LBI1479:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 3111              		.loc 13 433 22 view .LVU762
 3112              	.LBB1480:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3113              		.loc 13 434 58 is_stmt 0 view .LVU763
 3114 0146 9DF84850 		ldrb	r5, [sp, #72]	@ zero_extendqisi2
 3115              	.LVL227:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/ccawPiBL.s 			page 230


 3116              		.loc 13 434 58 view .LVU764
 3117              	.LBE1480:
 3118              	.LBE1479:
 3119              	.LBE1478:
 175:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_CIRCULAR_RANGE);
 3120              		.loc 3 175 9 view .LVU765
 3121 014a 3DB3     		cbz	r5, .L249
 179:MotorControl/controller.cpp ****     }
 3122              		.loc 3 179 9 is_stmt 1 view .LVU766
 179:MotorControl/controller.cpp ****     }
 3123              		.loc 3 179 31 is_stmt 0 view .LVU767
 3124 014c 04F56453 		add	r3, r4, #14592
 3125 0150 D3ED057A 		vldr.32	s15, [r3, #20]
 3126 0154 DDED116A 		vldr.32	s13, [sp, #68]
 3127              	.LVL228:
 3128              	.LBB1481:
 3129              	.LBI1481:
 133:./MotorControl/utils.hpp ****     float res = wrap_pm(x, y);
 3130              		.loc 11 133 14 is_stmt 1 view .LVU768
 3131              	.LBB1482:
 134:./MotorControl/utils.hpp ****     if (res < 0) res += y;
 3132              		.loc 11 134 5 view .LVU769
 3133              	.LBB1483:
 3134              	.LBI1483:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 3135              		.loc 11 123 14 view .LVU770
 3136              	.LBB1484:
 125:./MotorControl/utils.hpp **** #else
 3137              		.loc 11 125 5 view .LVU771
 125:./MotorControl/utils.hpp **** #else
 3138              		.loc 11 125 36 is_stmt 0 view .LVU772
 3139 0158 87EEA67A 		vdiv.f32	s14, s15, s13
 3140              	.LVL229:
 3141              	.LBB1485:
 3142              	.LBI1485:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 3143              		.loc 11 108 12 is_stmt 1 view .LVU773
 3144              	.LBB1486:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 3145              		.loc 11 110 5 view .LVU774
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 3146              		.loc 11 111 5 view .LVU775
 3147              		.syntax unified
 3148              	@ 111 "./MotorControl/utils.hpp" 1
 3149 015c BDEE477A 		vcvtr.s32.f32   s14, s14
 3150              	@ 0 "" 2
 3151              	.LVL230:
 114:./MotorControl/utils.hpp **** #else
 3152              		.loc 11 114 5 view .LVU776
 114:./MotorControl/utils.hpp **** #else
 3153              		.loc 11 114 5 is_stmt 0 view .LVU777
 3154              		.thumb
 3155              		.syntax unified
 3156              	.LBE1486:
 3157              	.LBE1485:
 125:./MotorControl/utils.hpp **** #else
 3158              		.loc 11 125 42 view .LVU778
ARM GAS  /tmp/ccawPiBL.s 			page 231


 3159 0160 B8EEC77A 		vcvt.f32.s32	s14, s14
 3160              	.LVL231:
 129:./MotorControl/utils.hpp **** }
 3161              		.loc 11 129 5 is_stmt 1 view .LVU779
 129:./MotorControl/utils.hpp **** }
 3162              		.loc 11 129 23 is_stmt 0 view .LVU780
 3163 0164 26EE877A 		vmul.f32	s14, s13, s14
 3164              	.LVL232:
 129:./MotorControl/utils.hpp **** }
 3165              		.loc 11 129 25 view .LVU781
 3166 0168 77EEC77A 		vsub.f32	s15, s15, s14
 3167              	.LVL233:
 129:./MotorControl/utils.hpp **** }
 3168              		.loc 11 129 25 view .LVU782
 3169              	.LBE1484:
 3170              	.LBE1483:
 135:./MotorControl/utils.hpp ****     return res;
 3171              		.loc 11 135 5 is_stmt 1 view .LVU783
 3172 016c F5EEC07A 		vcmpe.f32	s15, #0
 3173 0170 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 3174 0174 17D4     		bmi	.L250
 3175              	.L136:
 3176              		.loc 11 136 5 view .LVU784
 3177              	.LVL234:
 3178              		.loc 11 136 5 is_stmt 0 view .LVU785
 3179              	.LBE1482:
 3180              	.LBE1481:
 179:MotorControl/controller.cpp ****     }
 3181              		.loc 3 179 20 view .LVU786
 3182 0176 04F56453 		add	r3, r4, #14592
 3183 017a C3ED057A 		vstr.32	s15, [r3, #20]
 3184              	.L134:
 183:MotorControl/controller.cpp ****         case INPUT_MODE_INACTIVE: {
 3185              		.loc 3 183 5 is_stmt 1 view .LVU787
 3186              	.LBB1488:
 183:MotorControl/controller.cpp ****         case INPUT_MODE_INACTIVE: {
 3187              		.loc 3 183 21 is_stmt 0 view .LVU788
 3188 017e 637E     		ldrb	r3, [r4, #25]	@ zero_extendqisi2
 183:MotorControl/controller.cpp ****         case INPUT_MODE_INACTIVE: {
 3189              		.loc 3 183 5 view .LVU789
 3190 0180 082B     		cmp	r3, #8
 3191 0182 00F27182 		bhi	.L138
 3192 0186 DFE813F0 		tbh	[pc, r3, lsl #1]
 3193              	.L140:
 3194 018a 2500     		.2byte	(.L147-.L140)/2
 3195 018c 1100     		.2byte	(.L146-.L140)/2
 3196 018e 4700     		.2byte	(.L145-.L140)/2
 3197 0190 BD00     		.2byte	(.L144-.L140)/2
 3198 0192 6F02     		.2byte	(.L138-.L140)/2
 3199 0194 9A01     		.2byte	(.L143-.L140)/2
 3200 0196 8900     		.2byte	(.L142-.L140)/2
 3201 0198 1101     		.2byte	(.L141-.L140)/2
 3202 019a 1602     		.2byte	(.L139-.L140)/2
 3203              		.p2align 1
 3204              	.L249:
 183:MotorControl/controller.cpp ****         case INPUT_MODE_INACTIVE: {
 3205              		.loc 3 183 5 view .LVU790
ARM GAS  /tmp/ccawPiBL.s 			page 232


 3206              	.LBE1488:
 176:MotorControl/controller.cpp ****             return false;
 3207              		.loc 3 176 13 is_stmt 1 view .LVU791
 176:MotorControl/controller.cpp ****             return false;
 3208              		.loc 3 176 22 is_stmt 0 view .LVU792
 3209 019c 4021     		movs	r1, #64
 3210 019e 2046     		mov	r0, r4
 3211 01a0 FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 3212              	.LVL235:
 177:MotorControl/controller.cpp ****         }
 3213              		.loc 3 177 13 is_stmt 1 view .LVU793
 177:MotorControl/controller.cpp ****         }
 3214              		.loc 3 177 20 is_stmt 0 view .LVU794
 3215 01a4 C0E7     		b	.L130
 3216              	.LVL236:
 3217              	.L250:
 3218              	.LBB1658:
 3219              	.LBB1487:
 135:./MotorControl/utils.hpp ****     return res;
 3220              		.loc 11 135 18 is_stmt 1 view .LVU795
 135:./MotorControl/utils.hpp ****     return res;
 3221              		.loc 11 135 22 is_stmt 0 view .LVU796
 3222 01a6 77EEA67A 		vadd.f32	s15, s15, s13
 3223              	.LVL237:
 135:./MotorControl/utils.hpp ****     return res;
 3224              		.loc 11 135 22 view .LVU797
 3225 01aa E4E7     		b	.L136
 3226              	.LVL238:
 3227              	.L146:
 135:./MotorControl/utils.hpp ****     return res;
 3228              		.loc 11 135 22 view .LVU798
 3229              	.LBE1487:
 3230              	.LBE1658:
 3231              	.LBB1659:
 3232              	.LBB1489:
 187:MotorControl/controller.cpp ****             pos_setpoint_ = input_pos_;
 3233              		.loc 3 187 9 is_stmt 1 view .LVU799
 187:MotorControl/controller.cpp ****             pos_setpoint_ = input_pos_;
 3234              		.loc 3 187 38 view .LVU800
 188:MotorControl/controller.cpp ****             vel_setpoint_ = input_vel_;
 3235              		.loc 3 188 13 view .LVU801
 188:MotorControl/controller.cpp ****             vel_setpoint_ = input_vel_;
 3236              		.loc 3 188 29 is_stmt 0 view .LVU802
 3237 01ac 04F54053 		add	r3, r4, #12288
 3238 01b0 03F61412 		addw	r2, r3, #2324
 3239 01b4 1168     		ldr	r1, [r2]	@ float
 188:MotorControl/controller.cpp ****             vel_setpoint_ = input_vel_;
 3240              		.loc 3 188 27 view .LVU803
 3241 01b6 03F60412 		addw	r2, r3, #2308
 3242 01ba 1160     		str	r1, [r2]	@ float
 189:MotorControl/controller.cpp ****             torque_setpoint_ = input_torque_; 
 3243              		.loc 3 189 13 is_stmt 1 view .LVU804
 189:MotorControl/controller.cpp ****             torque_setpoint_ = input_torque_; 
 3244              		.loc 3 189 29 is_stmt 0 view .LVU805
 3245 01bc 03F61812 		addw	r2, r3, #2328
 3246 01c0 1168     		ldr	r1, [r2]	@ float
 189:MotorControl/controller.cpp ****             torque_setpoint_ = input_torque_; 
ARM GAS  /tmp/ccawPiBL.s 			page 233


 3247              		.loc 3 189 27 view .LVU806
 3248 01c2 03F60812 		addw	r2, r3, #2312
 3249 01c6 1160     		str	r1, [r2]	@ float
 190:MotorControl/controller.cpp ****         } break;
 3250              		.loc 3 190 13 is_stmt 1 view .LVU807
 190:MotorControl/controller.cpp ****         } break;
 3251              		.loc 3 190 32 is_stmt 0 view .LVU808
 3252 01c8 03F61C12 		addw	r2, r3, #2332
 3253 01cc 1268     		ldr	r2, [r2]	@ float
 190:MotorControl/controller.cpp ****         } break;
 3254              		.loc 3 190 30 view .LVU809
 3255 01ce 03F51163 		add	r3, r3, #2320
 3256 01d2 1A60     		str	r2, [r3]	@ float
 191:MotorControl/controller.cpp ****         case INPUT_MODE_VEL_RAMP: {
 3257              		.loc 3 191 11 is_stmt 1 view .LVU810
 3258              	.L147:
 191:MotorControl/controller.cpp ****         case INPUT_MODE_VEL_RAMP: {
 3259              		.loc 3 191 11 is_stmt 0 view .LVU811
 3260              	.LBE1489:
 3261              	.LBE1659:
 286:MotorControl/controller.cpp ****         vel_setpoint_ = std::clamp(vel_setpoint_, -config_.vel_limit, config_.vel_limit);
 3262              		.loc 3 286 5 is_stmt 1 view .LVU812
 286:MotorControl/controller.cpp ****         vel_setpoint_ = std::clamp(vel_setpoint_, -config_.vel_limit, config_.vel_limit);
 3263              		.loc 3 286 16 is_stmt 0 view .LVU813
 3264 01d4 04F54053 		add	r3, r4, #12288
 3265 01d8 93F8B138 		ldrb	r3, [r3, #2225]	@ zero_extendqisi2
 286:MotorControl/controller.cpp ****         vel_setpoint_ = std::clamp(vel_setpoint_, -config_.vel_limit, config_.vel_limit);
 3266              		.loc 3 286 5 view .LVU814
 3267 01dc 002B     		cmp	r3, #0
 3268 01de 00F04E82 		beq	.L166
 287:MotorControl/controller.cpp ****     }
 3269              		.loc 3 287 9 is_stmt 1 view .LVU815
 287:MotorControl/controller.cpp ****     }
 3270              		.loc 3 287 36 is_stmt 0 view .LVU816
 3271 01e2 04F56453 		add	r3, r4, #14592
 3272 01e6 0833     		adds	r3, r3, #8
 287:MotorControl/controller.cpp ****     }
 3273              		.loc 3 287 60 view .LVU817
 3274 01e8 2146     		mov	r1, r4
 3275 01ea D4ED0A6A 		vldr.32	s13, [r4, #40]
 3276 01ee 2831     		adds	r1, r1, #40
 287:MotorControl/controller.cpp ****     }
 3277              		.loc 3 287 51 view .LVU818
 3278 01f0 F1EE667A 		vneg.f32	s15, s13
 3279 01f4 CDED1B7A 		vstr.32	s15, [sp, #108]
 3280              	.LVL239:
 3281              	.LBB1660:
 3282              	.LBI1660:
3680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 3283              		.loc 6 3680 5 is_stmt 1 view .LVU819
 3284              	.LBB1661:
 3285              		.loc 6 3683 21 is_stmt 0 view .LVU820
 3286 01f8 93ED007A 		vldr.32	s14, [r3]
 3287              		.loc 6 3683 29 view .LVU821
 3288 01fc F4EEC77A 		vcmpe.f32	s15, s14
 3289 0200 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 3290 0204 00F33682 		bgt	.L214
ARM GAS  /tmp/ccawPiBL.s 			page 234


 3291 0208 F4EEC76A 		vcmpe.f32	s13, s14
 3292 020c F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 3293 0210 40F13182 		bpl	.L167
 3294 0214 0B46     		mov	r3, r1
 3295              	.LVL240:
 3296              		.loc 6 3683 29 view .LVU822
 3297 0216 2EE2     		b	.L167
 3298              	.LVL241:
 3299              	.L145:
 3300              		.loc 6 3683 29 view .LVU823
 3301              	.LBE1661:
 3302              	.LBE1660:
 3303              	.LBB1663:
 3304              	.LBB1655:
 192:MotorControl/controller.cpp ****             float max_step_size = std::abs(current_meas_period * config_.vel_ramp_rate);
 3305              		.loc 3 192 9 is_stmt 1 view .LVU824
 192:MotorControl/controller.cpp ****             float max_step_size = std::abs(current_meas_period * config_.vel_ramp_rate);
 3306              		.loc 3 192 35 view .LVU825
 3307              	.LBB1490:
 193:MotorControl/controller.cpp ****             float full_step = input_vel_ - vel_setpoint_;
 3308              		.loc 3 193 13 view .LVU826
 193:MotorControl/controller.cpp ****             float full_step = input_vel_ - vel_setpoint_;
 3309              		.loc 3 193 74 is_stmt 0 view .LVU827
 3310 0218 D4ED0D7A 		vldr.32	s15, [r4, #52]
 193:MotorControl/controller.cpp ****             float full_step = input_vel_ - vel_setpoint_;
 3311              		.loc 3 193 43 view .LVU828
 3312 021c 9FEDD07A 		vldr.32	s14, .L268+8
 3313 0220 67EE877A 		vmul.f32	s15, s15, s14
 3314              	.LVL242:
 3315              	.LBB1491:
 3316              	.LBI1491:
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   { return __builtin_fabsf(__x); }
 3317              		.loc 9 75 3 is_stmt 1 view .LVU829
 3318              	.LBB1492:
 3319              		.loc 9 76 5 view .LVU830
 3320              		.loc 9 76 31 is_stmt 0 view .LVU831
 3321 0224 F0EEE77A 		vabs.f32	s15, s15
 3322              	.LVL243:
 3323              		.loc 9 76 31 view .LVU832
 3324              	.LBE1492:
 3325              	.LBE1491:
 193:MotorControl/controller.cpp ****             float full_step = input_vel_ - vel_setpoint_;
 3326              		.loc 3 193 87 view .LVU833
 3327 0228 CDED037A 		vstr.32	s15, [sp, #12]
 194:MotorControl/controller.cpp ****             float step = std::clamp(full_step, -max_step_size, max_step_size);
 3328              		.loc 3 194 13 is_stmt 1 view .LVU834
 194:MotorControl/controller.cpp ****             float step = std::clamp(full_step, -max_step_size, max_step_size);
 3329              		.loc 3 194 31 is_stmt 0 view .LVU835
 3330 022c 04F54053 		add	r3, r4, #12288
 3331 0230 03F61812 		addw	r2, r3, #2328
 3332 0234 92ED007A 		vldr.32	s14, [r2]
 194:MotorControl/controller.cpp ****             float step = std::clamp(full_step, -max_step_size, max_step_size);
 3333              		.loc 3 194 44 view .LVU836
 3334 0238 03F60813 		addw	r3, r3, #2312
 3335 023c D3ED006A 		vldr.32	s13, [r3]
 194:MotorControl/controller.cpp ****             float step = std::clamp(full_step, -max_step_size, max_step_size);
 3336              		.loc 3 194 42 view .LVU837
ARM GAS  /tmp/ccawPiBL.s 			page 235


 3337 0240 37EE667A 		vsub.f32	s14, s14, s13
 194:MotorControl/controller.cpp ****             float step = std::clamp(full_step, -max_step_size, max_step_size);
 3338              		.loc 3 194 19 view .LVU838
 3339 0244 8DED057A 		vstr.32	s14, [sp, #20]
 195:MotorControl/controller.cpp **** 
 3340              		.loc 3 195 13 is_stmt 1 view .LVU839
 195:MotorControl/controller.cpp **** 
 3341              		.loc 3 195 48 is_stmt 0 view .LVU840
 3342 0248 B1EE676A 		vneg.f32	s12, s15
 3343 024c 8DED176A 		vstr.32	s12, [sp, #92]
 3344              	.LVL244:
 3345              	.LBB1493:
 3346              	.LBI1493:
3680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 3347              		.loc 6 3680 5 is_stmt 1 view .LVU841
 3348              	.LBB1494:
 3349              		.loc 6 3683 29 is_stmt 0 view .LVU842
 3350 0250 B4EEC67A 		vcmpe.f32	s14, s12
 3351 0254 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 3352 0258 06D4     		bmi	.L210
 3353 025a B4EEE77A 		vcmpe.f32	s14, s15
 3354 025e F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 3355 0262 19DD     		ble	.L240
 3356 0264 03AB     		add	r3, sp, #12
 3357              	.LVL245:
 3358              		.loc 6 3683 29 view .LVU843
 3359 0266 00E0     		b	.L148
 3360              	.LVL246:
 3361              	.L210:
 3362              		.loc 6 3683 29 view .LVU844
 3363 0268 17AB     		add	r3, sp, #92
 3364              	.LVL247:
 3365              	.L148:
 3366              		.loc 6 3683 29 view .LVU845
 3367              	.LBE1494:
 3368              	.LBE1493:
 195:MotorControl/controller.cpp **** 
 3369              		.loc 3 195 77 view .LVU846
 3370 026a 93ED007A 		vldr.32	s14, [r3]
 3371              	.LVL248:
 197:MotorControl/controller.cpp ****             torque_setpoint_ = (step / current_meas_period) * config_.inertia;
 3372              		.loc 3 197 13 is_stmt 1 view .LVU847
 197:MotorControl/controller.cpp ****             torque_setpoint_ = (step / current_meas_period) * config_.inertia;
 3373              		.loc 3 197 27 is_stmt 0 view .LVU848
 3374 026e 04F54053 		add	r3, r4, #12288
 3375 0272 03F60812 		addw	r2, r3, #2312
 3376 0276 76EE876A 		vadd.f32	s13, s13, s14
 3377 027a C2ED006A 		vstr.32	s13, [r2]
 198:MotorControl/controller.cpp ****         } break;
 3378              		.loc 3 198 13 is_stmt 1 view .LVU849
 198:MotorControl/controller.cpp ****         } break;
 3379              		.loc 3 198 38 is_stmt 0 view .LVU850
 3380 027e DFEDB86A 		vldr.32	s13, .L268+8
 3381 0282 C7EE267A 		vdiv.f32	s15, s14, s13
 198:MotorControl/controller.cpp ****         } break;
 3382              		.loc 3 198 71 view .LVU851
 3383 0286 94ED127A 		vldr.32	s14, [r4, #72]
ARM GAS  /tmp/ccawPiBL.s 			page 236


 3384              	.LVL249:
 198:MotorControl/controller.cpp ****         } break;
 3385              		.loc 3 198 61 view .LVU852
 3386 028a 67EE877A 		vmul.f32	s15, s15, s14
 198:MotorControl/controller.cpp ****         } break;
 3387              		.loc 3 198 30 view .LVU853
 3388 028e 03F51163 		add	r3, r3, #2320
 3389 0292 C3ED007A 		vstr.32	s15, [r3]
 3390              	.LBE1490:
 199:MotorControl/controller.cpp ****         case INPUT_MODE_TORQUE_RAMP: {
 3391              		.loc 3 199 11 is_stmt 1 view .LVU854
 3392 0296 9DE7     		b	.L147
 3393              	.LVL250:
 3394              	.L240:
 3395              	.LBB1497:
 3396              	.LBB1496:
 3397              	.LBB1495:
 3398              		.loc 6 3683 29 is_stmt 0 view .LVU855
 3399 0298 05AB     		add	r3, sp, #20
 3400              	.LVL251:
 3401              		.loc 6 3683 29 view .LVU856
 3402 029a E6E7     		b	.L148
 3403              	.LVL252:
 3404              	.L142:
 3405              		.loc 6 3683 29 view .LVU857
 3406              	.LBE1495:
 3407              	.LBE1496:
 3408              	.LBE1497:
 200:MotorControl/controller.cpp ****             float max_step_size = std::abs(current_meas_period * config_.torque_ramp_rate);
 3409              		.loc 3 200 9 is_stmt 1 view .LVU858
 200:MotorControl/controller.cpp ****             float max_step_size = std::abs(current_meas_period * config_.torque_ramp_rate);
 3410              		.loc 3 200 38 view .LVU859
 3411              	.LBB1498:
 201:MotorControl/controller.cpp ****             float full_step = input_torque_ - torque_setpoint_;
 3412              		.loc 3 201 13 view .LVU860
 201:MotorControl/controller.cpp ****             float full_step = input_torque_ - torque_setpoint_;
 3413              		.loc 3 201 74 is_stmt 0 view .LVU861
 3414 029c D4ED0E7A 		vldr.32	s15, [r4, #56]
 201:MotorControl/controller.cpp ****             float full_step = input_torque_ - torque_setpoint_;
 3415              		.loc 3 201 43 view .LVU862
 3416 02a0 9FEDAF7A 		vldr.32	s14, .L268+8
 3417 02a4 67EE877A 		vmul.f32	s15, s15, s14
 3418              	.LVL253:
 3419              	.LBB1499:
 3420              	.LBI1499:
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   { return __builtin_fabsf(__x); }
 3421              		.loc 9 75 3 is_stmt 1 view .LVU863
 3422              	.LBB1500:
 3423              		.loc 9 76 5 view .LVU864
 3424              		.loc 9 76 31 is_stmt 0 view .LVU865
 3425 02a8 F0EEE77A 		vabs.f32	s15, s15
 3426              	.LVL254:
 3427              		.loc 9 76 31 view .LVU866
 3428              	.LBE1500:
 3429              	.LBE1499:
 201:MotorControl/controller.cpp ****             float full_step = input_torque_ - torque_setpoint_;
 3430              		.loc 3 201 90 view .LVU867
ARM GAS  /tmp/ccawPiBL.s 			page 237


 3431 02ac CDED037A 		vstr.32	s15, [sp, #12]
 202:MotorControl/controller.cpp ****             float step = std::clamp(full_step, -max_step_size, max_step_size);
 3432              		.loc 3 202 13 is_stmt 1 view .LVU868
 202:MotorControl/controller.cpp ****             float step = std::clamp(full_step, -max_step_size, max_step_size);
 3433              		.loc 3 202 31 is_stmt 0 view .LVU869
 3434 02b0 04F54053 		add	r3, r4, #12288
 3435 02b4 03F61C12 		addw	r2, r3, #2332
 3436 02b8 92ED007A 		vldr.32	s14, [r2]
 202:MotorControl/controller.cpp ****             float step = std::clamp(full_step, -max_step_size, max_step_size);
 3437              		.loc 3 202 47 view .LVU870
 3438 02bc 03F51163 		add	r3, r3, #2320
 3439 02c0 D3ED006A 		vldr.32	s13, [r3]
 202:MotorControl/controller.cpp ****             float step = std::clamp(full_step, -max_step_size, max_step_size);
 3440              		.loc 3 202 45 view .LVU871
 3441 02c4 37EE667A 		vsub.f32	s14, s14, s13
 202:MotorControl/controller.cpp ****             float step = std::clamp(full_step, -max_step_size, max_step_size);
 3442              		.loc 3 202 19 view .LVU872
 3443 02c8 8DED057A 		vstr.32	s14, [sp, #20]
 203:MotorControl/controller.cpp **** 
 3444              		.loc 3 203 13 is_stmt 1 view .LVU873
 203:MotorControl/controller.cpp **** 
 3445              		.loc 3 203 48 is_stmt 0 view .LVU874
 3446 02cc B1EE676A 		vneg.f32	s12, s15
 3447 02d0 8DED186A 		vstr.32	s12, [sp, #96]
 3448              	.LVL255:
 3449              	.LBB1501:
 3450              	.LBI1501:
3680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 3451              		.loc 6 3680 5 is_stmt 1 view .LVU875
 3452              	.LBB1502:
 3453              		.loc 6 3683 29 is_stmt 0 view .LVU876
 3454 02d4 B4EEC67A 		vcmpe.f32	s14, s12
 3455 02d8 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 3456 02dc 06D4     		bmi	.L212
 3457 02de B4EEE77A 		vcmpe.f32	s14, s15
 3458 02e2 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 3459 02e6 0BDD     		ble	.L241
 3460 02e8 03AB     		add	r3, sp, #12
 3461              	.LVL256:
 3462              		.loc 6 3683 29 view .LVU877
 3463 02ea 00E0     		b	.L150
 3464              	.LVL257:
 3465              	.L212:
 3466              		.loc 6 3683 29 view .LVU878
 3467 02ec 18AB     		add	r3, sp, #96
 3468              	.LVL258:
 3469              	.L150:
 3470              		.loc 6 3683 29 view .LVU879
 3471              	.LBE1502:
 3472              	.LBE1501:
 203:MotorControl/controller.cpp **** 
 3473              		.loc 3 203 77 view .LVU880
 3474 02ee D3ED007A 		vldr.32	s15, [r3]
 3475              	.LVL259:
 205:MotorControl/controller.cpp ****         } break;
 3476              		.loc 3 205 13 is_stmt 1 view .LVU881
 205:MotorControl/controller.cpp ****         } break;
ARM GAS  /tmp/ccawPiBL.s 			page 238


 3477              		.loc 3 205 30 is_stmt 0 view .LVU882
 3478 02f2 04F56453 		add	r3, r4, #14592
 3479 02f6 76EEA76A 		vadd.f32	s13, s13, s15
 3480 02fa C3ED046A 		vstr.32	s13, [r3, #16]
 3481              	.LBE1498:
 206:MotorControl/controller.cpp ****         case INPUT_MODE_POS_FILTER: {
 3482              		.loc 3 206 11 is_stmt 1 view .LVU883
 3483 02fe 69E7     		b	.L147
 3484              	.LVL260:
 3485              	.L241:
 3486              	.LBB1505:
 3487              	.LBB1504:
 3488              	.LBB1503:
 3489              		.loc 6 3683 29 is_stmt 0 view .LVU884
 3490 0300 05AB     		add	r3, sp, #20
 3491              	.LVL261:
 3492              		.loc 6 3683 29 view .LVU885
 3493 0302 F4E7     		b	.L150
 3494              	.LVL262:
 3495              	.L144:
 3496              		.loc 6 3683 29 view .LVU886
 3497              	.LBE1503:
 3498              	.LBE1504:
 3499              	.LBE1505:
 207:MotorControl/controller.cpp ****             // 2nd order pos tracking filter
 3500              		.loc 3 207 9 is_stmt 1 view .LVU887
 207:MotorControl/controller.cpp ****             // 2nd order pos tracking filter
 3501              		.loc 3 207 37 view .LVU888
 3502              	.LBB1506:
 209:MotorControl/controller.cpp ****             if (config_.circular_setpoints) {
 3503              		.loc 3 209 13 view .LVU889
 209:MotorControl/controller.cpp ****             if (config_.circular_setpoints) {
 3504              		.loc 3 209 31 is_stmt 0 view .LVU890
 3505 0304 04F54053 		add	r3, r4, #12288
 3506 0308 03F61411 		addw	r1, r3, #2324
 3507 030c D1ED007A 		vldr.32	s15, [r1]
 209:MotorControl/controller.cpp ****             if (config_.circular_setpoints) {
 3508              		.loc 3 209 44 view .LVU891
 3509 0310 03F60413 		addw	r3, r3, #2308
 3510 0314 93ED006A 		vldr.32	s12, [r3]
 209:MotorControl/controller.cpp ****             if (config_.circular_setpoints) {
 3511              		.loc 3 209 19 view .LVU892
 3512 0318 77EEC66A 		vsub.f32	s13, s15, s12
 3513              	.LVL263:
 210:MotorControl/controller.cpp ****                 if (!pos_wrap.has_value()) {
 3514              		.loc 3 210 13 is_stmt 1 view .LVU893
 3515 031c 72B1     		cbz	r2, .L152
 211:MotorControl/controller.cpp ****                     set_error(ERROR_INVALID_CIRCULAR_RANGE);
 3516              		.loc 3 211 17 view .LVU894
 3517              	.LVL264:
 3518              	.LBB1507:
 3519              	.LBI1507:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 3520              		.loc 13 916 22 view .LVU895
 3521              	.LBB1508:
 3522              	.LBI1508:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
ARM GAS  /tmp/ccawPiBL.s 			page 239


 3523              		.loc 13 433 22 view .LVU896
 3524              	.LBB1509:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3525              		.loc 13 434 58 is_stmt 0 view .LVU897
 3526 031e 9DF84850 		ldrb	r5, [sp, #72]	@ zero_extendqisi2
 3527              	.LVL265:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3528              		.loc 13 434 58 view .LVU898
 3529              	.LBE1509:
 3530              	.LBE1508:
 3531              	.LBE1507:
 211:MotorControl/controller.cpp ****                     set_error(ERROR_INVALID_CIRCULAR_RANGE);
 3532              		.loc 3 211 17 view .LVU899
 3533 0322 F5B3     		cbz	r5, .L251
 215:MotorControl/controller.cpp ****             }
 3534              		.loc 3 215 17 is_stmt 1 view .LVU900
 215:MotorControl/controller.cpp ****             }
 3535              		.loc 3 215 36 is_stmt 0 view .LVU901
 3536 0324 DDED117A 		vldr.32	s15, [sp, #68]
 3537              	.LVL266:
 3538              	.LBB1510:
 3539              	.LBI1510:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 3540              		.loc 11 123 14 is_stmt 1 view .LVU902
 3541              	.LBB1511:
 125:./MotorControl/utils.hpp **** #else
 3542              		.loc 11 125 5 view .LVU903
 125:./MotorControl/utils.hpp **** #else
 3543              		.loc 11 125 36 is_stmt 0 view .LVU904
 3544 0328 86EEA77A 		vdiv.f32	s14, s13, s15
 3545              	.LVL267:
 3546              	.LBB1512:
 3547              	.LBI1512:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 3548              		.loc 11 108 12 is_stmt 1 view .LVU905
 3549              	.LBB1513:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 3550              		.loc 11 110 5 view .LVU906
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 3551              		.loc 11 111 5 view .LVU907
 3552              		.syntax unified
 3553              	@ 111 "./MotorControl/utils.hpp" 1
 3554 032c BDEE477A 		vcvtr.s32.f32   s14, s14
 3555              	@ 0 "" 2
 3556              	.LVL268:
 114:./MotorControl/utils.hpp **** #else
 3557              		.loc 11 114 5 view .LVU908
 114:./MotorControl/utils.hpp **** #else
 3558              		.loc 11 114 5 is_stmt 0 view .LVU909
 3559              		.thumb
 3560              		.syntax unified
 3561              	.LBE1513:
 3562              	.LBE1512:
 125:./MotorControl/utils.hpp **** #else
 3563              		.loc 11 125 42 view .LVU910
 3564 0330 B8EEC77A 		vcvt.f32.s32	s14, s14
 3565              	.LVL269:
ARM GAS  /tmp/ccawPiBL.s 			page 240


 129:./MotorControl/utils.hpp **** }
 3566              		.loc 11 129 5 is_stmt 1 view .LVU911
 129:./MotorControl/utils.hpp **** }
 3567              		.loc 11 129 23 is_stmt 0 view .LVU912
 3568 0334 67EE877A 		vmul.f32	s15, s15, s14
 3569              	.LVL270:
 129:./MotorControl/utils.hpp **** }
 3570              		.loc 11 129 25 view .LVU913
 3571 0338 76EEE76A 		vsub.f32	s13, s13, s15
 3572              	.LVL271:
 3573              	.L152:
 129:./MotorControl/utils.hpp **** }
 3574              		.loc 11 129 25 view .LVU914
 3575              	.LBE1511:
 3576              	.LBE1510:
 217:MotorControl/controller.cpp ****             float accel = input_filter_kp_*delta_pos + input_filter_ki_*delta_vel; // Feedback
 3577              		.loc 3 217 13 is_stmt 1 view .LVU915
 217:MotorControl/controller.cpp ****             float accel = input_filter_kp_*delta_pos + input_filter_ki_*delta_vel; // Feedback
 3578              		.loc 3 217 31 is_stmt 0 view .LVU916
 3579 033c 04F54053 		add	r3, r4, #12288
 3580 0340 03F61812 		addw	r2, r3, #2328
 3581 0344 D2ED005A 		vldr.32	s11, [r2]
 217:MotorControl/controller.cpp ****             float accel = input_filter_kp_*delta_pos + input_filter_ki_*delta_vel; // Feedback
 3582              		.loc 3 217 44 view .LVU917
 3583 0348 03F60812 		addw	r2, r3, #2312
 3584 034c 92ED007A 		vldr.32	s14, [r2]
 217:MotorControl/controller.cpp ****             float accel = input_filter_kp_*delta_pos + input_filter_ki_*delta_vel; // Feedback
 3585              		.loc 3 217 19 view .LVU918
 3586 0350 75EEC75A 		vsub.f32	s11, s11, s14
 3587              	.LVL272:
 218:MotorControl/controller.cpp ****             torque_setpoint_ = accel * config_.inertia; // Accel
 3588              		.loc 3 218 13 is_stmt 1 view .LVU919
 218:MotorControl/controller.cpp ****             torque_setpoint_ = accel * config_.inertia; // Accel
 3589              		.loc 3 218 27 is_stmt 0 view .LVU920
 3590 0354 03F51261 		add	r1, r3, #2336
 3591 0358 D1ED007A 		vldr.32	s15, [r1]
 218:MotorControl/controller.cpp ****             torque_setpoint_ = accel * config_.inertia; // Accel
 3592              		.loc 3 218 43 view .LVU921
 3593 035c 67EEA67A 		vmul.f32	s15, s15, s13
 218:MotorControl/controller.cpp ****             torque_setpoint_ = accel * config_.inertia; // Accel
 3594              		.loc 3 218 56 view .LVU922
 3595 0360 03F62411 		addw	r1, r3, #2340
 3596 0364 D1ED006A 		vldr.32	s13, [r1]
 3597              	.LVL273:
 218:MotorControl/controller.cpp ****             torque_setpoint_ = accel * config_.inertia; // Accel
 3598              		.loc 3 218 72 view .LVU923
 3599 0368 66EEA56A 		vmul.f32	s13, s13, s11
 218:MotorControl/controller.cpp ****             torque_setpoint_ = accel * config_.inertia; // Accel
 3600              		.loc 3 218 19 view .LVU924
 3601 036c 77EEA67A 		vadd.f32	s15, s15, s13
 3602              	.LVL274:
 219:MotorControl/controller.cpp ****             vel_setpoint_ += current_meas_period * accel; // delta vel
 3603              		.loc 3 219 13 is_stmt 1 view .LVU925
 219:MotorControl/controller.cpp ****             vel_setpoint_ += current_meas_period * accel; // delta vel
 3604              		.loc 3 219 48 is_stmt 0 view .LVU926
 3605 0370 D4ED126A 		vldr.32	s13, [r4, #72]
 219:MotorControl/controller.cpp ****             vel_setpoint_ += current_meas_period * accel; // delta vel
ARM GAS  /tmp/ccawPiBL.s 			page 241


 3606              		.loc 3 219 38 view .LVU927
 3607 0374 66EEA76A 		vmul.f32	s13, s13, s15
 219:MotorControl/controller.cpp ****             vel_setpoint_ += current_meas_period * accel; // delta vel
 3608              		.loc 3 219 30 view .LVU928
 3609 0378 03F51161 		add	r1, r3, #2320
 3610 037c C1ED006A 		vstr.32	s13, [r1]
 220:MotorControl/controller.cpp ****             pos_setpoint_ += current_meas_period * vel_setpoint_; // Delta pos
 3611              		.loc 3 220 13 is_stmt 1 view .LVU929
 220:MotorControl/controller.cpp ****             pos_setpoint_ += current_meas_period * vel_setpoint_; // Delta pos
 3612              		.loc 3 220 50 is_stmt 0 view .LVU930
 3613 0380 DFED776A 		vldr.32	s13, .L268+8
 3614 0384 67EEA67A 		vmul.f32	s15, s15, s13
 3615              	.LVL275:
 220:MotorControl/controller.cpp ****             pos_setpoint_ += current_meas_period * vel_setpoint_; // Delta pos
 3616              		.loc 3 220 27 view .LVU931
 3617 0388 77EE277A 		vadd.f32	s15, s14, s15
 3618 038c C2ED007A 		vstr.32	s15, [r2]
 221:MotorControl/controller.cpp ****         } break;
 3619              		.loc 3 221 13 is_stmt 1 view .LVU932
 221:MotorControl/controller.cpp ****         } break;
 3620              		.loc 3 221 50 is_stmt 0 view .LVU933
 3621 0390 67EEA67A 		vmul.f32	s15, s15, s13
 221:MotorControl/controller.cpp ****         } break;
 3622              		.loc 3 221 27 view .LVU934
 3623 0394 03F60413 		addw	r3, r3, #2308
 221:MotorControl/controller.cpp ****         } break;
 3624              		.loc 3 221 27 view .LVU935
 3625 0398 76EE277A 		vadd.f32	s15, s12, s15
 3626 039c C3ED007A 		vstr.32	s15, [r3]
 3627              	.LBE1506:
 222:MotorControl/controller.cpp ****         case INPUT_MODE_MIRROR: {
 3628              		.loc 3 222 11 is_stmt 1 view .LVU936
 3629 03a0 18E7     		b	.L147
 3630              	.LVL276:
 3631              	.L251:
 3632              	.LBB1514:
 212:MotorControl/controller.cpp ****                     return false;
 3633              		.loc 3 212 21 view .LVU937
 212:MotorControl/controller.cpp ****                     return false;
 3634              		.loc 3 212 30 is_stmt 0 view .LVU938
 3635 03a2 4021     		movs	r1, #64
 3636 03a4 2046     		mov	r0, r4
 3637 03a6 FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 3638              	.LVL277:
 213:MotorControl/controller.cpp ****                 }
 3639              		.loc 3 213 21 is_stmt 1 view .LVU939
 213:MotorControl/controller.cpp ****                 }
 3640              		.loc 3 213 28 is_stmt 0 view .LVU940
 3641 03aa BDE6     		b	.L130
 3642              	.L141:
 213:MotorControl/controller.cpp ****                 }
 3643              		.loc 3 213 28 view .LVU941
 3644              	.LBE1514:
 223:MotorControl/controller.cpp ****             if (config_.axis_to_mirror < AXIS_COUNT) {
 3645              		.loc 3 223 9 is_stmt 1 view .LVU942
 223:MotorControl/controller.cpp ****             if (config_.axis_to_mirror < AXIS_COUNT) {
 3646              		.loc 3 223 33 view .LVU943
ARM GAS  /tmp/ccawPiBL.s 			page 242


 3647              	.LBE1655:
 3648              	.LBE1663:
 224:MotorControl/controller.cpp ****                 std::optional<float> other_pos = axes[config_.axis_to_mirror].encoder_.pos_estimate
 3649              		.loc 3 224 13 view .LVU944
 3650              	.LBB1664:
 3651              	.LBB1656:
 3652              	.LBB1515:
 224:MotorControl/controller.cpp ****                 std::optional<float> other_pos = axes[config_.axis_to_mirror].encoder_.pos_estimate
 3653              		.loc 3 224 25 is_stmt 0 view .LVU945
 3654 03ac 04F54053 		add	r3, r4, #12288
 3655 03b0 93F8B438 		ldrb	r3, [r3, #2228]	@ zero_extendqisi2
 224:MotorControl/controller.cpp ****                 std::optional<float> other_pos = axes[config_.axis_to_mirror].encoder_.pos_estimate
 3656              		.loc 3 224 13 view .LVU946
 3657 03b4 012B     		cmp	r3, #1
 3658 03b6 7CD8     		bhi	.L154
 3659              	.LBB1516:
 225:MotorControl/controller.cpp ****                 std::optional<float> other_vel = axes[config_.axis_to_mirror].encoder_.vel_estimate
 3660              		.loc 3 225 17 is_stmt 1 view .LVU947
 3661              	.LVL278:
 3662              	.LBB1517:
 3663              	.LBI1517:
 3664              		.file 16 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array"
   1:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // <array> -*- C++ -*-
   2:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
   3:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // Copyright (C) 2007-2020 Free Software Foundation, Inc.
   4:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** //
   5:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // This file is part of the GNU ISO C++ Library.  This library is free
   6:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // software; you can redistribute it and/or modify it under the
   7:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // terms of the GNU General Public License as published by the
   8:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // Free Software Foundation; either version 3, or (at your option)
   9:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // any later version.
  10:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  11:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // This library is distributed in the hope that it will be useful,
  12:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // GNU General Public License for more details.
  15:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  16:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // Under Section 7 of GPL version 3, you are granted additional
  17:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // permissions described in the GCC Runtime Library Exception, version
  18:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // 3.1, as published by the Free Software Foundation.
  19:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  20:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // You should have received a copy of the GNU General Public License and
  21:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // a copy of the GCC Runtime Library Exception along with this program;
  22:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** // <http://www.gnu.org/licenses/>.
  24:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  25:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** /** @file include/array
  26:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****  *  This is a Standard C++ Library header.
  27:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****  */
  28:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  29:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #ifndef _GLIBCXX_ARRAY
  30:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #define _GLIBCXX_ARRAY 1
  31:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  32:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #pragma GCC system_header
  33:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  34:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #if __cplusplus < 201103L
  35:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** # include <bits/c++0x_warning.h>
ARM GAS  /tmp/ccawPiBL.s 			page 243


  36:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #else
  37:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  38:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <utility>
  39:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <bits/functexcept.h>
  40:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <bits/stl_algobase.h>
  41:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** #include <bits/range_access.h>
  42:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  43:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** namespace std _GLIBCXX_VISIBILITY(default)
  44:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** {
  45:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
  46:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  47:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   template<typename _Tp, std::size_t _Nm>
  48:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     struct __array_traits
  49:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     {
  50:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef _Tp _Type[_Nm];
  51:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef __is_swappable<_Tp> _Is_swappable;
  52:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;
  53:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  54:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       static constexpr _Tp&
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _S_ref(const _Type& __t, std::size_t __n) noexcept
  56:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
  57:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  58:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       static constexpr _Tp*
  59:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _S_ptr(const _Type& __t) noexcept
  60:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp*>(__t); }
  61:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     };
  62:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  63:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****  template<typename _Tp>
  64:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    struct __array_traits<_Tp, 0>
  65:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    {
  66:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      struct _Type { };
  67:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      typedef true_type _Is_swappable;
  68:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      typedef true_type _Is_nothrow_swappable;
  69:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  70:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      static constexpr _Tp&
  71:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      _S_ref(const _Type&, std::size_t) noexcept
  72:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      { return *static_cast<_Tp*>(nullptr); }
  73:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  74:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      static constexpr _Tp*
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      _S_ptr(const _Type&) noexcept
  76:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****      { return nullptr; }
  77:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    };
  78:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
  79:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   /**
  80:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @brief A standard container for storing a fixed size sequence of elements.
  81:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  82:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @ingroup sequences
  83:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  84:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  Meets the requirements of a <a href="tables.html#65">container</a>, a
  85:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  <a href="tables.html#66">reversible container</a>, and a
  86:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  <a href="tables.html#67">sequence</a>.
  87:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  88:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  Sets support random access iterators.
  89:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *
  90:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @tparam  Tp  Type of element. Required to be a complete type.
  91:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****    *  @tparam  Nm  Number of elements.
  92:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   */
ARM GAS  /tmp/ccawPiBL.s 			page 244


  93:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****   template<typename _Tp, std::size_t _Nm>
  94:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     struct array
  95:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****     {
  96:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef _Tp 	    			      value_type;
  97:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef value_type*			      pointer;
  98:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef const value_type*                       const_pointer;
  99:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef value_type&                   	      reference;
 100:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef const value_type&             	      const_reference;
 101:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef value_type*          		      iterator;
 102:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef const value_type*			      const_iterator;
 103:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::size_t                    	      size_type;
 104:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::ptrdiff_t                   	      difference_type;
 105:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::reverse_iterator<iterator>	      reverse_iterator;
 106:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef std::reverse_iterator<const_iterator>   const_reverse_iterator;
 107:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 108:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Support for zero-sized arrays mandatory.
 109:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typedef _GLIBCXX_STD_C::__array_traits<_Tp, _Nm> _AT_Type;
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       typename _AT_Type::_Type                         _M_elems;
 111:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 112:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // No explicit construct/copy/destroy for aggregate type.
 113:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 114:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // DR 776.
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX20_CONSTEXPR void
 116:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       fill(const value_type& __u)
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { std::fill_n(begin(), size(), __u); }
 118:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 119:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX20_CONSTEXPR void
 120:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       swap(array& __other)
 121:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       noexcept(_AT_Type::_Is_nothrow_swappable::value)
 122:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { std::swap_ranges(begin(), end(), __other.begin()); }
 123:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 124:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Iterators.
 125:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR iterator
 126:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       begin() noexcept
 127:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return iterator(data()); }
 128:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 129:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 130:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       begin() const noexcept
 131:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data()); }
 132:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 133:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR iterator
 134:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       end() noexcept
 135:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return iterator(data() + _Nm); }
 136:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 137:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 138:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       end() const noexcept
 139:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data() + _Nm); }
 140:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 141:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reverse_iterator
 142:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rbegin() noexcept
 143:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return reverse_iterator(end()); }
 144:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 145:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 146:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rbegin() const noexcept
 147:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(end()); }
 148:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 149:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reverse_iterator
ARM GAS  /tmp/ccawPiBL.s 			page 245


 150:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rend() noexcept
 151:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return reverse_iterator(begin()); }
 152:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 153:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 154:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       rend() const noexcept
 155:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(begin()); }
 156:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 157:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 158:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       cbegin() const noexcept
 159:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data()); }
 160:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 161:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_iterator
 162:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       cend() const noexcept
 163:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_iterator(data() + _Nm); }
 164:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 165:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 166:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       crbegin() const noexcept
 167:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(end()); }
 168:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 169:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR const_reverse_iterator
 170:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       crend() const noexcept
 171:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_reverse_iterator(begin()); }
 172:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 173:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Capacity.
 174:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       constexpr size_type
 175:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       size() const noexcept { return _Nm; }
 176:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 177:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       constexpr size_type
 178:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       max_size() const noexcept { return _Nm; }
 179:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 180:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX_NODISCARD constexpr bool
 181:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       empty() const noexcept { return size() == 0; }
 182:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array **** 
 183:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       // Element access.
 184:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       _GLIBCXX17_CONSTEXPR reference
 185:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       operator[](size_type __n) noexcept
 3665              		.loc 16 185 7 view .LVU948
 3666              	.LBB1518:
 3667              	.LBI1518:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3668              		.loc 16 55 7 view .LVU949
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3669              		.loc 16 55 7 is_stmt 0 view .LVU950
 3670              	.LBE1518:
 3671              	.LBE1517:
 225:MotorControl/controller.cpp ****                 std::optional<float> other_vel = axes[config_.axis_to_mirror].encoder_.vel_estimate
 3672              		.loc 3 225 79 view .LVU951
 3673 03b8 674A     		ldr	r2, .L268
 3674 03ba 4FF42C71 		mov	r1, #688
 3675 03be 01FB0323 		mla	r3, r1, r3, r2
 3676 03c2 D3F8AC30 		ldr	r3, [r3, #172]
 225:MotorControl/controller.cpp ****                 std::optional<float> other_vel = axes[config_.axis_to_mirror].encoder_.vel_estimate
 3677              		.loc 3 225 110 view .LVU952
 3678 03c6 03F1D002 		add	r2, r3, #208
 3679              	.LVL279:
 3680              	.LBB1519:
 3681              	.LBI1519:
ARM GAS  /tmp/ccawPiBL.s 			page 246


  73:./MotorControl/component.hpp ****         if (age_ == 0) {
 3682              		.loc 12 73 22 is_stmt 1 view .LVU953
 3683              	.LBB1520:
  74:./MotorControl/component.hpp ****             return content_;
 3684              		.loc 12 74 13 is_stmt 0 view .LVU954
 3685 03ca D3F8D030 		ldr	r3, [r3, #208]
  74:./MotorControl/component.hpp ****             return content_;
 3686              		.loc 12 74 9 view .LVU955
 3687 03ce 002B     		cmp	r3, #0
 3688 03d0 57D0     		beq	.L252
 3689              	.LVL280:
 3690              	.LBB1521:
 3691              	.LBI1521:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3692              		.loc 13 692 17 is_stmt 1 view .LVU956
 3693              	.LBB1522:
 3694              	.LBB1523:
 3695              	.LBI1523:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3696              		.loc 13 602 17 view .LVU957
 3697              	.LBB1524:
 3698              	.LBI1524:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 3699              		.loc 13 302 7 view .LVU958
 3700              	.LBB1525:
 3701              	.LBI1525:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 3702              		.loc 13 110 7 view .LVU959
 3703              	.LBB1526:
 3704              	.LBB1527:
 3705              	.LBI1527:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3706              		.loc 13 199 14 view .LVU960
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3707              		.loc 13 199 14 is_stmt 0 view .LVU961
 3708              	.LBE1527:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 3709              		.loc 13 110 7 view .LVU962
 3710 03d2 0023     		movs	r3, #0
 3711 03d4 8DF80830 		strb	r3, [sp, #8]
 3712              	.LVL281:
 3713              	.L156:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 3714              		.loc 13 110 7 view .LVU963
 3715              	.LBE1526:
 3716              	.LBE1525:
 3717              	.LBE1524:
 3718              	.LBE1523:
 3719              	.LBE1522:
 3720              	.LBE1521:
 3721              	.LBE1520:
 3722              	.LBE1519:
 226:MotorControl/controller.cpp ****                 std::optional<float> other_torque = axes[config_.axis_to_mirror].controller_.torque
 3723              		.loc 3 226 17 is_stmt 1 view .LVU964
 226:MotorControl/controller.cpp ****                 std::optional<float> other_torque = axes[config_.axis_to_mirror].controller_.torque
 3724              		.loc 3 226 63 is_stmt 0 view .LVU965
 3725 03d8 04F54053 		add	r3, r4, #12288
ARM GAS  /tmp/ccawPiBL.s 			page 247


 3726 03dc 93F8B428 		ldrb	r2, [r3, #2228]	@ zero_extendqisi2
 3727              	.LVL282:
 3728              	.LBB1548:
 3729              	.LBI1548:
 3730              		.loc 16 185 7 is_stmt 1 view .LVU966
 3731              	.LBB1549:
 3732              	.LBI1549:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3733              		.loc 16 55 7 view .LVU967
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3734              		.loc 16 55 7 is_stmt 0 view .LVU968
 3735              	.LBE1549:
 3736              	.LBE1548:
 226:MotorControl/controller.cpp ****                 std::optional<float> other_torque = axes[config_.axis_to_mirror].controller_.torque
 3737              		.loc 3 226 79 view .LVU969
 3738 03e0 5D4B     		ldr	r3, .L268
 3739 03e2 4FF42C71 		mov	r1, #688
 3740 03e6 01FB0233 		mla	r3, r1, r2, r3
 3741 03ea D3F8AC30 		ldr	r3, [r3, #172]
 226:MotorControl/controller.cpp ****                 std::optional<float> other_torque = axes[config_.axis_to_mirror].controller_.torque
 3742              		.loc 3 226 110 view .LVU970
 3743 03ee 03F1D802 		add	r2, r3, #216
 3744              	.LVL283:
 3745              	.LBB1550:
 3746              	.LBI1550:
  73:./MotorControl/component.hpp ****         if (age_ == 0) {
 3747              		.loc 12 73 22 is_stmt 1 view .LVU971
 3748              	.LBB1551:
  74:./MotorControl/component.hpp ****             return content_;
 3749              		.loc 12 74 13 is_stmt 0 view .LVU972
 3750 03f2 D3F8D830 		ldr	r3, [r3, #216]
  74:./MotorControl/component.hpp ****             return content_;
 3751              		.loc 12 74 9 view .LVU973
 3752 03f6 002B     		cmp	r3, #0
 3753 03f8 49D0     		beq	.L253
 3754              	.LVL284:
 3755              	.LBB1552:
 3756              	.LBI1552:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3757              		.loc 13 692 17 is_stmt 1 view .LVU974
 3758              	.LBB1553:
 3759              	.LBB1554:
 3760              	.LBI1554:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3761              		.loc 13 602 17 view .LVU975
 3762              	.LBB1555:
 3763              	.LBI1555:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 3764              		.loc 13 302 7 view .LVU976
 3765              	.LBB1556:
 3766              	.LBI1556:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 3767              		.loc 13 110 7 view .LVU977
 3768              	.LBB1557:
 3769              	.LBB1558:
 3770              	.LBI1558:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
ARM GAS  /tmp/ccawPiBL.s 			page 248


 3771              		.loc 13 199 14 view .LVU978
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3772              		.loc 13 199 14 is_stmt 0 view .LVU979
 3773              	.LBE1558:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 3774              		.loc 13 110 7 view .LVU980
 3775 03fa 0023     		movs	r3, #0
 3776 03fc 8DF81030 		strb	r3, [sp, #16]
 3777              	.LVL285:
 3778              	.L158:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 3779              		.loc 13 110 7 view .LVU981
 3780              	.LBE1557:
 3781              	.LBE1556:
 3782              	.LBE1555:
 3783              	.LBE1554:
 3784              	.LBE1553:
 3785              	.LBE1552:
 3786              	.LBE1551:
 3787              	.LBE1550:
 227:MotorControl/controller.cpp **** 
 3788              		.loc 3 227 17 is_stmt 1 view .LVU982
 227:MotorControl/controller.cpp **** 
 3789              		.loc 3 227 66 is_stmt 0 view .LVU983
 3790 0400 04F54053 		add	r3, r4, #12288
 3791 0404 93F8B428 		ldrb	r2, [r3, #2228]	@ zero_extendqisi2
 3792              	.LVL286:
 3793              	.LBB1579:
 3794              	.LBI1579:
 3795              		.loc 16 185 7 is_stmt 1 view .LVU984
 3796              	.LBB1580:
 3797              	.LBI1580:
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3798              		.loc 16 55 7 view .LVU985
  55:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/array ****       { return const_cast<_Tp&>(__t[__n]); }
 3799              		.loc 16 55 7 is_stmt 0 view .LVU986
 3800              	.LBE1580:
 3801              	.LBE1579:
 227:MotorControl/controller.cpp **** 
 3802              		.loc 3 227 82 view .LVU987
 3803 0408 534B     		ldr	r3, .L268
 3804 040a 4FF42C71 		mov	r1, #688
 3805 040e 01FB0233 		mla	r3, r1, r2, r3
 3806 0412 D3F80021 		ldr	r2, [r3, #256]
 227:MotorControl/controller.cpp **** 
 3807              		.loc 3 227 117 view .LVU988
 3808 0416 43F64813 		movw	r3, #14664
 3809 041a D118     		adds	r1, r2, r3
 3810              	.LVL287:
 3811              	.LBB1581:
 3812              	.LBI1581:
  73:./MotorControl/component.hpp ****         if (age_ == 0) {
 3813              		.loc 12 73 22 is_stmt 1 view .LVU989
 3814              	.LBB1582:
  74:./MotorControl/component.hpp ****             return content_;
 3815              		.loc 12 74 13 is_stmt 0 view .LVU990
 3816 041c D358     		ldr	r3, [r2, r3]
ARM GAS  /tmp/ccawPiBL.s 			page 249


  74:./MotorControl/component.hpp ****             return content_;
 3817              		.loc 12 74 9 view .LVU991
 3818 041e 002B     		cmp	r3, #0
 3819 0420 3BD0     		beq	.L254
 3820              	.LVL288:
 3821              	.LBB1583:
 3822              	.LBI1583:
 692:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3823              		.loc 13 692 17 is_stmt 1 view .LVU992
 3824              	.LBB1584:
 3825              	.LBB1585:
 3826              	.LBI1585:
 602:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3827              		.loc 13 602 17 view .LVU993
 3828              	.LBB1586:
 3829              	.LBI1586:
 302:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****     };
 3830              		.loc 13 302 7 view .LVU994
 3831              	.LBB1587:
 3832              	.LBI1587:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 3833              		.loc 13 110 7 view .LVU995
 3834              	.LBB1588:
 3835              	.LBB1589:
 3836              	.LBI1589:
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3837              		.loc 13 199 14 view .LVU996
 199:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3838              		.loc 13 199 14 is_stmt 0 view .LVU997
 3839              	.LBE1589:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 3840              		.loc 13 110 7 view .LVU998
 3841 0422 0023     		movs	r3, #0
 3842 0424 8DF81830 		strb	r3, [sp, #24]
 3843              	.LVL289:
 3844              	.L160:
 110:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       ~_Optional_payload_base() = default;
 3845              		.loc 13 110 7 view .LVU999
 3846              	.LBE1588:
 3847              	.LBE1587:
 3848              	.LBE1586:
 3849              	.LBE1585:
 3850              	.LBE1584:
 3851              	.LBE1583:
 3852              	.LBE1582:
 3853              	.LBE1581:
 229:MotorControl/controller.cpp ****                     set_error(ERROR_INVALID_ESTIMATE);
 3854              		.loc 3 229 17 is_stmt 1 view .LVU1000
 3855              	.LBB1610:
 3856              	.LBI1610:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 3857              		.loc 13 916 22 view .LVU1001
 3858              	.LBB1611:
 3859              	.LBI1611:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 3860              		.loc 13 433 22 view .LVU1002
 3861              	.LBB1612:
ARM GAS  /tmp/ccawPiBL.s 			page 250


 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3862              		.loc 13 434 58 is_stmt 0 view .LVU1003
 3863 0428 9DF80830 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 3864              	.LVL290:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3865              		.loc 13 434 58 view .LVU1004
 3866              	.LBE1612:
 3867              	.LBE1611:
 3868              	.LBE1610:
 229:MotorControl/controller.cpp ****                     set_error(ERROR_INVALID_ESTIMATE);
 3869              		.loc 3 229 70 view .LVU1005
 3870 042c 002B     		cmp	r3, #0
 3871 042e 3AD0     		beq	.L161
 3872              	.LVL291:
 3873              	.LBB1613:
 3874              	.LBI1613:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 3875              		.loc 13 916 22 is_stmt 1 view .LVU1006
 3876              	.LBB1614:
 3877              	.LBI1614:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 3878              		.loc 13 433 22 view .LVU1007
 3879              	.LBB1615:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3880              		.loc 13 434 58 is_stmt 0 view .LVU1008
 3881 0430 9DF81030 		ldrb	r3, [sp, #16]	@ zero_extendqisi2
 3882              	.LVL292:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3883              		.loc 13 434 58 view .LVU1009
 3884              	.LBE1615:
 3885              	.LBE1614:
 3886              	.LBE1613:
 229:MotorControl/controller.cpp ****                     set_error(ERROR_INVALID_ESTIMATE);
 3887              		.loc 3 229 44 view .LVU1010
 3888 0434 BBB3     		cbz	r3, .L161
 3889              	.LVL293:
 3890              	.LBB1616:
 3891              	.LBI1616:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 3892              		.loc 13 916 22 is_stmt 1 view .LVU1011
 3893              	.LBB1617:
 3894              	.LBI1617:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 3895              		.loc 13 433 22 view .LVU1012
 3896              	.LBB1618:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3897              		.loc 13 434 58 is_stmt 0 view .LVU1013
 3898 0436 9DF81830 		ldrb	r3, [sp, #24]	@ zero_extendqisi2
 3899              	.LVL294:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3900              		.loc 13 434 58 view .LVU1014
 3901              	.LBE1618:
 3902              	.LBE1617:
 3903              	.LBE1616:
 229:MotorControl/controller.cpp ****                     set_error(ERROR_INVALID_ESTIMATE);
 3904              		.loc 3 229 70 view .LVU1015
 3905 043a A3B3     		cbz	r3, .L161
ARM GAS  /tmp/ccawPiBL.s 			page 251


 234:MotorControl/controller.cpp ****                 vel_setpoint_ = *other_vel * config_.mirror_ratio;
 3906              		.loc 3 234 17 is_stmt 1 view .LVU1016
 234:MotorControl/controller.cpp ****                 vel_setpoint_ = *other_vel * config_.mirror_ratio;
 3907              		.loc 3 234 54 is_stmt 0 view .LVU1017
 3908 043c 04F54053 		add	r3, r4, #12288
 3909 0440 03F6B802 		addw	r2, r3, #2232
 3910 0444 D2ED007A 		vldr.32	s15, [r2]
 234:MotorControl/controller.cpp ****                 vel_setpoint_ = *other_vel * config_.mirror_ratio;
 3911              		.loc 3 234 44 view .LVU1018
 3912 0448 9DED017A 		vldr.32	s14, [sp, #4]
 3913 044c 27EE277A 		vmul.f32	s14, s14, s15
 234:MotorControl/controller.cpp ****                 vel_setpoint_ = *other_vel * config_.mirror_ratio;
 3914              		.loc 3 234 31 view .LVU1019
 3915 0450 03F60412 		addw	r2, r3, #2308
 3916 0454 82ED007A 		vstr.32	s14, [r2]
 235:MotorControl/controller.cpp ****                 torque_setpoint_ = *other_torque * config_.torque_mirror_ratio;
 3917              		.loc 3 235 17 is_stmt 1 view .LVU1020
 235:MotorControl/controller.cpp ****                 torque_setpoint_ = *other_torque * config_.torque_mirror_ratio;
 3918              		.loc 3 235 33 is_stmt 0 view .LVU1021
 3919 0458 9DED037A 		vldr.32	s14, [sp, #12]
 235:MotorControl/controller.cpp ****                 torque_setpoint_ = *other_torque * config_.torque_mirror_ratio;
 3920              		.loc 3 235 44 view .LVU1022
 3921 045c 67EE877A 		vmul.f32	s15, s15, s14
 235:MotorControl/controller.cpp ****                 torque_setpoint_ = *other_torque * config_.torque_mirror_ratio;
 3922              		.loc 3 235 31 view .LVU1023
 3923 0460 03F60812 		addw	r2, r3, #2312
 3924 0464 C2ED007A 		vstr.32	s15, [r2]
 236:MotorControl/controller.cpp ****             } else {
 3925              		.loc 3 236 17 is_stmt 1 view .LVU1024
 236:MotorControl/controller.cpp ****             } else {
 3926              		.loc 3 236 60 is_stmt 0 view .LVU1025
 3927 0468 03F6BC02 		addw	r2, r3, #2236
 3928 046c 92ED007A 		vldr.32	s14, [r2]
 236:MotorControl/controller.cpp ****             } else {
 3929              		.loc 3 236 50 view .LVU1026
 3930 0470 DDED057A 		vldr.32	s15, [sp, #20]
 3931 0474 67EE877A 		vmul.f32	s15, s15, s14
 236:MotorControl/controller.cpp ****             } else {
 3932              		.loc 3 236 34 view .LVU1027
 3933 0478 03F51163 		add	r3, r3, #2320
 3934 047c C3ED007A 		vstr.32	s15, [r3]
 3935              	.LBE1516:
 3936 0480 A8E6     		b	.L147
 3937              	.LVL295:
 3938              	.L252:
 3939              	.LBB1622:
 3940              	.LBB1619:
 3941              	.LBB1547:
 3942              	.LBB1528:
 3943              	.LBI1528:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 3944              		.loc 13 700 2 is_stmt 1 view .LVU1028
 3945              	.LBB1529:
 3946              	.LBB1530:
 3947              	.LBB1531:
 3948              	.LBI1531:
 3949              		.loc 14 76 5 view .LVU1029
ARM GAS  /tmp/ccawPiBL.s 			page 252


 3950              		.loc 14 76 5 is_stmt 0 view .LVU1030
 3951              	.LBE1531:
 3952              	.LBB1532:
 3953              	.LBI1532:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 3954              		.loc 13 607 28 is_stmt 1 view .LVU1031
 3955              	.LBB1533:
 3956              	.LBB1534:
 3957              	.LBB1535:
 3958              	.LBI1535:
 3959              		.loc 14 76 5 view .LVU1032
 3960              		.loc 14 76 5 is_stmt 0 view .LVU1033
 3961              	.LBE1535:
 3962              	.LBB1536:
 3963              	.LBI1536:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 3964              		.loc 13 300 42 is_stmt 1 view .LVU1034
 3965              	.LBB1537:
 3966              	.LBB1538:
 3967              	.LBB1539:
 3968              	.LBI1539:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 3969              		.loc 13 115 2 view .LVU1035
 3970              	.LBB1540:
 3971              	.LBB1541:
 3972              	.LBB1542:
 3973              	.LBI1542:
 3974              		.loc 14 76 5 view .LVU1036
 3975              		.loc 14 76 5 is_stmt 0 view .LVU1037
 3976              	.LBE1542:
 3977              	.LBB1543:
 3978              	.LBI1543:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 3979              		.loc 13 203 6 is_stmt 1 view .LVU1038
 3980              	.LBB1544:
 3981              	.LBB1545:
 3982              	.LBB1546:
 3983              	.LBI1546:
 3984              		.loc 14 76 5 view .LVU1039
 3985              		.loc 14 76 5 is_stmt 0 view .LVU1040
 3986              	.LBE1546:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 3987              		.loc 13 204 47 view .LVU1041
 3988 0482 5368     		ldr	r3, [r2, #4]	@ float
 3989 0484 0193     		str	r3, [sp, #4]	@ float
 3990              	.LVL296:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 3991              		.loc 13 204 47 view .LVU1042
 3992              	.LBE1545:
 3993              	.LBE1544:
 3994              	.LBE1543:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 3995              		.loc 13 117 19 view .LVU1043
 3996 0486 0123     		movs	r3, #1
 3997 0488 8DF80830 		strb	r3, [sp, #8]
 3998              	.LVL297:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
ARM GAS  /tmp/ccawPiBL.s 			page 253


 3999              		.loc 13 117 19 view .LVU1044
 4000              	.LBE1541:
 4001              	.LBE1540:
 4002              	.LBE1539:
 4003              	.LBE1538:
 4004              	.LBE1537:
 4005              	.LBE1536:
 4006              	.LBE1534:
 4007              	.LBE1533:
 4008              	.LBE1532:
 4009              	.LBE1530:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4010              		.loc 13 701 51 view .LVU1045
 4011 048c A4E7     		b	.L156
 4012              	.LVL298:
 4013              	.L253:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4014              		.loc 13 701 51 view .LVU1046
 4015              	.LBE1529:
 4016              	.LBE1528:
 4017              	.LBE1547:
 4018              	.LBE1619:
 4019              	.LBB1620:
 4020              	.LBB1578:
 4021              	.LBB1559:
 4022              	.LBI1559:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 4023              		.loc 13 700 2 is_stmt 1 view .LVU1047
 4024              	.LBB1560:
 4025              	.LBB1561:
 4026              	.LBB1562:
 4027              	.LBI1562:
 4028              		.loc 14 76 5 view .LVU1048
 4029              		.loc 14 76 5 is_stmt 0 view .LVU1049
 4030              	.LBE1562:
 4031              	.LBB1563:
 4032              	.LBI1563:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 4033              		.loc 13 607 28 is_stmt 1 view .LVU1050
 4034              	.LBB1564:
 4035              	.LBB1565:
 4036              	.LBB1566:
 4037              	.LBI1566:
 4038              		.loc 14 76 5 view .LVU1051
 4039              		.loc 14 76 5 is_stmt 0 view .LVU1052
 4040              	.LBE1566:
 4041              	.LBB1567:
 4042              	.LBI1567:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4043              		.loc 13 300 42 is_stmt 1 view .LVU1053
 4044              	.LBB1568:
 4045              	.LBB1569:
 4046              	.LBB1570:
 4047              	.LBI1570:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 4048              		.loc 13 115 2 view .LVU1054
 4049              	.LBB1571:
ARM GAS  /tmp/ccawPiBL.s 			page 254


 4050              	.LBB1572:
 4051              	.LBB1573:
 4052              	.LBI1573:
 4053              		.loc 14 76 5 view .LVU1055
 4054              		.loc 14 76 5 is_stmt 0 view .LVU1056
 4055              	.LBE1573:
 4056              	.LBB1574:
 4057              	.LBI1574:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 4058              		.loc 13 203 6 is_stmt 1 view .LVU1057
 4059              	.LBB1575:
 4060              	.LBB1576:
 4061              	.LBB1577:
 4062              	.LBI1577:
 4063              		.loc 14 76 5 view .LVU1058
 4064              		.loc 14 76 5 is_stmt 0 view .LVU1059
 4065              	.LBE1577:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 4066              		.loc 13 204 47 view .LVU1060
 4067 048e 5368     		ldr	r3, [r2, #4]	@ float
 4068 0490 0393     		str	r3, [sp, #12]	@ float
 4069              	.LVL299:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 4070              		.loc 13 204 47 view .LVU1061
 4071              	.LBE1576:
 4072              	.LBE1575:
 4073              	.LBE1574:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 4074              		.loc 13 117 19 view .LVU1062
 4075 0492 0123     		movs	r3, #1
 4076 0494 8DF81030 		strb	r3, [sp, #16]
 4077              	.LVL300:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 4078              		.loc 13 117 19 view .LVU1063
 4079              	.LBE1572:
 4080              	.LBE1571:
 4081              	.LBE1570:
 4082              	.LBE1569:
 4083              	.LBE1568:
 4084              	.LBE1567:
 4085              	.LBE1565:
 4086              	.LBE1564:
 4087              	.LBE1563:
 4088              	.LBE1561:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4089              		.loc 13 701 51 view .LVU1064
 4090 0498 B2E7     		b	.L158
 4091              	.LVL301:
 4092              	.L254:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4093              		.loc 13 701 51 view .LVU1065
 4094              	.LBE1560:
 4095              	.LBE1559:
 4096              	.LBE1578:
 4097              	.LBE1620:
 4098              	.LBB1621:
 4099              	.LBB1609:
ARM GAS  /tmp/ccawPiBL.s 			page 255


 4100              	.LBB1590:
 4101              	.LBI1590:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 4102              		.loc 13 700 2 is_stmt 1 view .LVU1066
 4103              	.LBB1591:
 4104              	.LBB1592:
 4105              	.LBB1593:
 4106              	.LBI1593:
 4107              		.loc 14 76 5 view .LVU1067
 4108              		.loc 14 76 5 is_stmt 0 view .LVU1068
 4109              	.LBE1593:
 4110              	.LBB1594:
 4111              	.LBI1594:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 4112              		.loc 13 607 28 is_stmt 1 view .LVU1069
 4113              	.LBB1595:
 4114              	.LBB1596:
 4115              	.LBB1597:
 4116              	.LBI1597:
 4117              		.loc 14 76 5 view .LVU1070
 4118              		.loc 14 76 5 is_stmt 0 view .LVU1071
 4119              	.LBE1597:
 4120              	.LBB1598:
 4121              	.LBI1598:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4122              		.loc 13 300 42 is_stmt 1 view .LVU1072
 4123              	.LBB1599:
 4124              	.LBB1600:
 4125              	.LBB1601:
 4126              	.LBI1601:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 4127              		.loc 13 115 2 view .LVU1073
 4128              	.LBB1602:
 4129              	.LBB1603:
 4130              	.LBB1604:
 4131              	.LBI1604:
 4132              		.loc 14 76 5 view .LVU1074
 4133              		.loc 14 76 5 is_stmt 0 view .LVU1075
 4134              	.LBE1604:
 4135              	.LBB1605:
 4136              	.LBI1605:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 4137              		.loc 13 203 6 is_stmt 1 view .LVU1076
 4138              	.LBB1606:
 4139              	.LBB1607:
 4140              	.LBB1608:
 4141              	.LBI1608:
 4142              		.loc 14 76 5 view .LVU1077
 4143              		.loc 14 76 5 is_stmt 0 view .LVU1078
 4144              	.LBE1608:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 4145              		.loc 13 204 47 view .LVU1079
 4146 049a 4B68     		ldr	r3, [r1, #4]	@ float
 4147 049c 0593     		str	r3, [sp, #20]	@ float
 4148              	.LVL302:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 4149              		.loc 13 204 47 view .LVU1080
ARM GAS  /tmp/ccawPiBL.s 			page 256


 4150              	.LBE1607:
 4151              	.LBE1606:
 4152              	.LBE1605:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 4153              		.loc 13 117 19 view .LVU1081
 4154 049e 0123     		movs	r3, #1
 4155 04a0 8DF81830 		strb	r3, [sp, #24]
 4156              	.LVL303:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 4157              		.loc 13 117 19 view .LVU1082
 4158              	.LBE1603:
 4159              	.LBE1602:
 4160              	.LBE1601:
 4161              	.LBE1600:
 4162              	.LBE1599:
 4163              	.LBE1598:
 4164              	.LBE1596:
 4165              	.LBE1595:
 4166              	.LBE1594:
 4167              	.LBE1592:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4168              		.loc 13 701 51 view .LVU1083
 4169 04a4 C0E7     		b	.L160
 4170              	.LVL304:
 4171              	.L161:
 701:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4172              		.loc 13 701 51 view .LVU1084
 4173              	.LBE1591:
 4174              	.LBE1590:
 4175              	.LBE1609:
 4176              	.LBE1621:
 230:MotorControl/controller.cpp ****                     return false;
 4177              		.loc 3 230 21 is_stmt 1 discriminator 5 view .LVU1085
 230:MotorControl/controller.cpp ****                     return false;
 4178              		.loc 3 230 30 is_stmt 0 discriminator 5 view .LVU1086
 4179 04a6 2021     		movs	r1, #32
 4180 04a8 2046     		mov	r0, r4
 4181 04aa FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 4182              	.LVL305:
 231:MotorControl/controller.cpp ****                 }
 4183              		.loc 3 231 21 is_stmt 1 discriminator 5 view .LVU1087
 231:MotorControl/controller.cpp ****                 }
 4184              		.loc 3 231 28 is_stmt 0 discriminator 5 view .LVU1088
 4185 04ae 0025     		movs	r5, #0
 4186 04b0 3AE6     		b	.L130
 4187              	.L154:
 231:MotorControl/controller.cpp ****                 }
 4188              		.loc 3 231 28 discriminator 5 view .LVU1089
 4189              	.LBE1622:
 238:MotorControl/controller.cpp ****                 return false;
 4190              		.loc 3 238 17 is_stmt 1 view .LVU1090
 238:MotorControl/controller.cpp ****                 return false;
 4191              		.loc 3 238 26 is_stmt 0 view .LVU1091
 4192 04b2 0821     		movs	r1, #8
 4193 04b4 2046     		mov	r0, r4
 4194 04b6 FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 4195              	.LVL306:
ARM GAS  /tmp/ccawPiBL.s 			page 257


 239:MotorControl/controller.cpp ****             }
 4196              		.loc 3 239 17 is_stmt 1 view .LVU1092
 239:MotorControl/controller.cpp ****             }
 4197              		.loc 3 239 24 is_stmt 0 view .LVU1093
 4198 04ba 0025     		movs	r5, #0
 4199 04bc 34E6     		b	.L130
 4200              	.L143:
 239:MotorControl/controller.cpp ****             }
 4201              		.loc 3 239 24 view .LVU1094
 4202              	.LBE1515:
 245:MotorControl/controller.cpp ****             if(input_pos_updated_){
 4203              		.loc 3 245 9 is_stmt 1 view .LVU1095
 245:MotorControl/controller.cpp ****             if(input_pos_updated_){
 4204              		.loc 3 245 36 view .LVU1096
 4205              	.LBB1623:
 246:MotorControl/controller.cpp ****                 move_to_pos(input_pos_);
 4206              		.loc 3 246 13 view .LVU1097
 246:MotorControl/controller.cpp ****                 move_to_pos(input_pos_);
 4207              		.loc 3 246 16 is_stmt 0 view .LVU1098
 4208 04be 04F54053 		add	r3, r4, #12288
 4209 04c2 93F83C39 		ldrb	r3, [r3, #2364]	@ zero_extendqisi2
 246:MotorControl/controller.cpp ****                 move_to_pos(input_pos_);
 4210              		.loc 3 246 13 view .LVU1099
 4211 04c6 002B     		cmp	r3, #0
 4212 04c8 38D1     		bne	.L255
 4213              	.L162:
 251:MotorControl/controller.cpp ****                 break;
 4214              		.loc 3 251 13 is_stmt 1 view .LVU1100
 251:MotorControl/controller.cpp ****                 break;
 4215              		.loc 3 251 17 is_stmt 0 view .LVU1101
 4216 04ca 04F54053 		add	r3, r4, #12288
 4217 04ce 93F83D39 		ldrb	r3, [r3, #2365]	@ zero_extendqisi2
 251:MotorControl/controller.cpp ****                 break;
 4218              		.loc 3 251 13 view .LVU1102
 4219 04d2 002B     		cmp	r3, #0
 4220 04d4 7FF47EAE 		bne	.L147
 254:MotorControl/controller.cpp ****                 // Drop into position control mode when done to avoid problems on loop counter delt
 4221              		.loc 3 254 13 is_stmt 1 view .LVU1103
 4222              	.LBB1624:
 254:MotorControl/controller.cpp ****                 // Drop into position control mode when done to avoid problems on loop counter delt
 4223              		.loc 3 254 17 is_stmt 0 view .LVU1104
 4224 04d8 04F54053 		add	r3, r4, #12288
 4225 04dc D3F8D838 		ldr	r3, [r3, #2264]
 254:MotorControl/controller.cpp ****                 // Drop into position control mode when done to avoid problems on loop counter delt
 4226              		.loc 3 254 24 view .LVU1105
 4227 04e0 D3F85C01 		ldr	r0, [r3, #348]
 254:MotorControl/controller.cpp ****                 // Drop into position control mode when done to avoid problems on loop counter delt
 4228              		.loc 3 254 35 view .LVU1106
 4229 04e4 90ED0F0A 		vldr.32	s0, [r0, #60]
 254:MotorControl/controller.cpp ****                 // Drop into position control mode when done to avoid problems on loop counter delt
 4230              		.loc 3 254 58 view .LVU1107
 4231 04e8 D0ED0D7A 		vldr.32	s15, [r0, #52]
 254:MotorControl/controller.cpp ****                 // Drop into position control mode when done to avoid problems on loop counter delt
 4232              		.loc 3 254 13 view .LVU1108
 4233 04ec B4EEE70A 		vcmpe.f32	s0, s15
 4234 04f0 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 4235 04f4 38DD     		ble	.L242
ARM GAS  /tmp/ccawPiBL.s 			page 258


 256:MotorControl/controller.cpp ****                 pos_setpoint_ = axis_->trap_traj_.Xf_;
 4236              		.loc 3 256 17 is_stmt 1 view .LVU1109
 256:MotorControl/controller.cpp ****                 pos_setpoint_ = axis_->trap_traj_.Xf_;
 4237              		.loc 3 256 38 is_stmt 0 view .LVU1110
 4238 04f6 0322     		movs	r2, #3
 4239 04f8 2276     		strb	r2, [r4, #24]
 257:MotorControl/controller.cpp ****                 vel_setpoint_ = 0.0f;
 4240              		.loc 3 257 17 is_stmt 1 view .LVU1111
 257:MotorControl/controller.cpp ****                 vel_setpoint_ = 0.0f;
 4241              		.loc 3 257 40 is_stmt 0 view .LVU1112
 4242 04fa D3F85C31 		ldr	r3, [r3, #348]
 257:MotorControl/controller.cpp ****                 vel_setpoint_ = 0.0f;
 4243              		.loc 3 257 51 view .LVU1113
 4244 04fe 5969     		ldr	r1, [r3, #20]	@ float
 257:MotorControl/controller.cpp ****                 vel_setpoint_ = 0.0f;
 4245              		.loc 3 257 31 view .LVU1114
 4246 0500 04F54053 		add	r3, r4, #12288
 4247 0504 03F60412 		addw	r2, r3, #2308
 4248 0508 1160     		str	r1, [r2]	@ float
 258:MotorControl/controller.cpp ****                 torque_setpoint_ = 0.0f;
 4249              		.loc 3 258 17 is_stmt 1 view .LVU1115
 258:MotorControl/controller.cpp ****                 torque_setpoint_ = 0.0f;
 4250              		.loc 3 258 31 is_stmt 0 view .LVU1116
 4251 050a 03F60811 		addw	r1, r3, #2312
 4252 050e 0022     		movs	r2, #0
 4253 0510 0A60     		str	r2, [r1]	@ float
 259:MotorControl/controller.cpp ****                 trajectory_done_ = true;
 4254              		.loc 3 259 17 is_stmt 1 view .LVU1117
 259:MotorControl/controller.cpp ****                 trajectory_done_ = true;
 4255              		.loc 3 259 34 is_stmt 0 view .LVU1118
 4256 0512 03F51161 		add	r1, r3, #2320
 4257 0516 0A60     		str	r2, [r1]	@ float
 260:MotorControl/controller.cpp ****             } else {
 4258              		.loc 3 260 17 is_stmt 1 view .LVU1119
 260:MotorControl/controller.cpp ****             } else {
 4259              		.loc 3 260 34 is_stmt 0 view .LVU1120
 4260 0518 0122     		movs	r2, #1
 4261 051a 83F83D29 		strb	r2, [r3, #2365]
 4262              	.L165:
 4263              	.LBE1624:
 268:MotorControl/controller.cpp ****         } break;
 4264              		.loc 3 268 13 is_stmt 1 view .LVU1121
 268:MotorControl/controller.cpp ****         } break;
 4265              		.loc 3 268 40 is_stmt 0 view .LVU1122
 4266 051e 04F56453 		add	r3, r4, #14592
 4267 0522 0433     		adds	r3, r3, #4
 4268              	.LVL307:
 4269              	.LBB1626:
 4270              	.LBI1626:
 700:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _Base(std::in_place, std::forward<_Up>(__t)) { }
 4271              		.loc 13 700 2 is_stmt 1 view .LVU1123
 4272              	.LBB1627:
 4273              	.LBB1628:
 4274              	.LBB1629:
 4275              	.LBI1629:
 4276              		.loc 14 76 5 view .LVU1124
 4277              		.loc 14 76 5 is_stmt 0 view .LVU1125
ARM GAS  /tmp/ccawPiBL.s 			page 259


 4278              	.LBE1629:
 4279              	.LBB1630:
 4280              	.LBI1630:
 607:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****         : _M_payload(in_place,
 4281              		.loc 13 607 28 is_stmt 1 view .LVU1126
 4282              	.LBB1631:
 4283              	.LBB1632:
 4284              	.LBB1633:
 4285              	.LBI1633:
 4286              		.loc 14 76 5 view .LVU1127
 4287              		.loc 14 76 5 is_stmt 0 view .LVU1128
 4288              	.LBE1633:
 4289              	.LBB1634:
 4290              	.LBI1634:
 300:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4291              		.loc 13 300 42 is_stmt 1 view .LVU1129
 4292              	.LBB1635:
 4293              	.LBB1636:
 4294              	.LBB1637:
 4295              	.LBI1637:
 115:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	: _M_payload(__tag, std::forward<_Args>(__args)...),
 4296              		.loc 13 115 2 view .LVU1130
 4297              	.LBB1638:
 4298              	.LBB1639:
 4299              	.LBB1640:
 4300              	.LBI1640:
 4301              		.loc 14 76 5 view .LVU1131
 4302              		.loc 14 76 5 is_stmt 0 view .LVU1132
 4303              	.LBE1640:
 4304              	.LBB1641:
 4305              	.LBI1641:
 203:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    : _M_value(std::forward<_Args>(__args)...)
 4306              		.loc 13 203 6 is_stmt 1 view .LVU1133
 4307              	.LBB1642:
 4308              	.LBB1643:
 4309              	.LBB1644:
 4310              	.LBI1644:
 4311              		.loc 14 76 5 view .LVU1134
 4312              		.loc 14 76 5 is_stmt 0 view .LVU1135
 4313              	.LBE1644:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 4314              		.loc 13 204 47 view .LVU1136
 4315 0524 1B68     		ldr	r3, [r3]	@ float
 4316              	.LVL308:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 4317              		.loc 13 204 47 view .LVU1137
 4318 0526 1993     		str	r3, [sp, #100]	@ float
 4319              	.LVL309:
 204:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	    { }
 4320              		.loc 13 204 47 view .LVU1138
 4321              	.LBE1643:
 4322              	.LBE1642:
 4323              	.LBE1641:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 4324              		.loc 13 117 19 view .LVU1139
 4325 0528 0123     		movs	r3, #1
 4326 052a 8DF86830 		strb	r3, [sp, #104]
ARM GAS  /tmp/ccawPiBL.s 			page 260


 4327              	.LVL310:
 117:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 	{ }
 4328              		.loc 13 117 19 view .LVU1140
 4329              	.LBE1639:
 4330              	.LBE1638:
 4331              	.LBE1637:
 4332              	.LBE1636:
 4333              	.LBE1635:
 4334              	.LBE1634:
 4335              	.LBE1632:
 4336              	.LBE1631:
 4337              	.LBE1630:
 4338              	.LBE1628:
 4339              	.LBE1627:
 4340              	.LBE1626:
 268:MotorControl/controller.cpp ****         } break;
 4341              		.loc 3 268 38 view .LVU1141
 4342 052e 0DAB     		add	r3, sp, #52
 4343 0530 19AA     		add	r2, sp, #100
 4344 0532 92E80300 		ldm	r2, {r0, r1}
 4345 0536 83E80300 		stm	r3, {r0, r1}
 4346              	.LBE1623:
 269:MotorControl/controller.cpp ****         case INPUT_MODE_TUNING: {
 4347              		.loc 3 269 11 is_stmt 1 view .LVU1142
 4348 053a 4BE6     		b	.L147
 4349              	.L255:
 4350              	.LBB1646:
 247:MotorControl/controller.cpp ****                 input_pos_updated_ = false;
 4351              		.loc 3 247 17 view .LVU1143
 247:MotorControl/controller.cpp ****                 input_pos_updated_ = false;
 4352              		.loc 3 247 28 is_stmt 0 view .LVU1144
 4353 053c 04F54055 		add	r5, r4, #12288
 4354 0540 05F61413 		addw	r3, r5, #2324
 4355 0544 93ED000A 		vldr.32	s0, [r3]
 4356 0548 2046     		mov	r0, r4
 4357 054a FFF7FEFF 		bl	_ZN10Controller11move_to_posEf
 4358              	.LVL311:
 248:MotorControl/controller.cpp ****             }
 4359              		.loc 3 248 17 is_stmt 1 view .LVU1145
 248:MotorControl/controller.cpp ****             }
 4360              		.loc 3 248 36 is_stmt 0 view .LVU1146
 4361 054e 0023     		movs	r3, #0
 4362 0550 85F83C39 		strb	r3, [r5, #2364]
 4363 0554 B9E7     		b	.L162
 4364              	.L269:
 4365 0556 00BF     		.align	2
 4366              	.L268:
 4367 0558 00000000 		.word	axes
 4368 055c DB0FC940 		.word	1086918619
 4369 0560 6F120339 		.word	956502639
 4370 0564 B4A29139 		.word	965845684
 4371              	.L242:
 4372              	.LBB1645:
 4373              	.LBB1625:
 262:MotorControl/controller.cpp ****                 pos_setpoint_ = traj_step.Y;
 4374              		.loc 3 262 17 is_stmt 1 view .LVU1147
 262:MotorControl/controller.cpp ****                 pos_setpoint_ = traj_step.Y;
ARM GAS  /tmp/ccawPiBL.s 			page 261


 4375              		.loc 3 262 102 is_stmt 0 view .LVU1148
 4376 0568 FFF7FEFF 		bl	_ZN21TrapezoidalTrajectory4evalEf
 4377              	.LVL312:
 4378 056c 8DED050A 		vstr.32	s0, [sp, #20]
 4379 0570 CDED060A 		vstr.32	s1, [sp, #24]
 4380 0574 8DED071A 		vstr.32	s2, [sp, #28]
 263:MotorControl/controller.cpp ****                 vel_setpoint_ = traj_step.Yd;
 4381              		.loc 3 263 17 is_stmt 1 view .LVU1149
 263:MotorControl/controller.cpp ****                 vel_setpoint_ = traj_step.Yd;
 4382              		.loc 3 263 31 is_stmt 0 view .LVU1150
 4383 0578 04F54053 		add	r3, r4, #12288
 4384 057c 03F60412 		addw	r2, r3, #2308
 4385 0580 82ED000A 		vstr.32	s0, [r2]
 264:MotorControl/controller.cpp ****                 torque_setpoint_ = traj_step.Ydd * config_.inertia;
 4386              		.loc 3 264 17 is_stmt 1 view .LVU1151
 264:MotorControl/controller.cpp ****                 torque_setpoint_ = traj_step.Ydd * config_.inertia;
 4387              		.loc 3 264 31 is_stmt 0 view .LVU1152
 4388 0584 03F60812 		addw	r2, r3, #2312
 4389 0588 C2ED000A 		vstr.32	s1, [r2]
 265:MotorControl/controller.cpp ****                 axis_->trap_traj_.t_ += current_meas_period;
 4390              		.loc 3 265 17 is_stmt 1 view .LVU1153
 265:MotorControl/controller.cpp ****                 axis_->trap_traj_.t_ += current_meas_period;
 4391              		.loc 3 265 60 is_stmt 0 view .LVU1154
 4392 058c D4ED127A 		vldr.32	s15, [r4, #72]
 265:MotorControl/controller.cpp ****                 axis_->trap_traj_.t_ += current_meas_period;
 4393              		.loc 3 265 50 view .LVU1155
 4394 0590 21EE271A 		vmul.f32	s2, s2, s15
 265:MotorControl/controller.cpp ****                 axis_->trap_traj_.t_ += current_meas_period;
 4395              		.loc 3 265 34 view .LVU1156
 4396 0594 03F51162 		add	r2, r3, #2320
 4397 0598 82ED001A 		vstr.32	s2, [r2]
 266:MotorControl/controller.cpp ****             }
 4398              		.loc 3 266 17 is_stmt 1 view .LVU1157
 4399 059c D3F8D838 		ldr	r3, [r3, #2264]
 266:MotorControl/controller.cpp ****             }
 4400              		.loc 3 266 24 is_stmt 0 view .LVU1158
 4401 05a0 D3F85C31 		ldr	r3, [r3, #348]
 266:MotorControl/controller.cpp ****             }
 4402              		.loc 3 266 38 view .LVU1159
 4403 05a4 D3ED0F7A 		vldr.32	s15, [r3, #60]
 4404 05a8 1FED137A 		vldr.32	s14, .L268+8
 4405 05ac 77EE877A 		vadd.f32	s15, s15, s14
 4406 05b0 C3ED0F7A 		vstr.32	s15, [r3, #60]
 4407 05b4 B3E7     		b	.L165
 4408              	.L139:
 266:MotorControl/controller.cpp ****             }
 4409              		.loc 3 266 38 view .LVU1160
 4410              	.LBE1625:
 4411              	.LBE1645:
 4412              	.LBE1646:
 270:MotorControl/controller.cpp ****             autotuning_phase_ = wrap_pm_pi(autotuning_phase_ + (2.0f * M_PI * autotuning_.frequency
 4413              		.loc 3 270 9 is_stmt 1 view .LVU1161
 270:MotorControl/controller.cpp ****             autotuning_phase_ = wrap_pm_pi(autotuning_phase_ + (2.0f * M_PI * autotuning_.frequency
 4414              		.loc 3 270 33 view .LVU1162
 4415              	.LBB1647:
 271:MotorControl/controller.cpp ****             float c = our_arm_cos_f32(autotuning_phase_);
 4416              		.loc 3 271 13 view .LVU1163
ARM GAS  /tmp/ccawPiBL.s 			page 262


 271:MotorControl/controller.cpp ****             float c = our_arm_cos_f32(autotuning_phase_);
 4417              		.loc 3 271 44 is_stmt 0 view .LVU1164
 4418 05b6 04F54055 		add	r5, r4, #12288
 4419 05ba 05F63816 		addw	r6, r5, #2360
 4420 05be 96ED000A 		vldr.32	s0, [r6]
 271:MotorControl/controller.cpp ****             float c = our_arm_cos_f32(autotuning_phase_);
 4421              		.loc 3 271 91 view .LVU1165
 4422 05c2 05F62813 		addw	r3, r5, #2344
 4423 05c6 93ED007A 		vldr.32	s14, [r3]
 271:MotorControl/controller.cpp ****             float c = our_arm_cos_f32(autotuning_phase_);
 4424              		.loc 3 271 77 view .LVU1166
 4425 05ca 5FED1C6A 		vldr.32	s13, .L268+4
 4426 05ce 27EE267A 		vmul.f32	s14, s14, s13
 271:MotorControl/controller.cpp ****             float c = our_arm_cos_f32(autotuning_phase_);
 4427              		.loc 3 271 101 view .LVU1167
 4428 05d2 5FED1D7A 		vldr.32	s15, .L268+8
 4429 05d6 27EE277A 		vmul.f32	s14, s14, s15
 271:MotorControl/controller.cpp ****             float c = our_arm_cos_f32(autotuning_phase_);
 4430              		.loc 3 271 43 view .LVU1168
 4431 05da 30EE070A 		vadd.f32	s0, s0, s14
 4432              	.LVL313:
 4433              	.LBB1648:
 4434              	.LBI1648:
 137:./MotorControl/utils.hpp **** }
 138:./MotorControl/utils.hpp **** 
 139:./MotorControl/utils.hpp **** inline float wrap_pm_pi(float x) {
 4435              		.loc 11 139 14 is_stmt 1 view .LVU1169
 4436              	.LBE1648:
 4437              	.LBE1647:
 4438              	.LBE1656:
 4439              	.LBE1664:
 140:./MotorControl/utils.hpp ****     return wrap_pm(x, 2 * M_PI);
 4440              		.loc 11 140 5 view .LVU1170
 4441              	.LBB1665:
 4442              	.LBB1657:
 4443              	.LBB1654:
 4444              	.LBB1653:
 4445              	.LBB1649:
 4446              	.LBI1649:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 4447              		.loc 11 123 14 view .LVU1171
 4448              	.LBB1650:
 125:./MotorControl/utils.hpp **** #else
 4449              		.loc 11 125 5 view .LVU1172
 125:./MotorControl/utils.hpp **** #else
 4450              		.loc 11 125 36 is_stmt 0 view .LVU1173
 4451 05de C0EE267A 		vdiv.f32	s15, s0, s13
 4452              	.LVL314:
 4453              	.LBB1651:
 4454              	.LBI1651:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 4455              		.loc 11 108 12 is_stmt 1 view .LVU1174
 4456              	.LBB1652:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 4457              		.loc 11 110 5 view .LVU1175
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 4458              		.loc 11 111 5 view .LVU1176
ARM GAS  /tmp/ccawPiBL.s 			page 263


 4459              		.syntax unified
 4460              	@ 111 "./MotorControl/utils.hpp" 1
 4461 05e2 FDEE677A 		vcvtr.s32.f32   s15, s15
 4462              	@ 0 "" 2
 4463              	.LVL315:
 114:./MotorControl/utils.hpp **** #else
 4464              		.loc 11 114 5 view .LVU1177
 114:./MotorControl/utils.hpp **** #else
 4465              		.loc 11 114 5 is_stmt 0 view .LVU1178
 4466              		.thumb
 4467              		.syntax unified
 4468              	.LBE1652:
 4469              	.LBE1651:
 125:./MotorControl/utils.hpp **** #else
 4470              		.loc 11 125 42 view .LVU1179
 4471 05e6 F8EEE77A 		vcvt.f32.s32	s15, s15
 4472              	.LVL316:
 129:./MotorControl/utils.hpp **** }
 4473              		.loc 11 129 5 is_stmt 1 view .LVU1180
 129:./MotorControl/utils.hpp **** }
 4474              		.loc 11 129 23 is_stmt 0 view .LVU1181
 4475 05ea 67EEA67A 		vmul.f32	s15, s15, s13
 4476              	.LVL317:
 129:./MotorControl/utils.hpp **** }
 4477              		.loc 11 129 25 view .LVU1182
 4478 05ee 30EE670A 		vsub.f32	s0, s0, s15
 4479              	.LVL318:
 129:./MotorControl/utils.hpp **** }
 4480              		.loc 11 129 25 view .LVU1183
 4481              	.LBE1650:
 4482              	.LBE1649:
 4483              	.LBE1653:
 271:MotorControl/controller.cpp ****             float c = our_arm_cos_f32(autotuning_phase_);
 4484              		.loc 3 271 31 view .LVU1184
 4485 05f2 86ED000A 		vstr.32	s0, [r6]
 272:MotorControl/controller.cpp ****             float s = our_arm_sin_f32(autotuning_phase_);
 4486              		.loc 3 272 13 is_stmt 1 view .LVU1185
 272:MotorControl/controller.cpp ****             float s = our_arm_sin_f32(autotuning_phase_);
 4487              		.loc 3 272 38 is_stmt 0 view .LVU1186
 4488 05f6 FFF7FEFF 		bl	our_arm_cos_f32
 4489              	.LVL319:
 4490 05fa B0EE408A 		vmov.f32	s16, s0
 4491              	.LVL320:
 273:MotorControl/controller.cpp ****             pos_setpoint_ = input_pos_ + autotuning_.pos_amplitude * s; // + pos_amp_c * c
 4492              		.loc 3 273 13 is_stmt 1 view .LVU1187
 273:MotorControl/controller.cpp ****             pos_setpoint_ = input_pos_ + autotuning_.pos_amplitude * s; // + pos_amp_c * c
 4493              		.loc 3 273 38 is_stmt 0 view .LVU1188
 4494 05fe 96ED000A 		vldr.32	s0, [r6]
 4495              	.LVL321:
 273:MotorControl/controller.cpp ****             pos_setpoint_ = input_pos_ + autotuning_.pos_amplitude * s; // + pos_amp_c * c
 4496              		.loc 3 273 38 view .LVU1189
 4497 0602 FFF7FEFF 		bl	our_arm_sin_f32
 4498              	.LVL322:
 274:MotorControl/controller.cpp ****             vel_setpoint_ = input_vel_ + autotuning_.vel_amplitude * c;
 4499              		.loc 3 274 13 is_stmt 1 view .LVU1190
 274:MotorControl/controller.cpp ****             vel_setpoint_ = input_vel_ + autotuning_.vel_amplitude * c;
 4500              		.loc 3 274 29 is_stmt 0 view .LVU1191
ARM GAS  /tmp/ccawPiBL.s 			page 264


 4501 0606 05F61413 		addw	r3, r5, #2324
 4502 060a D3ED007A 		vldr.32	s15, [r3]
 274:MotorControl/controller.cpp ****             vel_setpoint_ = input_vel_ + autotuning_.vel_amplitude * c;
 4503              		.loc 3 274 54 view .LVU1192
 4504 060e 05F62C13 		addw	r3, r5, #2348
 4505 0612 93ED007A 		vldr.32	s14, [r3]
 274:MotorControl/controller.cpp ****             vel_setpoint_ = input_vel_ + autotuning_.vel_amplitude * c;
 4506              		.loc 3 274 68 view .LVU1193
 4507 0616 27EE007A 		vmul.f32	s14, s14, s0
 274:MotorControl/controller.cpp ****             vel_setpoint_ = input_vel_ + autotuning_.vel_amplitude * c;
 4508              		.loc 3 274 40 view .LVU1194
 4509 061a 77EE877A 		vadd.f32	s15, s15, s14
 274:MotorControl/controller.cpp ****             vel_setpoint_ = input_vel_ + autotuning_.vel_amplitude * c;
 4510              		.loc 3 274 27 view .LVU1195
 4511 061e 05F60413 		addw	r3, r5, #2308
 4512 0622 C3ED007A 		vstr.32	s15, [r3]
 275:MotorControl/controller.cpp ****             torque_setpoint_ = input_torque_ + autotuning_.torque_amplitude * -s;
 4513              		.loc 3 275 13 is_stmt 1 view .LVU1196
 275:MotorControl/controller.cpp ****             torque_setpoint_ = input_torque_ + autotuning_.torque_amplitude * -s;
 4514              		.loc 3 275 29 is_stmt 0 view .LVU1197
 4515 0626 05F61813 		addw	r3, r5, #2328
 4516 062a D3ED007A 		vldr.32	s15, [r3]
 275:MotorControl/controller.cpp ****             torque_setpoint_ = input_torque_ + autotuning_.torque_amplitude * -s;
 4517              		.loc 3 275 54 view .LVU1198
 4518 062e 05F51363 		add	r3, r5, #2352
 4519 0632 93ED007A 		vldr.32	s14, [r3]
 275:MotorControl/controller.cpp ****             torque_setpoint_ = input_torque_ + autotuning_.torque_amplitude * -s;
 4520              		.loc 3 275 68 view .LVU1199
 4521 0636 27EE087A 		vmul.f32	s14, s14, s16
 275:MotorControl/controller.cpp ****             torque_setpoint_ = input_torque_ + autotuning_.torque_amplitude * -s;
 4522              		.loc 3 275 40 view .LVU1200
 4523 063a 77EE877A 		vadd.f32	s15, s15, s14
 275:MotorControl/controller.cpp ****             torque_setpoint_ = input_torque_ + autotuning_.torque_amplitude * -s;
 4524              		.loc 3 275 27 view .LVU1201
 4525 063e 05F60813 		addw	r3, r5, #2312
 4526 0642 C3ED007A 		vstr.32	s15, [r3]
 276:MotorControl/controller.cpp ****         } break;
 4527              		.loc 3 276 13 is_stmt 1 view .LVU1202
 276:MotorControl/controller.cpp ****         } break;
 4528              		.loc 3 276 32 is_stmt 0 view .LVU1203
 4529 0646 05F61C13 		addw	r3, r5, #2332
 4530 064a D3ED007A 		vldr.32	s15, [r3]
 276:MotorControl/controller.cpp ****         } break;
 4531              		.loc 3 276 60 view .LVU1204
 4532 064e 05F63413 		addw	r3, r5, #2356
 4533 0652 93ED007A 		vldr.32	s14, [r3]
 276:MotorControl/controller.cpp ****         } break;
 4534              		.loc 3 276 77 view .LVU1205
 4535 0656 20EE470A 		vnmul.f32	s0, s0, s14
 4536              	.LVL323:
 276:MotorControl/controller.cpp ****         } break;
 4537              		.loc 3 276 46 view .LVU1206
 4538 065a 37EE800A 		vadd.f32	s0, s15, s0
 276:MotorControl/controller.cpp ****         } break;
 4539              		.loc 3 276 30 view .LVU1207
 4540 065e 05F51165 		add	r5, r5, #2320
 4541 0662 85ED000A 		vstr.32	s0, [r5]
ARM GAS  /tmp/ccawPiBL.s 			page 265


 4542              	.LBE1654:
 277:MotorControl/controller.cpp ****         default: {
 4543              		.loc 3 277 11 is_stmt 1 view .LVU1208
 4544 0666 B5E5     		b	.L147
 4545              	.LVL324:
 4546              	.L138:
 278:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_INPUT_MODE);
 4547              		.loc 3 278 9 view .LVU1209
 278:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_INPUT_MODE);
 4548              		.loc 3 278 18 view .LVU1210
 279:MotorControl/controller.cpp ****             return false;
 4549              		.loc 3 279 13 view .LVU1211
 279:MotorControl/controller.cpp ****             return false;
 4550              		.loc 3 279 22 is_stmt 0 view .LVU1212
 4551 0668 0221     		movs	r1, #2
 4552 066a 2046     		mov	r0, r4
 4553 066c FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 4554              	.LVL325:
 280:MotorControl/controller.cpp ****         }
 4555              		.loc 3 280 13 is_stmt 1 view .LVU1213
 280:MotorControl/controller.cpp ****         }
 4556              		.loc 3 280 20 is_stmt 0 view .LVU1214
 4557 0670 0025     		movs	r5, #0
 4558 0672 59E5     		b	.L130
 4559              	.LVL326:
 4560              	.L214:
 280:MotorControl/controller.cpp ****         }
 4561              		.loc 3 280 20 view .LVU1215
 4562              	.LBE1657:
 4563              	.LBE1665:
 4564              	.LBB1666:
 4565              	.LBB1662:
 4566              		.loc 6 3683 29 view .LVU1216
 4567 0674 1BAB     		add	r3, sp, #108
 4568              	.LVL327:
 4569              	.L167:
 4570              		.loc 6 3683 29 view .LVU1217
 4571              	.LBE1662:
 4572              	.LBE1666:
 287:MotorControl/controller.cpp ****     }
 4573              		.loc 3 287 35 view .LVU1218
 4574 0676 1A68     		ldr	r2, [r3]	@ float
 287:MotorControl/controller.cpp ****     }
 4575              		.loc 3 287 23 view .LVU1219
 4576 0678 04F56453 		add	r3, r4, #14592
 4577 067c 9A60     		str	r2, [r3, #8]	@ float
 4578              	.L166:
 289:MotorControl/controller.cpp ****     torque_setpoint_ = std::clamp(torque_setpoint_, -Tlim, Tlim);
 4579              		.loc 3 289 5 is_stmt 1 view .LVU1220
 289:MotorControl/controller.cpp ****     torque_setpoint_ = std::clamp(torque_setpoint_, -Tlim, Tlim);
 4580              		.loc 3 289 24 is_stmt 0 view .LVU1221
 4581 067e 04F54055 		add	r5, r4, #12288
 4582 0682 D5F8D838 		ldr	r3, [r5, #2264]
 289:MotorControl/controller.cpp ****     torque_setpoint_ = std::clamp(torque_setpoint_, -Tlim, Tlim);
 4583              		.loc 3 289 58 view .LVU1222
 4584 0686 D3F85801 		ldr	r0, [r3, #344]
 4585 068a FFF7FEFF 		bl	_ZN5Motor20max_available_torqueEv
ARM GAS  /tmp/ccawPiBL.s 			page 266


 4586              	.LVL328:
 4587 068e B0EE408A 		vmov.f32	s16, s0
 289:MotorControl/controller.cpp ****     torque_setpoint_ = std::clamp(torque_setpoint_, -Tlim, Tlim);
 4588              		.loc 3 289 59 view .LVU1223
 4589 0692 8DED0A0A 		vstr.32	s0, [sp, #40]
 290:MotorControl/controller.cpp **** 
 4590              		.loc 3 290 5 is_stmt 1 view .LVU1224
 290:MotorControl/controller.cpp **** 
 4591              		.loc 3 290 35 is_stmt 0 view .LVU1225
 4592 0696 04F56453 		add	r3, r4, #14592
 4593 069a 1033     		adds	r3, r3, #16
 290:MotorControl/controller.cpp **** 
 4594              		.loc 3 290 53 view .LVU1226
 4595 069c F1EE408A 		vneg.f32	s17, s0
 4596 06a0 CDED1C8A 		vstr.32	s17, [sp, #112]
 4597              	.LVL329:
 4598              	.LBB1667:
 4599              	.LBI1667:
3680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 4600              		.loc 6 3680 5 is_stmt 1 view .LVU1227
 4601              	.LBB1668:
 4602              		.loc 6 3683 21 is_stmt 0 view .LVU1228
 4603 06a4 05F51165 		add	r5, r5, #2320
 4604 06a8 D5ED007A 		vldr.32	s15, [r5]
 4605              		.loc 6 3683 29 view .LVU1229
 4606 06ac F4EEE78A 		vcmpe.f32	s17, s15
 4607 06b0 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 4608 06b4 06DC     		bgt	.L215
 4609 06b6 F4EEC07A 		vcmpe.f32	s15, s0
 4610 06ba F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 4611 06be 02DD     		ble	.L169
 4612 06c0 0AAB     		add	r3, sp, #40
 4613              	.LVL330:
 4614              		.loc 6 3683 29 view .LVU1230
 4615 06c2 00E0     		b	.L169
 4616              	.LVL331:
 4617              	.L215:
 4618              		.loc 6 3683 29 view .LVU1231
 4619 06c4 1CAB     		add	r3, sp, #112
 4620              	.LVL332:
 4621              	.L169:
 4622              		.loc 6 3683 29 view .LVU1232
 4623              	.LBE1668:
 4624              	.LBE1667:
 290:MotorControl/controller.cpp **** 
 4625              		.loc 3 290 34 view .LVU1233
 4626 06c6 D3ED001A 		vldr.32	s3, [r3]
 290:MotorControl/controller.cpp **** 
 4627              		.loc 3 290 22 view .LVU1234
 4628 06ca 04F54053 		add	r3, r4, #12288
 4629 06ce 03F51162 		add	r2, r3, #2320
 4630 06d2 C2ED001A 		vstr.32	s3, [r2]
 294:MotorControl/controller.cpp ****     float vel_des = vel_setpoint_;
 4631              		.loc 3 294 5 is_stmt 1 view .LVU1235
 4632              	.LVL333:
 295:MotorControl/controller.cpp ****     if (config_.control_mode >= CONTROL_MODE_POSITION_CONTROL) {
 4633              		.loc 3 295 5 view .LVU1236
ARM GAS  /tmp/ccawPiBL.s 			page 267


 295:MotorControl/controller.cpp ****     if (config_.control_mode >= CONTROL_MODE_POSITION_CONTROL) {
 4634              		.loc 3 295 21 is_stmt 0 view .LVU1237
 4635 06d6 03F60813 		addw	r3, r3, #2312
 4636 06da 93ED007A 		vldr.32	s14, [r3]
 295:MotorControl/controller.cpp ****     if (config_.control_mode >= CONTROL_MODE_POSITION_CONTROL) {
 4637              		.loc 3 295 11 view .LVU1238
 4638 06de 8DED097A 		vstr.32	s14, [sp, #36]
 296:MotorControl/controller.cpp ****         float pos_err;
 4639              		.loc 3 296 5 is_stmt 1 view .LVU1239
 4640              	.LBB1669:
 296:MotorControl/controller.cpp ****         float pos_err;
 4641              		.loc 3 296 17 is_stmt 0 view .LVU1240
 4642 06e2 267E     		ldrb	r6, [r4, #24]	@ zero_extendqisi2
 296:MotorControl/controller.cpp ****         float pos_err;
 4643              		.loc 3 296 5 view .LVU1241
 4644 06e4 022E     		cmp	r6, #2
 4645 06e6 64D9     		bls	.L216
 4646              	.LBB1670:
 297:MotorControl/controller.cpp **** 
 4647              		.loc 3 297 9 is_stmt 1 view .LVU1242
 299:MotorControl/controller.cpp ****             if (!pos_estimate_circular.has_value() || !pos_wrap.has_value()) {
 4648              		.loc 3 299 9 view .LVU1243
 299:MotorControl/controller.cpp ****             if (!pos_estimate_circular.has_value() || !pos_wrap.has_value()) {
 4649              		.loc 3 299 21 is_stmt 0 view .LVU1244
 4650 06e8 94F83C30 		ldrb	r3, [r4, #60]	@ zero_extendqisi2
 299:MotorControl/controller.cpp ****             if (!pos_estimate_circular.has_value() || !pos_wrap.has_value()) {
 4651              		.loc 3 299 9 view .LVU1245
 4652 06ec B3B3     		cbz	r3, .L172
 300:MotorControl/controller.cpp ****                 set_error(ERROR_INVALID_ESTIMATE);
 4653              		.loc 3 300 13 is_stmt 1 view .LVU1246
 4654              	.LVL334:
 4655              	.LBB1671:
 4656              	.LBI1671:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 4657              		.loc 13 916 22 view .LVU1247
 4658              	.LBB1672:
 4659              	.LBI1672:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 4660              		.loc 13 433 22 view .LVU1248
 4661              	.LBB1673:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4662              		.loc 13 434 58 is_stmt 0 view .LVU1249
 4663 06ee 9DF85030 		ldrb	r3, [sp, #80]	@ zero_extendqisi2
 4664              	.LVL335:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4665              		.loc 13 434 58 view .LVU1250
 4666              	.LBE1673:
 4667              	.LBE1672:
 4668              	.LBE1671:
 300:MotorControl/controller.cpp ****                 set_error(ERROR_INVALID_ESTIMATE);
 4669              		.loc 3 300 52 view .LVU1251
 4670 06f2 53B3     		cbz	r3, .L173
 4671              	.LVL336:
 4672              	.LBB1674:
 4673              	.LBI1674:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 4674              		.loc 13 916 22 is_stmt 1 view .LVU1252
ARM GAS  /tmp/ccawPiBL.s 			page 268


 4675              	.LBB1675:
 4676              	.LBI1675:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 4677              		.loc 13 433 22 view .LVU1253
 4678              	.LBB1676:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4679              		.loc 13 434 58 is_stmt 0 view .LVU1254
 4680 06f4 9DF84830 		ldrb	r3, [sp, #72]	@ zero_extendqisi2
 4681              	.LVL337:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4682              		.loc 13 434 58 view .LVU1255
 4683              	.LBE1676:
 4684              	.LBE1675:
 4685              	.LBE1674:
 300:MotorControl/controller.cpp ****                 set_error(ERROR_INVALID_ESTIMATE);
 4686              		.loc 3 300 52 view .LVU1256
 4687 06f8 3BB3     		cbz	r3, .L173
 305:MotorControl/controller.cpp ****             // Circular delta
 4688              		.loc 3 305 13 is_stmt 1 view .LVU1257
 305:MotorControl/controller.cpp ****             // Circular delta
 4689              		.loc 3 305 38 is_stmt 0 view .LVU1258
 4690 06fa 04F56453 		add	r3, r4, #14592
 4691 06fe D3ED017A 		vldr.32	s15, [r3, #4]
 4692 0702 DDED116A 		vldr.32	s13, [sp, #68]
 4693              	.LVL338:
 4694              	.LBB1677:
 4695              	.LBI1677:
 133:./MotorControl/utils.hpp ****     float res = wrap_pm(x, y);
 4696              		.loc 11 133 14 is_stmt 1 view .LVU1259
 4697              	.LBB1678:
 134:./MotorControl/utils.hpp ****     if (res < 0) res += y;
 4698              		.loc 11 134 5 view .LVU1260
 4699              	.LBB1679:
 4700              	.LBI1679:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
 4701              		.loc 11 123 14 view .LVU1261
 4702              	.LBB1680:
 125:./MotorControl/utils.hpp **** #else
 4703              		.loc 11 125 5 view .LVU1262
 125:./MotorControl/utils.hpp **** #else
 4704              		.loc 11 125 36 is_stmt 0 view .LVU1263
 4705 0706 87EEA66A 		vdiv.f32	s12, s15, s13
 4706              	.LVL339:
 4707              	.LBB1681:
 4708              	.LBI1681:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 4709              		.loc 11 108 12 is_stmt 1 view .LVU1264
 4710              	.LBB1682:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 4711              		.loc 11 110 5 view .LVU1265
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 4712              		.loc 11 111 5 view .LVU1266
 4713              		.syntax unified
 4714              	@ 111 "./MotorControl/utils.hpp" 1
 4715 070a BDEE466A 		vcvtr.s32.f32   s12, s12
 4716              	@ 0 "" 2
 4717              	.LVL340:
ARM GAS  /tmp/ccawPiBL.s 			page 269


 114:./MotorControl/utils.hpp **** #else
 4718              		.loc 11 114 5 view .LVU1267
 114:./MotorControl/utils.hpp **** #else
 4719              		.loc 11 114 5 is_stmt 0 view .LVU1268
 4720              		.thumb
 4721              		.syntax unified
 4722              	.LBE1682:
 4723              	.LBE1681:
 125:./MotorControl/utils.hpp **** #else
 4724              		.loc 11 125 42 view .LVU1269
 4725 070e B8EEC66A 		vcvt.f32.s32	s12, s12
 4726              	.LVL341:
 129:./MotorControl/utils.hpp **** }
 4727              		.loc 11 129 5 is_stmt 1 view .LVU1270
 129:./MotorControl/utils.hpp **** }
 4728              		.loc 11 129 23 is_stmt 0 view .LVU1271
 4729 0712 26EE866A 		vmul.f32	s12, s13, s12
 4730              	.LVL342:
 129:./MotorControl/utils.hpp **** }
 4731              		.loc 11 129 25 view .LVU1272
 4732 0716 77EEC67A 		vsub.f32	s15, s15, s12
 4733              	.LVL343:
 129:./MotorControl/utils.hpp **** }
 4734              		.loc 11 129 25 view .LVU1273
 4735              	.LBE1680:
 4736              	.LBE1679:
 135:./MotorControl/utils.hpp ****     return res;
 4737              		.loc 11 135 5 is_stmt 1 view .LVU1274
 4738 071a F5EEC07A 		vcmpe.f32	s15, #0
 4739 071e F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 4740 0722 18D4     		bmi	.L256
 4741              	.L175:
 136:./MotorControl/utils.hpp **** }
 4742              		.loc 11 136 5 view .LVU1275
 4743              	.LVL344:
 136:./MotorControl/utils.hpp **** }
 4744              		.loc 11 136 5 is_stmt 0 view .LVU1276
 4745              	.LBE1678:
 4746              	.LBE1677:
 305:MotorControl/controller.cpp ****             // Circular delta
 4747              		.loc 3 305 27 view .LVU1277
 4748 0724 04F56453 		add	r3, r4, #14592
 4749 0728 C3ED017A 		vstr.32	s15, [r3, #4]
 307:MotorControl/controller.cpp ****             pos_err = wrap_pm(pos_err, *pos_wrap);
 4750              		.loc 3 307 13 is_stmt 1 view .LVU1278
 307:MotorControl/controller.cpp ****             pos_err = wrap_pm(pos_err, *pos_wrap);
 4751              		.loc 3 307 39 is_stmt 0 view .LVU1279
 4752 072c 9DED136A 		vldr.32	s12, [sp, #76]
 307:MotorControl/controller.cpp ****             pos_err = wrap_pm(pos_err, *pos_wrap);
 4753              		.loc 3 307 21 view .LVU1280
 4754 0730 77EEC67A 		vsub.f32	s15, s15, s12
 4755              	.LVL345:
 308:MotorControl/controller.cpp ****         } else {
 4756              		.loc 3 308 13 is_stmt 1 view .LVU1281
 4757              	.LBB1684:
 4758              	.LBI1684:
 123:./MotorControl/utils.hpp **** #ifdef FPU_FPV4
ARM GAS  /tmp/ccawPiBL.s 			page 270


 4759              		.loc 11 123 14 view .LVU1282
 4760              	.LBB1685:
 125:./MotorControl/utils.hpp **** #else
 4761              		.loc 11 125 5 view .LVU1283
 125:./MotorControl/utils.hpp **** #else
 4762              		.loc 11 125 36 is_stmt 0 view .LVU1284
 4763 0734 87EEA66A 		vdiv.f32	s12, s15, s13
 4764              	.LVL346:
 4765              	.LBB1686:
 4766              	.LBI1686:
 108:./MotorControl/utils.hpp **** #ifdef __arm__
 4767              		.loc 11 108 12 is_stmt 1 view .LVU1285
 4768              	.LBB1687:
 110:./MotorControl/utils.hpp ****     asm("vcvtr.s32.f32   %[res], %[x]"
 4769              		.loc 11 110 5 view .LVU1286
 111:./MotorControl/utils.hpp ****         : [res] "=X" (res)
 4770              		.loc 11 111 5 view .LVU1287
 4771              		.syntax unified
 4772              	@ 111 "./MotorControl/utils.hpp" 1
 4773 0738 BDEE466A 		vcvtr.s32.f32   s12, s12
 4774              	@ 0 "" 2
 4775              	.LVL347:
 114:./MotorControl/utils.hpp **** #else
 4776              		.loc 11 114 5 view .LVU1288
 114:./MotorControl/utils.hpp **** #else
 4777              		.loc 11 114 5 is_stmt 0 view .LVU1289
 4778              		.thumb
 4779              		.syntax unified
 4780              	.LBE1687:
 4781              	.LBE1686:
 125:./MotorControl/utils.hpp **** #else
 4782              		.loc 11 125 42 view .LVU1290
 4783 073c B8EEC66A 		vcvt.f32.s32	s12, s12
 4784              	.LVL348:
 129:./MotorControl/utils.hpp **** }
 4785              		.loc 11 129 5 is_stmt 1 view .LVU1291
 129:./MotorControl/utils.hpp **** }
 4786              		.loc 11 129 23 is_stmt 0 view .LVU1292
 4787 0740 66EE866A 		vmul.f32	s13, s13, s12
 4788              	.LVL349:
 129:./MotorControl/utils.hpp **** }
 4789              		.loc 11 129 25 view .LVU1293
 4790 0744 77EEE67A 		vsub.f32	s15, s15, s13
 4791              	.LVL350:
 129:./MotorControl/utils.hpp **** }
 4792              		.loc 11 129 25 view .LVU1294
 4793              	.LBE1685:
 4794              	.LBE1684:
 4795 0748 13E0     		b	.L176
 4796              	.LVL351:
 4797              	.L173:
 301:MotorControl/controller.cpp ****                 return false;
 4798              		.loc 3 301 17 is_stmt 1 discriminator 3 view .LVU1295
 301:MotorControl/controller.cpp ****                 return false;
 4799              		.loc 3 301 26 is_stmt 0 discriminator 3 view .LVU1296
 4800 074a 2021     		movs	r1, #32
 4801 074c 2046     		mov	r0, r4
ARM GAS  /tmp/ccawPiBL.s 			page 271


 4802 074e FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 4803              	.LVL352:
 302:MotorControl/controller.cpp ****             }
 4804              		.loc 3 302 17 is_stmt 1 discriminator 3 view .LVU1297
 302:MotorControl/controller.cpp ****             }
 4805              		.loc 3 302 24 is_stmt 0 discriminator 3 view .LVU1298
 4806 0752 0025     		movs	r5, #0
 4807 0754 E8E4     		b	.L130
 4808              	.LVL353:
 4809              	.L256:
 4810              	.LBB1688:
 4811              	.LBB1683:
 135:./MotorControl/utils.hpp ****     return res;
 4812              		.loc 11 135 18 is_stmt 1 view .LVU1299
 135:./MotorControl/utils.hpp ****     return res;
 4813              		.loc 11 135 22 is_stmt 0 view .LVU1300
 4814 0756 77EEA67A 		vadd.f32	s15, s15, s13
 4815              	.LVL354:
 135:./MotorControl/utils.hpp ****     return res;
 4816              		.loc 11 135 22 view .LVU1301
 4817 075a E3E7     		b	.L175
 4818              	.LVL355:
 4819              	.L172:
 135:./MotorControl/utils.hpp ****     return res;
 4820              		.loc 11 135 22 view .LVU1302
 4821              	.LBE1683:
 4822              	.LBE1688:
 310:MotorControl/controller.cpp ****                 set_error(ERROR_INVALID_ESTIMATE);
 4823              		.loc 3 310 13 is_stmt 1 view .LVU1303
 4824              	.LBB1689:
 4825              	.LBI1689:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 4826              		.loc 13 916 22 view .LVU1304
 4827              	.LBB1690:
 4828              	.LBI1690:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 4829              		.loc 13 433 22 view .LVU1305
 4830              	.LBB1691:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4831              		.loc 13 434 58 is_stmt 0 view .LVU1306
 4832 075c 9DF85850 		ldrb	r5, [sp, #88]	@ zero_extendqisi2
 4833              	.LVL356:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4834              		.loc 13 434 58 view .LVU1307
 4835              	.LBE1691:
 4836              	.LBE1690:
 4837              	.LBE1689:
 310:MotorControl/controller.cpp ****                 set_error(ERROR_INVALID_ESTIMATE);
 4838              		.loc 3 310 13 view .LVU1308
 4839 0760 15B3     		cbz	r5, .L257
 314:MotorControl/controller.cpp ****         }
 4840              		.loc 3 314 13 is_stmt 1 view .LVU1309
 314:MotorControl/controller.cpp ****         }
 4841              		.loc 3 314 23 is_stmt 0 view .LVU1310
 4842 0762 04F56453 		add	r3, r4, #14592
 4843 0766 D3ED017A 		vldr.32	s15, [r3, #4]
 314:MotorControl/controller.cpp ****         }
ARM GAS  /tmp/ccawPiBL.s 			page 272


 4844              		.loc 3 314 39 view .LVU1311
 4845 076a DDED156A 		vldr.32	s13, [sp, #84]
 314:MotorControl/controller.cpp ****         }
 4846              		.loc 3 314 21 view .LVU1312
 4847 076e 77EEE67A 		vsub.f32	s15, s15, s13
 4848              	.LVL357:
 4849              	.L176:
 317:MotorControl/controller.cpp ****         // V-shaped gain shedule based on position error
 4850              		.loc 3 317 9 is_stmt 1 view .LVU1313
 317:MotorControl/controller.cpp ****         // V-shaped gain shedule based on position error
 4851              		.loc 3 317 28 is_stmt 0 view .LVU1314
 4852 0772 D4ED076A 		vldr.32	s13, [r4, #28]
 317:MotorControl/controller.cpp ****         // V-shaped gain shedule based on position error
 4853              		.loc 3 317 37 view .LVU1315
 4854 0776 66EEA76A 		vmul.f32	s13, s13, s15
 317:MotorControl/controller.cpp ****         // V-shaped gain shedule based on position error
 4855              		.loc 3 317 17 view .LVU1316
 4856 077a 37EE267A 		vadd.f32	s14, s14, s13
 4857 077e 8DED097A 		vstr.32	s14, [sp, #36]
 319:MotorControl/controller.cpp ****         if (config_.enable_gain_scheduling && abs_pos_err <= config_.gain_scheduling_width) {
 4858              		.loc 3 319 9 is_stmt 1 view .LVU1317
 4859              	.LVL358:
 4860              	.LBB1692:
 4861              	.LBI1692:
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   { return __builtin_fabsf(__x); }
 4862              		.loc 9 75 3 view .LVU1318
 4863              	.LBB1693:
 4864              		.loc 9 76 5 view .LVU1319
 4865              		.loc 9 76 31 is_stmt 0 view .LVU1320
 4866 0782 F0EEE77A 		vabs.f32	s15, s15
 4867              	.LVL359:
 4868              		.loc 9 76 31 view .LVU1321
 4869              	.LBE1693:
 4870              	.LBE1692:
 320:MotorControl/controller.cpp ****             gain_scheduling_multiplier = abs_pos_err / config_.gain_scheduling_width;
 4871              		.loc 3 320 9 is_stmt 1 view .LVU1322
 320:MotorControl/controller.cpp ****             gain_scheduling_multiplier = abs_pos_err / config_.gain_scheduling_width;
 4872              		.loc 3 320 21 is_stmt 0 view .LVU1323
 4873 0786 04F54053 		add	r3, r4, #12288
 4874 078a 93F8B038 		ldrb	r3, [r3, #2224]	@ zero_extendqisi2
 320:MotorControl/controller.cpp ****             gain_scheduling_multiplier = abs_pos_err / config_.gain_scheduling_width;
 4875              		.loc 3 320 9 view .LVU1324
 4876 078e 6BB3     		cbz	r3, .L217
 320:MotorControl/controller.cpp ****             gain_scheduling_multiplier = abs_pos_err / config_.gain_scheduling_width;
 4877              		.loc 3 320 70 discriminator 1 view .LVU1325
 4878 0790 04F56253 		add	r3, r4, #14464
 4879 0794 93ED0B7A 		vldr.32	s14, [r3, #44]
 320:MotorControl/controller.cpp ****             gain_scheduling_multiplier = abs_pos_err / config_.gain_scheduling_width;
 4880              		.loc 3 320 44 discriminator 1 view .LVU1326
 4881 0798 B4EEE77A 		vcmpe.f32	s14, s15
 4882 079c F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 4883 07a0 27DB     		blt	.L243
 321:MotorControl/controller.cpp ****         }
 4884              		.loc 3 321 13 is_stmt 1 view .LVU1327
 321:MotorControl/controller.cpp ****         }
 4885              		.loc 3 321 40 is_stmt 0 view .LVU1328
 4886 07a2 87EE879A 		vdiv.f32	s18, s15, s14
ARM GAS  /tmp/ccawPiBL.s 			page 273


 4887              	.LVL360:
 321:MotorControl/controller.cpp ****         }
 4888              		.loc 3 321 40 view .LVU1329
 4889 07a6 06E0     		b	.L171
 4890              	.LVL361:
 4891              	.L257:
 311:MotorControl/controller.cpp ****                 return false;
 4892              		.loc 3 311 17 is_stmt 1 view .LVU1330
 311:MotorControl/controller.cpp ****                 return false;
 4893              		.loc 3 311 26 is_stmt 0 view .LVU1331
 4894 07a8 2021     		movs	r1, #32
 4895 07aa 2046     		mov	r0, r4
 4896 07ac FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 4897              	.LVL362:
 312:MotorControl/controller.cpp ****             }
 4898              		.loc 3 312 17 is_stmt 1 view .LVU1332
 312:MotorControl/controller.cpp ****             }
 4899              		.loc 3 312 24 is_stmt 0 view .LVU1333
 4900 07b0 BAE4     		b	.L130
 4901              	.L216:
 312:MotorControl/controller.cpp ****             }
 4902              		.loc 3 312 24 view .LVU1334
 4903              	.LBE1670:
 4904              	.LBE1669:
 294:MotorControl/controller.cpp ****     float vel_des = vel_setpoint_;
 4905              		.loc 3 294 11 view .LVU1335
 4906 07b2 B7EE009A 		vmov.f32	s18, #1.0e+0
 4907              	.LVL363:
 4908              	.L171:
 326:MotorControl/controller.cpp ****     if (config_.enable_vel_limit) {
 4909              		.loc 3 326 5 is_stmt 1 view .LVU1336
 326:MotorControl/controller.cpp ****     if (config_.enable_vel_limit) {
 4910              		.loc 3 326 29 is_stmt 0 view .LVU1337
 4911 07b6 94ED0A0A 		vldr.32	s0, [r4, #40]
 326:MotorControl/controller.cpp ****     if (config_.enable_vel_limit) {
 4912              		.loc 3 326 11 view .LVU1338
 4913 07ba 8DED080A 		vstr.32	s0, [sp, #32]
 327:MotorControl/controller.cpp ****         vel_des = std::clamp(vel_des, -vel_lim, vel_lim);
 4914              		.loc 3 327 5 is_stmt 1 view .LVU1339
 327:MotorControl/controller.cpp ****         vel_des = std::clamp(vel_des, -vel_lim, vel_lim);
 4915              		.loc 3 327 17 is_stmt 0 view .LVU1340
 4916 07be 04F54053 		add	r3, r4, #12288
 4917 07c2 93F8B138 		ldrb	r3, [r3, #2225]	@ zero_extendqisi2
 327:MotorControl/controller.cpp ****         vel_des = std::clamp(vel_des, -vel_lim, vel_lim);
 4918              		.loc 3 327 5 view .LVU1341
 4919 07c6 D3B1     		cbz	r3, .L179
 328:MotorControl/controller.cpp ****     }
 4920              		.loc 3 328 9 is_stmt 1 view .LVU1342
 328:MotorControl/controller.cpp ****     }
 4921              		.loc 3 328 39 is_stmt 0 view .LVU1343
 4922 07c8 F1EE407A 		vneg.f32	s15, s0
 4923 07cc CDED1D7A 		vstr.32	s15, [sp, #116]
 4924              	.LVL364:
 4925              	.LBB1694:
 4926              	.LBI1694:
3680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 4927              		.loc 6 3680 5 is_stmt 1 view .LVU1344
ARM GAS  /tmp/ccawPiBL.s 			page 274


 4928              	.LBB1695:
 4929              		.loc 6 3683 21 is_stmt 0 view .LVU1345
 4930 07d0 9DED097A 		vldr.32	s14, [sp, #36]
 4931              		.loc 6 3683 29 view .LVU1346
 4932 07d4 F4EEC77A 		vcmpe.f32	s15, s14
 4933 07d8 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 4934 07dc 0CDC     		bgt	.L219
 4935 07de B4EEC70A 		vcmpe.f32	s0, s14
 4936 07e2 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 4937 07e6 62D5     		bpl	.L244
 4938 07e8 08AB     		add	r3, sp, #32
 4939              	.LVL365:
 4940              		.loc 6 3683 29 view .LVU1347
 4941 07ea 06E0     		b	.L180
 4942              	.LVL366:
 4943              	.L217:
 4944              		.loc 6 3683 29 view .LVU1348
 4945              	.LBE1695:
 4946              	.LBE1694:
 294:MotorControl/controller.cpp ****     float vel_des = vel_setpoint_;
 4947              		.loc 3 294 11 view .LVU1349
 4948 07ec B7EE009A 		vmov.f32	s18, #1.0e+0
 4949 07f0 E1E7     		b	.L171
 4950              	.L243:
 4951 07f2 B7EE009A 		vmov.f32	s18, #1.0e+0
 4952 07f6 DEE7     		b	.L171
 4953              	.LVL367:
 4954              	.L219:
 4955              	.LBB1698:
 4956              	.LBB1696:
 4957              		.loc 6 3683 29 view .LVU1350
 4958 07f8 1DAB     		add	r3, sp, #116
 4959              	.LVL368:
 4960              	.L180:
 4961              		.loc 6 3683 29 view .LVU1351
 4962              	.LBE1696:
 4963              	.LBE1698:
 328:MotorControl/controller.cpp ****     }
 4964              		.loc 3 328 29 view .LVU1352
 4965 07fa 1B68     		ldr	r3, [r3]	@ float
 328:MotorControl/controller.cpp ****     }
 4966              		.loc 3 328 17 view .LVU1353
 4967 07fc 0993     		str	r3, [sp, #36]	@ float
 4968              	.L179:
 332:MotorControl/controller.cpp ****         if (!vel_estimate.has_value()) {
 4969              		.loc 3 332 5 is_stmt 1 view .LVU1354
 332:MotorControl/controller.cpp ****         if (!vel_estimate.has_value()) {
 4970              		.loc 3 332 17 is_stmt 0 view .LVU1355
 4971 07fe 04F54053 		add	r3, r4, #12288
 4972 0802 93F8B238 		ldrb	r3, [r3, #2226]	@ zero_extendqisi2
 332:MotorControl/controller.cpp ****         if (!vel_estimate.has_value()) {
 4973              		.loc 3 332 5 view .LVU1356
 4974 0806 83B1     		cbz	r3, .L182
 333:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_ESTIMATE);
 4975              		.loc 3 333 9 is_stmt 1 view .LVU1357
 4976              	.LVL369:
 4977              	.LBB1699:
ARM GAS  /tmp/ccawPiBL.s 			page 275


 4978              	.LBI1699:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 4979              		.loc 13 916 22 view .LVU1358
 4980              	.LBB1700:
 4981              	.LBI1700:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 4982              		.loc 13 433 22 view .LVU1359
 4983              	.LBB1701:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4984              		.loc 13 434 58 is_stmt 0 view .LVU1360
 4985 0808 9DF84050 		ldrb	r5, [sp, #64]	@ zero_extendqisi2
 4986              	.LVL370:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 4987              		.loc 13 434 58 view .LVU1361
 4988              	.LBE1701:
 4989              	.LBE1700:
 4990              	.LBE1699:
 333:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_ESTIMATE);
 4991              		.loc 3 333 9 view .LVU1362
 4992 080c 002D     		cmp	r5, #0
 4993 080e 50D0     		beq	.L258
 337:MotorControl/controller.cpp ****             set_error(ERROR_OVERSPEED);
 4994              		.loc 3 337 9 is_stmt 1 view .LVU1363
 337:MotorControl/controller.cpp ****             set_error(ERROR_OVERSPEED);
 4995              		.loc 3 337 21 is_stmt 0 view .LVU1364
 4996 0810 DDED0F7A 		vldr.32	s15, [sp, #60]
 4997              	.LVL371:
 4998              	.LBB1702:
 4999              	.LBI1702:
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   { return __builtin_fabsf(__x); }
 5000              		.loc 9 75 3 is_stmt 1 view .LVU1365
 5001              	.LBB1703:
 5002              		.loc 9 76 5 view .LVU1366
 5003              		.loc 9 76 31 is_stmt 0 view .LVU1367
 5004 0814 F0EEE77A 		vabs.f32	s15, s15
 5005              	.LVL372:
 5006              		.loc 9 76 31 view .LVU1368
 5007              	.LBE1703:
 5008              	.LBE1702:
 337:MotorControl/controller.cpp ****             set_error(ERROR_OVERSPEED);
 5009              		.loc 3 337 47 view .LVU1369
 5010 0818 94ED0B7A 		vldr.32	s14, [r4, #44]
 337:MotorControl/controller.cpp ****             set_error(ERROR_OVERSPEED);
 5011              		.loc 3 337 67 view .LVU1370
 5012 081c 20EE077A 		vmul.f32	s14, s0, s14
 337:MotorControl/controller.cpp ****             set_error(ERROR_OVERSPEED);
 5013              		.loc 3 337 9 view .LVU1371
 5014 0820 B4EEE77A 		vcmpe.f32	s14, s15
 5015 0824 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5016 0828 48D4     		bmi	.L259
 5017              	.L182:
 345:MotorControl/controller.cpp ****     float vel_integrator_gain = config_.vel_integrator_gain;
 5018              		.loc 3 345 5 is_stmt 1 view .LVU1372
 345:MotorControl/controller.cpp ****     float vel_integrator_gain = config_.vel_integrator_gain;
 5019              		.loc 3 345 11 is_stmt 0 view .LVU1373
 5020 082a 94ED081A 		vldr.32	s2, [r4, #32]
 5021              	.LVL373:
ARM GAS  /tmp/ccawPiBL.s 			page 276


 346:MotorControl/controller.cpp ****     if (axis_->motor_.config_.motor_type == Motor::MOTOR_TYPE_ACIM) {
 5022              		.loc 3 346 5 is_stmt 1 view .LVU1374
 346:MotorControl/controller.cpp ****     if (axis_->motor_.config_.motor_type == Motor::MOTOR_TYPE_ACIM) {
 5023              		.loc 3 346 11 is_stmt 0 view .LVU1375
 5024 082e 94ED09AA 		vldr.32	s20, [r4, #36]
 5025              	.LVL374:
 347:MotorControl/controller.cpp ****         float effective_flux = axis_->acim_estimator_.rotor_flux_;
 5026              		.loc 3 347 5 is_stmt 1 view .LVU1376
 5027              	.LBB1704:
 347:MotorControl/controller.cpp ****         float effective_flux = axis_->acim_estimator_.rotor_flux_;
 5028              		.loc 3 347 9 is_stmt 0 view .LVU1377
 5029 0832 04F54053 		add	r3, r4, #12288
 5030 0836 D3F8D878 		ldr	r7, [r3, #2264]
 347:MotorControl/controller.cpp ****         float effective_flux = axis_->acim_estimator_.rotor_flux_;
 5031              		.loc 3 347 16 view .LVU1378
 5032 083a D7F85831 		ldr	r3, [r7, #344]
 347:MotorControl/controller.cpp ****         float effective_flux = axis_->acim_estimator_.rotor_flux_;
 5033              		.loc 3 347 31 view .LVU1379
 5034 083e 93F83820 		ldrb	r2, [r3, #56]	@ zero_extendqisi2
 347:MotorControl/controller.cpp ****         float effective_flux = axis_->acim_estimator_.rotor_flux_;
 5035              		.loc 3 347 5 view .LVU1380
 5036 0842 032A     		cmp	r2, #3
 5037 0844 40D0     		beq	.L260
 5038              	.L185:
 347:MotorControl/controller.cpp ****         float effective_flux = axis_->acim_estimator_.rotor_flux_;
 5039              		.loc 3 347 5 view .LVU1381
 5040              	.LBE1704:
 359:MotorControl/controller.cpp **** 
 5041              		.loc 3 359 5 is_stmt 1 view .LVU1382
 5042              	.LVL375:
 364:MotorControl/controller.cpp ****         if (!anticogging_pos_estimate.has_value()) {
 5043              		.loc 3 364 5 view .LVU1383
 5044              	.LBB1708:
 364:MotorControl/controller.cpp ****         if (!anticogging_pos_estimate.has_value()) {
 5045              		.loc 3 364 9 is_stmt 0 view .LVU1384
 5046 0846 04F54053 		add	r3, r4, #12288
 5047 084a 93F83E39 		ldrb	r3, [r3, #2366]	@ zero_extendqisi2
 364:MotorControl/controller.cpp ****         if (!anticogging_pos_estimate.has_value()) {
 5048              		.loc 3 364 5 view .LVU1385
 5049 084e 002B     		cmp	r3, #0
 5050 0850 64D0     		beq	.L189
 364:MotorControl/controller.cpp ****         if (!anticogging_pos_estimate.has_value()) {
 5051              		.loc 3 364 51 discriminator 1 view .LVU1386
 5052 0852 04F54053 		add	r3, r4, #12288
 5053 0856 93F8A838 		ldrb	r3, [r3, #2216]	@ zero_extendqisi2
 364:MotorControl/controller.cpp ****         if (!anticogging_pos_estimate.has_value()) {
 5054              		.loc 3 364 28 discriminator 1 view .LVU1387
 5055 085a 002B     		cmp	r3, #0
 5056 085c 5ED0     		beq	.L189
 5057              	.LBB1709:
 365:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_ESTIMATE);
 5058              		.loc 3 365 9 is_stmt 1 view .LVU1388
 5059              	.LVL376:
 5060              	.LBB1710:
 5061              	.LBI1710:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 5062              		.loc 13 916 22 view .LVU1389
ARM GAS  /tmp/ccawPiBL.s 			page 277


 5063              	.LBB1711:
 5064              	.LBI1711:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 5065              		.loc 13 433 22 view .LVU1390
 5066              	.LBB1712:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 5067              		.loc 13 434 58 is_stmt 0 view .LVU1391
 5068 085e 9DF83850 		ldrb	r5, [sp, #56]	@ zero_extendqisi2
 5069              	.LVL377:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 5070              		.loc 13 434 58 view .LVU1392
 5071              	.LBE1712:
 5072              	.LBE1711:
 5073              	.LBE1710:
 365:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_ESTIMATE);
 5074              		.loc 3 365 9 view .LVU1393
 5075 0862 002D     		cmp	r5, #0
 5076 0864 4AD0     		beq	.L261
 369:MotorControl/controller.cpp ****         torque += config_.anticogging.cogging_map[std::clamp(mod((int)anticogging_pos, 3600), 0, 36
 5077              		.loc 3 369 9 is_stmt 1 view .LVU1394
 5078              	.LVL378:
 369:MotorControl/controller.cpp ****         torque += config_.anticogging.cogging_map[std::clamp(mod((int)anticogging_pos, 3600), 0, 36
 5079              		.loc 3 369 9 is_stmt 0 view .LVU1395
 5080              	.LBE1709:
 5081              	.LBE1708:
 5082              		.loc 10 149 9 is_stmt 1 view .LVU1396
 5083              	.LBB1726:
 5084              	.LBB1723:
 369:MotorControl/controller.cpp ****         torque += config_.anticogging.cogging_map[std::clamp(mod((int)anticogging_pos, 3600), 0, 36
 5085              		.loc 3 369 93 is_stmt 0 view .LVU1397
 5086 0866 DDED0D6A 		vldr.32	s13, [sp, #52]
 5087 086a 1FEDC27A 		vldr.32	s14, .L268+12
 5088 086e C6EE877A 		vdiv.f32	s15, s13, s14
 5089              	.LVL379:
 370:MotorControl/controller.cpp ****     }
 5090              		.loc 3 370 9 is_stmt 1 view .LVU1398
 370:MotorControl/controller.cpp ****     }
 5091              		.loc 3 370 65 is_stmt 0 view .LVU1399
 5092 0872 FDEEE77A 		vcvt.s32.f32	s15, s15
 5093              	.LVL380:
 370:MotorControl/controller.cpp ****     }
 5094              		.loc 3 370 65 view .LVU1400
 5095 0876 17EE902A 		vmov	r2, s15	@ int
 5096              	.LVL381:
 5097              	.LBB1713:
 5098              	.LBI1713:
 141:./MotorControl/utils.hpp **** }
 142:./MotorControl/utils.hpp **** 
 143:./MotorControl/utils.hpp **** // Evaluate polynomials in an efficient way
 144:./MotorControl/utils.hpp **** // coeffs[0] is highest order, as per numpy.polyfit
 145:./MotorControl/utils.hpp **** // p(x) = coeffs[0] * x^deg + ... + coeffs[deg], for some degree "deg"
 146:./MotorControl/utils.hpp **** inline float horner_poly_eval(float x, const float *coeffs, size_t count) {
 147:./MotorControl/utils.hpp ****     float result = 0.0f;
 148:./MotorControl/utils.hpp ****     for (size_t idx = 0; idx < count; ++idx)
 149:./MotorControl/utils.hpp ****         result = (result * x) + coeffs[idx];
 150:./MotorControl/utils.hpp ****     return result;
 151:./MotorControl/utils.hpp **** }
ARM GAS  /tmp/ccawPiBL.s 			page 278


 152:./MotorControl/utils.hpp **** 
 153:./MotorControl/utils.hpp **** // Modulo (as opposed to remainder), per https://stackoverflow.com/a/19288271
 154:./MotorControl/utils.hpp **** inline int mod(const int dividend, const int divisor){
 5099              		.loc 11 154 12 is_stmt 1 view .LVU1401
 5100              	.LBB1714:
 155:./MotorControl/utils.hpp ****     int r = dividend % divisor;
 5101              		.loc 11 155 5 view .LVU1402
 5102              		.loc 11 155 9 is_stmt 0 view .LVU1403
 5103 087a B24B     		ldr	r3, .L270
 5104 087c 83FB0213 		smull	r1, r3, r3, r2
 5105 0880 9918     		adds	r1, r3, r2
 5106 0882 D317     		asrs	r3, r2, #31
 5107 0884 C3EBE123 		rsb	r3, r3, r1, asr #11
 5108 0888 4FF46161 		mov	r1, #3600
 5109 088c 01FB1323 		mls	r3, r1, r3, r2
 5110              	.LVL382:
 156:./MotorControl/utils.hpp ****     if (r < 0) r += divisor;
 5111              		.loc 11 156 5 is_stmt 1 view .LVU1404
 5112 0890 002B     		cmp	r3, #0
 5113 0892 38DB     		blt	.L262
 5114              	.L191:
 157:./MotorControl/utils.hpp ****     return r;
 5115              		.loc 11 157 5 view .LVU1405
 5116              	.LVL383:
 5117              		.loc 11 157 5 is_stmt 0 view .LVU1406
 5118              	.LBE1714:
 5119              	.LBE1713:
 370:MotorControl/controller.cpp ****     }
 5120              		.loc 3 370 65 view .LVU1407
 5121 0894 1E93     		str	r3, [sp, #120]
 370:MotorControl/controller.cpp ****     }
 5122              		.loc 3 370 95 view .LVU1408
 5123 0896 0022     		movs	r2, #0
 5124 0898 1F92     		str	r2, [sp, #124]
 370:MotorControl/controller.cpp ****     }
 5125              		.loc 3 370 98 view .LVU1409
 5126 089a 4FF46162 		mov	r2, #3600
 5127 089e 2092     		str	r2, [sp, #128]
 5128              	.LVL384:
 5129              	.LBB1716:
 5130              	.LBI1716:
3680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 5131              		.loc 6 3680 5 is_stmt 1 view .LVU1410
 5132              	.LBB1717:
 5133              		.loc 6 3683 29 is_stmt 0 view .LVU1411
 5134 08a0 002B     		cmp	r3, #0
 5135 08a2 32DB     		blt	.L221
 5136 08a4 9342     		cmp	r3, r2
 5137 08a6 40F38980 		ble	.L222
 5138 08aa 20AB     		add	r3, sp, #128
 5139              	.LVL385:
 5140              		.loc 6 3683 29 view .LVU1412
 5141 08ac 2EE0     		b	.L192
 5142              	.LVL386:
 5143              	.L244:
 5144              		.loc 6 3683 29 view .LVU1413
 5145              	.LBE1717:
ARM GAS  /tmp/ccawPiBL.s 			page 279


 5146              	.LBE1716:
 5147              	.LBE1723:
 5148              	.LBE1726:
 5149              	.LBB1727:
 5150              	.LBB1697:
 5151 08ae 09AB     		add	r3, sp, #36
 5152              	.LVL387:
 5153              		.loc 6 3683 29 view .LVU1414
 5154 08b0 A3E7     		b	.L180
 5155              	.LVL388:
 5156              	.L258:
 5157              		.loc 6 3683 29 view .LVU1415
 5158              	.LBE1697:
 5159              	.LBE1727:
 334:MotorControl/controller.cpp ****             return false;
 5160              		.loc 3 334 13 is_stmt 1 view .LVU1416
 334:MotorControl/controller.cpp ****             return false;
 5161              		.loc 3 334 22 is_stmt 0 view .LVU1417
 5162 08b2 2021     		movs	r1, #32
 5163 08b4 2046     		mov	r0, r4
 5164 08b6 FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 5165              	.LVL389:
 335:MotorControl/controller.cpp ****         }
 5166              		.loc 3 335 13 is_stmt 1 view .LVU1418
 335:MotorControl/controller.cpp ****         }
 5167              		.loc 3 335 20 is_stmt 0 view .LVU1419
 5168 08ba 35E4     		b	.L130
 5169              	.L259:
 338:MotorControl/controller.cpp ****             return false;
 5170              		.loc 3 338 13 is_stmt 1 view .LVU1420
 338:MotorControl/controller.cpp ****             return false;
 5171              		.loc 3 338 22 is_stmt 0 view .LVU1421
 5172 08bc 0121     		movs	r1, #1
 5173 08be 2046     		mov	r0, r4
 5174 08c0 FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 5175              	.LVL390:
 339:MotorControl/controller.cpp ****         }
 5176              		.loc 3 339 13 is_stmt 1 view .LVU1422
 339:MotorControl/controller.cpp ****         }
 5177              		.loc 3 339 20 is_stmt 0 view .LVU1423
 5178 08c4 0025     		movs	r5, #0
 5179 08c6 2FE4     		b	.L130
 5180              	.LVL391:
 5181              	.L260:
 5182              	.LBB1728:
 5183              	.LBB1705:
 348:MotorControl/controller.cpp ****         float minflux = axis_->motor_.config_.acim_gain_min_flux;
 5184              		.loc 3 348 9 is_stmt 1 view .LVU1424
 348:MotorControl/controller.cpp ****         float minflux = axis_->motor_.config_.acim_gain_min_flux;
 5185              		.loc 3 348 15 is_stmt 0 view .LVU1425
 5186 08c8 D7ED377A 		vldr.32	s15, [r7, #220]
 5187              	.LVL392:
 349:MotorControl/controller.cpp ****         if (std::abs(effective_flux) < minflux)
 5188              		.loc 3 349 9 is_stmt 1 view .LVU1426
 349:MotorControl/controller.cpp ****         if (std::abs(effective_flux) < minflux)
 5189              		.loc 3 349 15 is_stmt 0 view .LVU1427
 5190 08cc 93ED167A 		vldr.32	s14, [r3, #88]
ARM GAS  /tmp/ccawPiBL.s 			page 280


 5191              	.LVL393:
 350:MotorControl/controller.cpp ****             effective_flux = std::copysignf(minflux, effective_flux);
 5192              		.loc 3 350 9 is_stmt 1 view .LVU1428
 5193              	.LBB1706:
 5194              	.LBI1706:
  75:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_abs.h ****   { return __builtin_fabsf(__x); }
 5195              		.loc 9 75 3 view .LVU1429
 5196              	.LBB1707:
 5197              		.loc 9 76 5 view .LVU1430
 5198              		.loc 9 76 31 is_stmt 0 view .LVU1431
 5199 08d0 F0EEE76A 		vabs.f32	s13, s15
 5200              	.LVL394:
 5201              		.loc 9 76 31 view .LVU1432
 5202              	.LBE1707:
 5203              	.LBE1706:
 350:MotorControl/controller.cpp ****             effective_flux = std::copysignf(minflux, effective_flux);
 5204              		.loc 3 350 9 view .LVU1433
 5205 08d4 B4EEE67A 		vcmpe.f32	s14, s13
 5206 08d8 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5207 08dc 09DD     		ble	.L186
 351:MotorControl/controller.cpp ****         vel_gain /= effective_flux;
 5208              		.loc 3 351 13 is_stmt 1 view .LVU1434
 351:MotorControl/controller.cpp ****         vel_gain /= effective_flux;
 5209              		.loc 3 351 44 is_stmt 0 view .LVU1435
 5210 08de B0EEC77A 		vabs.f32	s14, s14
 5211              	.LVL395:
 351:MotorControl/controller.cpp ****         vel_gain /= effective_flux;
 5212              		.loc 3 351 44 view .LVU1436
 5213 08e2 17EE903A 		vmov	r3, s15	@ int
 5214              	.LVL396:
 351:MotorControl/controller.cpp ****         vel_gain /= effective_flux;
 5215              		.loc 3 351 44 view .LVU1437
 5216 08e6 002B     		cmp	r3, #0
 5217 08e8 01DA     		bge	.L188
 5218 08ea B1EE477A 		vneg.f32	s14, s14
 5219              	.L188:
 5220 08ee F0EE477A 		vmov.f32	s15, s14
 5221              	.LVL397:
 5222              	.L186:
 352:MotorControl/controller.cpp ****         vel_integrator_gain /= effective_flux;
 5223              		.loc 3 352 9 is_stmt 1 view .LVU1438
 352:MotorControl/controller.cpp ****         vel_integrator_gain /= effective_flux;
 5224              		.loc 3 352 18 is_stmt 0 view .LVU1439
 5225 08f2 81EE271A 		vdiv.f32	s2, s2, s15
 5226              	.LVL398:
 353:MotorControl/controller.cpp ****         // TODO: also scale the integral value which is also changing units.
 5227              		.loc 3 353 9 is_stmt 1 view .LVU1440
 353:MotorControl/controller.cpp ****         // TODO: also scale the integral value which is also changing units.
 5228              		.loc 3 353 29 is_stmt 0 view .LVU1441
 5229 08f6 8AEE27AA 		vdiv.f32	s20, s20, s15
 5230              	.LVL399:
 353:MotorControl/controller.cpp ****         // TODO: also scale the integral value which is also changing units.
 5231              		.loc 3 353 29 view .LVU1442
 5232              	.LBE1705:
 5233 08fa A4E7     		b	.L185
 5234              	.LVL400:
 5235              	.L261:
ARM GAS  /tmp/ccawPiBL.s 			page 281


 353:MotorControl/controller.cpp ****         // TODO: also scale the integral value which is also changing units.
 5236              		.loc 3 353 29 view .LVU1443
 5237              	.LBE1728:
 5238              	.LBB1729:
 5239              	.LBB1724:
 366:MotorControl/controller.cpp ****             return false;
 5240              		.loc 3 366 13 is_stmt 1 view .LVU1444
 366:MotorControl/controller.cpp ****             return false;
 5241              		.loc 3 366 22 is_stmt 0 view .LVU1445
 5242 08fc 2021     		movs	r1, #32
 5243 08fe 2046     		mov	r0, r4
 5244 0900 FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 5245              	.LVL401:
 367:MotorControl/controller.cpp ****         }
 5246              		.loc 3 367 13 is_stmt 1 view .LVU1446
 367:MotorControl/controller.cpp ****         }
 5247              		.loc 3 367 20 is_stmt 0 view .LVU1447
 5248 0904 10E4     		b	.L130
 5249              	.LVL402:
 5250              	.L262:
 5251              	.LBB1720:
 5252              	.LBB1715:
 156:./MotorControl/utils.hpp ****     return r;
 5253              		.loc 11 156 16 is_stmt 1 view .LVU1448
 156:./MotorControl/utils.hpp ****     return r;
 5254              		.loc 11 156 18 is_stmt 0 view .LVU1449
 5255 0906 0B44     		add	r3, r3, r1
 5256              	.LVL403:
 156:./MotorControl/utils.hpp ****     return r;
 5257              		.loc 11 156 18 view .LVU1450
 5258 0908 C4E7     		b	.L191
 5259              	.LVL404:
 5260              	.L221:
 156:./MotorControl/utils.hpp ****     return r;
 5261              		.loc 11 156 18 view .LVU1451
 5262              	.LBE1715:
 5263              	.LBE1720:
 5264              	.LBB1721:
 5265              	.LBB1718:
 5266              		.loc 6 3683 29 view .LVU1452
 5267 090a 1FAB     		add	r3, sp, #124
 5268              	.LVL405:
 5269              	.L192:
 5270              		.loc 6 3683 29 view .LVU1453
 5271              	.LBE1718:
 5272              	.LBE1721:
 370:MotorControl/controller.cpp ****     }
 5273              		.loc 3 370 61 view .LVU1454
 5274 090c 1B68     		ldr	r3, [r3]
 370:MotorControl/controller.cpp ****     }
 5275              		.loc 3 370 103 view .LVU1455
 5276 090e 1433     		adds	r3, r3, #20
 5277 0910 04EB8303 		add	r3, r4, r3, lsl #2
 5278 0914 D3ED027A 		vldr.32	s15, [r3, #8]
 370:MotorControl/controller.cpp ****     }
 5279              		.loc 3 370 16 view .LVU1456
 5280 0918 71EEA71A 		vadd.f32	s3, s3, s15
ARM GAS  /tmp/ccawPiBL.s 			page 282


 5281              	.LVL406:
 5282              	.L189:
 370:MotorControl/controller.cpp ****     }
 5283              		.loc 3 370 16 view .LVU1457
 5284              	.LBE1724:
 5285              	.LBE1729:
 373:MotorControl/controller.cpp ****     if (config_.control_mode >= CONTROL_MODE_VELOCITY_CONTROL) {
 5286              		.loc 3 373 5 is_stmt 1 view .LVU1458
 374:MotorControl/controller.cpp ****         if (!vel_estimate.has_value()) {
 5287              		.loc 3 374 5 view .LVU1459
 5288 091c 012E     		cmp	r6, #1
 5289 091e 55D9     		bls	.L223
 375:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_ESTIMATE);
 5290              		.loc 3 375 9 view .LVU1460
 5291              	.LVL407:
 5292              	.LBB1730:
 5293              	.LBI1730:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 5294              		.loc 13 916 22 view .LVU1461
 5295              	.LBB1731:
 5296              	.LBI1731:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 5297              		.loc 13 433 22 view .LVU1462
 5298              	.LBB1732:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 5299              		.loc 13 434 58 is_stmt 0 view .LVU1463
 5300 0920 9DF84050 		ldrb	r5, [sp, #64]	@ zero_extendqisi2
 5301              	.LVL408:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 5302              		.loc 13 434 58 view .LVU1464
 5303              	.LBE1732:
 5304              	.LBE1731:
 5305              	.LBE1730:
 375:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_ESTIMATE);
 5306              		.loc 3 375 9 view .LVU1465
 5307 0924 002D     		cmp	r5, #0
 5308 0926 4BD0     		beq	.L263
 380:MotorControl/controller.cpp ****         torque += (vel_gain * gain_scheduling_multiplier) * v_err;
 5309              		.loc 3 380 9 is_stmt 1 view .LVU1466
 380:MotorControl/controller.cpp ****         torque += (vel_gain * gain_scheduling_multiplier) * v_err;
 5310              		.loc 3 380 15 is_stmt 0 view .LVU1467
 5311 0928 DDED099A 		vldr.32	s19, [sp, #36]
 5312 092c DDED0F7A 		vldr.32	s15, [sp, #60]
 5313 0930 79EEE79A 		vsub.f32	s19, s19, s15
 5314              	.LVL409:
 381:MotorControl/controller.cpp **** 
 5315              		.loc 3 381 9 is_stmt 1 view .LVU1468
 381:MotorControl/controller.cpp **** 
 5316              		.loc 3 381 29 is_stmt 0 view .LVU1469
 5317 0934 69EE017A 		vmul.f32	s15, s18, s2
 381:MotorControl/controller.cpp **** 
 5318              		.loc 3 381 59 view .LVU1470
 5319 0938 67EEA97A 		vmul.f32	s15, s15, s19
 381:MotorControl/controller.cpp **** 
 5320              		.loc 3 381 16 view .LVU1471
 5321 093c 77EEA11A 		vadd.f32	s3, s15, s3
 5322              	.LVL410:
ARM GAS  /tmp/ccawPiBL.s 			page 283


 384:MotorControl/controller.cpp ****     }
 5323              		.loc 3 384 9 is_stmt 1 view .LVU1472
 384:MotorControl/controller.cpp ****     }
 5324              		.loc 3 384 19 is_stmt 0 view .LVU1473
 5325 0940 04F56453 		add	r3, r4, #14592
 5326 0944 D3ED037A 		vldr.32	s15, [r3, #12]
 384:MotorControl/controller.cpp ****     }
 5327              		.loc 3 384 16 view .LVU1474
 5328 0948 77EEA11A 		vadd.f32	s3, s15, s3
 5329              	.LVL411:
 5330              	.L193:
 388:MotorControl/controller.cpp ****         if (!vel_estimate.has_value()) {
 5331              		.loc 3 388 5 is_stmt 1 view .LVU1475
 5332 094c 012E     		cmp	r6, #1
 5333 094e 40D9     		bls	.L264
 5334              	.LVL412:
 5335              	.L195:
 397:MotorControl/controller.cpp ****     if (torque > Tlim) {
 5336              		.loc 3 397 5 view .LVU1476
 398:MotorControl/controller.cpp ****         limited = true;
 5337              		.loc 3 398 5 view .LVU1477
 5338 0950 F4EEC81A 		vcmpe.f32	s3, s16
 5339 0954 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5340 0958 51DC     		bgt	.L224
 398:MotorControl/controller.cpp ****         limited = true;
 5341              		.loc 3 398 5 is_stmt 0 view .LVU1478
 5342 095a B0EE618A 		vmov.f32	s16, s3
 397:MotorControl/controller.cpp ****     if (torque > Tlim) {
 5343              		.loc 3 397 10 view .LVU1479
 5344 095e 0023     		movs	r3, #0
 5345              	.L197:
 5346              	.LVL413:
 402:MotorControl/controller.cpp ****         limited = true;
 5347              		.loc 3 402 5 is_stmt 1 view .LVU1480
 5348 0960 F4EEC88A 		vcmpe.f32	s17, s16
 5349 0964 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5350 0968 4BDC     		bgt	.L225
 5351 096a F0EE488A 		vmov.f32	s17, s16
 5352              	.LVL414:
 5353              	.L198:
 408:MotorControl/controller.cpp ****         // reset integral if not in use
 5354              		.loc 3 408 5 view .LVU1481
 5355 096e 012E     		cmp	r6, #1
 5356 0970 49D9     		bls	.L265
 412:MotorControl/controller.cpp ****             // TODO make decayfactor configurable
 5357              		.loc 3 412 9 view .LVU1482
 5358 0972 002B     		cmp	r3, #0
 5359 0974 4CD0     		beq	.L201
 414:MotorControl/controller.cpp ****         } else {
 5360              		.loc 3 414 13 view .LVU1483
 414:MotorControl/controller.cpp ****         } else {
 5361              		.loc 3 414 36 is_stmt 0 view .LVU1484
 5362 0976 04F56453 		add	r3, r4, #14592
 5363              	.LVL415:
 414:MotorControl/controller.cpp ****         } else {
 5364              		.loc 3 414 36 view .LVU1485
 5365 097a D3ED037A 		vldr.32	s15, [r3, #12]
ARM GAS  /tmp/ccawPiBL.s 			page 284


 5366 097e 9FED727A 		vldr.32	s14, .L270+4
 5367 0982 67EE877A 		vmul.f32	s15, s15, s14
 5368 0986 C3ED037A 		vstr.32	s15, [r3, #12]
 5369              	.LVL416:
 5370              	.L202:
 419:MotorControl/controller.cpp ****     }
 5371              		.loc 3 419 9 is_stmt 1 view .LVU1486
 419:MotorControl/controller.cpp ****     }
 5372              		.loc 3 419 45 is_stmt 0 view .LVU1487
 5373 098a 04F56453 		add	r3, r4, #14592
 5374 098e 0C33     		adds	r3, r3, #12
 419:MotorControl/controller.cpp ****     }
 5375              		.loc 3 419 78 view .LVU1488
 5376 0990 2146     		mov	r1, r4
 5377 0992 D4ED0C6A 		vldr.32	s13, [r4, #48]
 5378 0996 3031     		adds	r1, r1, #48
 419:MotorControl/controller.cpp ****     }
 5379              		.loc 3 419 69 view .LVU1489
 5380 0998 F1EE667A 		vneg.f32	s15, s13
 5381 099c CDED217A 		vstr.32	s15, [sp, #132]
 5382              	.LVL417:
 5383              	.LBB1733:
 5384              	.LBI1733:
3680:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_algo.h ****     {
 5385              		.loc 6 3680 5 is_stmt 1 view .LVU1490
 5386              	.LBB1734:
 5387              		.loc 6 3683 21 is_stmt 0 view .LVU1491
 5388 09a0 93ED007A 		vldr.32	s14, [r3]
 5389              		.loc 6 3683 29 view .LVU1492
 5390 09a4 F4EEC77A 		vcmpe.f32	s15, s14
 5391 09a8 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5392 09ac 41DC     		bgt	.L226
 5393 09ae F4EEC76A 		vcmpe.f32	s13, s14
 5394 09b2 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5395 09b6 3DD5     		bpl	.L203
 5396 09b8 0B46     		mov	r3, r1
 5397              	.LVL418:
 5398              		.loc 6 3683 29 view .LVU1493
 5399 09ba 3BE0     		b	.L203
 5400              	.LVL419:
 5401              	.L222:
 5402              		.loc 6 3683 29 view .LVU1494
 5403              	.LBE1734:
 5404              	.LBE1733:
 5405              	.LBB1736:
 5406              	.LBB1725:
 5407              	.LBB1722:
 5408              	.LBB1719:
 5409 09bc 1EAB     		add	r3, sp, #120
 5410              	.LVL420:
 5411              		.loc 6 3683 29 view .LVU1495
 5412 09be A5E7     		b	.L192
 5413              	.LVL421:
 5414              	.L263:
 5415              		.loc 6 3683 29 view .LVU1496
 5416              	.LBE1719:
 5417              	.LBE1722:
ARM GAS  /tmp/ccawPiBL.s 			page 285


 5418              	.LBE1725:
 5419              	.LBE1736:
 376:MotorControl/controller.cpp ****             return false;
 5420              		.loc 3 376 13 is_stmt 1 view .LVU1497
 376:MotorControl/controller.cpp ****             return false;
 5421              		.loc 3 376 22 is_stmt 0 view .LVU1498
 5422 09c0 2021     		movs	r1, #32
 5423 09c2 2046     		mov	r0, r4
 5424 09c4 FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 5425              	.LVL422:
 377:MotorControl/controller.cpp ****         }
 5426              		.loc 3 377 13 is_stmt 1 view .LVU1499
 377:MotorControl/controller.cpp ****         }
 5427              		.loc 3 377 20 is_stmt 0 view .LVU1500
 5428 09c8 FFF7AEBB 		b	.L130
 5429              	.LVL423:
 5430              	.L223:
 373:MotorControl/controller.cpp ****     if (config_.control_mode >= CONTROL_MODE_VELOCITY_CONTROL) {
 5431              		.loc 3 373 11 view .LVU1501
 5432 09cc DFED5F9A 		vldr.32	s19, .L270+8
 5433 09d0 BCE7     		b	.L193
 5434              	.LVL424:
 5435              	.L264:
 388:MotorControl/controller.cpp ****         if (!vel_estimate.has_value()) {
 5436              		.loc 3 388 73 discriminator 1 view .LVU1502
 5437 09d2 04F54053 		add	r3, r4, #12288
 5438 09d6 93F8B338 		ldrb	r3, [r3, #2227]	@ zero_extendqisi2
 388:MotorControl/controller.cpp ****         if (!vel_estimate.has_value()) {
 5439              		.loc 3 388 62 discriminator 1 view .LVU1503
 5440 09da 002B     		cmp	r3, #0
 5441 09dc B8D0     		beq	.L195
 389:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_ESTIMATE);
 5442              		.loc 3 389 9 is_stmt 1 view .LVU1504
 5443              	.LVL425:
 5444              	.LBB1737:
 5445              	.LBI1737:
 916:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return this->_M_is_engaged(); }
 5446              		.loc 13 916 22 view .LVU1505
 5447              	.LBB1738:
 5448              	.LBI1738:
 433:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional ****       { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
 5449              		.loc 13 433 22 view .LVU1506
 5450              	.LBB1739:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 5451              		.loc 13 434 58 is_stmt 0 view .LVU1507
 5452 09de 9DF84050 		ldrb	r5, [sp, #64]	@ zero_extendqisi2
 5453              	.LVL426:
 434:/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/optional **** 
 5454              		.loc 13 434 58 view .LVU1508
 5455              	.LBE1739:
 5456              	.LBE1738:
 5457              	.LBE1737:
 389:MotorControl/controller.cpp ****             set_error(ERROR_INVALID_ESTIMATE);
 5458              		.loc 3 389 9 view .LVU1509
 5459 09e2 35B1     		cbz	r5, .L266
 393:MotorControl/controller.cpp ****     }
 5460              		.loc 3 393 9 is_stmt 1 view .LVU1510
ARM GAS  /tmp/ccawPiBL.s 			page 286


 393:MotorControl/controller.cpp ****     }
 5461              		.loc 3 393 26 is_stmt 0 view .LVU1511
 5462 09e4 DDED0F0A 		vldr.32	s1, [sp, #60]
 5463 09e8 FFF7FEFF 		bl	_ZL8limitVelffff
 5464              	.LVL427:
 393:MotorControl/controller.cpp ****     }
 5465              		.loc 3 393 26 view .LVU1512
 5466 09ec F0EE401A 		vmov.f32	s3, s0
 5467              	.LVL428:
 393:MotorControl/controller.cpp ****     }
 5468              		.loc 3 393 26 view .LVU1513
 5469 09f0 AEE7     		b	.L195
 5470              	.LVL429:
 5471              	.L266:
 390:MotorControl/controller.cpp ****             return false;
 5472              		.loc 3 390 13 is_stmt 1 view .LVU1514
 390:MotorControl/controller.cpp ****             return false;
 5473              		.loc 3 390 22 is_stmt 0 view .LVU1515
 5474 09f2 2021     		movs	r1, #32
 5475 09f4 2046     		mov	r0, r4
 5476 09f6 FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 5477              	.LVL430:
 391:MotorControl/controller.cpp ****         }
 5478              		.loc 3 391 13 is_stmt 1 view .LVU1516
 391:MotorControl/controller.cpp ****         }
 5479              		.loc 3 391 20 is_stmt 0 view .LVU1517
 5480 09fa FFF795BB 		b	.L130
 5481              	.LVL431:
 5482              	.L224:
 399:MotorControl/controller.cpp ****         torque = Tlim;
 5483              		.loc 3 399 17 view .LVU1518
 5484 09fe 0123     		movs	r3, #1
 5485 0a00 AEE7     		b	.L197
 5486              	.LVL432:
 5487              	.L225:
 403:MotorControl/controller.cpp ****         torque = -Tlim;
 5488              		.loc 3 403 17 view .LVU1519
 5489 0a02 0123     		movs	r3, #1
 5490              	.LVL433:
 403:MotorControl/controller.cpp ****         torque = -Tlim;
 5491              		.loc 3 403 17 view .LVU1520
 5492 0a04 B3E7     		b	.L198
 5493              	.LVL434:
 5494              	.L265:
 410:MotorControl/controller.cpp ****     } else {
 5495              		.loc 3 410 9 is_stmt 1 view .LVU1521
 410:MotorControl/controller.cpp ****     } else {
 5496              		.loc 3 410 32 is_stmt 0 view .LVU1522
 5497 0a06 04F56453 		add	r3, r4, #14592
 5498              	.LVL435:
 410:MotorControl/controller.cpp ****     } else {
 5499              		.loc 3 410 32 view .LVU1523
 5500 0a0a 0022     		movs	r2, #0
 5501 0a0c DA60     		str	r2, [r3, #12]	@ float
 5502 0a0e 15E0     		b	.L200
 5503              	.LVL436:
 5504              	.L201:
ARM GAS  /tmp/ccawPiBL.s 			page 287


 416:MotorControl/controller.cpp ****         }
 5505              		.loc 3 416 13 is_stmt 1 view .LVU1524
 416:MotorControl/controller.cpp ****         }
 5506              		.loc 3 416 61 is_stmt 0 view .LVU1525
 5507 0a10 29EE0A9A 		vmul.f32	s18, s18, s20
 5508              	.LVL437:
 416:MotorControl/controller.cpp ****         }
 5509              		.loc 3 416 91 view .LVU1526
 5510 0a14 DFED4E7A 		vldr.32	s15, .L270+12
 5511 0a18 29EE279A 		vmul.f32	s18, s18, s15
 416:MotorControl/controller.cpp ****         }
 5512              		.loc 3 416 114 view .LVU1527
 5513 0a1c 29EE299A 		vmul.f32	s18, s18, s19
 416:MotorControl/controller.cpp ****         }
 5514              		.loc 3 416 36 view .LVU1528
 5515 0a20 04F56453 		add	r3, r4, #14592
 5516              	.LVL438:
 416:MotorControl/controller.cpp ****         }
 5517              		.loc 3 416 36 view .LVU1529
 5518 0a24 D3ED037A 		vldr.32	s15, [r3, #12]
 5519 0a28 37EE899A 		vadd.f32	s18, s15, s18
 5520 0a2c 83ED039A 		vstr.32	s18, [r3, #12]
 5521 0a30 ABE7     		b	.L202
 5522              	.LVL439:
 5523              	.L226:
 5524              	.LBB1740:
 5525              	.LBB1735:
 5526              		.loc 6 3683 29 view .LVU1530
 5527 0a32 21AB     		add	r3, sp, #132
 5528              	.LVL440:
 5529              	.L203:
 5530              		.loc 6 3683 29 view .LVU1531
 5531              	.LBE1735:
 5532              	.LBE1740:
 419:MotorControl/controller.cpp ****     }
 5533              		.loc 3 419 44 view .LVU1532
 5534 0a34 1A68     		ldr	r2, [r3]	@ float
 419:MotorControl/controller.cpp ****     }
 5535              		.loc 3 419 32 view .LVU1533
 5536 0a36 04F56453 		add	r3, r4, #14592
 5537 0a3a DA60     		str	r2, [r3, #12]	@ float
 5538              	.L200:
 422:MotorControl/controller.cpp ****     if (axis_->motor_.config_.motor_type != Motor::MOTOR_TYPE_GIMBAL) {
 5539              		.loc 3 422 5 is_stmt 1 view .LVU1534
 5540              	.LVL441:
 423:MotorControl/controller.cpp ****         ideal_electrical_power = axis_->motor_.current_control_.power_ - \
 5541              		.loc 3 423 5 view .LVU1535
 423:MotorControl/controller.cpp ****         ideal_electrical_power = axis_->motor_.current_control_.power_ - \
 5542              		.loc 3 423 16 is_stmt 0 view .LVU1536
 5543 0a3c D7F85831 		ldr	r3, [r7, #344]
 423:MotorControl/controller.cpp ****         ideal_electrical_power = axis_->motor_.current_control_.power_ - \
 5544              		.loc 3 423 31 view .LVU1537
 5545 0a40 93F83820 		ldrb	r2, [r3, #56]	@ zero_extendqisi2
 423:MotorControl/controller.cpp ****         ideal_electrical_power = axis_->motor_.current_control_.power_ - \
 5546              		.loc 3 423 5 view .LVU1538
 5547 0a44 022A     		cmp	r2, #2
 5548 0a46 72D0     		beq	.L205
ARM GAS  /tmp/ccawPiBL.s 			page 288


 424:MotorControl/controller.cpp ****             SQ(axis_->motor_.current_control_.Iq_measured_) * 1.5f * axis_->motor_.config_.phase_re
 5549              		.loc 3 424 9 is_stmt 1 view .LVU1539
 424:MotorControl/controller.cpp ****             SQ(axis_->motor_.current_control_.Iq_measured_) * 1.5f * axis_->motor_.config_.phase_re
 5550              		.loc 3 424 65 is_stmt 0 view .LVU1540
 5551 0a48 93ED5B7A 		vldr.32	s14, [r3, #364]
 5552              	.LVL442:
 5553              	.LBB1741:
 5554              	.LBI1741:
  84:./MotorControl/utils.hpp ****     return x * x;
 5555              		.loc 11 84 13 is_stmt 1 view .LVU1541
 5556              	.LBB1742:
  85:./MotorControl/utils.hpp **** }
 5557              		.loc 11 85 14 is_stmt 0 view .LVU1542
 5558 0a4c D3ED567A 		vldr.32	s15, [r3, #344]
  85:./MotorControl/utils.hpp **** }
 5559              		.loc 11 85 16 view .LVU1543
 5560 0a50 67EEA77A 		vmul.f32	s15, s15, s15
 5561              	.LVL443:
  85:./MotorControl/utils.hpp **** }
 5562              		.loc 11 85 16 view .LVU1544
 5563              	.LBE1742:
 5564              	.LBE1741:
 425:MotorControl/controller.cpp ****             SQ(axis_->motor_.current_control_.Id_measured_) * 1.5f * axis_->motor_.config_.phase_re
 5565              		.loc 3 425 61 view .LVU1545
 5566 0a54 B7EE086A 		vmov.f32	s12, #1.5e+0
 5567 0a58 67EE867A 		vmul.f32	s15, s15, s12
 425:MotorControl/controller.cpp ****             SQ(axis_->motor_.current_control_.Id_measured_) * 1.5f * axis_->motor_.config_.phase_re
 5568              		.loc 3 425 92 view .LVU1546
 5569 0a5c D3ED0C6A 		vldr.32	s13, [r3, #48]
 425:MotorControl/controller.cpp ****             SQ(axis_->motor_.current_control_.Id_measured_) * 1.5f * axis_->motor_.config_.phase_re
 5570              		.loc 3 425 68 view .LVU1547
 5571 0a60 67EEA67A 		vmul.f32	s15, s15, s13
 424:MotorControl/controller.cpp ****             SQ(axis_->motor_.current_control_.Iq_measured_) * 1.5f * axis_->motor_.config_.phase_re
 5572              		.loc 3 424 72 view .LVU1548
 5573 0a64 37EE677A 		vsub.f32	s14, s14, s15
 5574              	.LVL444:
 5575              	.LBB1743:
 5576              	.LBI1743:
  84:./MotorControl/utils.hpp ****     return x * x;
 5577              		.loc 11 84 13 is_stmt 1 view .LVU1549
 5578              	.LBB1744:
  85:./MotorControl/utils.hpp **** }
 5579              		.loc 11 85 14 is_stmt 0 view .LVU1550
 5580 0a68 D3ED557A 		vldr.32	s15, [r3, #340]
  85:./MotorControl/utils.hpp **** }
 5581              		.loc 11 85 16 view .LVU1551
 5582 0a6c 67EEA77A 		vmul.f32	s15, s15, s15
 5583              	.LVL445:
  85:./MotorControl/utils.hpp **** }
 5584              		.loc 11 85 16 view .LVU1552
 5585              	.LBE1744:
 5586              	.LBE1743:
 426:MotorControl/controller.cpp ****     }
 5587              		.loc 3 426 61 view .LVU1553
 5588 0a70 67EE867A 		vmul.f32	s15, s15, s12
 426:MotorControl/controller.cpp ****     }
 5589              		.loc 3 426 68 view .LVU1554
ARM GAS  /tmp/ccawPiBL.s 			page 289


 5590 0a74 66EEA77A 		vmul.f32	s15, s13, s15
 424:MotorControl/controller.cpp ****             SQ(axis_->motor_.current_control_.Iq_measured_) * 1.5f * axis_->motor_.config_.phase_re
 5591              		.loc 3 424 32 view .LVU1555
 5592 0a78 37EE677A 		vsub.f32	s14, s14, s15
 5593              	.LVL446:
 5594              	.L206:
 431:MotorControl/controller.cpp ****     electrical_power_ += config_.electrical_power_bandwidth * current_meas_period * (ideal_electric
 5595              		.loc 3 431 5 is_stmt 1 view .LVU1556
 431:MotorControl/controller.cpp ****     electrical_power_ += config_.electrical_power_bandwidth * current_meas_period * (ideal_electric
 5596              		.loc 3 431 34 is_stmt 0 view .LVU1557
 5597 0a7c 04F54053 		add	r3, r4, #12288
 5598 0a80 03F6C402 		addw	r2, r3, #2244
 5599 0a84 D2ED007A 		vldr.32	s15, [r2]
 431:MotorControl/controller.cpp ****     electrical_power_ += config_.electrical_power_bandwidth * current_meas_period * (ideal_electric
 5600              		.loc 3 431 61 view .LVU1558
 5601 0a88 DFED315A 		vldr.32	s11, .L270+12
 5602 0a8c 27EEA56A 		vmul.f32	s12, s15, s11
 431:MotorControl/controller.cpp ****     electrical_power_ += config_.electrical_power_bandwidth * current_meas_period * (ideal_electric
 5603              		.loc 3 431 95 view .LVU1559
 5604 0a90 DDED0F7A 		vldr.32	s15, [sp, #60]
 431:MotorControl/controller.cpp ****     electrical_power_ += config_.electrical_power_bandwidth * current_meas_period * (ideal_electric
 5605              		.loc 3 431 93 view .LVU1560
 5606 0a94 67EEA87A 		vmul.f32	s15, s15, s17
 431:MotorControl/controller.cpp ****     electrical_power_ += config_.electrical_power_bandwidth * current_meas_period * (ideal_electric
 5607              		.loc 3 431 109 view .LVU1561
 5608 0a98 DFED2E6A 		vldr.32	s13, .L270+16
 5609 0a9c 67EEA67A 		vmul.f32	s15, s15, s13
 431:MotorControl/controller.cpp ****     electrical_power_ += config_.electrical_power_bandwidth * current_meas_period * (ideal_electric
 5610              		.loc 3 431 116 view .LVU1562
 5611 0aa0 77EEA77A 		vadd.f32	s15, s15, s15
 431:MotorControl/controller.cpp ****     electrical_power_ += config_.electrical_power_bandwidth * current_meas_period * (ideal_electric
 5612              		.loc 3 431 125 view .LVU1563
 5613 0aa4 04F56552 		add	r2, r4, #14656
 5614 0aa8 D2ED006A 		vldr.32	s13, [r2]
 431:MotorControl/controller.cpp ****     electrical_power_ += config_.electrical_power_bandwidth * current_meas_period * (ideal_electric
 5615              		.loc 3 431 123 view .LVU1564
 5616 0aac 77EEE67A 		vsub.f32	s15, s15, s13
 431:MotorControl/controller.cpp ****     electrical_power_ += config_.electrical_power_bandwidth * current_meas_period * (ideal_electric
 5617              		.loc 3 431 83 view .LVU1565
 5618 0ab0 66EE277A 		vmul.f32	s15, s12, s15
 431:MotorControl/controller.cpp ****     electrical_power_ += config_.electrical_power_bandwidth * current_meas_period * (ideal_electric
 5619              		.loc 3 431 23 view .LVU1566
 5620 0ab4 76EEA77A 		vadd.f32	s15, s13, s15
 5621 0ab8 C2ED007A 		vstr.32	s15, [r2]
 432:MotorControl/controller.cpp **** 
 5622              		.loc 3 432 5 is_stmt 1 view .LVU1567
 432:MotorControl/controller.cpp **** 
 5623              		.loc 3 432 23 is_stmt 0 view .LVU1568
 5624 0abc 03F64412 		addw	r2, r3, #2372
 5625 0ac0 92ED006A 		vldr.32	s12, [r2]
 432:MotorControl/controller.cpp **** 
 5626              		.loc 3 432 34 view .LVU1569
 5627 0ac4 03F6C801 		addw	r1, r3, #2248
 5628 0ac8 D1ED006A 		vldr.32	s13, [r1]
 432:MotorControl/controller.cpp **** 
 5629              		.loc 3 432 61 view .LVU1570
 5630 0acc 66EEA56A 		vmul.f32	s13, s13, s11
ARM GAS  /tmp/ccawPiBL.s 			page 290


 432:MotorControl/controller.cpp **** 
 5631              		.loc 3 432 109 view .LVU1571
 5632 0ad0 37EE467A 		vsub.f32	s14, s14, s12
 5633              	.LVL447:
 432:MotorControl/controller.cpp **** 
 5634              		.loc 3 432 83 view .LVU1572
 5635 0ad4 26EE877A 		vmul.f32	s14, s13, s14
 432:MotorControl/controller.cpp **** 
 5636              		.loc 3 432 23 view .LVU1573
 5637 0ad8 36EE077A 		vadd.f32	s14, s12, s14
 5638 0adc 82ED007A 		vstr.32	s14, [r2]
 438:MotorControl/controller.cpp ****         set_error(ERROR_SPINOUT_DETECTED);
 5639              		.loc 3 438 5 is_stmt 1 view .LVU1574
 438:MotorControl/controller.cpp ****         set_error(ERROR_SPINOUT_DETECTED);
 5640              		.loc 3 438 37 is_stmt 0 view .LVU1575
 5641 0ae0 03F50D63 		add	r3, r3, #2256
 5642 0ae4 D3ED006A 		vldr.32	s13, [r3]
 438:MotorControl/controller.cpp ****         set_error(ERROR_SPINOUT_DETECTED);
 5643              		.loc 3 438 5 view .LVU1576
 5644 0ae8 F4EEE67A 		vcmpe.f32	s15, s13
 5645 0aec F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5646 0af0 08D5     		bpl	.L207
 438:MotorControl/controller.cpp ****         set_error(ERROR_SPINOUT_DETECTED);
 5647              		.loc 3 438 103 discriminator 1 view .LVU1577
 5648 0af2 04F56353 		add	r3, r4, #14528
 5649 0af6 D3ED037A 		vldr.32	s15, [r3, #12]
 438:MotorControl/controller.cpp ****         set_error(ERROR_SPINOUT_DETECTED);
 5650              		.loc 3 438 72 discriminator 1 view .LVU1578
 5651 0afa B4EEE77A 		vcmpe.f32	s14, s15
 5652 0afe F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 5653 0b02 17DC     		bgt	.L267
 5654              	.L207:
 443:MotorControl/controller.cpp **** 
 5655              		.loc 3 443 5 is_stmt 1 view .LVU1579
 5656              	.LVL448:
 5657              	.LBB1745:
 5658              	.LBI1745:
  52:./MotorControl/component.hpp ****         content_ = value;
 5659              		.loc 12 52 10 view .LVU1580
 5660              	.LBB1746:
  53:./MotorControl/component.hpp ****         age_ = 0;
 5661              		.loc 12 53 18 is_stmt 0 view .LVU1581
 5662 0b04 04F54053 		add	r3, r4, #12288
 5663 0b08 03F64812 		addw	r2, r3, #2376
 5664 0b0c C2ED018A 		vstr.32	s17, [r2, #4]
  54:./MotorControl/component.hpp ****     }
 5665              		.loc 12 54 14 view .LVU1582
 5666 0b10 0022     		movs	r2, #0
 5667 0b12 C3F84829 		str	r2, [r3, #2376]
 5668              	.LVL449:
  54:./MotorControl/component.hpp ****     }
 5669              		.loc 12 54 14 view .LVU1583
 5670              	.LBE1746:
 5671              	.LBE1745:
 449:MotorControl/controller.cpp ****     return true;
 5672              		.loc 3 449 5 is_stmt 1 view .LVU1584
 449:MotorControl/controller.cpp ****     return true;
ARM GAS  /tmp/ccawPiBL.s 			page 291


 5673              		.loc 3 449 16 is_stmt 0 view .LVU1585
 5674 0b16 2020     		movs	r0, #32
 5675 0b18 FFF7FEFF 		bl	_ZcoN10ODriveIntf14ControllerIntf5ErrorE
 5676              	.LVL450:
 5677 0b1c 0146     		mov	r1, r0
 5678 0b1e 04F56350 		add	r0, r4, #14528
 5679 0b22 1C30     		adds	r0, r0, #28
 5680 0b24 FFF7FEFF 		bl	_ZaNRN10ODriveIntf14ControllerIntf5ErrorES1_
 5681              	.LVL451:
 450:MotorControl/controller.cpp **** }
 5682              		.loc 3 450 5 is_stmt 1 view .LVU1586
 450:MotorControl/controller.cpp **** }
 5683              		.loc 3 450 12 is_stmt 0 view .LVU1587
 5684 0b28 0125     		movs	r5, #1
 5685 0b2a FFF7FDBA 		b	.L130
 5686              	.LVL452:
 5687              	.L205:
 429:MotorControl/controller.cpp ****     }
 5688              		.loc 3 429 9 is_stmt 1 view .LVU1588
 429:MotorControl/controller.cpp ****     }
 5689              		.loc 3 429 32 is_stmt 0 view .LVU1589
 5690 0b2e 93ED5B7A 		vldr.32	s14, [r3, #364]
 5691              	.LVL453:
 429:MotorControl/controller.cpp ****     }
 5692              		.loc 3 429 32 view .LVU1590
 5693 0b32 A3E7     		b	.L206
 5694              	.LVL454:
 5695              	.L267:
 439:MotorControl/controller.cpp ****         return false;
 5696              		.loc 3 439 9 is_stmt 1 view .LVU1591
 439:MotorControl/controller.cpp ****         return false;
 5697              		.loc 3 439 18 is_stmt 0 view .LVU1592
 5698 0b34 8021     		movs	r1, #128
 5699 0b36 2046     		mov	r0, r4
 5700 0b38 FFF7FEFF 		bl	_ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
 5701              	.LVL455:
 440:MotorControl/controller.cpp ****     }
 5702              		.loc 3 440 9 is_stmt 1 view .LVU1593
 440:MotorControl/controller.cpp ****     }
 5703              		.loc 3 440 16 is_stmt 0 view .LVU1594
 5704 0b3c 0025     		movs	r5, #0
 5705 0b3e FFF7F3BA 		b	.L130
 5706              	.L271:
 5707 0b42 00BF     		.align	2
 5708              	.L270:
 5709 0b44 C5B3A291 		.word	-1851608123
 5710 0b48 A4707D3F 		.word	1065185444
 5711 0b4c 00000000 		.word	0
 5712 0b50 6F120339 		.word	956502639
 5713 0b54 DB0F4940 		.word	1078530011
 5714              		.cfi_endproc
 5715              	.LFE5203:
 5716              		.fnend
 5718              		.weak	_ZTSSt18bad_variant_access
 5719              		.section	.rodata._ZTSSt18bad_variant_access,"aG",%progbits,_ZTSSt18bad_variant_access,comdat
 5720              		.align	2
 5723              	_ZTSSt18bad_variant_access:
ARM GAS  /tmp/ccawPiBL.s 			page 292


 5724 0000 53743138 		.ascii	"St18bad_variant_access\000"
 5724      6261645F 
 5724      76617269 
 5724      616E745F 
 5724      61636365 
 5725              		.weak	_ZTISt18bad_variant_access
 5726              		.section	.rodata._ZTISt18bad_variant_access,"aG",%progbits,_ZTISt18bad_variant_access,comdat
 5727              		.align	2
 5730              	_ZTISt18bad_variant_access:
 5731 0000 08000000 		.word	_ZTVN10__cxxabiv120__si_class_type_infoE+8
 5732 0004 00000000 		.word	_ZTSSt18bad_variant_access
 5733 0008 00000000 		.word	_ZTISt9exception
 5734              		.weak	_ZTSN10ODriveIntf14ControllerIntfE
 5735              		.section	.rodata._ZTSN10ODriveIntf14ControllerIntfE,"aG",%progbits,_ZTSN10ODriveIntf14ControllerIn
 5736              		.align	2
 5739              	_ZTSN10ODriveIntf14ControllerIntfE:
 5740 0000 4E31304F 		.ascii	"N10ODriveIntf14ControllerIntfE\000"
 5740      44726976 
 5740      65496E74 
 5740      66313443 
 5740      6F6E7472 
 5741              		.weak	_ZTIN10ODriveIntf14ControllerIntfE
 5742              		.section	.rodata._ZTIN10ODriveIntf14ControllerIntfE,"aG",%progbits,_ZTIN10ODriveIntf14ControllerIn
 5743              		.align	2
 5746              	_ZTIN10ODriveIntf14ControllerIntfE:
 5747 0000 08000000 		.word	_ZTVN10__cxxabiv117__class_type_infoE+8
 5748 0004 00000000 		.word	_ZTSN10ODriveIntf14ControllerIntfE
 5749              		.global	_ZTS10Controller
 5750              		.global	_ZTI10Controller
 5751              		.weak	_ZTVSt18bad_variant_access
 5752              		.section	.rodata._ZTVSt18bad_variant_access,"aG",%progbits,_ZTVSt18bad_variant_access,comdat
 5753              		.align	2
 5756              	_ZTVSt18bad_variant_access:
 5757 0000 00000000 		.word	0
 5758 0004 00000000 		.word	_ZTISt18bad_variant_access
 5759 0008 00000000 		.word	_ZNSt18bad_variant_accessD1Ev
 5760 000c 00000000 		.word	_ZNSt18bad_variant_accessD0Ev
 5761 0010 00000000 		.word	_ZNKSt18bad_variant_access4whatEv
 5762              		.global	_ZTV10Controller
 5763              		.section	.rodata._ZTI10Controller,"a"
 5764              		.align	2
 5767              	_ZTI10Controller:
 5768 0000 08000000 		.word	_ZTVN10__cxxabiv120__si_class_type_infoE+8
 5769 0004 00000000 		.word	_ZTS10Controller
 5770 0008 00000000 		.word	_ZTIN10ODriveIntf14ControllerIntfE
 5771              		.section	.rodata._ZTS10Controller,"a"
 5772              		.align	2
 5775              	_ZTS10Controller:
 5776 0000 3130436F 		.ascii	"10Controller\000"
 5776      6E74726F 
 5776      6C6C6572 
 5776      00
 5777              		.section	.rodata._ZTV10Controller,"a"
 5778              		.align	2
 5781              	_ZTV10Controller:
 5782 0000 00000000 		.word	0
 5783 0004 00000000 		.word	_ZTI10Controller
ARM GAS  /tmp/ccawPiBL.s 			page 293


 5784 0008 00000000 		.word	_ZN10Controller16move_incrementalEfb
 5785 000c 00000000 		.word	_ZN10Controller29start_anticogging_calibrationEv
 5786 0010 00000000 		.word	_ZN10Controller23remove_anticogging_biasEv
 5787 0014 00000000 		.word	_ZN10Controller21get_anticogging_valueEm
 5788              		.text
 5789              	.Letext0:
 5790              		.file 17 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/machine/_default_types.h"
 5791              		.file 18 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/_stdint.h"
 5792              		.file 19 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdint.h"
 5793              		.file 20 "ThirdParty/CMSIS/Device/ST/STM32F4xx/Include/stm32f405xx.h"
 5794              		.file 21 "/opt/gcc-arm-none-eabi/lib/gcc/arm-none-eabi/10.3.1/include/stddef.h"
 5795              		.file 22 "/opt/gcc-arm-none-eabi/lib/gcc/arm-none-eabi/10.3.1/include/stdarg.h"
 5796              		.file 23 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/_types.h"
 5797              		.file 24 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/reent.h"
 5798              		.file 25 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/sys/lock.h"
 5799              		.file 26 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdio.h"
 5800              		.file 27 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_def.h"
 5801              		.file 28 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_dma.h"
 5802              		.file 29 "ThirdParty/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_tim.h"
 5803              		.file 30 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdlib"
 5804              		.file 31 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cmath"
 5805              		.file 32 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/type_traits"
 5806              		.file 33 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/arm-none-eabi/thumb/v7e-m+fp/har
 5807              		.file 34 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/debug/debug.h"
 5808              		.file 35 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/utility"
 5809              		.file 36 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_pair.h"
 5810              		.file 37 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/exception_ptr.h"
 5811              		.file 38 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/stl_iterator.h"
 5812              		.file 39 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/enable_special_members.h"
 5813              		.file 40 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/algorithmfwd.h"
 5814              		.file 41 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/functional"
 5815              		.file 42 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstring"
 5816              		.file 43 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/parse_numbers.h"
 5817              		.file 44 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cwchar"
 5818              		.file 45 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/clocale"
 5819              		.file 46 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdint"
 5820              		.file 47 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/string_view"
 5821              		.file 48 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/basic_string.h"
 5822              		.file 49 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/cstdio"
 5823              		.file 50 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/predefined_ops.h"
 5824              		.file 51 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/stdlib.h"
 5825              		.file 52 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/stdlib.h"
 5826              		.file 53 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/math.h"
 5827              		.file 54 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/math.h"
 5828              		.file 55 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/string.h"
 5829              		.file 56 "fibre-cpp/include/fibre/cpp_utils.hpp"
 5830              		.file 57 "fibre-cpp/include/fibre/callback.hpp"
 5831              		.file 58 "Board/v3/Inc/board.h"
 5832              		.file 59 "./MotorControl/motor.hpp"
 5833              		.file 60 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/pstl/execution_defs.h"
 5834              		.file 61 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/bits/std_function.h"
 5835              		.file 62 "MotorControl/trapTraj.hpp"
 5836              		.file 63 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/wchar.h"
 5837              		.file 64 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/locale.h"
 5838              		.file 65 "MotorControl/odrive_main.h"
 5839              		.file 66 "/opt/gcc-arm-none-eabi/arm-none-eabi/include/c++/10.3.1/new"
 5840              		.file 67 "<built-in>"
ARM GAS  /tmp/ccawPiBL.s 			page 294


ARM GAS  /tmp/ccawPiBL.s 			page 295


DEFINED SYMBOLS
                            *ABS*:0000000000000000 controller.cpp
     /tmp/ccawPiBL.s:20     .text._ZNKSt18bad_variant_access4whatEv:0000000000000000 $t
     /tmp/ccawPiBL.s:26     .text._ZNKSt18bad_variant_access4whatEv:0000000000000000 _ZNKSt18bad_variant_access4whatEv
.ARM.exidx.text._ZNKSt18bad_variant_access4whatEv:0000000000000000 $d
     /tmp/ccawPiBL.s:48     .text._ZN10Controller21get_anticogging_valueEm:0000000000000000 $t
     /tmp/ccawPiBL.s:54     .text._ZN10Controller21get_anticogging_valueEm:0000000000000000 _ZN10Controller21get_anticogging_valueEm
     /tmp/ccawPiBL.s:86     .text._ZN10Controller21get_anticogging_valueEm:0000000000000018 $d
.ARM.exidx.text._ZN10Controller21get_anticogging_valueEm:0000000000000000 $d
     /tmp/ccawPiBL.s:93     .text._ZN10Controller16move_incrementalEfb:0000000000000000 $t
     /tmp/ccawPiBL.s:99     .text._ZN10Controller16move_incrementalEfb:0000000000000000 _ZN10Controller16move_incrementalEfb
.ARM.exidx.text._ZN10Controller16move_incrementalEfb:0000000000000000 $d
     /tmp/ccawPiBL.s:159    .text._ZN10Controller29start_anticogging_calibrationEv:0000000000000000 $t
     /tmp/ccawPiBL.s:165    .text._ZN10Controller29start_anticogging_calibrationEv:0000000000000000 _ZN10Controller29start_anticogging_calibrationEv
.ARM.exidx.text._ZN10Controller29start_anticogging_calibrationEv:0000000000000000 $d
     /tmp/ccawPiBL.s:199    .text._ZN10Controller23remove_anticogging_biasEv:0000000000000000 $t
     /tmp/ccawPiBL.s:205    .text._ZN10Controller23remove_anticogging_biasEv:0000000000000000 _ZN10Controller23remove_anticogging_biasEv
     /tmp/ccawPiBL.s:294    .text._ZN10Controller23remove_anticogging_biasEv:000000000000003c $d
.ARM.exidx.text._ZN10Controller23remove_anticogging_biasEv:0000000000000000 $d
     /tmp/ccawPiBL.s:302    .text._ZL8limitVelffff:0000000000000000 $t
     /tmp/ccawPiBL.s:307    .text._ZL8limitVelffff:0000000000000000 _ZL8limitVelffff
 .ARM.exidx.text._ZL8limitVelffff:0000000000000000 $d
     /tmp/ccawPiBL.s:392    .text._ZNSt18bad_variant_accessD2Ev:0000000000000000 $t
     /tmp/ccawPiBL.s:398    .text._ZNSt18bad_variant_accessD2Ev:0000000000000000 _ZNSt18bad_variant_accessD2Ev
     /tmp/ccawPiBL.s:428    .text._ZNSt18bad_variant_accessD2Ev:0000000000000010 $d
     /tmp/ccawPiBL.s:5756   .rodata._ZTVSt18bad_variant_access:0000000000000000 _ZTVSt18bad_variant_access
.ARM.exidx.text._ZNSt18bad_variant_accessD2Ev:0000000000000000 $d
     /tmp/ccawPiBL.s:398    .text._ZNSt18bad_variant_accessD2Ev:0000000000000000 _ZNSt18bad_variant_accessD1Ev
     /tmp/ccawPiBL.s:437    .text._ZNSt18bad_variant_accessD0Ev:0000000000000000 $t
     /tmp/ccawPiBL.s:443    .text._ZNSt18bad_variant_accessD0Ev:0000000000000000 _ZNSt18bad_variant_accessD0Ev
     /tmp/ccawPiBL.s:481    .text._ZNSt18bad_variant_accessD0Ev:0000000000000018 $d
.ARM.exidx.text._ZNSt18bad_variant_accessD0Ev:0000000000000000 $d
     /tmp/ccawPiBL.s:488    .text._ZSt26__throw_bad_variant_accessPKc:0000000000000000 $t
     /tmp/ccawPiBL.s:494    .text._ZSt26__throw_bad_variant_accessPKc:0000000000000000 _ZSt26__throw_bad_variant_accessPKc
     /tmp/ccawPiBL.s:548    .text._ZSt26__throw_bad_variant_accessPKc:000000000000001c $d
     /tmp/ccawPiBL.s:5730   .rodata._ZTISt18bad_variant_access:0000000000000000 _ZTISt18bad_variant_access
.ARM.exidx.text._ZSt26__throw_bad_variant_accessPKc:0000000000000000 $d
     /tmp/ccawPiBL.s:557    .text._ZoRRN10ODriveIntf14ControllerIntf5ErrorES1_:0000000000000000 $t
     /tmp/ccawPiBL.s:563    .text._ZoRRN10ODriveIntf14ControllerIntf5ErrorES1_:0000000000000000 _ZoRRN10ODriveIntf14ControllerIntf5ErrorES1_
.ARM.exidx.text._ZoRRN10ODriveIntf14ControllerIntf5ErrorES1_:0000000000000000 $d
     /tmp/ccawPiBL.s:588    .text._ZaNRN10ODriveIntf14ControllerIntf5ErrorES1_:0000000000000000 $t
     /tmp/ccawPiBL.s:594    .text._ZaNRN10ODriveIntf14ControllerIntf5ErrorES1_:0000000000000000 _ZaNRN10ODriveIntf14ControllerIntf5ErrorES1_
.ARM.exidx.text._ZaNRN10ODriveIntf14ControllerIntf5ErrorES1_:0000000000000000 $d
     /tmp/ccawPiBL.s:618    .text._ZcoN10ODriveIntf14ControllerIntf5ErrorE:0000000000000000 $t
     /tmp/ccawPiBL.s:624    .text._ZcoN10ODriveIntf14ControllerIntf5ErrorE:0000000000000000 _ZcoN10ODriveIntf14ControllerIntf5ErrorE
.ARM.exidx.text._ZcoN10ODriveIntf14ControllerIntf5ErrorE:0000000000000000 $d
     /tmp/ccawPiBL.s:646    .text._ZN10Controller5resetEv:0000000000000000 $t
     /tmp/ccawPiBL.s:652    .text._ZN10Controller5resetEv:0000000000000000 _ZN10Controller5resetEv
.ARM.exidx.text._ZN10Controller5resetEv:0000000000000000 $d
     /tmp/ccawPiBL.s:693    .text._ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE:0000000000000000 $t
     /tmp/ccawPiBL.s:699    .text._ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE:0000000000000000 _ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE
     /tmp/ccawPiBL.s:740    .text._ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE:000000000000002c $d
.ARM.exidx.text._ZN10Controller9set_errorEN10ODriveIntf14ControllerIntf5ErrorE:0000000000000000 $d
     /tmp/ccawPiBL.s:748    .text._ZN10Controller11move_to_posEf:0000000000000000 $t
     /tmp/ccawPiBL.s:754    .text._ZN10Controller11move_to_posEf:0000000000000000 _ZN10Controller11move_to_posEf
.ARM.exidx.text._ZN10Controller11move_to_posEf:0000000000000000 $d
     /tmp/ccawPiBL.s:804    .text._ZN10Controller23anticogging_calibrationEff:0000000000000000 $t
ARM GAS  /tmp/ccawPiBL.s 			page 296


     /tmp/ccawPiBL.s:810    .text._ZN10Controller23anticogging_calibrationEff:0000000000000000 _ZN10Controller23anticogging_calibrationEff
     /tmp/ccawPiBL.s:1045   .text._ZN10Controller23anticogging_calibrationEff:00000000000000f0 $d
.ARM.exidx.text._ZN10Controller23anticogging_calibrationEff:0000000000000000 $d
     /tmp/ccawPiBL.s:1053   .text._ZN10Controller23set_input_pos_and_stepsEf:0000000000000000 $t
     /tmp/ccawPiBL.s:1059   .text._ZN10Controller23set_input_pos_and_stepsEf:0000000000000000 _ZN10Controller23set_input_pos_and_stepsEf
.ARM.exidx.text._ZN10Controller23set_input_pos_and_stepsEf:0000000000000000 $d
     /tmp/ccawPiBL.s:1213   .rodata._ZN10Controller20control_mode_updatedEv.str1.4:0000000000000000 $d
     /tmp/ccawPiBL.s:1217   .text._ZN10Controller20control_mode_updatedEv:0000000000000000 $t
     /tmp/ccawPiBL.s:1223   .text._ZN10Controller20control_mode_updatedEv:0000000000000000 _ZN10Controller20control_mode_updatedEv
     /tmp/ccawPiBL.s:1853   .text._ZN10Controller20control_mode_updatedEv:00000000000000a4 $d
.ARM.exidx.text._ZN10Controller20control_mode_updatedEv:0000000000000000 $d
     /tmp/ccawPiBL.s:1859   .text._ZN10Controller19update_filter_gainsEv:0000000000000000 $t
     /tmp/ccawPiBL.s:1865   .text._ZN10Controller19update_filter_gainsEv:0000000000000000 _ZN10Controller19update_filter_gainsEv
     /tmp/ccawPiBL.s:1948   .text._ZN10Controller19update_filter_gainsEv:000000000000004c $d
.ARM.exidx.text._ZN10Controller19update_filter_gainsEv:0000000000000000 $d
     /tmp/ccawPiBL.s:1957   .text._ZN10Controller12apply_configEv:0000000000000000 $t
     /tmp/ccawPiBL.s:1963   .text._ZN10Controller12apply_configEv:0000000000000000 _ZN10Controller12apply_configEv
.ARM.exidx.text._ZN10Controller12apply_configEv:0000000000000000 $d
     /tmp/ccawPiBL.s:1995   .text._ZN9InputPortIfE7presentEv:0000000000000000 $t
     /tmp/ccawPiBL.s:2001   .text._ZN9InputPortIfE7presentEv:0000000000000000 _ZN9InputPortIfE7presentEv
     /tmp/ccawPiBL.s:2589   .text._ZN9InputPortIfE7presentEv:0000000000000068 $d
.ARM.extab.text._ZN9InputPortIfE7presentEv:0000000000000000 $d
.ARM.exidx.text._ZN9InputPortIfE7presentEv:0000000000000000 $d
     /tmp/ccawPiBL.s:2603   .text._ZN10Controller6updateEv:0000000000000000 $t
     /tmp/ccawPiBL.s:2609   .text._ZN10Controller6updateEv:0000000000000000 _ZN10Controller6updateEv
     /tmp/ccawPiBL.s:3194   .text._ZN10Controller6updateEv:000000000000018a $d
     /tmp/ccawPiBL.s:3203   .text._ZN10Controller6updateEv:000000000000019c $t
     /tmp/ccawPiBL.s:4367   .text._ZN10Controller6updateEv:0000000000000558 $d
     /tmp/ccawPiBL.s:4376   .text._ZN10Controller6updateEv:0000000000000568 $t
     /tmp/ccawPiBL.s:5709   .text._ZN10Controller6updateEv:0000000000000b44 $d
.ARM.extab.text._ZN10Controller6updateEv:0000000000000000 $d
.ARM.exidx.text._ZN10Controller6updateEv:0000000000000000 $d
     /tmp/ccawPiBL.s:5723   .rodata._ZTSSt18bad_variant_access:0000000000000000 _ZTSSt18bad_variant_access
     /tmp/ccawPiBL.s:5720   .rodata._ZTSSt18bad_variant_access:0000000000000000 $d
     /tmp/ccawPiBL.s:5727   .rodata._ZTISt18bad_variant_access:0000000000000000 $d
     /tmp/ccawPiBL.s:5739   .rodata._ZTSN10ODriveIntf14ControllerIntfE:0000000000000000 _ZTSN10ODriveIntf14ControllerIntfE
     /tmp/ccawPiBL.s:5736   .rodata._ZTSN10ODriveIntf14ControllerIntfE:0000000000000000 $d
     /tmp/ccawPiBL.s:5746   .rodata._ZTIN10ODriveIntf14ControllerIntfE:0000000000000000 _ZTIN10ODriveIntf14ControllerIntfE
     /tmp/ccawPiBL.s:5743   .rodata._ZTIN10ODriveIntf14ControllerIntfE:0000000000000000 $d
     /tmp/ccawPiBL.s:5775   .rodata._ZTS10Controller:0000000000000000 _ZTS10Controller
     /tmp/ccawPiBL.s:5767   .rodata._ZTI10Controller:0000000000000000 _ZTI10Controller
     /tmp/ccawPiBL.s:5753   .rodata._ZTVSt18bad_variant_access:0000000000000000 $d
     /tmp/ccawPiBL.s:5781   .rodata._ZTV10Controller:0000000000000000 _ZTV10Controller
     /tmp/ccawPiBL.s:5764   .rodata._ZTI10Controller:0000000000000000 $d
     /tmp/ccawPiBL.s:5772   .rodata._ZTS10Controller:0000000000000000 $d
     /tmp/ccawPiBL.s:5778   .rodata._ZTV10Controller:0000000000000000 $d
                           .group:0000000000000000 _ZNSt18bad_variant_accessD5Ev

UNDEFINED SYMBOLS
_ZNSt9exceptionD2Ev
_ZdlPvj
__cxa_allocate_exception
__cxa_throw
_ZTVSt9exception
__aeabi_unwind_cpp_pr0
odrv
_ZN21TrapezoidalTrajectory15planTrapezoidalEffffff
ARM GAS  /tmp/ccawPiBL.s 			page 297


__aeabi_f2lz
__aeabi_unwind_cpp_pr1
__aeabi_ldivmod
__aeabi_l2f
axes
_ZN21TrapezoidalTrajectory4evalEf
our_arm_cos_f32
our_arm_sin_f32
_ZN5Motor20max_available_torqueEv
_ZTVN10__cxxabiv120__si_class_type_infoE
_ZTISt9exception
_ZTVN10__cxxabiv117__class_type_infoE
